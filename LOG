======================================================================
AFTER FLATTENING:
 Module wybe
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : 
  imports         : public use wybe.array
                    public use wybe.bool
                    public use wybe.c_string
                    public use wybe.char
                    public use wybe.comparison
                    public use wybe.control
                    public use wybe.count
                    public use wybe.float
                    public use wybe.int
                    public use wybe.io
                    public use wybe.list
                    public use wybe.machine_word
                    public use wybe.memory_management
                    public use wybe.phantom
                    public use wybe.predicate
                    public use wybe.range
                    public use wybe.string
  resources       : 
  submodules      : wybe.array, wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.control, wybe.count, wybe.float, wybe.int, wybe.io, wybe.list, wybe.machine_word, wybe.memory_management, wybe.phantom, wybe.predicate, wybe.range, wybe.string
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.array(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.array.[]<0>
                    wybe.array.[]<1>
                    wybe.array.[|]<0>
                    wybe.array.array<0>
                    wybe.array.array<1>
                    wybe.array.inbounds<0>
                    wybe.array.unsafe_get<0>
                    wybe.array.unsafe_update<0>
  imports         : public use wybe.array.raw_array
                    use wybe.bool
                    use wybe.int
                    use wybe.list
                    use wybe.machine_word
  resources       : 
  submodules      : wybe.array.raw_array
  procs           : 

[] > public {test} (0 calls)
0: [](a:_(T) @array:67:21, idx:int @array:67:29, ?#result:T @array:67:5):
    inbounds(a @array:68:14, idx @array:68:17)
    unsafe_get(a @array:69:10, idx @array:69:23, ?tmp#0 @array:69:10)
    =(?x @array:69:6, tmp#0)
    foreign llvm move(x @array:67:42, ?#result @array:67:5)
[] > public {test} (0 calls)
1: [](!a:_(T) @array:81:22, idx:int @array:81:30, x:T @array:81:39):
    inbounds(a @array:82:14, idx @array:82:17)
    unsafe_update(!a @array:83:20, idx @array:83:23, x @array:83:28)


[|] > public {test} (0 calls)
0: [|](?head:T @array:51:23, ?tail:_(T) @array:51:32, a:_(T) @array:51:43):
    array(?length @array:52:12, ?data @array:52:21, a @array:52:29)
    >(length @array:53:6, 0 @array:53:15)
    word_size_bytes(?tmp#0 @array:54:34)
    foreign lpvm access(data @array:54:25, 0 @array:54:31, tmp#0, 0 @array:54:51, ?head @array:54:55)
    word_size_bytes(?tmp#1 @array:55:28)
    foreign llvm add(data @array:55:22, tmp#1, ?data @array:55:46)
    -(length @array:56:19, 1 @array:56:28, ?tmp#3 @array:56:19)
    array(tmp#3, data @array:56:31, ?tmp#2 @array:56:13)
    =(?tail @array:56:6, tmp#2)


array > public (0 calls)
0: array(x:T @array:18:15, len:int @array:18:20, ?#result:_(T) @array:18:5):
    word_size_bytes(?tmp#1 @array:19:19)
    *(len @array:19:13, tmp#1, ?tmp#0 @array:19:13)
    =(?size @array:19:6, tmp#0)
    foreign lpvm alloc(size @array:20:24, ?data @array:20:31)
    =(?offset @array:21:6, 0 @array:21:15)
    do {
        if {<(offset @array:23:15, size @array:23:24)::

            pass
        else::
            break

        }
        foreign lpvm mutate(data @array:24:29, ?data @array:24:36, offset @array:24:42, 1 @array:24:50, size @array:24:53, 0 @array:24:59, x @array:24:62)
        word_size_bytes(?tmp#2 @array:25:21)
        +=(!offset @array:25:10, tmp#2)
    }
    array(len @array:27:17, data @array:27:22, ?tmp#3 @array:27:11)
    =(?ar @array:27:6, tmp#3)
    foreign llvm move(ar @array:18:36, ?#result @array:18:5)
array > public (0 calls)
1: array(ls:list(T) @array:34:15, ?#result:_(T) @array:34:5):
    length(ls @array:35:19, ?tmp#0 @array:35:12)
    =(?len @array:35:6, tmp#0)
    word_size_bytes(?tmp#2 @array:36:19)
    *(len @array:36:13, tmp#2, ?tmp#1 @array:36:13)
    =(?size @array:36:6, tmp#1)
    foreign lpvm alloc(size @array:37:24, ?data @array:37:31)
    =(?offset @array:38:6, 0 @array:38:15)
    foreign llvm move(ls @array:39:15, ?tmp#3)
    do {
        if {[|](?x @array:39:10, ?tmp#3, tmp#3)::

            foreign lpvm mutate(data @array:40:29, ?data @array:40:36, offset @array:40:42, 1 @array:40:50, size @array:40:53, 0 @array:40:59, x @array:40:62)
            word_size_bytes(?tmp#4 @array:41:21)
            +=(!offset @array:41:10, tmp#4)
        else::
            break

        }
    }
    array(len @array:43:17, data @array:43:22, ?tmp#5 @array:43:11)
    =(?ar @array:43:6, tmp#5)
    foreign llvm move(ar @array:34:34, ?#result @array:34:5)


inbounds > public {test,inline} (0 calls)
0: inbounds(a:_(T) @array:60:33, idx:int @array:60:41):
    <=(0 @array:61:6, idx @array:61:12)
    length(a @array:62:12, ?tmp#0 @array:62:12)
    <(idx @array:62:6, tmp#0)


unsafe_get > public {inline} (0 calls)
0: unsafe_get(a:_(T) @array:75:29, idx:int @array:75:37, ?#result:T @array:75:5):
    raw_data(a @array:76:25, ?tmp#0 @array:76:25)
    word_size_bytes(?tmp#2 @array:76:43)
    *(idx @array:76:37, tmp#2, ?tmp#1 @array:76:37)
    word_size_bytes(?tmp#3 @array:76:60)
    foreign lpvm access(tmp#0, tmp#1, tmp#3, 0 @array:76:77, ?x @array:76:81)
    foreign llvm move(x @array:75:50, ?#result @array:75:5)


unsafe_update > public {inline} (0 calls)
0: unsafe_update(!a:_(T) @array:89:33, idx:int @array:89:41, x:T @array:89:50):
    raw_data(a @array:90:25, ?tmp#0 @array:90:25)
    word_size_bytes(?tmp#2 @array:90:50)
    *(idx @array:90:44, tmp#2, ?tmp#1 @array:90:44)
    length(a @array:91:44, ?tmp#4 @array:91:44)
    word_size_bytes(?tmp#5 @array:91:55)
    *(tmp#4, tmp#5, ?tmp#3 @array:91:44)
    foreign lpvm mutate(tmp#0, ?data @array:90:38, tmp#1, 0 @array:90:67, tmp#3, 0 @array:91:72, x @array:91:75)
    raw_data(!a @array:92:6, data @array:92:19)

LLVM code       : None

--------------------------------------------------
 Module wybe.array.raw_array(T)
  representation  : address
  public submods  : 
  public resources: 
  public procs    : 
  imports         : use wybe
                    use wybe.array
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.bool
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.bool.&&<0>
                    wybe.bool.&=<0>
                    wybe.bool.=<0>
                    wybe.bool.^=<0>
                    wybe.bool.^^<0>
                    wybe.bool.print<0>
                    wybe.bool.println<0>
                    wybe.bool.succeed<0>
                    wybe.bool.|=<0>
                    wybe.bool.||<0>
                    wybe.bool.~<0>
                    wybe.bool.~=<0>
  imports         : use wybe.c_string
                    use wybe.io
  resources       : 
  procs           : 

&& > public (0 calls)
0: &&(p:_ @bool:13:10, q:_ @bool:13:18, ?#result:_ @bool:13:5):
    foreign llvm and(p @bool:13:44, q @bool:13:47, ?tmp#0 @bool:13:27)
    foreign llvm move(tmp#0, ?#result @bool:13:5)


&= > public (0 calls)
0: &=(!p:_ @bool:16:11, q:_ @bool:16:19):
    &&(p @bool:16:32, q @bool:16:38, ?tmp#0 @bool:16:32)
    =(?p @bool:16:27, tmp#0)


= > public (0 calls)
0: =(x:_ @bool:37:10, y:_ @bool:37:17, ?#result:_ @bool:37:5):
    foreign llvm icmp_eq(x @bool:37:47, y @bool:37:50, ?tmp#0 @bool:37:26)
    foreign llvm move(tmp#0, ?#result @bool:37:5)


^= > public (0 calls)
0: ^=(!p:_ @bool:28:11, q:_ @bool:28:19):
    ^^(q @bool:28:31, p @bool:28:37, ?tmp#0 @bool:28:31)
    =(?p @bool:28:27, tmp#0)


^^ > public (0 calls)
0: ^^(p:_ @bool:25:10, q:_ @bool:25:18, ?#result:_ @bool:25:5):
    foreign llvm xor(p @bool:25:44, q @bool:25:47, ?tmp#0 @bool:25:27)
    foreign llvm move(tmp#0, ?#result @bool:25:5)


print > public (0 calls)
0: print(x:_ @bool:47:15) use !io:
    if {x::

        foreign llvm move(c"true" @bool:47:45, ?tmp#0)
    else::
        foreign llvm move(c"false" @bool:47:60, ?tmp#0)

    }
    !print(tmp#0 @bool:47:41)


println > public (0 calls)
0: println(x:_ @bool:49:17) use !io:
    !print(x @bool:49:39)
    !nl


succeed > public (0 calls)
0: succeed():
    pass


|= > public (0 calls)
0: |=(!p:_ @bool:22:11, q:_ @bool:22:19):
    ||(p @bool:22:32, q @bool:22:38, ?tmp#0 @bool:22:32)
    =(?p @bool:22:27, tmp#0)


|| > public (0 calls)
0: ||(p:_ @bool:19:10, q:_ @bool:19:18, ?#result:_ @bool:19:5):
    foreign llvm or(p @bool:19:43, q @bool:19:46, ?tmp#0 @bool:19:27)
    foreign llvm move(tmp#0, ?#result @bool:19:5)


~ > public (0 calls)
0: ~(p:_ @bool:31:11, ?#result:_ @bool:31:5):
    true(?tmp#1 @bool:31:40)
    foreign llvm xor(p @bool:31:37, tmp#1, ?tmp#0 @bool:31:20)
    foreign llvm move(tmp#0, ?#result @bool:31:5)


~= > public (0 calls)
0: ~=(x:_ @bool:38:10, y:_ @bool:38:18, ?#result:_ @bool:38:5):
    foreign llvm icmp_ne(x @bool:38:48, y @bool:38:51, ?tmp#0 @bool:38:27)
    foreign llvm move(tmp#0, ?#result @bool:38:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.c_string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.c_string.<<0>
                    wybe.c_string.<=<0>
                    wybe.c_string.=<0>
                    wybe.c_string.><0>
                    wybe.c_string.>=<0>
                    wybe.c_string.[]<0>
                    wybe.c_string.[|]<0>
                    wybe.c_string.length<0>
                    wybe.c_string.print<0>
                    wybe.c_string.println<0>
                    wybe.c_string.read<0>
                    wybe.c_string.unsafe_c_string_index<0>
                    wybe.c_string.~=<0>
  imports         : use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:_ @c_string:12:10, y:_ @c_string:12:17, ?#result:bool @c_string:12:5):
    foreign c strcmp(x @c_string:12:46, y @c_string:12:48, ?tmp#1:int @c_string:12:29)
    <(tmp#1:int, 0 @c_string:12:57, ?tmp#0 @c_string:12:29)
    foreign llvm move(tmp#0, ?#result @c_string:12:5)


<= > public (0 calls)
0: <=(x:_ @c_string:13:10, y:_ @c_string:13:18, ?#result:bool @c_string:13:5):
    foreign c strcmp(x @c_string:13:47, y @c_string:13:49, ?tmp#1:int @c_string:13:30)
    <=(tmp#1:int, 0 @c_string:13:60, ?tmp#0 @c_string:13:30)
    foreign llvm move(tmp#0, ?#result @c_string:13:5)


= > public (0 calls)
0: =(x:_ @c_string:10:10, y:_ @c_string:10:17, ?#result:bool @c_string:10:5):
    foreign c strcmp(x @c_string:10:46, y @c_string:10:48, ?tmp#1:int @c_string:10:29)
    =(tmp#1:int, 0 @c_string:10:57, ?tmp#0 @c_string:10:29)
    foreign llvm move(tmp#0, ?#result @c_string:10:5)


> > public (0 calls)
0: >(x:_ @c_string:14:10, y:_ @c_string:14:17, ?#result:bool @c_string:14:5):
    foreign c strcmp(x @c_string:14:46, y @c_string:14:48, ?tmp#1:int @c_string:14:29)
    >(tmp#1:int, 0 @c_string:14:57, ?tmp#0 @c_string:14:29)
    foreign llvm move(tmp#0, ?#result @c_string:14:5)


>= > public (0 calls)
0: >=(x:_ @c_string:15:10, y:_ @c_string:15:18, ?#result:bool @c_string:15:5):
    foreign c strcmp(x @c_string:15:47, y @c_string:15:49, ?tmp#1:int @c_string:15:30)
    >=(tmp#1:int, 0 @c_string:15:60, ?tmp#0 @c_string:15:30)
    foreign llvm move(tmp#0, ?#result @c_string:15:5)


[] > public {test} (0 calls)
0: [](str:_ @c_string:26:19, idx:int @c_string:26:26, ?#result:char @c_string:26:5):
    <=(0 @c_string:27:6, idx @c_string:27:12)
    length(str @c_string:28:19, ?tmp#0 @c_string:28:12)
    <(idx @c_string:28:6, tmp#0)
    unsafe_c_string_index(str @c_string:29:32, idx @c_string:29:37, ?tmp#1 @c_string:29:10)
    =(?c @c_string:29:6, tmp#1)
    foreign llvm move(c @c_string:26:42, ?#result @c_string:26:5)


[|] > public {test} (0 calls)
0: [|](?head:char @c_string:19:23, ?tail:_ @c_string:19:35, str:_ @c_string:19:43):
    foreign lpvm access(str @c_string:20:25, 0 @c_string:20:30, 0 @c_string:20:33, 0 @c_string:20:36, ?head @c_string:20:40)
    foreign llvm icmp_ne(head @c_string:21:26, '\NUL' @c_string:21:32, ?not_done @c_string:21:37)
    true(?tmp#0 @c_string:22:17)
    =(not_done @c_string:22:6, tmp#0)
    foreign llvm add(str @c_string:23:22, 1 @c_string:23:27, ?tail @c_string:23:31)


length > public (0 calls)
0: length(str:_ @c_string:17:16, ?#result:int @c_string:17:5):
    foreign c strlen(str @c_string:17:46, ?tmp#0 @c_string:17:29)
    foreign llvm move(tmp#0, ?#result @c_string:17:5)


print > public (0 calls)
0: print(x:_ @c_string:35:15) use !io:
    foreign c print_string(x @c_string:35:53, !io @c_string:35:57)


println > public (0 calls)
0: println(x:_ @c_string:37:17) use !io:
    !print(x @c_string:37:39)
    !nl


read > public (0 calls)
0: read(?x:_ @c_string:39:15) use !io:
    foreign c read_line(?x @c_string:39:51, !io @c_string:39:55)


unsafe_c_string_index > public (0 calls)
0: unsafe_c_string_index(str:_ @c_string:32:31, idx:int @c_string:32:38, ?#result:char @c_string:32:5):
    foreign lpvm access(str @c_string:33:27, idx @c_string:33:32, 1 @c_string:33:37, 0 @c_string:33:40, ?tmp#0 @c_string:33:7)
    foreign llvm move(tmp#0, ?#result @c_string:32:5)


~= > public (0 calls)
0: ~=(x:_ @c_string:11:10, y:_ @c_string:11:18, ?#result:bool @c_string:11:5):
    foreign c strcmp(x @c_string:11:47, y @c_string:11:49, ?tmp#1:int @c_string:11:30)
    ~=(tmp#1:int, 0 @c_string:11:60, ?tmp#0 @c_string:11:30)
    foreign llvm move(tmp#0, ?#result @c_string:11:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.char
  representation  : 8 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.char.<<0>
                    wybe.char.<=<0>
                    wybe.char.<=><0>
                    wybe.char.=<0>
                    wybe.char.><0>
                    wybe.char.>=<0>
                    wybe.char.chr<0>
                    wybe.char.ord<0>
                    wybe.char.print<0>
                    wybe.char.println<0>
                    wybe.char.read<0>
                    wybe.char.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:_ @char:17:10, y:_ @char:17:17, ?#result:bool @char:17:5):
    foreign llvm icmp_ult(x @char:17:51, y @char:17:54, ?tmp#0 @char:17:29)
    foreign llvm move(tmp#0, ?#result @char:17:5)


<= > public (0 calls)
0: <=(x:_ @char:18:10, y:_ @char:18:18, ?#result:bool @char:18:5):
    foreign llvm icmp_ule(x @char:18:52, y @char:18:55, ?tmp#0 @char:18:30)
    foreign llvm move(tmp#0, ?#result @char:18:5)


<=> > public (0 calls)
0: <=>(x:_ @char:23:10, y:_ @char:23:20, ?#result:comparison @char:23:5):
    if {<(x @char:24:10, y @char:24:14)::

        lesser(?tmp#1 @char:24:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @char:24:28, y @char:24:32)::

            equal(?tmp#3 @char:24:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @char:24:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @char:24:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @char:24:10, ?#result @char:23:5)


= > public (0 calls)
0: =(x:_ @char:13:10, y:_ @char:13:17, ?#result:bool @char:13:5):
    foreign llvm icmp_eq(x @char:13:50, y @char:13:53, ?tmp#0 @char:13:29)
    foreign llvm move(tmp#0, ?#result @char:13:5)


> > public (0 calls)
0: >(x:_ @char:19:10, y:_ @char:19:17, ?#result:bool @char:19:5):
    foreign llvm icmp_ugt(x @char:19:51, y @char:19:54, ?tmp#0 @char:19:29)
    foreign llvm move(tmp#0, ?#result @char:19:5)


>= > public (0 calls)
0: >=(x:_ @char:20:10, y:_ @char:20:18, ?#result:bool @char:20:5):
    foreign llvm icmp_uge(x @char:20:52, y @char:20:55, ?tmp#0 @char:20:30)
    foreign llvm move(tmp#0, ?#result @char:20:5)


chr > public {test} (0 calls)
0: chr(i:int @char:33:20, ?#result:_ @char:33:5):
    <=(0 @char:33:60, i @char:33:66)
    <=(i @char:33:70, 255 @char:33:76)
    foreign lpvm cast(i @char:33:49, ?tmp#0 @char:33:31)
    foreign llvm move(tmp#0, ?#result @char:33:5)


ord > public (0 calls)
0: ord(c:_ @char:30:13, ?#result:int @char:30:5):
    foreign lpvm cast(c @char:30:42, ?tmp#0 @char:30:24)
    foreign llvm move(tmp#0, ?#result @char:30:5)


print > public (0 calls)
0: print(x:_ @char:37:15) use !io:
    foreign c putchar(x @char:37:48, !io @char:37:52)


println > public (0 calls)
0: println(x:_ @char:39:17) use !io:
    !print(x @char:39:39)
    !nl


read > public (0 calls)
0: read(?x:_ @char:41:15) use !io:
    foreign c read_char(?x @char:41:51, !io @char:41:55)


~= > public (0 calls)
0: ~=(x:_ @char:14:10, y:_ @char:14:18, ?#result:bool @char:14:5):
    foreign llvm icmp_ne(x @char:14:51, y @char:14:54, ?tmp#0 @char:14:30)
    foreign llvm move(tmp#0, ?#result @char:14:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.comparison
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.comparison.<<0>
                    wybe.comparison.<=<0>
                    wybe.comparison.=<0>
                    wybe.comparison.><0>
                    wybe.comparison.>=<0>
                    wybe.comparison.~=<0>
  imports         : use wybe.bool
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:_ @comparison:12:10, y:_ @comparison:12:17, ?#result:bool @comparison:12:5):
    foreign llvm icmp_ult(x @comparison:12:51, y @comparison:12:54, ?tmp#0 @comparison:12:29)
    foreign llvm move(tmp#0, ?#result @comparison:12:5)


<= > public (0 calls)
0: <=(x:_ @comparison:13:10, y:_ @comparison:13:18, ?#result:bool @comparison:13:5):
    foreign llvm icmp_ule(x @comparison:13:52, y @comparison:13:55, ?tmp#0 @comparison:13:30)
    foreign llvm move(tmp#0, ?#result @comparison:13:5)


= > public (0 calls)
0: =(x:_ @comparison:10:10, y:_ @comparison:10:17, ?#result:bool @comparison:10:5):
    foreign llvm icmp_eq(x @comparison:10:50, y @comparison:10:53, ?tmp#0 @comparison:10:29)
    foreign llvm move(tmp#0, ?#result @comparison:10:5)


> > public (0 calls)
0: >(x:_ @comparison:14:10, y:_ @comparison:14:17, ?#result:bool @comparison:14:5):
    foreign llvm icmp_ugt(x @comparison:14:51, y @comparison:14:54, ?tmp#0 @comparison:14:29)
    foreign llvm move(tmp#0, ?#result @comparison:14:5)


>= > public (0 calls)
0: >=(x:_ @comparison:15:10, y:_ @comparison:15:18, ?#result:bool @comparison:15:5):
    foreign llvm icmp_uge(x @comparison:15:52, y @comparison:15:55, ?tmp#0 @comparison:15:30)
    foreign llvm move(tmp#0, ?#result @comparison:15:5)


~= > public (0 calls)
0: ~=(x:_ @comparison:11:10, y:_ @comparison:11:18, ?#result:bool @comparison:11:5):
    foreign llvm icmp_ne(x @comparison:11:51, y @comparison:11:54, ?tmp#0 @comparison:11:30)
    foreign llvm move(tmp#0, ?#result @comparison:11:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.control
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.control.assert<0>
                    wybe.control.error<0>
                    wybe.control.error<1>
                    wybe.control.exit<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.int
                    use wybe.string
  resources       : 
  procs           : 

assert > public {semipure} (0 calls)
0: assert(condition:bool @control:26:27) use call_source_location:
    if {~(condition @control:27:11)::

        !error(c"assertion failed" @control:27:31)
    else::
        pass

    }


error > public {terminal,semipure} (0 calls)
0: error(message:string @control:17:35) use call_source_location:
    c_string(message @control:18:77, ?tmp#0 @control:18:68)
    foreign c {terminal,semipure} error_exit(call_source_location @control:18:46, tmp#0)
error > public {terminal,semipure} (0 calls)
1: error(message:c_string @control:21:35) use call_source_location:
    foreign c {terminal,semipure} error_exit(call_source_location @control:22:46, message @control:22:68)


exit > public {terminal,semipure} (0 calls)
0: exit(code:int @control:10:34):
    foreign c {terminal,semipure} exit(code @control:11:40)

LLVM code       : None

--------------------------------------------------
 Module wybe.count
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.count.%<0>
                    wybe.count.%=<0>
                    wybe.count.*<0>
                    wybe.count.*=<0>
                    wybe.count.+<0>
                    wybe.count.+<1>
                    wybe.count.+<2>
                    wybe.count.+=<0>
                    wybe.count.-<0>
                    wybe.count.-<1>
                    wybe.count.-<2>
                    wybe.count.-=<0>
                    wybe.count./<0>
                    wybe.count./=<0>
                    wybe.count.<<0>
                    wybe.count.<=<0>
                    wybe.count.<=><0>
                    wybe.count.=<0>
                    wybe.count.><0>
                    wybe.count.>=<0>
                    wybe.count.decr<0>
                    wybe.count.incr<0>
                    wybe.count.max<0>
                    wybe.count.min<0>
                    wybe.count.print<0>
                    wybe.count.println<0>
                    wybe.count.read<0>
                    wybe.count.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public (0 calls)
0: %(x:_ @count:51:10, y:_ @count:51:16, ?#result:_ @count:51:5):
    foreign llvm urem(x @count:51:43, y @count:51:45, ?tmp#0 @count:51:25)
    foreign llvm move(tmp#0, ?#result @count:51:5)


%= > public (0 calls)
0: %=(!x:_ @count:54:11, y:_ @count:54:19):
    %(x @count:54:31, y @count:54:35, ?tmp#0 @count:54:31)
    =(?x @count:54:27, tmp#0)


* > public (0 calls)
0: *(x:_ @count:39:10, y:_ @count:39:16, ?#result:_ @count:39:5):
    foreign llvm mul(x @count:39:42, y @count:39:44, ?tmp#0 @count:39:25)
    foreign llvm move(tmp#0, ?#result @count:39:5)


*= > public (0 calls)
0: *=(!x:_ @count:42:11, y:_ @count:42:19):
    *(x @count:42:31, y @count:42:35, ?tmp#0 @count:42:31)
    =(?x @count:42:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @count:15:10, y:_ @count:15:16, ?#result:_ @count:15:5):
    foreign llvm add(x @count:15:42, y @count:15:44, ?tmp#0 @count:15:25)
    foreign llvm move(tmp#0, ?#result @count:15:5)
+ > public {test} (0 calls)
1: +(?x:_ @count:16:21, y:_ @count:16:27, z:_ @count:16:5):
    >=(z @count:17:5, y @count:17:11)
    foreign llvm sub(z @count:18:27, y @count:18:29, ?tmp#0 @count:18:10)
    =(?x @count:18:6, tmp#0)
+ > public {test} (0 calls)
2: +(x:_ @count:20:20, ?y:_ @count:20:27, z:_ @count:20:5):
    >=(z @count:21:5, x @count:21:11)
    foreign llvm sub(z @count:22:27, x @count:22:29, ?tmp#0 @count:22:10)
    =(?y @count:22:6, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @count:26:11, y:_ @count:26:19):
    +(x @count:26:31, y @count:26:35, ?tmp#0 @count:26:31)
    =(?x @count:26:27, tmp#0)


- > public {test} (0 calls)
0: -(x:_ @count:31:20, y:_ @count:31:26, ?#result:_ @count:31:5):
    >=(y @count:31:65, x @count:31:71)
    foreign llvm sub(x @count:31:52, y @count:31:54, ?tmp#0 @count:31:35)
    foreign llvm move(tmp#0, ?#result @count:31:5)
- > public (0 calls)
1: -(?x:_ @count:32:11, y:_ @count:32:17, z:_ @count:32:5):
    foreign llvm add(z @count:32:59, y @count:32:61, ?tmp#0 @count:32:42)
    =(?x @count:32:38, tmp#0)
- > public (0 calls)
2: -(x:_ @count:33:10, ?y:_ @count:33:17, z:_ @count:33:5):
    foreign llvm sub(z @count:33:59, x @count:33:61, ?tmp#0 @count:33:42)
    =(?y @count:33:38, tmp#0)


-= > public {test} (0 calls)
0: -=(!x:_ @count:36:21, y:_ @count:36:29):
    -(x @count:36:41, y @count:36:45, ?tmp#0 @count:36:41)
    =(?x @count:36:37, tmp#0)


/ > public (0 calls)
0: /(x:_ @count:45:10, y:_ @count:45:16, ?#result:_ @count:45:5):
    foreign llvm udiv(x @count:45:43, y @count:45:45, ?tmp#0 @count:45:25)
    foreign llvm move(tmp#0, ?#result @count:45:5)


/= > public (0 calls)
0: /=(!x:_ @count:48:11, y:_ @count:48:19):
    /(x @count:48:31, y @count:48:35, ?tmp#0 @count:48:31)
    =(?x @count:48:27, tmp#0)


< > public (0 calls)
0: <(x:_ @count:64:10, y:_ @count:64:17, ?#result:bool @count:64:5):
    foreign llvm icmp_ult(x @count:64:51, y @count:64:53, ?tmp#0 @count:64:29)
    foreign llvm move(tmp#0, ?#result @count:64:5)


<= > public (0 calls)
0: <=(x:_ @count:65:10, y:_ @count:65:18, ?#result:bool @count:65:5):
    foreign llvm icmp_ule(x @count:65:52, y @count:65:54, ?tmp#0 @count:65:30)
    foreign llvm move(tmp#0, ?#result @count:65:5)


<=> > public (0 calls)
0: <=>(x:_ @count:70:10, y:_ @count:70:20, ?#result:comparison @count:70:5):
    if {<(x @count:71:10, y @count:71:14)::

        lesser(?tmp#1 @count:71:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @count:71:28, y @count:71:32)::

            equal(?tmp#3 @count:71:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @count:71:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @count:71:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:71:10, ?#result @count:70:5)


= > public (0 calls)
0: =(x:_ @count:60:10, y:_ @count:60:17, ?#result:bool @count:60:5):
    foreign llvm icmp_eq(x @count:60:50, y @count:60:52, ?tmp#0 @count:60:29)
    foreign llvm move(tmp#0, ?#result @count:60:5)


> > public (0 calls)
0: >(x:_ @count:66:10, y:_ @count:66:17, ?#result:bool @count:66:5):
    foreign llvm icmp_ugt(x @count:66:51, y @count:66:53, ?tmp#0 @count:66:29)
    foreign llvm move(tmp#0, ?#result @count:66:5)


>= > public (0 calls)
0: >=(x:_ @count:67:10, y:_ @count:67:18, ?#result:bool @count:67:5):
    foreign llvm icmp_uge(x @count:67:52, y @count:67:54, ?tmp#0 @count:67:30)
    foreign llvm move(tmp#0, ?#result @count:67:5)


decr > public {test} (0 calls)
0: decr(!x:_ @count:84:25):
    -(x @count:84:37, 1:_ @count:84:41, ?tmp#0 @count:84:37)
    =(?x @count:84:33, tmp#0)


incr > public (0 calls)
0: incr(!x:_ @count:81:15):
    +(x @count:81:27, 1:_ @count:81:31, ?tmp#0 @count:81:27)
    =(?x @count:81:23, tmp#0)


max > public (0 calls)
0: max(x:_ @count:75:13, y:_ @count:75:18, ?#result:_ @count:75:5):
    if {>=(x @count:75:31, y @count:75:35)::

        foreign llvm move(x @count:75:39, ?tmp#0)
    else::
        foreign llvm move(y @count:75:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:75:31, ?#result @count:75:5)


min > public (0 calls)
0: min(x:_ @count:74:13, y:_ @count:74:18, ?#result:_ @count:74:5):
    if {<=(x @count:74:31, y @count:74:35)::

        foreign llvm move(x @count:74:39, ?tmp#0)
    else::
        foreign llvm move(y @count:74:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:74:31, ?#result @count:74:5)


print > public (0 calls)
0: print(x:_ @count:88:15) use !io:
    foreign c print_count(x @count:88:52, !io @count:88:56)


println > public (0 calls)
0: println(x:_ @count:90:17) use !io:
    !print(x @count:90:39)
    !nl


read > public (0 calls)
0: read(?x:_ @count:92:15) use !io:
    foreign c read_count(?x @count:92:52, !io @count:92:56)


~= > public (0 calls)
0: ~=(x:_ @count:61:10, y:_ @count:61:18, ?#result:bool @count:61:5):
    foreign llvm icmp_ne(x @count:61:51, y @count:61:53, ?tmp#0 @count:61:30)
    foreign llvm move(tmp#0, ?#result @count:61:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.float
  representation  : 64 bit float
  public submods  : 
  public resources: 
  public procs    : wybe.float.*<0>
                    wybe.float.**<0>
                    wybe.float.*=<0>
                    wybe.float.+<0>
                    wybe.float.+<1>
                    wybe.float.+<2>
                    wybe.float.+=<0>
                    wybe.float.-<0>
                    wybe.float.-<1>
                    wybe.float.-<2>
                    wybe.float.-<3>
                    wybe.float.-<4>
                    wybe.float.-=<0>
                    wybe.float./<0>
                    wybe.float./=<0>
                    wybe.float.<<0>
                    wybe.float.<=<0>
                    wybe.float.<=><0>
                    wybe.float.=<0>
                    wybe.float.><0>
                    wybe.float.>=<0>
                    wybe.float.abs<0>
                    wybe.float.ceil<0>
                    wybe.float.cos<0>
                    wybe.float.e<0>
                    wybe.float.exp<0>
                    wybe.float.floor<0>
                    wybe.float.iceil<0>
                    wybe.float.ifloor<0>
                    wybe.float.iround<0>
                    wybe.float.log<0>
                    wybe.float.log10<0>
                    wybe.float.log2<0>
                    wybe.float.max<0>
                    wybe.float.min<0>
                    wybe.float.pi<0>
                    wybe.float.power<0>
                    wybe.float.print<0>
                    wybe.float.println<0>
                    wybe.float.read<0>
                    wybe.float.round<0>
                    wybe.float.sin<0>
                    wybe.float.sqrt<0>
                    wybe.float.square<0>
                    wybe.float.tan<0>
                    wybe.float.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

* > public (0 calls)
0: *(x:_ @float:45:10, y:_ @float:45:16, ?#result:_ @float:45:5):
    foreign llvm fmul(x @float:45:43, y @float:45:45, ?tmp#0 @float:45:25)
    foreign llvm move(tmp#0, ?#result @float:45:5)


** > public (0 calls)
0: **(x:_ @float:112:10, n:_ @float:112:18, ?#result:_ @float:112:5):
    foreign c llvm.pow.f64(x @float:112:52, n @float:112:54, ?tmp#0 @float:112:27)
    foreign llvm move(tmp#0, ?#result @float:112:5)


*= > public (0 calls)
0: *=(!x:_ @float:48:11, y:_ @float:48:19):
    *(x @float:48:31, y @float:48:35, ?tmp#0 @float:48:31)
    =(?x @float:48:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @float:23:10, y:_ @float:23:17, ?#result:_ @float:23:5):
    foreign llvm fadd(x @float:23:45, y @float:23:47, ?tmp#0 @float:23:27)
    foreign llvm move(tmp#0, ?#result @float:23:5)
+ > public (0 calls)
1: +(?x:_ @float:24:11, y:_ @float:24:17, z:_ @float:24:5):
    foreign llvm fsub(z @float:24:61, y @float:24:63, ?tmp#0 @float:24:43)
    =(?x @float:24:39, tmp#0)
+ > public (0 calls)
2: +(x:_ @float:25:10, ?y:_ @float:25:18, z:_ @float:25:5):
    foreign llvm fsub(z @float:25:61, x @float:25:63, ?tmp#0 @float:25:43)
    =(?y @float:25:39, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @float:28:11, y:_ @float:28:19):
    +(x @float:28:31, y @float:28:35, ?tmp#0 @float:28:31)
    =(?x @float:28:27, tmp#0)


- > public (0 calls)
0: -(x:_ @float:32:10, y:_ @float:32:17, ?#result:_ @float:32:5):
    foreign llvm fsub(x @float:32:45, y @float:32:47, ?tmp#0 @float:32:27)
    foreign llvm move(tmp#0, ?#result @float:32:5)
- > public (0 calls)
1: -(?x:_ @float:33:11, y:_ @float:33:17, z:_ @float:33:5):
    foreign llvm fadd(z @float:33:61, y @float:33:63, ?tmp#0 @float:33:43)
    =(?x @float:33:39, tmp#0)
- > public (0 calls)
2: -(x:_ @float:34:10, ?y:_ @float:34:18, z:_ @float:34:5):
    foreign llvm fsub(z @float:34:61, x @float:34:63, ?tmp#0 @float:34:43)
    =(?y @float:34:39, tmp#0)
- > public (0 calls)
3: -(x:_ @float:38:11, ?#result:_ @float:38:5):
    foreign llvm fsub(0.0 @float:38:39, x @float:38:43, ?tmp#0 @float:38:21)
    foreign llvm move(tmp#0, ?#result @float:38:5)
- > public (0 calls)
4: -(?x:_ @float:39:12, y:_ @float:39:5):
    foreign llvm fsub(0.0 @float:39:55, y @float:39:59, ?tmp#0 @float:39:37)
    =(?x @float:39:33, tmp#0)


-= > public (0 calls)
0: -=(!x:_ @float:42:11, y:_ @float:42:19):
    -(x @float:42:31, y @float:42:35, ?tmp#0 @float:42:31)
    =(?x @float:42:27, tmp#0)


/ > public (0 calls)
0: /(x:_ @float:51:10, y:_ @float:51:16, ?#result:_ @float:51:5):
    foreign llvm fdiv(x @float:51:43, y @float:51:45, ?tmp#0 @float:51:25)
    foreign llvm move(tmp#0, ?#result @float:51:5)


/= > public (0 calls)
0: /=(!x:_ @float:54:11, y:_ @float:54:19):
    /(x @float:54:31, y @float:54:35, ?tmp#0 @float:54:31)
    =(?x @float:54:27, tmp#0)


< > public (0 calls)
0: <(x:_ @float:70:10, y:_ @float:70:17, ?#result:bool @float:70:5):
    foreign llvm fcmp_slt(x @float:70:51, y @float:70:53, ?tmp#0 @float:70:29)
    foreign llvm move(tmp#0, ?#result @float:70:5)


<= > public (0 calls)
0: <=(x:_ @float:71:10, y:_ @float:71:18, ?#result:bool @float:71:5):
    foreign llvm fcmp_sle(x @float:71:52, y @float:71:54, ?tmp#0 @float:71:30)
    foreign llvm move(tmp#0, ?#result @float:71:5)


<=> > public (0 calls)
0: <=>(x:_ @float:76:10, y:_ @float:76:20, ?#result:comparison @float:76:5):
    if {<(x @float:77:10, y @float:77:14)::

        lesser(?tmp#1 @float:77:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @float:77:28, y @float:77:32)::

            equal(?tmp#3 @float:77:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @float:77:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @float:77:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @float:77:10, ?#result @float:76:5)


= > public (0 calls)
0: =(x:_ @float:66:10, y:_ @float:66:17, ?#result:bool @float:66:5):
    foreign llvm fcmp_eq(x @float:66:50, y @float:66:52, ?tmp#0 @float:66:29)
    foreign llvm move(tmp#0, ?#result @float:66:5)


> > public (0 calls)
0: >(x:_ @float:72:10, y:_ @float:72:17, ?#result:bool @float:72:5):
    foreign llvm fcmp_sgt(x @float:72:51, y @float:72:53, ?tmp#0 @float:72:29)
    foreign llvm move(tmp#0, ?#result @float:72:5)


>= > public (0 calls)
0: >=(x:_ @float:73:10, y:_ @float:73:18, ?#result:bool @float:73:5):
    foreign llvm fcmp_sge(x @float:73:52, y @float:73:54, ?tmp#0 @float:73:30)
    foreign llvm move(tmp#0, ?#result @float:73:5)


abs > public (0 calls)
0: abs(x:_ @float:60:13, ?#result:_ @float:60:5):
    foreign c llvm.fabs.f64(x @float:60:48, ?tmp#0 @float:60:22)
    foreign llvm move(tmp#0, ?#result @float:60:5)


ceil > public (0 calls)
0: ceil(x:_ @float:87:14, ?#result:_ @float:87:5):
    foreign c llvm.ceil.f64(x @float:87:49, ?tmp#0 @float:87:23)
    foreign llvm move(tmp#0, ?#result @float:87:5)


cos > public (0 calls)
0: cos(x:_ @float:116:13, ?#result:_ @float:116:5):
    foreign c llvm.cos.f64(x @float:116:47, ?tmp#0 @float:116:22)
    foreign llvm move(tmp#0, ?#result @float:116:5)


e > public (0 calls)
0: e(?#result:_ @float:16:5):
    foreign llvm move(2.7182818284590455 @float:16:15, ?#result @float:16:5)


exp > public (0 calls)
0: exp(x:_ @float:120:13, ?#result:_ @float:120:5):
    foreign c llvm.exp.f64(x @float:120:47, ?tmp#0 @float:120:22)
    foreign llvm move(tmp#0, ?#result @float:120:5)


floor > public (0 calls)
0: floor(x:_ @float:90:15, ?#result:_ @float:90:5):
    foreign c llvm.floor.f64(x @float:90:51, ?tmp#0 @float:90:24)
    foreign llvm move(tmp#0, ?#result @float:90:5)


iceil > public (0 calls)
0: iceil(x:_ @float:99:15, ?#result:int @float:99:5):
    ceil(x @float:99:51, ?tmp#1 @float:99:46)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:99:26)
    foreign llvm move(tmp#0, ?#result @float:99:5)


ifloor > public (0 calls)
0: ifloor(x:_ @float:102:16, ?#result:int @float:102:5):
    floor(x @float:102:53, ?tmp#1 @float:102:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:102:27)
    foreign llvm move(tmp#0, ?#result @float:102:5)


iround > public (0 calls)
0: iround(x:_ @float:96:16, ?#result:int @float:96:5):
    round(x @float:96:53, ?tmp#1 @float:96:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:96:27)
    foreign llvm move(tmp#0, ?#result @float:96:5)


log > public (0 calls)
0: log(x:_ @float:123:13, ?#result:_ @float:123:5):
    foreign c llvm.log.f64(x @float:123:47, ?tmp#0 @float:123:22)
    foreign llvm move(tmp#0, ?#result @float:123:5)


log10 > public (0 calls)
0: log10(x:_ @float:126:15, ?#result:_ @float:126:5):
    foreign c llvm.log10.f64(x @float:126:51, ?tmp#0 @float:126:24)
    foreign llvm move(tmp#0, ?#result @float:126:5)


log2 > public (0 calls)
0: log2(x:_ @float:129:14, ?#result:_ @float:129:5):
    foreign c llvm.log2.f64(x @float:129:49, ?tmp#0 @float:129:23)
    foreign llvm move(tmp#0, ?#result @float:129:5)


max > public (0 calls)
0: max(x:_ @float:81:13, y:_ @float:81:18, ?#result:_ @float:81:5):
    foreign c llvm.maxnum.f64(x @float:81:55, y @float:81:57, ?tmp#0 @float:81:27)
    foreign llvm move(tmp#0, ?#result @float:81:5)


min > public (0 calls)
0: min(x:_ @float:80:13, y:_ @float:80:18, ?#result:_ @float:80:5):
    foreign c llvm.minnum.f64(x @float:80:55, y @float:80:57, ?tmp#0 @float:80:27)
    foreign llvm move(tmp#0, ?#result @float:80:5)


pi > public (0 calls)
0: pi(?#result:_ @float:13:5):
    foreign llvm move(3.141592653589793 @float:13:16, ?#result @float:13:5)


power > public (0 calls)
0: power(x:_ @float:111:15, n:_ @float:111:19, ?#result:_ @float:111:5):
    foreign c llvm.pow.f64(x @float:111:53, n @float:111:55, ?tmp#0 @float:111:28)
    foreign llvm move(tmp#0, ?#result @float:111:5)


print > public (0 calls)
0: print(x:_ @float:133:15) use !io:
    foreign c print_float(x @float:133:52, !io @float:133:56)


println > public (0 calls)
0: println(x:_ @float:135:17) use !io:
    !print(x @float:135:39)
    !nl


read > public (0 calls)
0: read(?x:_ @float:137:15) use !io:
    foreign c read_float(?x @float:137:52, !io @float:137:56)


round > public (0 calls)
0: round(x:_ @float:93:15, ?#result:_ @float:93:5):
    foreign c llvm.round.f64(x @float:93:51, ?tmp#0 @float:93:24)
    foreign llvm move(tmp#0, ?#result @float:93:5)


sin > public (0 calls)
0: sin(x:_ @float:115:13, ?#result:_ @float:115:5):
    foreign c llvm.sin.f64(x @float:115:47, ?tmp#0 @float:115:22)
    foreign llvm move(tmp#0, ?#result @float:115:5)


sqrt > public (0 calls)
0: sqrt(x:_ @float:108:14, ?#result:_ @float:108:5):
    foreign c llvm.sqrt.f64(x @float:108:49, ?tmp#0 @float:108:23)
    foreign llvm move(tmp#0, ?#result @float:108:5)


square > public (0 calls)
0: square(x:_ @float:57:16, ?#result:_ @float:57:5):
    foreign llvm fmul(x @float:57:43, x @float:57:45, ?tmp#0 @float:57:25)
    foreign llvm move(tmp#0, ?#result @float:57:5)


tan > public (0 calls)
0: tan(x:_ @float:117:13, ?#result:_ @float:117:5):
    foreign c llvm.sin.f64(x @float:117:47, ?tmp#1 @float:117:22)
    foreign c llvm.cos.f64(x @float:117:77, ?tmp#2 @float:117:52)
    /(tmp#1, tmp#2, ?tmp#0 @float:117:22)
    foreign llvm move(tmp#0, ?#result @float:117:5)


~= > public (0 calls)
0: ~=(x:_ @float:67:10, y:_ @float:67:18, ?#result:bool @float:67:5):
    foreign llvm fcmp_ne(x @float:67:51, y @float:67:53, ?tmp#0 @float:67:30)
    foreign llvm move(tmp#0, ?#result @float:67:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.int
  representation  : 64 bit signed
  public submods  : 
  public resources: 
  public procs    : wybe.int.%<0>
                    wybe.int.%=<0>
                    wybe.int.*<0>
                    wybe.int.*=<0>
                    wybe.int.+<0>
                    wybe.int.+<1>
                    wybe.int.+<2>
                    wybe.int.+=<0>
                    wybe.int.-<0>
                    wybe.int.-<1>
                    wybe.int.-<2>
                    wybe.int.-<3>
                    wybe.int.-<4>
                    wybe.int.-=<0>
                    wybe.int./<0>
                    wybe.int./=<0>
                    wybe.int.<<0>
                    wybe.int.<<<0>
                    wybe.int.<<=<0>
                    wybe.int.<=<0>
                    wybe.int.<=><0>
                    wybe.int.=<0>
                    wybe.int.><0>
                    wybe.int.>=<0>
                    wybe.int.>><0>
                    wybe.int.>>=<0>
                    wybe.int.decr<0>
                    wybe.int.incr<0>
                    wybe.int.logical_bitshift<0>
                    wybe.int.logical_bitshift<1>
                    wybe.int.max<0>
                    wybe.int.min<0>
                    wybe.int.power<0>
                    wybe.int.print<0>
                    wybe.int.println<0>
                    wybe.int.read<0>
                    wybe.int.signum<0>
                    wybe.int.sqrt<0>
                    wybe.int.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public (0 calls)
0: %(x:_ @int:50:10, y:_ @int:50:16, ?#result:_ @int:50:5):
    foreign llvm srem(x @int:50:43, y @int:50:45, ?tmp#0 @int:50:25)
    foreign llvm move(tmp#0, ?#result @int:50:5)


%= > public (0 calls)
0: %=(!x:_ @int:53:11, y:_ @int:53:19):
    %(x @int:53:31, y @int:53:35, ?tmp#0 @int:53:31)
    =(?x @int:53:27, tmp#0)


* > public (0 calls)
0: *(x:_ @int:38:10, y:_ @int:38:16, ?#result:_ @int:38:5):
    foreign llvm mul(x @int:38:42, y @int:38:44, ?tmp#0 @int:38:25)
    foreign llvm move(tmp#0, ?#result @int:38:5)


*= > public (0 calls)
0: *=(!x:_ @int:41:11, y:_ @int:41:19):
    *(x @int:41:31, y @int:41:35, ?tmp#0 @int:41:31)
    =(?x @int:41:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @int:16:10, y:_ @int:16:17, ?#result:_ @int:16:5):
    foreign llvm add(x @int:16:44, y @int:16:46, ?tmp#0 @int:16:27)
    foreign llvm move(tmp#0, ?#result @int:16:5)
+ > public (0 calls)
1: +(?x:_ @int:17:11, y:_ @int:17:17, z:_ @int:17:5):
    foreign llvm sub(z @int:17:60, y @int:17:62, ?tmp#0 @int:17:43)
    =(?x @int:17:39, tmp#0)
+ > public (0 calls)
2: +(x:_ @int:18:10, ?y:_ @int:18:18, z:_ @int:18:5):
    foreign llvm sub(z @int:18:60, x @int:18:62, ?tmp#0 @int:18:43)
    =(?y @int:18:39, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @int:21:11, y:_ @int:21:19):
    +(x @int:21:31, y @int:21:35, ?tmp#0 @int:21:31)
    =(?x @int:21:27, tmp#0)


- > public (0 calls)
0: -(x:_ @int:25:10, y:_ @int:25:17, ?#result:_ @int:25:5):
    foreign llvm sub(x @int:25:44, y @int:25:46, ?tmp#0 @int:25:27)
    foreign llvm move(tmp#0, ?#result @int:25:5)
- > public (0 calls)
1: -(?x:_ @int:26:11, y:_ @int:26:17, z:_ @int:26:5):
    foreign llvm add(z @int:26:60, y @int:26:62, ?tmp#0 @int:26:43)
    =(?x @int:26:39, tmp#0)
- > public (0 calls)
2: -(x:_ @int:27:10, ?y:_ @int:27:18, z:_ @int:27:5):
    foreign llvm sub(z @int:27:60, x @int:27:62, ?tmp#0 @int:27:43)
    =(?y @int:27:39, tmp#0)
- > public (0 calls)
3: -(x:_ @int:31:11, ?#result:_ @int:31:5):
    foreign llvm sub(0 @int:31:38, x @int:31:40, ?tmp#0 @int:31:21)
    foreign llvm move(tmp#0, ?#result @int:31:5)
- > public (0 calls)
4: -(?x:_ @int:32:12, y:_ @int:32:5):
    foreign llvm sub(0 @int:32:54, y @int:32:56, ?tmp#0 @int:32:37)
    =(?x @int:32:33, tmp#0)


-= > public (0 calls)
0: -=(!x:_ @int:35:11, y:_ @int:35:19):
    -(x @int:35:31, y @int:35:35, ?tmp#0 @int:35:31)
    =(?x @int:35:27, tmp#0)


/ > public (0 calls)
0: /(x:_ @int:44:10, y:_ @int:44:16, ?#result:_ @int:44:5):
    foreign llvm sdiv(x @int:44:43, y @int:44:45, ?tmp#0 @int:44:25)
    foreign llvm move(tmp#0, ?#result @int:44:5)


/= > public (0 calls)
0: /=(!x:_ @int:47:11, y:_ @int:47:19):
    /(x @int:47:31, y @int:47:35, ?tmp#0 @int:47:31)
    =(?x @int:47:27, tmp#0)


< > public (0 calls)
0: <(x:_ @int:87:10, y:_ @int:87:17, ?#result:bool @int:87:5):
    foreign llvm icmp_slt(x @int:87:51, y @int:87:53, ?tmp#0 @int:87:29)
    foreign llvm move(tmp#0, ?#result @int:87:5)


<< > public (0 calls)
0: <<(x:_ @int:56:10, s:_ @int:56:18, ?#result:_ @int:56:5):
    foreign llvm shl(x @int:56:44, s @int:56:47, ?tmp#0 @int:56:27)
    foreign llvm move(tmp#0, ?#result @int:56:5)


<<= > public (0 calls)
0: <<=(!x:_ @int:59:11, s:_ @int:59:21):
    <<(x @int:59:33, s @int:59:39, ?tmp#0 @int:59:33)
    =(?x @int:59:29, tmp#0)


<= > public (0 calls)
0: <=(x:_ @int:88:10, y:_ @int:88:18, ?#result:bool @int:88:5):
    foreign llvm icmp_sle(x @int:88:52, y @int:88:54, ?tmp#0 @int:88:30)
    foreign llvm move(tmp#0, ?#result @int:88:5)


<=> > public (0 calls)
0: <=>(x:_ @int:93:10, y:_ @int:93:20, ?#result:comparison @int:93:5):
    if {<(x @int:94:10, y @int:94:14)::

        lesser(?tmp#1 @int:94:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @int:94:28, y @int:94:32)::

            equal(?tmp#3 @int:94:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @int:94:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @int:94:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @int:94:10, ?#result @int:93:5)


= > public (0 calls)
0: =(x:_ @int:83:10, y:_ @int:83:17, ?#result:bool @int:83:5):
    foreign llvm icmp_eq(x @int:83:50, y @int:83:52, ?tmp#0 @int:83:29)
    foreign llvm move(tmp#0, ?#result @int:83:5)


> > public (0 calls)
0: >(x:_ @int:89:10, y:_ @int:89:17, ?#result:bool @int:89:5):
    foreign llvm icmp_sgt(x @int:89:51, y @int:89:53, ?tmp#0 @int:89:29)
    foreign llvm move(tmp#0, ?#result @int:89:5)


>= > public (0 calls)
0: >=(x:_ @int:90:10, y:_ @int:90:18, ?#result:bool @int:90:5):
    foreign llvm icmp_sge(x @int:90:52, y @int:90:54, ?tmp#0 @int:90:30)
    foreign llvm move(tmp#0, ?#result @int:90:5)


>> > public (0 calls)
0: >>(x:_ @int:65:10, s:_ @int:65:18, ?#result:_ @int:65:5):
    foreign llvm ashr(x @int:65:45, s @int:65:48, ?tmp#0 @int:65:27)
    foreign llvm move(tmp#0, ?#result @int:65:5)


>>= > public (0 calls)
0: >>=(!x:_ @int:68:11, s:_ @int:68:21):
    >>(x @int:68:33, s @int:68:39, ?tmp#0 @int:68:33)
    =(?x @int:68:29, tmp#0)


decr > public (0 calls)
0: decr(!x:_ @int:111:15):
    -(x @int:111:27, 1 @int:111:31, ?tmp#0 @int:111:27)
    =(?x @int:111:23, tmp#0)


incr > public (0 calls)
0: incr(!x:_ @int:110:15):
    +(x @int:110:27, 1 @int:110:31, ?tmp#0 @int:110:27)
    =(?x @int:110:23, tmp#0)


logical_bitshift > public (0 calls)
0: logical_bitshift(x:_ @int:74:26, s:_ @int:74:31, ?#result:_ @int:74:5):
    foreign llvm lshr(x @int:74:58, s @int:74:61, ?tmp#0 @int:74:40)
    foreign llvm move(tmp#0, ?#result @int:74:5)
logical_bitshift > public (0 calls)
1: logical_bitshift(!x:_ @int:77:27, s:_ @int:77:32):
    logical_bitshift(x @int:77:61, s @int:77:64, ?tmp#0 @int:77:44)
    =(?x @int:77:40, tmp#0)


max > public (0 calls)
0: max(x:_ @int:98:13, y:_ @int:98:18, ?#result:_ @int:98:5):
    if {>=(x @int:98:31, y @int:98:35)::

        foreign llvm move(x @int:98:39, ?tmp#0)
    else::
        foreign llvm move(y @int:98:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @int:98:31, ?#result @int:98:5)


min > public (0 calls)
0: min(x:_ @int:97:13, y:_ @int:97:18, ?#result:_ @int:97:5):
    if {<=(x @int:97:31, y @int:97:35)::

        foreign llvm move(x @int:97:39, ?tmp#0)
    else::
        foreign llvm move(y @int:97:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @int:97:31, ?#result @int:97:5)


power > public (0 calls)
0: power(x:_ @int:107:15, y:_ @int:107:20, ?#result:_ @int:107:5):
    foreign c ipow(x @int:107:44, y @int:107:46, ?tmp#0 @int:107:29)
    foreign llvm move(tmp#0, ?#result @int:107:5)


print > public (0 calls)
0: print(x:_ @int:119:15) use !io:
    foreign c print_int(x @int:119:50, !io @int:119:54)


println > public (0 calls)
0: println(x:_ @int:121:17) use !io:
    !print(x @int:121:39)
    !nl


read > public (0 calls)
0: read(?x:_ @int:123:15) use !io:
    foreign c read_int(?x @int:123:50, !io @int:123:54)


signum > public (0 calls)
0: signum(x:_ @int:114:16, ?#result:_ @int:114:5):
    foreign c signum(x @int:114:42, ?tmp#0 @int:114:25)
    foreign llvm move(tmp#0, ?#result @int:114:5)


sqrt > public (0 calls)
0: sqrt(x:_ @int:104:14, ?#result:_ @int:104:5):
    foreign c isqrt(x @int:104:39, ?tmp#0 @int:104:23)
    foreign llvm move(tmp#0, ?#result @int:104:5)


~= > public (0 calls)
0: ~=(x:_ @int:84:10, y:_ @int:84:18, ?#result:bool @int:84:5):
    foreign llvm icmp_ne(x @int:84:51, y @int:84:53, ?tmp#0 @int:84:30)
    foreign llvm move(tmp#0, ?#result @int:84:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.io
  representation  : (not a type)
  public submods  : 
  public resources: io: wybe.io.io
  public procs    : wybe.io.eof<0>
                    wybe.io.nl<0>
  imports         : use wybe.char
                    public use wybe.phantom
  resources       : io: fromList [(wybe.io.io,phantom = 0:phantom @io:13:27 @io:13:5)]
  procs           : 

eof > public {inline} (0 calls)
0: eof(?#result:char @io:20:5):
    foreign lpvm cast(-1 @io:20:47, ?tmp#0 @io:20:29)
    foreign llvm move(tmp#0, ?#result @io:20:5)


nl > public {inline} (0 calls)
0: nl() use !io:
    foreign c putchar('\n' @io:17:49, !io @io:17:54)

LLVM code       : None

--------------------------------------------------
 Module wybe.list(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.list.,,<0>
                    wybe.list.[]<0>
                    wybe.list.all<0>
                    wybe.list.any<0>
                    wybe.list.empty<0>
                    wybe.list.filter<0>
                    wybe.list.foldl<0>
                    wybe.list.foldr<0>
                    wybe.list.length<0>
                    wybe.list.list<0>
                    wybe.list.map<0>
                    wybe.list.map<1>
                    wybe.list.map<2>
                    wybe.list.print<0>
                    wybe.list.println<0>
                    wybe.list.reverse<0>
  imports         : use wybe.array
                    use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
                    use wybe.machine_word
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_(T) @list:20:10, y:_(T) @list:20:20, ?#result:_(T) @list:20:5):
    if {[|](?h @list:21:16, ?t @list:21:21, x @list:21:10)::

        ,,(t @list:21:32, y @list:21:37, ?tmp#2 @list:21:32)
        [|](h @list:21:28, tmp#2, ?tmp#1 @list:21:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(y @list:21:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:21:10, ?#result @list:20:5)


[] > public {test} (0 calls)
0: [](xs:_(T) @list:31:21, idx:int @list:31:30, ?#result:T @list:31:5):
    >=(idx @list:32:5, 0 @list:32:13)
    index1(xs @list:33:17, idx @list:33:21, ?tmp#0 @list:33:10)
    =(?x @list:33:6, tmp#0)
    foreign llvm move(x @list:31:43, ?#result @list:31:5)


all > public {test} (0 calls)
0: all(p:{test}(T) @list:61:20, xs:_(T) @list:61:33):
    foreign llvm move(xs @list:62:15, ?tmp#0)
    do {
        if {[|](?x @list:62:10, ?tmp#0, tmp#0)::

            p(x @list:63:11)
        else::
            break

        }
    }


any > public {test} (0 calls)
0: any(p:{test}(T) @list:69:20, xs:_(T) @list:69:33):
    [|](?x @list:70:7, ?xs @list:70:12, xs @list:70:18)
    (   p(x @list:71:8)
    | any(p @list:71:17, xs @list:71:20))


empty > public {test} (0 calls)
0: empty(xs:_(T) @list:15:22):
    if {[|](?tmp#0 @list:16:11, ?tmp#1 @list:16:15, xs @list:16:20)::

        fail
    else::
        pass

    }


filter > public (0 calls)
0: filter(p:{test}(T) @list:95:16, !xs:_(T) @list:95:30):
    [](?tmp#0 @list:96:12)
    =(?out @list:96:6, tmp#0)
    foreign llvm move(xs @list:97:15, ?tmp#1)
    do {
        if {[|](?x @list:97:10, ?tmp#1, tmp#1)::

            if {p(x @list:98:16)::

                [|](x @list:98:30, out @list:98:34, ?tmp#2 @list:98:29)
                =(?out @list:98:23, tmp#2)
            else::
                pass

            }
        else::
            break

        }
    }
    reverse(out @list:100:19, ?tmp#3 @list:100:11)
    =(?as @list:100:6, tmp#3)


foldl > public (0 calls)
0: foldl(f:(A, !B) @list:77:15, as:_(A) @list:77:26, !b:B @list:77:36):
    foreign llvm move(as @list:78:15, ?tmp#0)
    do {
        if {[|](?a @list:78:10, ?tmp#0, tmp#0)::

            f(a @list:79:11, !b @list:79:15)
        else::
            break

        }
    }


foldr > public (0 calls)
0: foldr(f:(A, !B) @list:86:15, as:_(A) @list:86:26, !b:B @list:86:36):
    if {[|](?a @list:87:12, ?as @list:87:17, as @list:87:23)::

        foldr(f @list:88:15, as @list:88:18, !b @list:88:23)
        f(a @list:89:11, !b @list:89:15)
    else::
        pass

    }


index1 > {test} (0 calls)
0: index1(xs:_(T) @list:148:19, idx:int @list:148:28, ?#result:T @list:148:1):
    [|](?x @list:149:7, ?xs @list:149:12, xs @list:149:18)
    (   =(idx @list:150:6, 0 @list:150:12)
    | (   -(idx @list:150:27, 1 @list:150:33, ?tmp#0 @list:150:27)
        & index1(xs @list:150:23, tmp#0, ?x @list:150:37)))
    foreign llvm move(x @list:148:41, ?#result @list:148:1)


length > public (0 calls)
0: length(x:_(T) @list:24:16, ?#result:int @list:24:5):
    length1(x @list:24:38, 0 @list:24:41, ?tmp#0 @list:24:30)
    foreign llvm move(tmp#0, ?#result @list:24:5)


length1 > (0 calls)
0: length1(x:_(T) @list:140:13, acc:int @list:140:21, ?#result:int @list:140:1):
    if {[|](?h @list:141:16, ?t @list:141:21, x @list:141:10)::

        +(acc @list:141:38, 1 @list:141:44, ?tmp#2 @list:141:38)
        length1(t @list:141:35, tmp#2, ?tmp#1 @list:141:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(acc @list:141:57, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:141:10, ?#result @list:140:1)


list > public (0 calls)
0: list(ar:array(T) @list:128:14, ?#result:_(T) @list:128:5):
    [](?tmp#0 @list:129:11)
    =(?ls @list:129:6, tmp#0)
    foreign llvm move(ar @list:130:15, ?tmp#1)
    do {
        if {[|](?x @list:130:10, ?tmp#1, tmp#1)::

            [|](x @list:131:16, ls @list:131:20, ?tmp#2 @list:131:15)
            =(?ls @list:131:10, tmp#2)
        else::
            break

        }
    }
    reverse(ls @list:133:13, ?ls @list:133:18)
    foreign llvm move(ls @list:128:34, ?#result @list:128:5)


map > public (0 calls)
0: map(f:{resource}(T) @list:41:13, xs:_(T) @list:41:30):
    foreign llvm move(xs @list:42:15, ?tmp#0)
    do {
        if {[|](?x @list:42:10, ?tmp#0, tmp#0)::

            !f(x @list:43:12)
        else::
            break

        }
    }
map > public (0 calls)
1: map(f:(A, ?B) @list:49:13, as:_(A) @list:49:24, ?#result:_(B) @list:49:5):
    if {[|](?a @list:50:12, ?as @list:50:17, as @list:50:23)::

        f(a @list:50:33, ?tmp#2 @list:50:31)
        map(f @list:50:42, as @list:50:45, ?tmp#3 @list:50:38)
        [|](tmp#2, tmp#3, ?tmp#1 @list:50:29)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:50:61)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:50:10, ?#result @list:49:5)
map > public (0 calls)
2: map(f:(A, B, ?C) @list:55:13, as:_(A) @list:55:27, bs:_(B) @list:55:36, ?#result:_(C) @list:55:5):
    if {(   [|](?a @list:56:12, ?as @list:56:17, as @list:56:23)
        & [|](?b @list:56:30, ?bs @list:56:35, bs @list:56:41))::

        f(a @list:56:51, b @list:56:54, ?tmp#2 @list:56:49)
        map(f @list:56:63, as @list:56:66, bs @list:56:70, ?tmp#3 @list:56:59)
        [|](tmp#2, tmp#3, ?tmp#1 @list:56:47)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:57:47)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:56:10, ?#result @list:55:5)


print > public (0 calls)
0: print(printer:{resource}(T) @list:108:15, xs:_(T) @list:108:38) use !io:
    !print('[' @list:109:12)
    if {[|](?x @list:110:12, ?xs @list:110:17, xs @list:110:23)::

        !printer(x @list:111:18)
        !print1(printer @list:112:17, xs @list:112:26)
    else::
        pass

    }
    !print(']' @list:114:12)


print1 > (0 calls)
0: print1(printer:{resource}(T) @list:154:12, xs:_(T) @list:154:35) use !io:
    if {[|](?x @list:155:12, ?xs @list:155:17, xs @list:155:23)::

        !print(',' @list:156:16)
        !printer(x @list:157:18)
        !print1(printer @list:158:17, xs @list:158:26)
    else::
        pass

    }


println > public (0 calls)
0: println(printer:{resource}(T) @list:119:17, xs:_(T) @list:119:40) use !io:
    !print(printer @list:120:12, xs @list:120:21)
    !nl


reverse > public (0 calls)
0: reverse(x:_(T) @list:27:17, ?#result:_(T) @list:27:5):
    [](?tmp#1 @list:27:44)
    reverse1(x @list:27:41, tmp#1, ?tmp#0 @list:27:32)
    foreign llvm move(tmp#0, ?#result @list:27:5)


reverse1 > (0 calls)
0: reverse1(x:_(T) @list:144:14, tail:_(T) @list:144:22, ?#result:_(T) @list:144:1):
    if {[|](?h @list:145:16, ?t @list:145:21, x @list:145:10)::

        [|](h @list:145:40, tail @list:145:44, ?tmp#2 @list:145:39)
        reverse1(t @list:145:36, tmp#2, ?tmp#1 @list:145:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(tail @list:145:61, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:145:10, ?#result @list:144:1)

LLVM code       : None

--------------------------------------------------
 Module wybe.machine_word
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.machine_word.word_size_bits<0>
                    wybe.machine_word.word_size_bytes<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

word_size_bits > public (0 calls)
0: word_size_bits(?#result:int @machine_word:12:5):
    word_size_bytes(?tmp#1 @machine_word:12:34)
    *(8 @machine_word:12:30, tmp#1, ?tmp#0 @machine_word:12:30)
    foreign llvm move(tmp#0, ?#result @machine_word:12:5)


word_size_bytes > public (0 calls)
0: word_size_bytes(?#result:int @machine_word:10:5):
    foreign llvm move(8 @machine_word:10:31, ?#result @machine_word:10:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.memory_management
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.memory_management.malloc_count<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

malloc_count > public {semipure} (0 calls)
0: malloc_count(?x:int @memory_management:11:34):
    foreign c {impure} malloc_count(?x @memory_management:12:38)

LLVM code       : None

--------------------------------------------------
 Module wybe.phantom
 modifiers       : {unique} 
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : 
  imports         : 
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.predicate
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.predicate.const<0>
                    wybe.predicate.id<0>
  imports         : 
  resources       : 
  procs           : 

const > public (0 calls)
0: const(a:A @predicate:8:15, b:B @predicate:8:20, ?#result:A @predicate:8:5):
    foreign llvm move(a @predicate:8:29, ?#result @predicate:8:5)


id > public (0 calls)
0: id(a:A @predicate:6:12, ?#result:A @predicate:6:5):
    foreign llvm move(a @predicate:6:21, ?#result @predicate:6:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.range
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.range...<0>
                    wybe.range.[]<0>
                    wybe.range.[|]<0>
                    wybe.range.irange<0>
                    wybe.range.size<0>
                    wybe.range.xrange<0>
  imports         : use wybe.bool
                    use wybe.int
  resources       : 
  procs           : 

.. > public (0 calls)
0: ..(start:int @range:38:10, end:int @range:38:23, ?#result:_ @range:38:5):
    if {<=(start @range:39:27, end @range:39:37)::

        foreign llvm move(1 @range:39:44, ?tmp#1)
    else::
        foreign llvm move(-1 @range:39:56, ?tmp#1)

    }
    construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)
    foreign llvm move(tmp#0, ?#result @range:38:5)


[] > public {test} (0 calls)
0: [](r:_ @range:20:19, idx:int @range:20:24, ?value:int @range:20:34):
    <=(0 @range:21:6, idx @range:21:12)
    range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)
    *(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)
    +(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)
    =(?value @range:23:6, tmp#0)
    if {<=(0 @range:24:10, stride @range:24:16)::

        <(value @range:24:27, end @range:24:35)
    else::
        <(end @range:24:51, value @range:24:57)

    }


[|] > public {test} (0 calls)
0: [|](?value:int @range:12:23, ?rest:_ @range:12:35, current:_ @range:12:43):
    range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)
    ~=(value @range:14:6, end @range:14:16)
    +(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)
    range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)
    =(?rest @range:15:6, tmp#0)


construct > (0 calls)
0: construct(start:int @range:49:15, stride:int @range:49:26, end:int @range:49:38, ?#result:_ @range:49:1):
    -(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)
    %(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)
    =(?diff @range:50:6, tmp#0)
    if {<=(0 @range:51:19, stride @range:51:25)::

        if {=(diff @range:52:26, 0 @range:52:33)::

            max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
            -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
            max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
            foreign llvm move(tmp#5, ?tmp#3)

        }
        foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
    else::
        if {=(diff @range:55:26, 0 @range:55:33)::

            min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
            foreign llvm move(tmp#9, ?tmp#8)
        else::
            +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
            min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
            foreign llvm move(tmp#10, ?tmp#8)

        }
        foreign llvm move(tmp#8 @range:55:26, ?tmp#2)

    }
    =(?final @range:51:6, tmp#2 @range:51:19)
    range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)
    =(?r @range:58:6, tmp#12)
    foreign llvm move(r @range:49:51, ?#result @range:49:1)


irange > public (0 calls)
0: irange(start:int @range:32:16, stride:int @range:32:27, end:int @range:32:39, ?#result:_ @range:32:5):
    if {<(stride @range:33:41, 0 @range:33:50)::

        foreign llvm move(-1 @range:33:55, ?tmp#2)
    else::
        foreign llvm move(1 @range:33:68, ?tmp#2)

    }
    +(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)
    construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)
    foreign llvm move(tmp#0, ?#result @range:32:5)


size > public (0 calls)
0: size(r:_ @range:42:14, ?#result:int @range:42:5):
    range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)
    if {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
        & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
        & signum(tmp#3, ?tmp#2 @range:44:29)
        & ~=(tmp#1, tmp#2))::

        foreign llvm move(0 @range:44:52, ?tmp#0)
    else::
        if {<=(0 @range:45:10, stride @range:45:16)::

            -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
            -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
            /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
            +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
            foreign llvm move(tmp#5, ?tmp#4)
        else::
            -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
            -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
            -(stride @range:46:39, ?tmp#13 @range:46:38)
            /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
            +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
            foreign llvm move(tmp#9, ?tmp#4)

        }
        foreign llvm move(tmp#4 @range:45:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)


xrange > public (0 calls)
0: xrange(start:int @range:28:16, stride:int @range:28:27, end:int @range:28:39, ?#result:_ @range:28:5):
    construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)
    foreign llvm move(tmp#0, ?#result @range:28:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.string
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.string.,,<0>
                    wybe.string.<<0>
                    wybe.string.<=<0>
                    wybe.string.<=><0>
                    wybe.string.=<0>
                    wybe.string.><0>
                    wybe.string.>=<0>
                    wybe.string.[]<0>
                    wybe.string.[]<1>
                    wybe.string.[|]<0>
                    wybe.string.c_string<0>
                    wybe.string.length<0>
                    wybe.string.print<0>
                    wybe.string.println<0>
                    wybe.string.read<0>
                    wybe.string.string<0>
                    wybe.string.string<1>
                    wybe.string.~=<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.char
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
                    use wybe.range
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_ @string:64:10, y:_ @string:64:17, ?#result:_ @string:64:5):
    if {(   empty(?tmp#1 @string:65:14)
        & =(x @string:65:10, tmp#1))::

        foreign llvm move(y @string:65:23, ?tmp#0)
    else::
        if {(   empty(?tmp#3 @string:66:14)
            & =(y @string:66:10, tmp#3))::

            foreign llvm move(x @string:66:23, ?tmp#2)
        else::
            concat(x @string:67:25, y @string:67:28, ?tmp#4 @string:67:18)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:66:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:65:10, ?#result @string:64:5)


< > public (0 calls)
0: <(x:_ @string:119:10, y:_ @string:119:17, ?#result:bool @string:119:5):
    <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
    equal(?tmp#2 @string:119:44)
    <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
    foreign llvm move(tmp#0, ?#result @string:119:5)


<= > public (0 calls)
0: <=(x:_ @string:120:10, y:_ @string:120:18, ?#result:bool @string:120:5):
    <=>(x @string:120:31, y @string:120:39, ?tmp#1 @string:120:31)
    equal(?tmp#2 @string:120:46)
    <=(tmp#1, tmp#2, ?tmp#0 @string:120:30)
    foreign llvm move(tmp#0, ?#result @string:120:5)


<=> > public (0 calls)
0: <=>(x:_ @string:125:10, y:_ @string:125:20, ?#result:comparison @string:125:5):
    equal(?tmp#0 @string:126:10)
    =(?c @string:126:6, tmp#0)
    foreign llvm move(x @string:127:16, ?tmp#1)
    foreign llvm move(y @string:127:26, ?tmp#2)
    do {
        if {[|](?cx @string:127:10, ?tmp#1, tmp#1)::

            if {[|](?cy @string:127:20, ?tmp#2, tmp#2)::

                if {<(cx @string:128:14, cy @string:128:19)::

                    lesser(?tmp#3 @string:128:30)
                    =(?c @string:128:26, tmp#3)
                    break
                else::
                    if {>(cx @string:129:14, cy @string:129:19)::

                        greater(?tmp#4 @string:129:30)
                        =(?c @string:129:26, tmp#4)
                        break
                    else::
                        pass

                    }

                }
            else::
                break

            }
        else::
            break

        }
    }
    if {(   equal(?tmp#5 @string:132:14)
        & =(c @string:132:10, tmp#5))::

        length(x @string:133:22, ?tmp#6 @string:133:15)
        =(?lx @string:133:10, tmp#6)
        length(y @string:134:22, ?tmp#7 @string:134:15)
        =(?ly @string:134:10, tmp#7)
        if {<(lx @string:135:14, ly @string:135:19)::

            lesser(?tmp#8 @string:135:30)
            =(?c @string:135:26, tmp#8)
        else::
            if {>(lx @string:135:39, ly @string:135:44)::

                greater(?tmp#9 @string:135:55)
                =(?c @string:135:51, tmp#9)
            else::
                pass

            }

        }
    else::
        pass

    }
    foreign llvm move(c @string:125:38, ?#result @string:125:5)


= > public (0 calls)
0: =(x:_ @string:115:10, y:_ @string:115:17, ?#result:bool @string:115:5):
    <=>(x @string:115:30, y @string:115:38, ?tmp#1 @string:115:30)
    equal(?tmp#2 @string:115:44)
    =(tmp#1, tmp#2, ?tmp#0 @string:115:29)
    foreign llvm move(tmp#0, ?#result @string:115:5)


> > public (0 calls)
0: >(x:_ @string:121:10, y:_ @string:121:17, ?#result:bool @string:121:5):
    <=>(x @string:121:30, y @string:121:38, ?tmp#1 @string:121:30)
    equal(?tmp#2 @string:121:44)
    >(tmp#1, tmp#2, ?tmp#0 @string:121:29)
    foreign llvm move(tmp#0, ?#result @string:121:5)


>= > public (0 calls)
0: >=(x:_ @string:122:10, y:_ @string:122:18, ?#result:bool @string:122:5):
    <=>(x @string:122:31, y @string:122:39, ?tmp#1 @string:122:31)
    equal(?tmp#2 @string:122:46)
    >=(tmp#1, tmp#2, ?tmp#0 @string:122:30)
    foreign llvm move(tmp#0, ?#result @string:122:5)


[] > public {test} (0 calls)
0: [](s:_ @string:91:19, idx:int @string:91:24, ?c:char @string:91:34):
    if {buffer(?len @string:93:17, ?str @string:93:23, s @string:92:10)::

        <=(0 @string:94:14, idx @string:94:20)
        <(idx @string:95:14, len @string:95:20)
        unsafe_c_string_index(str @string:96:35, idx @string:96:40, ?c @string:96:46)
    else::
        if {concat(?left @string:97:17, ?right @string:97:24, s @string:92:10)::

            length(left @string:98:32, ?tmp#0 @string:98:25)
            =(?left_len @string:98:14, tmp#0)
            if {<(idx @string:99:18, left_len @string:99:24)::

                [](left @string:99:41, idx @string:99:46, ?tmp#1 @string:99:41)
                =(?c @string:99:37, tmp#1)
            else::
                -(idx @string:100:37, left_len @string:100:43, ?tmp#3 @string:100:37)
                [](right @string:100:31, tmp#3, ?tmp#2 @string:100:31)
                =(?c @string:100:27, tmp#2)

            }
        else::
            if {slice(?base @string:102:16, ?range @string:102:23, s @string:92:10)::

                [](range @string:102:43, idx @string:102:49, ?tmp#5 @string:102:43)
                [](base @string:102:38, tmp#5, ?tmp#4 @string:102:38)
                =(?c @string:102:34, tmp#4)
            else::
                if {singleton(?c @string:103:20, s @string:92:10)::

                    =(idx @string:103:27, 0 @string:103:33)
                else::
                    fail

                }

            }

        }

    }
[] > public (0 calls)
1: [](s:_ @string:109:12, r:range @string:109:17, ?#result:_ @string:109:5):
    slice(s @string:109:36, r @string:109:39, ?tmp#0 @string:109:30)
    foreign llvm move(tmp#0, ?#result @string:109:5)


[|] > public {test} (0 calls)
0: [|](?head:char @string:71:23, ?tail:_ @string:71:35, s:_ @string:71:43):
    if {buffer(?len @string:73:17, ?str @string:73:23, s @string:72:10)::

        [|](?head @string:74:15, ?str @string:74:23, str @string:74:30)
        if {=(len @string:75:26, 1 @string:75:32)::

            empty(?tmp#1 @string:75:37)
            foreign llvm move(tmp#1, ?tmp#0)
        else::
            -(len @string:75:60, 1 @string:75:66, ?tmp#3 @string:75:60)
            buffer(tmp#3, str @string:75:69, ?tmp#2 @string:75:53)
            foreign llvm move(tmp#2, ?tmp#0)

        }
        =(?tail @string:75:14, tmp#0 @string:75:26)
    else::
        if {concat(?left @string:76:17, ?right @string:76:24, s @string:72:10)::

            if {[|](?head @string:77:20, ?t @string:77:28, left @string:77:33)::

                concat(t @string:77:56, right @string:77:59, ?tmp#4 @string:77:49)
                =(?tail @string:77:42, tmp#4)
            else::
                [|](?head @string:78:28, ?tail @string:78:36, right @string:78:44)

            }
        else::
            if {slice(?base @string:80:16, ?range @string:80:23, s @string:72:10)::

                do {
                    [|](?idx @string:82:19, ?range @string:82:26, range @string:82:35)
                    if {(   [](base @string:83:30, idx @string:83:35, ?tmp#5 @string:83:30)
                        & =(?head @string:83:23, tmp#5))::

                        slice(base @string:83:57, range @string:83:63, ?tmp#6 @string:83:51)
                        =(?tail @string:83:44, tmp#6)
                        break
                    else::
                        pass

                    }
                }
            else::
                if {singleton(?head @string:85:20, s @string:72:10)::

                    empty(?tmp#7 @string:85:37)
                    =(?tail @string:85:30, tmp#7)
                else::
                    fail

                }

            }

        }

    }


c_string > public (0 calls)
0: c_string(s:_ @string:40:18, ?#result:c_string @string:40:5):
    if {buffer(?tmp#0 @string:41:21, ?str @string:41:25, s @string:41:10)::

        pass
    else::
        length(s @string:43:27, ?tmp#2 @string:43:20)
        +(tmp#2, 1 @string:43:32, ?tmp#1 @string:43:20)
        =(?len @string:43:14, tmp#1)
        foreign lpvm alloc(len @string:44:32, ?str @string:44:38)
        true(?tmp#3 @string:45:49)
        foreign lpvm mutate(str @string:45:33, ?str @string:45:39, len @string:45:44, tmp#3, len @string:45:55, 0 @string:45:60, '\NUL' @string:45:63)
        =(?offset @string:46:14, 0 @string:46:23)
        pack(s @string:47:18, !str @string:47:22, len @string:47:27, !offset @string:47:33)

    }
    foreign llvm move(str @string:40:34, ?#result @string:40:5)


fixed_range_size > (0 calls)
0: fixed_range_size(hi:int @string:184:22, r:range @string:184:30, ?sz:int @string:184:40):
    range(?start @string:185:16, ?stride @string:185:24, ?end @string:185:33, r @string:185:5)
    if {<=(0 @string:186:10, stride @string:186:16)::

        -(start @string:187:39, ?tmp#4 @string:187:38)
        /(tmp#4, stride @string:187:47, ?tmp#3 @string:187:38)
        *(tmp#3, stride @string:187:56, ?tmp#2 @string:187:38)
        +(start @string:187:30, tmp#2, ?tmp#1 @string:187:30)
        max(start @string:187:23, tmp#1, ?tmp#0 @string:187:19)
        =(?lo @string:187:14, tmp#0)
        min(hi @string:188:23, end @string:188:27, ?tmp#5 @string:188:19)
        =(?hi @string:188:14, tmp#5)
    else::
        max(-1 @string:190:23, end @string:190:27, ?tmp#6 @string:190:19)
        =(?lo @string:190:14, tmp#6)
        +(hi @string:191:30, stride @string:191:35, ?tmp#10 @string:191:30)
        -(start @string:191:45, hi @string:191:53, ?tmp#13 @string:191:45)
        -(tmp#13, 1 @string:191:58, ?tmp#12 @string:191:45)
        -(stride @string:191:64, ?tmp#14 @string:191:63)
        %(tmp#12, tmp#14, ?tmp#11 @string:191:44)
        +(tmp#10, tmp#11, ?tmp#9 @string:191:30)
        +(tmp#9, 1 @string:191:73, ?tmp#8 @string:191:30)
        min(start @string:191:23, tmp#8, ?tmp#7 @string:191:19)
        =(?hi @string:191:14, tmp#7)
        -(stride @string:192:24, ?tmp#15 @string:192:23)
        =(?stride @string:192:14, tmp#15)

    }
    if {<=(hi @string:194:16, lo @string:194:23)::

        foreign llvm move(0 @string:194:29, ?tmp#16)
    else::
        -(hi @string:194:42, lo @string:194:47, ?tmp#20 @string:194:42)
        -(tmp#20, 1 @string:194:52, ?tmp#19 @string:194:42)
        /(tmp#19, stride @string:194:57, ?tmp#18 @string:194:41)
        +(tmp#18, 1 @string:194:66, ?tmp#17 @string:194:41)
        foreign llvm move(tmp#17, ?tmp#16)

    }
    =(?sz @string:194:6, tmp#16 @string:194:16)


length > public (0 calls)
0: length(s:_ @string:52:16, ?#result:int @string:52:5):
    if {buffer(?len @string:53:22, ?tmp#1 @string:53:27, s @string:53:10)::

        foreign llvm move(len @string:53:33, ?tmp#0)
    else::
        if {concat(?left @string:54:22, ?right @string:54:29, s @string:54:10)::

            length(left @string:54:46, ?tmp#4 @string:54:39)
            length(right @string:54:61, ?tmp#5 @string:54:54)
            +(tmp#4, tmp#5, ?tmp#3 @string:54:39)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            if {slice(?base @string:55:21, ?range @string:55:28, s @string:55:10)::

                length(base @string:55:62, ?tmp#8 @string:55:55)
                fixed_range_size(tmp#8, range @string:55:69, ?tmp#7 @string:55:38)
                foreign llvm move(tmp#7, ?tmp#6)
            else::
                if {singleton(?tmp#10 @string:56:24, s @string:56:10)::

                    foreign llvm move(1 @string:56:30, ?tmp#9)
                else::
                    foreign llvm move(0 @string:57:18, ?tmp#9)

                }
                foreign llvm move(tmp#9 @string:56:10, ?tmp#6)

            }
            foreign llvm move(tmp#6 @string:55:10, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:54:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:53:10, ?#result @string:52:5)


pack > (0 calls)
0: pack(s:_ @string:160:10, !raw:c_string @string:160:16, size:int @string:160:30, !offset:int @string:160:41):
    if {buffer(?tmp#0 @string:162:16, ?str @string:162:20, s @string:161:10)::

        foreign llvm move(str @string:163:23, ?tmp#1)
        do {
            if {[|](?c @string:163:18, ?tmp#1, tmp#1)::

                true(?tmp#2 @string:164:56)
                foreign lpvm mutate(raw @string:164:37, ?raw @string:164:43, offset @string:164:48, tmp#2, size @string:164:62, 0 @string:164:68, c @string:164:71)
                incr(!offset @string:165:23)
            else::
                break

            }
        }
    else::
        if {concat(?left @string:167:17, ?right @string:167:24, s @string:161:10)::

            pack(left @string:168:18, !raw @string:168:25, size @string:168:30, !offset @string:168:37)
            pack(right @string:169:18, !raw @string:169:26, size @string:169:31, !offset @string:169:38)
            incr(!offset @string:170:19)
        else::
            if {slice(?tmp#3 @string:171:15, ?tmp#4 @string:171:18, s @string:161:10)::

                foreign llvm move(s @string:172:23, ?tmp#5)
                do {
                    if {[|](?c @string:172:18, ?tmp#5, tmp#5)::

                        true(?tmp#6 @string:173:56)
                        foreign lpvm mutate(raw @string:173:37, ?raw @string:173:43, offset @string:173:48, tmp#6, size @string:173:62, 0 @string:173:68, c @string:173:71)
                        incr(!offset @string:174:23)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:176:20, s @string:161:10)::

                    true(?tmp#7 @string:177:52)
                    foreign lpvm mutate(raw @string:177:33, ?raw @string:177:39, offset @string:177:44, tmp#7, size @string:177:58, 0 @string:177:64, c @string:177:67)
                    incr(!offset @string:178:19)
                else::
                    fail

                }

            }

        }

    }


print > public (0 calls)
0: print(x:_ @string:142:15) use !io:
    if {buffer(?tmp#0 @string:144:16, ?str @string:144:20, x @string:143:10)::

        !print(str @string:144:35)
    else::
        if {concat(?left @string:145:17, ?right @string:145:24, x @string:143:10)::

            !print(left @string:145:41)
            !print(right @string:145:55)
        else::
            if {slice(?tmp#1 @string:146:15, ?tmp#2 @string:146:18, x @string:143:10)::

                foreign llvm move(x @string:146:34, ?tmp#3)
                do {
                    if {[|](?c @string:146:29, ?tmp#3, tmp#3)::

                        !print(c @string:146:45)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:147:20, x @string:143:10)::

                    !print(c @string:147:33)
                else::
                    fail

                }

            }

        }

    }


println > public (0 calls)
0: println(x:_ @string:151:17) use !io:
    !print(x @string:151:39)
    !nl


read > public (0 calls)
0: read(?x:_ @string:153:15) use !io:
    !read(?str:c_string @string:153:37)
    string(str @string:153:64, ?tmp#0 @string:153:57)
    =(?x @string:153:53, tmp#0)


string > public (0 calls)
0: string(str:c_string @string:28:16, ?#result:_ @string:28:5):
    length(str @string:29:19, ?tmp#0 @string:29:12)
    =(?len @string:29:6, tmp#0)
    if {=(len @string:30:15, 0 @string:30:21)::

        empty(?tmp#2 @string:30:26)
        foreign llvm move(tmp#2, ?tmp#1)
    else::
        if {=(len @string:31:15, 1 @string:31:21)::

            foreign lpvm access(str @string:31:56, 0 @string:31:61, 1 @string:31:64, 0 @string:31:67, ?tmp#5 @string:31:36)
            singleton(tmp#5, ?tmp#4 @string:31:26)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            buffer(len @string:32:33, str @string:32:38, ?tmp#6 @string:32:26)
            foreign llvm move(tmp#6, ?tmp#3)

        }
        foreign llvm move(tmp#3 @string:31:15, ?tmp#1)

    }
    =(?s @string:30:6, tmp#1 @string:30:15)
    foreign llvm move(s @string:28:34, ?#result @string:28:5)
string > public (0 calls)
1: string(c:char @string:37:16, ?#result:_ @string:37:5):
    singleton(c @string:37:38, ?tmp#0 @string:37:28)
    foreign llvm move(tmp#0, ?#result @string:37:5)


~= > public (0 calls)
0: ~=(x:_ @string:116:10, y:_ @string:116:18, ?#result:bool @string:116:5):
    <=>(x @string:116:31, y @string:116:39, ?tmp#1 @string:116:31)
    equal(?tmp#2 @string:116:46)
    ~=(tmp#1, tmp#2, ?tmp#0 @string:116:30)
    foreign llvm move(tmp#0, ?#result @string:116:5)

LLVM code       : None

Types: **** Validating parameter types in module wybe.predicate
Types: Validating def of const
Types: Checking type A of param a:A
Types: Param is a:A
Types: Checking type B of param b:B
Types: Param is b:B
Types: Checking type A of param ?#result:A
Types: Param is ?#result:A
Types: Validating def of id
Types: Checking type A of param a:A
Types: Param is a:A
Types: Checking type A of param ?#result:A
Types: Param is ?#result:A
Types: **** Re-exiting module wybe.predicate
Types: **** Type checking modules wybe.predicate
Types: **** Strongly connected components:
Types:     wybe.predicate.id
Types:     wybe.predicate.const
Types: Type checking non-recursive proc wybe.predicate.id
Types: ** Type checking decl of proc id
Types: found 1 definition(s)
Types: Type checking id
Types: ** Type checking id: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm move(a @predicate:6:21, ?#result @predicate:6:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","a"]
Types: Recording parameter types: a:A, ?#result:A
Types: Type variable A is bound to Nothing
Types:     type of 'a' is A
Types: Type variable A is bound to Nothing
Types: Unifying types A (-> A) and any (-> any)
Types:   Unification yields A
Types: Variable a type constrained to A
Types: Type variable A is bound to Nothing
Types:     type of '#result' is A
Types: Type variable A is bound to Nothing
Types: Unifying types A (-> A) and any (-> any)
Types:   Unification yields A
Types: Variable #result type constrained to A
Types: Recording resource types: 
Types: Recording casts in {foreign llvm move(a @predicate:6:21, ?#result @predicate:6:5)}
Types: Unifying move argument types a @predicate:6:21 and ?#result @predicate:6:5
Types: Finding type of expr a @predicate:6:21
Types: Type variable A is bound to Nothing
Types:   Type = A
Types: Finding type of expr ?#result @predicate:6:5
Types: Type variable A is bound to Nothing
Types:   Type = A
Types: Type variable A is bound to Nothing
Types: Type variable A is bound to Nothing
Types: Unifying types A (-> A) and A (-> A)
Types:   Unification yields A
Types: *** Before calls Typing {#result::A, a::A}; {} (with no errors)
Types:   With calls:
Types:   Typing {#result::A, a::A}; {} (with no errors)
Types: Finding type of expr a @predicate:6:21
Types: Type variable A is bound to Nothing
Types:   Type = A
Types: Type variable A is bound to Nothing
Types: Finding type of expr ?#result @predicate:6:5
Types: Type variable A is bound to Nothing
Types:   Type = A
Types: Type variable A is bound to Nothing
Types: Type checking foreign llvm call move(64 bit unsigned, 64 bit unsigned)
Types: Now mode checking proc id
Types: bound vars: semipure normal (total) computation binding {a}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(a @predicate:6:21, ?#result @predicate:6:5)
Types: Mode checking foreign call {foreign llvm move(a @predicate:6:21, ?#result @predicate:6:5)}
Types:     with assigned semipure normal (total) computation binding {a}, break set = Everything, with resources {}
Types: Mode check exp a
Types: Mode check exp resulted in a
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr a @predicate:6:21
Types: Type variable A is bound to Nothing
Types:   Type = A
Types: Type variable A is bound to Nothing
Types: Finding type of expr ?#result @predicate:6:5
Types: Type variable A is bound to Nothing
Types:   Type = A
Types: Type variable A is bound to Nothing
Types:     types and modes = [A,?A]
Types: New instr = {foreign llvm move(a:A @predicate:6:21, ?#result:A @predicate:6:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, a}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'id'
Types: Mode checked body   : [{foreign llvm move(a:A @predicate:6:21, ?#result:A @predicate:6:5)} @predicate:6:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, a}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: Type variable A is bound to Nothing
Types: Type variable A is bound to Nothing
Types: ===== NO Need to check again.
Types: ** New definition of id:
Types: 
Types: id > public (0 calls)
Types: 4: id(a:A @predicate:6:12, ?#result:A @predicate:6:5):
Types:     foreign llvm move(a:A @predicate:6:21, ?#result:A @predicate:6:5)
Types: Type checking non-recursive proc wybe.predicate.const
Types: ** Type checking decl of proc const
Types: found 1 definition(s)
Types: Type checking const
Types: ** Type checking const: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm move(a @predicate:8:29, ?#result @predicate:8:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","a","b"]
Types: Recording parameter types: a:A, b:B, ?#result:A
Types: Type variable A is bound to Nothing
Types:     type of 'a' is A
Types: Type variable A is bound to Nothing
Types: Unifying types A (-> A) and any (-> any)
Types:   Unification yields A
Types: Variable a type constrained to A
Types: Type variable B is bound to Nothing
Types:     type of 'b' is B
Types: Type variable B is bound to Nothing
Types: Unifying types B (-> B) and any (-> any)
Types:   Unification yields B
Types: Variable b type constrained to B
Types: Type variable A is bound to Nothing
Types:     type of '#result' is A
Types: Type variable A is bound to Nothing
Types: Unifying types A (-> A) and any (-> any)
Types:   Unification yields A
Types: Variable #result type constrained to A
Types: Recording resource types: 
Types: Recording casts in {foreign llvm move(a @predicate:8:29, ?#result @predicate:8:5)}
Types: Unifying move argument types a @predicate:8:29 and ?#result @predicate:8:5
Types: Finding type of expr a @predicate:8:29
Types: Type variable A is bound to Nothing
Types:   Type = A
Types: Finding type of expr ?#result @predicate:8:5
Types: Type variable A is bound to Nothing
Types:   Type = A
Types: Type variable A is bound to Nothing
Types: Type variable A is bound to Nothing
Types: Unifying types A (-> A) and A (-> A)
Types:   Unification yields A
Types: *** Before calls Typing {#result::A, a::A, b::B}; {} (with no errors)
Types:   With calls:
Types:   Typing {#result::A, a::A, b::B}; {} (with no errors)
Types: Finding type of expr a @predicate:8:29
Types: Type variable A is bound to Nothing
Types:   Type = A
Types: Type variable A is bound to Nothing
Types: Finding type of expr ?#result @predicate:8:5
Types: Type variable A is bound to Nothing
Types:   Type = A
Types: Type variable A is bound to Nothing
Types: Type checking foreign llvm call move(64 bit unsigned, 64 bit unsigned)
Types: Now mode checking proc const
Types: bound vars: semipure normal (total) computation binding {a, b}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(a @predicate:8:29, ?#result @predicate:8:5)
Types: Mode checking foreign call {foreign llvm move(a @predicate:8:29, ?#result @predicate:8:5)}
Types:     with assigned semipure normal (total) computation binding {a, b}, break set = Everything, with resources {}
Types: Mode check exp a
Types: Mode check exp resulted in a
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr a @predicate:8:29
Types: Type variable A is bound to Nothing
Types:   Type = A
Types: Type variable A is bound to Nothing
Types: Finding type of expr ?#result @predicate:8:5
Types: Type variable A is bound to Nothing
Types:   Type = A
Types: Type variable A is bound to Nothing
Types:     types and modes = [A,?A]
Types: New instr = {foreign llvm move(a:A @predicate:8:29, ?#result:A @predicate:8:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, a, b}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'const'
Types: Mode checked body   : [{foreign llvm move(a:A @predicate:8:29, ?#result:A @predicate:8:5)} @predicate:8:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, a, b}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: Type variable A is bound to Nothing
Types: Type variable B is bound to Nothing
Types: Type variable A is bound to Nothing
Types: ===== NO Need to check again.
Types: ** New definition of const:
Types: 
Types: const > public (0 calls)
Types: 4: const(a:A @predicate:8:15, b:B @predicate:8:20, ?#result:A @predicate:8:5):
Types:     foreign llvm move(a:A @predicate:8:29, ?#result:A @predicate:8:5)
======================================================================
AFTER TYPE CHECK:
 Module wybe
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : 
  imports         : public use wybe.array
                    public use wybe.bool
                    public use wybe.c_string
                    public use wybe.char
                    public use wybe.comparison
                    public use wybe.control
                    public use wybe.count
                    public use wybe.float
                    public use wybe.int
                    public use wybe.io
                    public use wybe.list
                    public use wybe.machine_word
                    public use wybe.memory_management
                    public use wybe.phantom
                    public use wybe.predicate
                    public use wybe.range
                    public use wybe.string
  resources       : 
  submodules      : wybe.array, wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.control, wybe.count, wybe.float, wybe.int, wybe.io, wybe.list, wybe.machine_word, wybe.memory_management, wybe.phantom, wybe.predicate, wybe.range, wybe.string
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.array(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.array.[]<0>
                    wybe.array.[]<1>
                    wybe.array.[|]<0>
                    wybe.array.array<0>
                    wybe.array.array<1>
                    wybe.array.inbounds<0>
                    wybe.array.unsafe_get<0>
                    wybe.array.unsafe_update<0>
  imports         : public use wybe.array.raw_array
                    use wybe.bool
                    use wybe.int
                    use wybe.list
                    use wybe.machine_word
  resources       : 
  submodules      : wybe.array.raw_array
  procs           : 

[] > public {test} (0 calls)
0: [](a:_(T) @array:67:21, idx:int @array:67:29, ?#result:T @array:67:5):
    inbounds(a @array:68:14, idx @array:68:17)
    unsafe_get(a @array:69:10, idx @array:69:23, ?tmp#0 @array:69:10)
    =(?x @array:69:6, tmp#0)
    foreign llvm move(x @array:67:42, ?#result @array:67:5)
[] > public {test} (0 calls)
1: [](!a:_(T) @array:81:22, idx:int @array:81:30, x:T @array:81:39):
    inbounds(a @array:82:14, idx @array:82:17)
    unsafe_update(!a @array:83:20, idx @array:83:23, x @array:83:28)


[|] > public {test} (0 calls)
0: [|](?head:T @array:51:23, ?tail:_(T) @array:51:32, a:_(T) @array:51:43):
    array(?length @array:52:12, ?data @array:52:21, a @array:52:29)
    >(length @array:53:6, 0 @array:53:15)
    word_size_bytes(?tmp#0 @array:54:34)
    foreign lpvm access(data @array:54:25, 0 @array:54:31, tmp#0, 0 @array:54:51, ?head @array:54:55)
    word_size_bytes(?tmp#1 @array:55:28)
    foreign llvm add(data @array:55:22, tmp#1, ?data @array:55:46)
    -(length @array:56:19, 1 @array:56:28, ?tmp#3 @array:56:19)
    array(tmp#3, data @array:56:31, ?tmp#2 @array:56:13)
    =(?tail @array:56:6, tmp#2)


array > public (0 calls)
0: array(x:T @array:18:15, len:int @array:18:20, ?#result:_(T) @array:18:5):
    word_size_bytes(?tmp#1 @array:19:19)
    *(len @array:19:13, tmp#1, ?tmp#0 @array:19:13)
    =(?size @array:19:6, tmp#0)
    foreign lpvm alloc(size @array:20:24, ?data @array:20:31)
    =(?offset @array:21:6, 0 @array:21:15)
    do {
        if {<(offset @array:23:15, size @array:23:24)::

            pass
        else::
            break

        }
        foreign lpvm mutate(data @array:24:29, ?data @array:24:36, offset @array:24:42, 1 @array:24:50, size @array:24:53, 0 @array:24:59, x @array:24:62)
        word_size_bytes(?tmp#2 @array:25:21)
        +=(!offset @array:25:10, tmp#2)
    }
    array(len @array:27:17, data @array:27:22, ?tmp#3 @array:27:11)
    =(?ar @array:27:6, tmp#3)
    foreign llvm move(ar @array:18:36, ?#result @array:18:5)
array > public (0 calls)
1: array(ls:list(T) @array:34:15, ?#result:_(T) @array:34:5):
    length(ls @array:35:19, ?tmp#0 @array:35:12)
    =(?len @array:35:6, tmp#0)
    word_size_bytes(?tmp#2 @array:36:19)
    *(len @array:36:13, tmp#2, ?tmp#1 @array:36:13)
    =(?size @array:36:6, tmp#1)
    foreign lpvm alloc(size @array:37:24, ?data @array:37:31)
    =(?offset @array:38:6, 0 @array:38:15)
    foreign llvm move(ls @array:39:15, ?tmp#3)
    do {
        if {[|](?x @array:39:10, ?tmp#3, tmp#3)::

            foreign lpvm mutate(data @array:40:29, ?data @array:40:36, offset @array:40:42, 1 @array:40:50, size @array:40:53, 0 @array:40:59, x @array:40:62)
            word_size_bytes(?tmp#4 @array:41:21)
            +=(!offset @array:41:10, tmp#4)
        else::
            break

        }
    }
    array(len @array:43:17, data @array:43:22, ?tmp#5 @array:43:11)
    =(?ar @array:43:6, tmp#5)
    foreign llvm move(ar @array:34:34, ?#result @array:34:5)


inbounds > public {test,inline} (0 calls)
0: inbounds(a:_(T) @array:60:33, idx:int @array:60:41):
    <=(0 @array:61:6, idx @array:61:12)
    length(a @array:62:12, ?tmp#0 @array:62:12)
    <(idx @array:62:6, tmp#0)


unsafe_get > public {inline} (0 calls)
0: unsafe_get(a:_(T) @array:75:29, idx:int @array:75:37, ?#result:T @array:75:5):
    raw_data(a @array:76:25, ?tmp#0 @array:76:25)
    word_size_bytes(?tmp#2 @array:76:43)
    *(idx @array:76:37, tmp#2, ?tmp#1 @array:76:37)
    word_size_bytes(?tmp#3 @array:76:60)
    foreign lpvm access(tmp#0, tmp#1, tmp#3, 0 @array:76:77, ?x @array:76:81)
    foreign llvm move(x @array:75:50, ?#result @array:75:5)


unsafe_update > public {inline} (0 calls)
0: unsafe_update(!a:_(T) @array:89:33, idx:int @array:89:41, x:T @array:89:50):
    raw_data(a @array:90:25, ?tmp#0 @array:90:25)
    word_size_bytes(?tmp#2 @array:90:50)
    *(idx @array:90:44, tmp#2, ?tmp#1 @array:90:44)
    length(a @array:91:44, ?tmp#4 @array:91:44)
    word_size_bytes(?tmp#5 @array:91:55)
    *(tmp#4, tmp#5, ?tmp#3 @array:91:44)
    foreign lpvm mutate(tmp#0, ?data @array:90:38, tmp#1, 0 @array:90:67, tmp#3, 0 @array:91:72, x @array:91:75)
    raw_data(!a @array:92:6, data @array:92:19)

LLVM code       : None

--------------------------------------------------
 Module wybe.array.raw_array(T)
  representation  : address
  public submods  : 
  public resources: 
  public procs    : 
  imports         : use wybe
                    use wybe.array
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.bool
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.bool.&&<0>
                    wybe.bool.&=<0>
                    wybe.bool.=<0>
                    wybe.bool.^=<0>
                    wybe.bool.^^<0>
                    wybe.bool.print<0>
                    wybe.bool.println<0>
                    wybe.bool.succeed<0>
                    wybe.bool.|=<0>
                    wybe.bool.||<0>
                    wybe.bool.~<0>
                    wybe.bool.~=<0>
  imports         : use wybe.c_string
                    use wybe.io
  resources       : 
  procs           : 

&& > public (0 calls)
0: &&(p:_ @bool:13:10, q:_ @bool:13:18, ?#result:_ @bool:13:5):
    foreign llvm and(p @bool:13:44, q @bool:13:47, ?tmp#0 @bool:13:27)
    foreign llvm move(tmp#0, ?#result @bool:13:5)


&= > public (0 calls)
0: &=(!p:_ @bool:16:11, q:_ @bool:16:19):
    &&(p @bool:16:32, q @bool:16:38, ?tmp#0 @bool:16:32)
    =(?p @bool:16:27, tmp#0)


= > public (0 calls)
0: =(x:_ @bool:37:10, y:_ @bool:37:17, ?#result:_ @bool:37:5):
    foreign llvm icmp_eq(x @bool:37:47, y @bool:37:50, ?tmp#0 @bool:37:26)
    foreign llvm move(tmp#0, ?#result @bool:37:5)


^= > public (0 calls)
0: ^=(!p:_ @bool:28:11, q:_ @bool:28:19):
    ^^(q @bool:28:31, p @bool:28:37, ?tmp#0 @bool:28:31)
    =(?p @bool:28:27, tmp#0)


^^ > public (0 calls)
0: ^^(p:_ @bool:25:10, q:_ @bool:25:18, ?#result:_ @bool:25:5):
    foreign llvm xor(p @bool:25:44, q @bool:25:47, ?tmp#0 @bool:25:27)
    foreign llvm move(tmp#0, ?#result @bool:25:5)


print > public (0 calls)
0: print(x:_ @bool:47:15) use !io:
    if {x::

        foreign llvm move(c"true" @bool:47:45, ?tmp#0)
    else::
        foreign llvm move(c"false" @bool:47:60, ?tmp#0)

    }
    !print(tmp#0 @bool:47:41)


println > public (0 calls)
0: println(x:_ @bool:49:17) use !io:
    !print(x @bool:49:39)
    !nl


succeed > public (0 calls)
0: succeed():
    pass


|= > public (0 calls)
0: |=(!p:_ @bool:22:11, q:_ @bool:22:19):
    ||(p @bool:22:32, q @bool:22:38, ?tmp#0 @bool:22:32)
    =(?p @bool:22:27, tmp#0)


|| > public (0 calls)
0: ||(p:_ @bool:19:10, q:_ @bool:19:18, ?#result:_ @bool:19:5):
    foreign llvm or(p @bool:19:43, q @bool:19:46, ?tmp#0 @bool:19:27)
    foreign llvm move(tmp#0, ?#result @bool:19:5)


~ > public (0 calls)
0: ~(p:_ @bool:31:11, ?#result:_ @bool:31:5):
    true(?tmp#1 @bool:31:40)
    foreign llvm xor(p @bool:31:37, tmp#1, ?tmp#0 @bool:31:20)
    foreign llvm move(tmp#0, ?#result @bool:31:5)


~= > public (0 calls)
0: ~=(x:_ @bool:38:10, y:_ @bool:38:18, ?#result:_ @bool:38:5):
    foreign llvm icmp_ne(x @bool:38:48, y @bool:38:51, ?tmp#0 @bool:38:27)
    foreign llvm move(tmp#0, ?#result @bool:38:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.c_string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.c_string.<<0>
                    wybe.c_string.<=<0>
                    wybe.c_string.=<0>
                    wybe.c_string.><0>
                    wybe.c_string.>=<0>
                    wybe.c_string.[]<0>
                    wybe.c_string.[|]<0>
                    wybe.c_string.length<0>
                    wybe.c_string.print<0>
                    wybe.c_string.println<0>
                    wybe.c_string.read<0>
                    wybe.c_string.unsafe_c_string_index<0>
                    wybe.c_string.~=<0>
  imports         : use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:_ @c_string:12:10, y:_ @c_string:12:17, ?#result:bool @c_string:12:5):
    foreign c strcmp(x @c_string:12:46, y @c_string:12:48, ?tmp#1:int @c_string:12:29)
    <(tmp#1:int, 0 @c_string:12:57, ?tmp#0 @c_string:12:29)
    foreign llvm move(tmp#0, ?#result @c_string:12:5)


<= > public (0 calls)
0: <=(x:_ @c_string:13:10, y:_ @c_string:13:18, ?#result:bool @c_string:13:5):
    foreign c strcmp(x @c_string:13:47, y @c_string:13:49, ?tmp#1:int @c_string:13:30)
    <=(tmp#1:int, 0 @c_string:13:60, ?tmp#0 @c_string:13:30)
    foreign llvm move(tmp#0, ?#result @c_string:13:5)


= > public (0 calls)
0: =(x:_ @c_string:10:10, y:_ @c_string:10:17, ?#result:bool @c_string:10:5):
    foreign c strcmp(x @c_string:10:46, y @c_string:10:48, ?tmp#1:int @c_string:10:29)
    =(tmp#1:int, 0 @c_string:10:57, ?tmp#0 @c_string:10:29)
    foreign llvm move(tmp#0, ?#result @c_string:10:5)


> > public (0 calls)
0: >(x:_ @c_string:14:10, y:_ @c_string:14:17, ?#result:bool @c_string:14:5):
    foreign c strcmp(x @c_string:14:46, y @c_string:14:48, ?tmp#1:int @c_string:14:29)
    >(tmp#1:int, 0 @c_string:14:57, ?tmp#0 @c_string:14:29)
    foreign llvm move(tmp#0, ?#result @c_string:14:5)


>= > public (0 calls)
0: >=(x:_ @c_string:15:10, y:_ @c_string:15:18, ?#result:bool @c_string:15:5):
    foreign c strcmp(x @c_string:15:47, y @c_string:15:49, ?tmp#1:int @c_string:15:30)
    >=(tmp#1:int, 0 @c_string:15:60, ?tmp#0 @c_string:15:30)
    foreign llvm move(tmp#0, ?#result @c_string:15:5)


[] > public {test} (0 calls)
0: [](str:_ @c_string:26:19, idx:int @c_string:26:26, ?#result:char @c_string:26:5):
    <=(0 @c_string:27:6, idx @c_string:27:12)
    length(str @c_string:28:19, ?tmp#0 @c_string:28:12)
    <(idx @c_string:28:6, tmp#0)
    unsafe_c_string_index(str @c_string:29:32, idx @c_string:29:37, ?tmp#1 @c_string:29:10)
    =(?c @c_string:29:6, tmp#1)
    foreign llvm move(c @c_string:26:42, ?#result @c_string:26:5)


[|] > public {test} (0 calls)
0: [|](?head:char @c_string:19:23, ?tail:_ @c_string:19:35, str:_ @c_string:19:43):
    foreign lpvm access(str @c_string:20:25, 0 @c_string:20:30, 0 @c_string:20:33, 0 @c_string:20:36, ?head @c_string:20:40)
    foreign llvm icmp_ne(head @c_string:21:26, '\NUL' @c_string:21:32, ?not_done @c_string:21:37)
    true(?tmp#0 @c_string:22:17)
    =(not_done @c_string:22:6, tmp#0)
    foreign llvm add(str @c_string:23:22, 1 @c_string:23:27, ?tail @c_string:23:31)


length > public (0 calls)
0: length(str:_ @c_string:17:16, ?#result:int @c_string:17:5):
    foreign c strlen(str @c_string:17:46, ?tmp#0 @c_string:17:29)
    foreign llvm move(tmp#0, ?#result @c_string:17:5)


print > public (0 calls)
0: print(x:_ @c_string:35:15) use !io:
    foreign c print_string(x @c_string:35:53, !io @c_string:35:57)


println > public (0 calls)
0: println(x:_ @c_string:37:17) use !io:
    !print(x @c_string:37:39)
    !nl


read > public (0 calls)
0: read(?x:_ @c_string:39:15) use !io:
    foreign c read_line(?x @c_string:39:51, !io @c_string:39:55)


unsafe_c_string_index > public (0 calls)
0: unsafe_c_string_index(str:_ @c_string:32:31, idx:int @c_string:32:38, ?#result:char @c_string:32:5):
    foreign lpvm access(str @c_string:33:27, idx @c_string:33:32, 1 @c_string:33:37, 0 @c_string:33:40, ?tmp#0 @c_string:33:7)
    foreign llvm move(tmp#0, ?#result @c_string:32:5)


~= > public (0 calls)
0: ~=(x:_ @c_string:11:10, y:_ @c_string:11:18, ?#result:bool @c_string:11:5):
    foreign c strcmp(x @c_string:11:47, y @c_string:11:49, ?tmp#1:int @c_string:11:30)
    ~=(tmp#1:int, 0 @c_string:11:60, ?tmp#0 @c_string:11:30)
    foreign llvm move(tmp#0, ?#result @c_string:11:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.char
  representation  : 8 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.char.<<0>
                    wybe.char.<=<0>
                    wybe.char.<=><0>
                    wybe.char.=<0>
                    wybe.char.><0>
                    wybe.char.>=<0>
                    wybe.char.chr<0>
                    wybe.char.ord<0>
                    wybe.char.print<0>
                    wybe.char.println<0>
                    wybe.char.read<0>
                    wybe.char.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:_ @char:17:10, y:_ @char:17:17, ?#result:bool @char:17:5):
    foreign llvm icmp_ult(x @char:17:51, y @char:17:54, ?tmp#0 @char:17:29)
    foreign llvm move(tmp#0, ?#result @char:17:5)


<= > public (0 calls)
0: <=(x:_ @char:18:10, y:_ @char:18:18, ?#result:bool @char:18:5):
    foreign llvm icmp_ule(x @char:18:52, y @char:18:55, ?tmp#0 @char:18:30)
    foreign llvm move(tmp#0, ?#result @char:18:5)


<=> > public (0 calls)
0: <=>(x:_ @char:23:10, y:_ @char:23:20, ?#result:comparison @char:23:5):
    if {<(x @char:24:10, y @char:24:14)::

        lesser(?tmp#1 @char:24:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @char:24:28, y @char:24:32)::

            equal(?tmp#3 @char:24:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @char:24:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @char:24:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @char:24:10, ?#result @char:23:5)


= > public (0 calls)
0: =(x:_ @char:13:10, y:_ @char:13:17, ?#result:bool @char:13:5):
    foreign llvm icmp_eq(x @char:13:50, y @char:13:53, ?tmp#0 @char:13:29)
    foreign llvm move(tmp#0, ?#result @char:13:5)


> > public (0 calls)
0: >(x:_ @char:19:10, y:_ @char:19:17, ?#result:bool @char:19:5):
    foreign llvm icmp_ugt(x @char:19:51, y @char:19:54, ?tmp#0 @char:19:29)
    foreign llvm move(tmp#0, ?#result @char:19:5)


>= > public (0 calls)
0: >=(x:_ @char:20:10, y:_ @char:20:18, ?#result:bool @char:20:5):
    foreign llvm icmp_uge(x @char:20:52, y @char:20:55, ?tmp#0 @char:20:30)
    foreign llvm move(tmp#0, ?#result @char:20:5)


chr > public {test} (0 calls)
0: chr(i:int @char:33:20, ?#result:_ @char:33:5):
    <=(0 @char:33:60, i @char:33:66)
    <=(i @char:33:70, 255 @char:33:76)
    foreign lpvm cast(i @char:33:49, ?tmp#0 @char:33:31)
    foreign llvm move(tmp#0, ?#result @char:33:5)


ord > public (0 calls)
0: ord(c:_ @char:30:13, ?#result:int @char:30:5):
    foreign lpvm cast(c @char:30:42, ?tmp#0 @char:30:24)
    foreign llvm move(tmp#0, ?#result @char:30:5)


print > public (0 calls)
0: print(x:_ @char:37:15) use !io:
    foreign c putchar(x @char:37:48, !io @char:37:52)


println > public (0 calls)
0: println(x:_ @char:39:17) use !io:
    !print(x @char:39:39)
    !nl


read > public (0 calls)
0: read(?x:_ @char:41:15) use !io:
    foreign c read_char(?x @char:41:51, !io @char:41:55)


~= > public (0 calls)
0: ~=(x:_ @char:14:10, y:_ @char:14:18, ?#result:bool @char:14:5):
    foreign llvm icmp_ne(x @char:14:51, y @char:14:54, ?tmp#0 @char:14:30)
    foreign llvm move(tmp#0, ?#result @char:14:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.comparison
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.comparison.<<0>
                    wybe.comparison.<=<0>
                    wybe.comparison.=<0>
                    wybe.comparison.><0>
                    wybe.comparison.>=<0>
                    wybe.comparison.~=<0>
  imports         : use wybe.bool
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:_ @comparison:12:10, y:_ @comparison:12:17, ?#result:bool @comparison:12:5):
    foreign llvm icmp_ult(x @comparison:12:51, y @comparison:12:54, ?tmp#0 @comparison:12:29)
    foreign llvm move(tmp#0, ?#result @comparison:12:5)


<= > public (0 calls)
0: <=(x:_ @comparison:13:10, y:_ @comparison:13:18, ?#result:bool @comparison:13:5):
    foreign llvm icmp_ule(x @comparison:13:52, y @comparison:13:55, ?tmp#0 @comparison:13:30)
    foreign llvm move(tmp#0, ?#result @comparison:13:5)


= > public (0 calls)
0: =(x:_ @comparison:10:10, y:_ @comparison:10:17, ?#result:bool @comparison:10:5):
    foreign llvm icmp_eq(x @comparison:10:50, y @comparison:10:53, ?tmp#0 @comparison:10:29)
    foreign llvm move(tmp#0, ?#result @comparison:10:5)


> > public (0 calls)
0: >(x:_ @comparison:14:10, y:_ @comparison:14:17, ?#result:bool @comparison:14:5):
    foreign llvm icmp_ugt(x @comparison:14:51, y @comparison:14:54, ?tmp#0 @comparison:14:29)
    foreign llvm move(tmp#0, ?#result @comparison:14:5)


>= > public (0 calls)
0: >=(x:_ @comparison:15:10, y:_ @comparison:15:18, ?#result:bool @comparison:15:5):
    foreign llvm icmp_uge(x @comparison:15:52, y @comparison:15:55, ?tmp#0 @comparison:15:30)
    foreign llvm move(tmp#0, ?#result @comparison:15:5)


~= > public (0 calls)
0: ~=(x:_ @comparison:11:10, y:_ @comparison:11:18, ?#result:bool @comparison:11:5):
    foreign llvm icmp_ne(x @comparison:11:51, y @comparison:11:54, ?tmp#0 @comparison:11:30)
    foreign llvm move(tmp#0, ?#result @comparison:11:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.control
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.control.assert<0>
                    wybe.control.error<0>
                    wybe.control.error<1>
                    wybe.control.exit<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.int
                    use wybe.string
  resources       : 
  procs           : 

assert > public {semipure} (0 calls)
0: assert(condition:bool @control:26:27) use call_source_location:
    if {~(condition @control:27:11)::

        !error(c"assertion failed" @control:27:31)
    else::
        pass

    }


error > public {terminal,semipure} (0 calls)
0: error(message:string @control:17:35) use call_source_location:
    c_string(message @control:18:77, ?tmp#0 @control:18:68)
    foreign c {terminal,semipure} error_exit(call_source_location @control:18:46, tmp#0)
error > public {terminal,semipure} (0 calls)
1: error(message:c_string @control:21:35) use call_source_location:
    foreign c {terminal,semipure} error_exit(call_source_location @control:22:46, message @control:22:68)


exit > public {terminal,semipure} (0 calls)
0: exit(code:int @control:10:34):
    foreign c {terminal,semipure} exit(code @control:11:40)

LLVM code       : None

--------------------------------------------------
 Module wybe.count
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.count.%<0>
                    wybe.count.%=<0>
                    wybe.count.*<0>
                    wybe.count.*=<0>
                    wybe.count.+<0>
                    wybe.count.+<1>
                    wybe.count.+<2>
                    wybe.count.+=<0>
                    wybe.count.-<0>
                    wybe.count.-<1>
                    wybe.count.-<2>
                    wybe.count.-=<0>
                    wybe.count./<0>
                    wybe.count./=<0>
                    wybe.count.<<0>
                    wybe.count.<=<0>
                    wybe.count.<=><0>
                    wybe.count.=<0>
                    wybe.count.><0>
                    wybe.count.>=<0>
                    wybe.count.decr<0>
                    wybe.count.incr<0>
                    wybe.count.max<0>
                    wybe.count.min<0>
                    wybe.count.print<0>
                    wybe.count.println<0>
                    wybe.count.read<0>
                    wybe.count.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public (0 calls)
0: %(x:_ @count:51:10, y:_ @count:51:16, ?#result:_ @count:51:5):
    foreign llvm urem(x @count:51:43, y @count:51:45, ?tmp#0 @count:51:25)
    foreign llvm move(tmp#0, ?#result @count:51:5)


%= > public (0 calls)
0: %=(!x:_ @count:54:11, y:_ @count:54:19):
    %(x @count:54:31, y @count:54:35, ?tmp#0 @count:54:31)
    =(?x @count:54:27, tmp#0)


* > public (0 calls)
0: *(x:_ @count:39:10, y:_ @count:39:16, ?#result:_ @count:39:5):
    foreign llvm mul(x @count:39:42, y @count:39:44, ?tmp#0 @count:39:25)
    foreign llvm move(tmp#0, ?#result @count:39:5)


*= > public (0 calls)
0: *=(!x:_ @count:42:11, y:_ @count:42:19):
    *(x @count:42:31, y @count:42:35, ?tmp#0 @count:42:31)
    =(?x @count:42:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @count:15:10, y:_ @count:15:16, ?#result:_ @count:15:5):
    foreign llvm add(x @count:15:42, y @count:15:44, ?tmp#0 @count:15:25)
    foreign llvm move(tmp#0, ?#result @count:15:5)
+ > public {test} (0 calls)
1: +(?x:_ @count:16:21, y:_ @count:16:27, z:_ @count:16:5):
    >=(z @count:17:5, y @count:17:11)
    foreign llvm sub(z @count:18:27, y @count:18:29, ?tmp#0 @count:18:10)
    =(?x @count:18:6, tmp#0)
+ > public {test} (0 calls)
2: +(x:_ @count:20:20, ?y:_ @count:20:27, z:_ @count:20:5):
    >=(z @count:21:5, x @count:21:11)
    foreign llvm sub(z @count:22:27, x @count:22:29, ?tmp#0 @count:22:10)
    =(?y @count:22:6, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @count:26:11, y:_ @count:26:19):
    +(x @count:26:31, y @count:26:35, ?tmp#0 @count:26:31)
    =(?x @count:26:27, tmp#0)


- > public {test} (0 calls)
0: -(x:_ @count:31:20, y:_ @count:31:26, ?#result:_ @count:31:5):
    >=(y @count:31:65, x @count:31:71)
    foreign llvm sub(x @count:31:52, y @count:31:54, ?tmp#0 @count:31:35)
    foreign llvm move(tmp#0, ?#result @count:31:5)
- > public (0 calls)
1: -(?x:_ @count:32:11, y:_ @count:32:17, z:_ @count:32:5):
    foreign llvm add(z @count:32:59, y @count:32:61, ?tmp#0 @count:32:42)
    =(?x @count:32:38, tmp#0)
- > public (0 calls)
2: -(x:_ @count:33:10, ?y:_ @count:33:17, z:_ @count:33:5):
    foreign llvm sub(z @count:33:59, x @count:33:61, ?tmp#0 @count:33:42)
    =(?y @count:33:38, tmp#0)


-= > public {test} (0 calls)
0: -=(!x:_ @count:36:21, y:_ @count:36:29):
    -(x @count:36:41, y @count:36:45, ?tmp#0 @count:36:41)
    =(?x @count:36:37, tmp#0)


/ > public (0 calls)
0: /(x:_ @count:45:10, y:_ @count:45:16, ?#result:_ @count:45:5):
    foreign llvm udiv(x @count:45:43, y @count:45:45, ?tmp#0 @count:45:25)
    foreign llvm move(tmp#0, ?#result @count:45:5)


/= > public (0 calls)
0: /=(!x:_ @count:48:11, y:_ @count:48:19):
    /(x @count:48:31, y @count:48:35, ?tmp#0 @count:48:31)
    =(?x @count:48:27, tmp#0)


< > public (0 calls)
0: <(x:_ @count:64:10, y:_ @count:64:17, ?#result:bool @count:64:5):
    foreign llvm icmp_ult(x @count:64:51, y @count:64:53, ?tmp#0 @count:64:29)
    foreign llvm move(tmp#0, ?#result @count:64:5)


<= > public (0 calls)
0: <=(x:_ @count:65:10, y:_ @count:65:18, ?#result:bool @count:65:5):
    foreign llvm icmp_ule(x @count:65:52, y @count:65:54, ?tmp#0 @count:65:30)
    foreign llvm move(tmp#0, ?#result @count:65:5)


<=> > public (0 calls)
0: <=>(x:_ @count:70:10, y:_ @count:70:20, ?#result:comparison @count:70:5):
    if {<(x @count:71:10, y @count:71:14)::

        lesser(?tmp#1 @count:71:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @count:71:28, y @count:71:32)::

            equal(?tmp#3 @count:71:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @count:71:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @count:71:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:71:10, ?#result @count:70:5)


= > public (0 calls)
0: =(x:_ @count:60:10, y:_ @count:60:17, ?#result:bool @count:60:5):
    foreign llvm icmp_eq(x @count:60:50, y @count:60:52, ?tmp#0 @count:60:29)
    foreign llvm move(tmp#0, ?#result @count:60:5)


> > public (0 calls)
0: >(x:_ @count:66:10, y:_ @count:66:17, ?#result:bool @count:66:5):
    foreign llvm icmp_ugt(x @count:66:51, y @count:66:53, ?tmp#0 @count:66:29)
    foreign llvm move(tmp#0, ?#result @count:66:5)


>= > public (0 calls)
0: >=(x:_ @count:67:10, y:_ @count:67:18, ?#result:bool @count:67:5):
    foreign llvm icmp_uge(x @count:67:52, y @count:67:54, ?tmp#0 @count:67:30)
    foreign llvm move(tmp#0, ?#result @count:67:5)


decr > public {test} (0 calls)
0: decr(!x:_ @count:84:25):
    -(x @count:84:37, 1:_ @count:84:41, ?tmp#0 @count:84:37)
    =(?x @count:84:33, tmp#0)


incr > public (0 calls)
0: incr(!x:_ @count:81:15):
    +(x @count:81:27, 1:_ @count:81:31, ?tmp#0 @count:81:27)
    =(?x @count:81:23, tmp#0)


max > public (0 calls)
0: max(x:_ @count:75:13, y:_ @count:75:18, ?#result:_ @count:75:5):
    if {>=(x @count:75:31, y @count:75:35)::

        foreign llvm move(x @count:75:39, ?tmp#0)
    else::
        foreign llvm move(y @count:75:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:75:31, ?#result @count:75:5)


min > public (0 calls)
0: min(x:_ @count:74:13, y:_ @count:74:18, ?#result:_ @count:74:5):
    if {<=(x @count:74:31, y @count:74:35)::

        foreign llvm move(x @count:74:39, ?tmp#0)
    else::
        foreign llvm move(y @count:74:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:74:31, ?#result @count:74:5)


print > public (0 calls)
0: print(x:_ @count:88:15) use !io:
    foreign c print_count(x @count:88:52, !io @count:88:56)


println > public (0 calls)
0: println(x:_ @count:90:17) use !io:
    !print(x @count:90:39)
    !nl


read > public (0 calls)
0: read(?x:_ @count:92:15) use !io:
    foreign c read_count(?x @count:92:52, !io @count:92:56)


~= > public (0 calls)
0: ~=(x:_ @count:61:10, y:_ @count:61:18, ?#result:bool @count:61:5):
    foreign llvm icmp_ne(x @count:61:51, y @count:61:53, ?tmp#0 @count:61:30)
    foreign llvm move(tmp#0, ?#result @count:61:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.float
  representation  : 64 bit float
  public submods  : 
  public resources: 
  public procs    : wybe.float.*<0>
                    wybe.float.**<0>
                    wybe.float.*=<0>
                    wybe.float.+<0>
                    wybe.float.+<1>
                    wybe.float.+<2>
                    wybe.float.+=<0>
                    wybe.float.-<0>
                    wybe.float.-<1>
                    wybe.float.-<2>
                    wybe.float.-<3>
                    wybe.float.-<4>
                    wybe.float.-=<0>
                    wybe.float./<0>
                    wybe.float./=<0>
                    wybe.float.<<0>
                    wybe.float.<=<0>
                    wybe.float.<=><0>
                    wybe.float.=<0>
                    wybe.float.><0>
                    wybe.float.>=<0>
                    wybe.float.abs<0>
                    wybe.float.ceil<0>
                    wybe.float.cos<0>
                    wybe.float.e<0>
                    wybe.float.exp<0>
                    wybe.float.floor<0>
                    wybe.float.iceil<0>
                    wybe.float.ifloor<0>
                    wybe.float.iround<0>
                    wybe.float.log<0>
                    wybe.float.log10<0>
                    wybe.float.log2<0>
                    wybe.float.max<0>
                    wybe.float.min<0>
                    wybe.float.pi<0>
                    wybe.float.power<0>
                    wybe.float.print<0>
                    wybe.float.println<0>
                    wybe.float.read<0>
                    wybe.float.round<0>
                    wybe.float.sin<0>
                    wybe.float.sqrt<0>
                    wybe.float.square<0>
                    wybe.float.tan<0>
                    wybe.float.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

* > public (0 calls)
0: *(x:_ @float:45:10, y:_ @float:45:16, ?#result:_ @float:45:5):
    foreign llvm fmul(x @float:45:43, y @float:45:45, ?tmp#0 @float:45:25)
    foreign llvm move(tmp#0, ?#result @float:45:5)


** > public (0 calls)
0: **(x:_ @float:112:10, n:_ @float:112:18, ?#result:_ @float:112:5):
    foreign c llvm.pow.f64(x @float:112:52, n @float:112:54, ?tmp#0 @float:112:27)
    foreign llvm move(tmp#0, ?#result @float:112:5)


*= > public (0 calls)
0: *=(!x:_ @float:48:11, y:_ @float:48:19):
    *(x @float:48:31, y @float:48:35, ?tmp#0 @float:48:31)
    =(?x @float:48:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @float:23:10, y:_ @float:23:17, ?#result:_ @float:23:5):
    foreign llvm fadd(x @float:23:45, y @float:23:47, ?tmp#0 @float:23:27)
    foreign llvm move(tmp#0, ?#result @float:23:5)
+ > public (0 calls)
1: +(?x:_ @float:24:11, y:_ @float:24:17, z:_ @float:24:5):
    foreign llvm fsub(z @float:24:61, y @float:24:63, ?tmp#0 @float:24:43)
    =(?x @float:24:39, tmp#0)
+ > public (0 calls)
2: +(x:_ @float:25:10, ?y:_ @float:25:18, z:_ @float:25:5):
    foreign llvm fsub(z @float:25:61, x @float:25:63, ?tmp#0 @float:25:43)
    =(?y @float:25:39, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @float:28:11, y:_ @float:28:19):
    +(x @float:28:31, y @float:28:35, ?tmp#0 @float:28:31)
    =(?x @float:28:27, tmp#0)


- > public (0 calls)
0: -(x:_ @float:32:10, y:_ @float:32:17, ?#result:_ @float:32:5):
    foreign llvm fsub(x @float:32:45, y @float:32:47, ?tmp#0 @float:32:27)
    foreign llvm move(tmp#0, ?#result @float:32:5)
- > public (0 calls)
1: -(?x:_ @float:33:11, y:_ @float:33:17, z:_ @float:33:5):
    foreign llvm fadd(z @float:33:61, y @float:33:63, ?tmp#0 @float:33:43)
    =(?x @float:33:39, tmp#0)
- > public (0 calls)
2: -(x:_ @float:34:10, ?y:_ @float:34:18, z:_ @float:34:5):
    foreign llvm fsub(z @float:34:61, x @float:34:63, ?tmp#0 @float:34:43)
    =(?y @float:34:39, tmp#0)
- > public (0 calls)
3: -(x:_ @float:38:11, ?#result:_ @float:38:5):
    foreign llvm fsub(0.0 @float:38:39, x @float:38:43, ?tmp#0 @float:38:21)
    foreign llvm move(tmp#0, ?#result @float:38:5)
- > public (0 calls)
4: -(?x:_ @float:39:12, y:_ @float:39:5):
    foreign llvm fsub(0.0 @float:39:55, y @float:39:59, ?tmp#0 @float:39:37)
    =(?x @float:39:33, tmp#0)


-= > public (0 calls)
0: -=(!x:_ @float:42:11, y:_ @float:42:19):
    -(x @float:42:31, y @float:42:35, ?tmp#0 @float:42:31)
    =(?x @float:42:27, tmp#0)


/ > public (0 calls)
0: /(x:_ @float:51:10, y:_ @float:51:16, ?#result:_ @float:51:5):
    foreign llvm fdiv(x @float:51:43, y @float:51:45, ?tmp#0 @float:51:25)
    foreign llvm move(tmp#0, ?#result @float:51:5)


/= > public (0 calls)
0: /=(!x:_ @float:54:11, y:_ @float:54:19):
    /(x @float:54:31, y @float:54:35, ?tmp#0 @float:54:31)
    =(?x @float:54:27, tmp#0)


< > public (0 calls)
0: <(x:_ @float:70:10, y:_ @float:70:17, ?#result:bool @float:70:5):
    foreign llvm fcmp_slt(x @float:70:51, y @float:70:53, ?tmp#0 @float:70:29)
    foreign llvm move(tmp#0, ?#result @float:70:5)


<= > public (0 calls)
0: <=(x:_ @float:71:10, y:_ @float:71:18, ?#result:bool @float:71:5):
    foreign llvm fcmp_sle(x @float:71:52, y @float:71:54, ?tmp#0 @float:71:30)
    foreign llvm move(tmp#0, ?#result @float:71:5)


<=> > public (0 calls)
0: <=>(x:_ @float:76:10, y:_ @float:76:20, ?#result:comparison @float:76:5):
    if {<(x @float:77:10, y @float:77:14)::

        lesser(?tmp#1 @float:77:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @float:77:28, y @float:77:32)::

            equal(?tmp#3 @float:77:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @float:77:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @float:77:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @float:77:10, ?#result @float:76:5)


= > public (0 calls)
0: =(x:_ @float:66:10, y:_ @float:66:17, ?#result:bool @float:66:5):
    foreign llvm fcmp_eq(x @float:66:50, y @float:66:52, ?tmp#0 @float:66:29)
    foreign llvm move(tmp#0, ?#result @float:66:5)


> > public (0 calls)
0: >(x:_ @float:72:10, y:_ @float:72:17, ?#result:bool @float:72:5):
    foreign llvm fcmp_sgt(x @float:72:51, y @float:72:53, ?tmp#0 @float:72:29)
    foreign llvm move(tmp#0, ?#result @float:72:5)


>= > public (0 calls)
0: >=(x:_ @float:73:10, y:_ @float:73:18, ?#result:bool @float:73:5):
    foreign llvm fcmp_sge(x @float:73:52, y @float:73:54, ?tmp#0 @float:73:30)
    foreign llvm move(tmp#0, ?#result @float:73:5)


abs > public (0 calls)
0: abs(x:_ @float:60:13, ?#result:_ @float:60:5):
    foreign c llvm.fabs.f64(x @float:60:48, ?tmp#0 @float:60:22)
    foreign llvm move(tmp#0, ?#result @float:60:5)


ceil > public (0 calls)
0: ceil(x:_ @float:87:14, ?#result:_ @float:87:5):
    foreign c llvm.ceil.f64(x @float:87:49, ?tmp#0 @float:87:23)
    foreign llvm move(tmp#0, ?#result @float:87:5)


cos > public (0 calls)
0: cos(x:_ @float:116:13, ?#result:_ @float:116:5):
    foreign c llvm.cos.f64(x @float:116:47, ?tmp#0 @float:116:22)
    foreign llvm move(tmp#0, ?#result @float:116:5)


e > public (0 calls)
0: e(?#result:_ @float:16:5):
    foreign llvm move(2.7182818284590455 @float:16:15, ?#result @float:16:5)


exp > public (0 calls)
0: exp(x:_ @float:120:13, ?#result:_ @float:120:5):
    foreign c llvm.exp.f64(x @float:120:47, ?tmp#0 @float:120:22)
    foreign llvm move(tmp#0, ?#result @float:120:5)


floor > public (0 calls)
0: floor(x:_ @float:90:15, ?#result:_ @float:90:5):
    foreign c llvm.floor.f64(x @float:90:51, ?tmp#0 @float:90:24)
    foreign llvm move(tmp#0, ?#result @float:90:5)


iceil > public (0 calls)
0: iceil(x:_ @float:99:15, ?#result:int @float:99:5):
    ceil(x @float:99:51, ?tmp#1 @float:99:46)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:99:26)
    foreign llvm move(tmp#0, ?#result @float:99:5)


ifloor > public (0 calls)
0: ifloor(x:_ @float:102:16, ?#result:int @float:102:5):
    floor(x @float:102:53, ?tmp#1 @float:102:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:102:27)
    foreign llvm move(tmp#0, ?#result @float:102:5)


iround > public (0 calls)
0: iround(x:_ @float:96:16, ?#result:int @float:96:5):
    round(x @float:96:53, ?tmp#1 @float:96:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:96:27)
    foreign llvm move(tmp#0, ?#result @float:96:5)


log > public (0 calls)
0: log(x:_ @float:123:13, ?#result:_ @float:123:5):
    foreign c llvm.log.f64(x @float:123:47, ?tmp#0 @float:123:22)
    foreign llvm move(tmp#0, ?#result @float:123:5)


log10 > public (0 calls)
0: log10(x:_ @float:126:15, ?#result:_ @float:126:5):
    foreign c llvm.log10.f64(x @float:126:51, ?tmp#0 @float:126:24)
    foreign llvm move(tmp#0, ?#result @float:126:5)


log2 > public (0 calls)
0: log2(x:_ @float:129:14, ?#result:_ @float:129:5):
    foreign c llvm.log2.f64(x @float:129:49, ?tmp#0 @float:129:23)
    foreign llvm move(tmp#0, ?#result @float:129:5)


max > public (0 calls)
0: max(x:_ @float:81:13, y:_ @float:81:18, ?#result:_ @float:81:5):
    foreign c llvm.maxnum.f64(x @float:81:55, y @float:81:57, ?tmp#0 @float:81:27)
    foreign llvm move(tmp#0, ?#result @float:81:5)


min > public (0 calls)
0: min(x:_ @float:80:13, y:_ @float:80:18, ?#result:_ @float:80:5):
    foreign c llvm.minnum.f64(x @float:80:55, y @float:80:57, ?tmp#0 @float:80:27)
    foreign llvm move(tmp#0, ?#result @float:80:5)


pi > public (0 calls)
0: pi(?#result:_ @float:13:5):
    foreign llvm move(3.141592653589793 @float:13:16, ?#result @float:13:5)


power > public (0 calls)
0: power(x:_ @float:111:15, n:_ @float:111:19, ?#result:_ @float:111:5):
    foreign c llvm.pow.f64(x @float:111:53, n @float:111:55, ?tmp#0 @float:111:28)
    foreign llvm move(tmp#0, ?#result @float:111:5)


print > public (0 calls)
0: print(x:_ @float:133:15) use !io:
    foreign c print_float(x @float:133:52, !io @float:133:56)


println > public (0 calls)
0: println(x:_ @float:135:17) use !io:
    !print(x @float:135:39)
    !nl


read > public (0 calls)
0: read(?x:_ @float:137:15) use !io:
    foreign c read_float(?x @float:137:52, !io @float:137:56)


round > public (0 calls)
0: round(x:_ @float:93:15, ?#result:_ @float:93:5):
    foreign c llvm.round.f64(x @float:93:51, ?tmp#0 @float:93:24)
    foreign llvm move(tmp#0, ?#result @float:93:5)


sin > public (0 calls)
0: sin(x:_ @float:115:13, ?#result:_ @float:115:5):
    foreign c llvm.sin.f64(x @float:115:47, ?tmp#0 @float:115:22)
    foreign llvm move(tmp#0, ?#result @float:115:5)


sqrt > public (0 calls)
0: sqrt(x:_ @float:108:14, ?#result:_ @float:108:5):
    foreign c llvm.sqrt.f64(x @float:108:49, ?tmp#0 @float:108:23)
    foreign llvm move(tmp#0, ?#result @float:108:5)


square > public (0 calls)
0: square(x:_ @float:57:16, ?#result:_ @float:57:5):
    foreign llvm fmul(x @float:57:43, x @float:57:45, ?tmp#0 @float:57:25)
    foreign llvm move(tmp#0, ?#result @float:57:5)


tan > public (0 calls)
0: tan(x:_ @float:117:13, ?#result:_ @float:117:5):
    foreign c llvm.sin.f64(x @float:117:47, ?tmp#1 @float:117:22)
    foreign c llvm.cos.f64(x @float:117:77, ?tmp#2 @float:117:52)
    /(tmp#1, tmp#2, ?tmp#0 @float:117:22)
    foreign llvm move(tmp#0, ?#result @float:117:5)


~= > public (0 calls)
0: ~=(x:_ @float:67:10, y:_ @float:67:18, ?#result:bool @float:67:5):
    foreign llvm fcmp_ne(x @float:67:51, y @float:67:53, ?tmp#0 @float:67:30)
    foreign llvm move(tmp#0, ?#result @float:67:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.int
  representation  : 64 bit signed
  public submods  : 
  public resources: 
  public procs    : wybe.int.%<0>
                    wybe.int.%=<0>
                    wybe.int.*<0>
                    wybe.int.*=<0>
                    wybe.int.+<0>
                    wybe.int.+<1>
                    wybe.int.+<2>
                    wybe.int.+=<0>
                    wybe.int.-<0>
                    wybe.int.-<1>
                    wybe.int.-<2>
                    wybe.int.-<3>
                    wybe.int.-<4>
                    wybe.int.-=<0>
                    wybe.int./<0>
                    wybe.int./=<0>
                    wybe.int.<<0>
                    wybe.int.<<<0>
                    wybe.int.<<=<0>
                    wybe.int.<=<0>
                    wybe.int.<=><0>
                    wybe.int.=<0>
                    wybe.int.><0>
                    wybe.int.>=<0>
                    wybe.int.>><0>
                    wybe.int.>>=<0>
                    wybe.int.decr<0>
                    wybe.int.incr<0>
                    wybe.int.logical_bitshift<0>
                    wybe.int.logical_bitshift<1>
                    wybe.int.max<0>
                    wybe.int.min<0>
                    wybe.int.power<0>
                    wybe.int.print<0>
                    wybe.int.println<0>
                    wybe.int.read<0>
                    wybe.int.signum<0>
                    wybe.int.sqrt<0>
                    wybe.int.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public (0 calls)
0: %(x:_ @int:50:10, y:_ @int:50:16, ?#result:_ @int:50:5):
    foreign llvm srem(x @int:50:43, y @int:50:45, ?tmp#0 @int:50:25)
    foreign llvm move(tmp#0, ?#result @int:50:5)


%= > public (0 calls)
0: %=(!x:_ @int:53:11, y:_ @int:53:19):
    %(x @int:53:31, y @int:53:35, ?tmp#0 @int:53:31)
    =(?x @int:53:27, tmp#0)


* > public (0 calls)
0: *(x:_ @int:38:10, y:_ @int:38:16, ?#result:_ @int:38:5):
    foreign llvm mul(x @int:38:42, y @int:38:44, ?tmp#0 @int:38:25)
    foreign llvm move(tmp#0, ?#result @int:38:5)


*= > public (0 calls)
0: *=(!x:_ @int:41:11, y:_ @int:41:19):
    *(x @int:41:31, y @int:41:35, ?tmp#0 @int:41:31)
    =(?x @int:41:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @int:16:10, y:_ @int:16:17, ?#result:_ @int:16:5):
    foreign llvm add(x @int:16:44, y @int:16:46, ?tmp#0 @int:16:27)
    foreign llvm move(tmp#0, ?#result @int:16:5)
+ > public (0 calls)
1: +(?x:_ @int:17:11, y:_ @int:17:17, z:_ @int:17:5):
    foreign llvm sub(z @int:17:60, y @int:17:62, ?tmp#0 @int:17:43)
    =(?x @int:17:39, tmp#0)
+ > public (0 calls)
2: +(x:_ @int:18:10, ?y:_ @int:18:18, z:_ @int:18:5):
    foreign llvm sub(z @int:18:60, x @int:18:62, ?tmp#0 @int:18:43)
    =(?y @int:18:39, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @int:21:11, y:_ @int:21:19):
    +(x @int:21:31, y @int:21:35, ?tmp#0 @int:21:31)
    =(?x @int:21:27, tmp#0)


- > public (0 calls)
0: -(x:_ @int:25:10, y:_ @int:25:17, ?#result:_ @int:25:5):
    foreign llvm sub(x @int:25:44, y @int:25:46, ?tmp#0 @int:25:27)
    foreign llvm move(tmp#0, ?#result @int:25:5)
- > public (0 calls)
1: -(?x:_ @int:26:11, y:_ @int:26:17, z:_ @int:26:5):
    foreign llvm add(z @int:26:60, y @int:26:62, ?tmp#0 @int:26:43)
    =(?x @int:26:39, tmp#0)
- > public (0 calls)
2: -(x:_ @int:27:10, ?y:_ @int:27:18, z:_ @int:27:5):
    foreign llvm sub(z @int:27:60, x @int:27:62, ?tmp#0 @int:27:43)
    =(?y @int:27:39, tmp#0)
- > public (0 calls)
3: -(x:_ @int:31:11, ?#result:_ @int:31:5):
    foreign llvm sub(0 @int:31:38, x @int:31:40, ?tmp#0 @int:31:21)
    foreign llvm move(tmp#0, ?#result @int:31:5)
- > public (0 calls)
4: -(?x:_ @int:32:12, y:_ @int:32:5):
    foreign llvm sub(0 @int:32:54, y @int:32:56, ?tmp#0 @int:32:37)
    =(?x @int:32:33, tmp#0)


-= > public (0 calls)
0: -=(!x:_ @int:35:11, y:_ @int:35:19):
    -(x @int:35:31, y @int:35:35, ?tmp#0 @int:35:31)
    =(?x @int:35:27, tmp#0)


/ > public (0 calls)
0: /(x:_ @int:44:10, y:_ @int:44:16, ?#result:_ @int:44:5):
    foreign llvm sdiv(x @int:44:43, y @int:44:45, ?tmp#0 @int:44:25)
    foreign llvm move(tmp#0, ?#result @int:44:5)


/= > public (0 calls)
0: /=(!x:_ @int:47:11, y:_ @int:47:19):
    /(x @int:47:31, y @int:47:35, ?tmp#0 @int:47:31)
    =(?x @int:47:27, tmp#0)


< > public (0 calls)
0: <(x:_ @int:87:10, y:_ @int:87:17, ?#result:bool @int:87:5):
    foreign llvm icmp_slt(x @int:87:51, y @int:87:53, ?tmp#0 @int:87:29)
    foreign llvm move(tmp#0, ?#result @int:87:5)


<< > public (0 calls)
0: <<(x:_ @int:56:10, s:_ @int:56:18, ?#result:_ @int:56:5):
    foreign llvm shl(x @int:56:44, s @int:56:47, ?tmp#0 @int:56:27)
    foreign llvm move(tmp#0, ?#result @int:56:5)


<<= > public (0 calls)
0: <<=(!x:_ @int:59:11, s:_ @int:59:21):
    <<(x @int:59:33, s @int:59:39, ?tmp#0 @int:59:33)
    =(?x @int:59:29, tmp#0)


<= > public (0 calls)
0: <=(x:_ @int:88:10, y:_ @int:88:18, ?#result:bool @int:88:5):
    foreign llvm icmp_sle(x @int:88:52, y @int:88:54, ?tmp#0 @int:88:30)
    foreign llvm move(tmp#0, ?#result @int:88:5)


<=> > public (0 calls)
0: <=>(x:_ @int:93:10, y:_ @int:93:20, ?#result:comparison @int:93:5):
    if {<(x @int:94:10, y @int:94:14)::

        lesser(?tmp#1 @int:94:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @int:94:28, y @int:94:32)::

            equal(?tmp#3 @int:94:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @int:94:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @int:94:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @int:94:10, ?#result @int:93:5)


= > public (0 calls)
0: =(x:_ @int:83:10, y:_ @int:83:17, ?#result:bool @int:83:5):
    foreign llvm icmp_eq(x @int:83:50, y @int:83:52, ?tmp#0 @int:83:29)
    foreign llvm move(tmp#0, ?#result @int:83:5)


> > public (0 calls)
0: >(x:_ @int:89:10, y:_ @int:89:17, ?#result:bool @int:89:5):
    foreign llvm icmp_sgt(x @int:89:51, y @int:89:53, ?tmp#0 @int:89:29)
    foreign llvm move(tmp#0, ?#result @int:89:5)


>= > public (0 calls)
0: >=(x:_ @int:90:10, y:_ @int:90:18, ?#result:bool @int:90:5):
    foreign llvm icmp_sge(x @int:90:52, y @int:90:54, ?tmp#0 @int:90:30)
    foreign llvm move(tmp#0, ?#result @int:90:5)


>> > public (0 calls)
0: >>(x:_ @int:65:10, s:_ @int:65:18, ?#result:_ @int:65:5):
    foreign llvm ashr(x @int:65:45, s @int:65:48, ?tmp#0 @int:65:27)
    foreign llvm move(tmp#0, ?#result @int:65:5)


>>= > public (0 calls)
0: >>=(!x:_ @int:68:11, s:_ @int:68:21):
    >>(x @int:68:33, s @int:68:39, ?tmp#0 @int:68:33)
    =(?x @int:68:29, tmp#0)


decr > public (0 calls)
0: decr(!x:_ @int:111:15):
    -(x @int:111:27, 1 @int:111:31, ?tmp#0 @int:111:27)
    =(?x @int:111:23, tmp#0)


incr > public (0 calls)
0: incr(!x:_ @int:110:15):
    +(x @int:110:27, 1 @int:110:31, ?tmp#0 @int:110:27)
    =(?x @int:110:23, tmp#0)


logical_bitshift > public (0 calls)
0: logical_bitshift(x:_ @int:74:26, s:_ @int:74:31, ?#result:_ @int:74:5):
    foreign llvm lshr(x @int:74:58, s @int:74:61, ?tmp#0 @int:74:40)
    foreign llvm move(tmp#0, ?#result @int:74:5)
logical_bitshift > public (0 calls)
1: logical_bitshift(!x:_ @int:77:27, s:_ @int:77:32):
    logical_bitshift(x @int:77:61, s @int:77:64, ?tmp#0 @int:77:44)
    =(?x @int:77:40, tmp#0)


max > public (0 calls)
0: max(x:_ @int:98:13, y:_ @int:98:18, ?#result:_ @int:98:5):
    if {>=(x @int:98:31, y @int:98:35)::

        foreign llvm move(x @int:98:39, ?tmp#0)
    else::
        foreign llvm move(y @int:98:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @int:98:31, ?#result @int:98:5)


min > public (0 calls)
0: min(x:_ @int:97:13, y:_ @int:97:18, ?#result:_ @int:97:5):
    if {<=(x @int:97:31, y @int:97:35)::

        foreign llvm move(x @int:97:39, ?tmp#0)
    else::
        foreign llvm move(y @int:97:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @int:97:31, ?#result @int:97:5)


power > public (0 calls)
0: power(x:_ @int:107:15, y:_ @int:107:20, ?#result:_ @int:107:5):
    foreign c ipow(x @int:107:44, y @int:107:46, ?tmp#0 @int:107:29)
    foreign llvm move(tmp#0, ?#result @int:107:5)


print > public (0 calls)
0: print(x:_ @int:119:15) use !io:
    foreign c print_int(x @int:119:50, !io @int:119:54)


println > public (0 calls)
0: println(x:_ @int:121:17) use !io:
    !print(x @int:121:39)
    !nl


read > public (0 calls)
0: read(?x:_ @int:123:15) use !io:
    foreign c read_int(?x @int:123:50, !io @int:123:54)


signum > public (0 calls)
0: signum(x:_ @int:114:16, ?#result:_ @int:114:5):
    foreign c signum(x @int:114:42, ?tmp#0 @int:114:25)
    foreign llvm move(tmp#0, ?#result @int:114:5)


sqrt > public (0 calls)
0: sqrt(x:_ @int:104:14, ?#result:_ @int:104:5):
    foreign c isqrt(x @int:104:39, ?tmp#0 @int:104:23)
    foreign llvm move(tmp#0, ?#result @int:104:5)


~= > public (0 calls)
0: ~=(x:_ @int:84:10, y:_ @int:84:18, ?#result:bool @int:84:5):
    foreign llvm icmp_ne(x @int:84:51, y @int:84:53, ?tmp#0 @int:84:30)
    foreign llvm move(tmp#0, ?#result @int:84:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.io
  representation  : (not a type)
  public submods  : 
  public resources: io: wybe.io.io
  public procs    : wybe.io.eof<0>
                    wybe.io.nl<0>
  imports         : use wybe.char
                    public use wybe.phantom
  resources       : io: fromList [(wybe.io.io,phantom = 0:phantom @io:13:27 @io:13:5)]
  procs           : 

eof > public {inline} (0 calls)
0: eof(?#result:char @io:20:5):
    foreign lpvm cast(-1 @io:20:47, ?tmp#0 @io:20:29)
    foreign llvm move(tmp#0, ?#result @io:20:5)


nl > public {inline} (0 calls)
0: nl() use !io:
    foreign c putchar('\n' @io:17:49, !io @io:17:54)

LLVM code       : None

--------------------------------------------------
 Module wybe.list(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.list.,,<0>
                    wybe.list.[]<0>
                    wybe.list.all<0>
                    wybe.list.any<0>
                    wybe.list.empty<0>
                    wybe.list.filter<0>
                    wybe.list.foldl<0>
                    wybe.list.foldr<0>
                    wybe.list.length<0>
                    wybe.list.list<0>
                    wybe.list.map<0>
                    wybe.list.map<1>
                    wybe.list.map<2>
                    wybe.list.print<0>
                    wybe.list.println<0>
                    wybe.list.reverse<0>
  imports         : use wybe.array
                    use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
                    use wybe.machine_word
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_(T) @list:20:10, y:_(T) @list:20:20, ?#result:_(T) @list:20:5):
    if {[|](?h @list:21:16, ?t @list:21:21, x @list:21:10)::

        ,,(t @list:21:32, y @list:21:37, ?tmp#2 @list:21:32)
        [|](h @list:21:28, tmp#2, ?tmp#1 @list:21:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(y @list:21:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:21:10, ?#result @list:20:5)


[] > public {test} (0 calls)
0: [](xs:_(T) @list:31:21, idx:int @list:31:30, ?#result:T @list:31:5):
    >=(idx @list:32:5, 0 @list:32:13)
    index1(xs @list:33:17, idx @list:33:21, ?tmp#0 @list:33:10)
    =(?x @list:33:6, tmp#0)
    foreign llvm move(x @list:31:43, ?#result @list:31:5)


all > public {test} (0 calls)
0: all(p:{test}(T) @list:61:20, xs:_(T) @list:61:33):
    foreign llvm move(xs @list:62:15, ?tmp#0)
    do {
        if {[|](?x @list:62:10, ?tmp#0, tmp#0)::

            p(x @list:63:11)
        else::
            break

        }
    }


any > public {test} (0 calls)
0: any(p:{test}(T) @list:69:20, xs:_(T) @list:69:33):
    [|](?x @list:70:7, ?xs @list:70:12, xs @list:70:18)
    (   p(x @list:71:8)
    | any(p @list:71:17, xs @list:71:20))


empty > public {test} (0 calls)
0: empty(xs:_(T) @list:15:22):
    if {[|](?tmp#0 @list:16:11, ?tmp#1 @list:16:15, xs @list:16:20)::

        fail
    else::
        pass

    }


filter > public (0 calls)
0: filter(p:{test}(T) @list:95:16, !xs:_(T) @list:95:30):
    [](?tmp#0 @list:96:12)
    =(?out @list:96:6, tmp#0)
    foreign llvm move(xs @list:97:15, ?tmp#1)
    do {
        if {[|](?x @list:97:10, ?tmp#1, tmp#1)::

            if {p(x @list:98:16)::

                [|](x @list:98:30, out @list:98:34, ?tmp#2 @list:98:29)
                =(?out @list:98:23, tmp#2)
            else::
                pass

            }
        else::
            break

        }
    }
    reverse(out @list:100:19, ?tmp#3 @list:100:11)
    =(?as @list:100:6, tmp#3)


foldl > public (0 calls)
0: foldl(f:(A, !B) @list:77:15, as:_(A) @list:77:26, !b:B @list:77:36):
    foreign llvm move(as @list:78:15, ?tmp#0)
    do {
        if {[|](?a @list:78:10, ?tmp#0, tmp#0)::

            f(a @list:79:11, !b @list:79:15)
        else::
            break

        }
    }


foldr > public (0 calls)
0: foldr(f:(A, !B) @list:86:15, as:_(A) @list:86:26, !b:B @list:86:36):
    if {[|](?a @list:87:12, ?as @list:87:17, as @list:87:23)::

        foldr(f @list:88:15, as @list:88:18, !b @list:88:23)
        f(a @list:89:11, !b @list:89:15)
    else::
        pass

    }


index1 > {test} (0 calls)
0: index1(xs:_(T) @list:148:19, idx:int @list:148:28, ?#result:T @list:148:1):
    [|](?x @list:149:7, ?xs @list:149:12, xs @list:149:18)
    (   =(idx @list:150:6, 0 @list:150:12)
    | (   -(idx @list:150:27, 1 @list:150:33, ?tmp#0 @list:150:27)
        & index1(xs @list:150:23, tmp#0, ?x @list:150:37)))
    foreign llvm move(x @list:148:41, ?#result @list:148:1)


length > public (0 calls)
0: length(x:_(T) @list:24:16, ?#result:int @list:24:5):
    length1(x @list:24:38, 0 @list:24:41, ?tmp#0 @list:24:30)
    foreign llvm move(tmp#0, ?#result @list:24:5)


length1 > (0 calls)
0: length1(x:_(T) @list:140:13, acc:int @list:140:21, ?#result:int @list:140:1):
    if {[|](?h @list:141:16, ?t @list:141:21, x @list:141:10)::

        +(acc @list:141:38, 1 @list:141:44, ?tmp#2 @list:141:38)
        length1(t @list:141:35, tmp#2, ?tmp#1 @list:141:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(acc @list:141:57, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:141:10, ?#result @list:140:1)


list > public (0 calls)
0: list(ar:array(T) @list:128:14, ?#result:_(T) @list:128:5):
    [](?tmp#0 @list:129:11)
    =(?ls @list:129:6, tmp#0)
    foreign llvm move(ar @list:130:15, ?tmp#1)
    do {
        if {[|](?x @list:130:10, ?tmp#1, tmp#1)::

            [|](x @list:131:16, ls @list:131:20, ?tmp#2 @list:131:15)
            =(?ls @list:131:10, tmp#2)
        else::
            break

        }
    }
    reverse(ls @list:133:13, ?ls @list:133:18)
    foreign llvm move(ls @list:128:34, ?#result @list:128:5)


map > public (0 calls)
0: map(f:{resource}(T) @list:41:13, xs:_(T) @list:41:30):
    foreign llvm move(xs @list:42:15, ?tmp#0)
    do {
        if {[|](?x @list:42:10, ?tmp#0, tmp#0)::

            !f(x @list:43:12)
        else::
            break

        }
    }
map > public (0 calls)
1: map(f:(A, ?B) @list:49:13, as:_(A) @list:49:24, ?#result:_(B) @list:49:5):
    if {[|](?a @list:50:12, ?as @list:50:17, as @list:50:23)::

        f(a @list:50:33, ?tmp#2 @list:50:31)
        map(f @list:50:42, as @list:50:45, ?tmp#3 @list:50:38)
        [|](tmp#2, tmp#3, ?tmp#1 @list:50:29)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:50:61)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:50:10, ?#result @list:49:5)
map > public (0 calls)
2: map(f:(A, B, ?C) @list:55:13, as:_(A) @list:55:27, bs:_(B) @list:55:36, ?#result:_(C) @list:55:5):
    if {(   [|](?a @list:56:12, ?as @list:56:17, as @list:56:23)
        & [|](?b @list:56:30, ?bs @list:56:35, bs @list:56:41))::

        f(a @list:56:51, b @list:56:54, ?tmp#2 @list:56:49)
        map(f @list:56:63, as @list:56:66, bs @list:56:70, ?tmp#3 @list:56:59)
        [|](tmp#2, tmp#3, ?tmp#1 @list:56:47)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:57:47)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:56:10, ?#result @list:55:5)


print > public (0 calls)
0: print(printer:{resource}(T) @list:108:15, xs:_(T) @list:108:38) use !io:
    !print('[' @list:109:12)
    if {[|](?x @list:110:12, ?xs @list:110:17, xs @list:110:23)::

        !printer(x @list:111:18)
        !print1(printer @list:112:17, xs @list:112:26)
    else::
        pass

    }
    !print(']' @list:114:12)


print1 > (0 calls)
0: print1(printer:{resource}(T) @list:154:12, xs:_(T) @list:154:35) use !io:
    if {[|](?x @list:155:12, ?xs @list:155:17, xs @list:155:23)::

        !print(',' @list:156:16)
        !printer(x @list:157:18)
        !print1(printer @list:158:17, xs @list:158:26)
    else::
        pass

    }


println > public (0 calls)
0: println(printer:{resource}(T) @list:119:17, xs:_(T) @list:119:40) use !io:
    !print(printer @list:120:12, xs @list:120:21)
    !nl


reverse > public (0 calls)
0: reverse(x:_(T) @list:27:17, ?#result:_(T) @list:27:5):
    [](?tmp#1 @list:27:44)
    reverse1(x @list:27:41, tmp#1, ?tmp#0 @list:27:32)
    foreign llvm move(tmp#0, ?#result @list:27:5)


reverse1 > (0 calls)
0: reverse1(x:_(T) @list:144:14, tail:_(T) @list:144:22, ?#result:_(T) @list:144:1):
    if {[|](?h @list:145:16, ?t @list:145:21, x @list:145:10)::

        [|](h @list:145:40, tail @list:145:44, ?tmp#2 @list:145:39)
        reverse1(t @list:145:36, tmp#2, ?tmp#1 @list:145:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(tail @list:145:61, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:145:10, ?#result @list:144:1)

LLVM code       : None

--------------------------------------------------
 Module wybe.machine_word
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.machine_word.word_size_bits<0>
                    wybe.machine_word.word_size_bytes<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

word_size_bits > public (0 calls)
0: word_size_bits(?#result:int @machine_word:12:5):
    word_size_bytes(?tmp#1 @machine_word:12:34)
    *(8 @machine_word:12:30, tmp#1, ?tmp#0 @machine_word:12:30)
    foreign llvm move(tmp#0, ?#result @machine_word:12:5)


word_size_bytes > public (0 calls)
0: word_size_bytes(?#result:int @machine_word:10:5):
    foreign llvm move(8 @machine_word:10:31, ?#result @machine_word:10:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.memory_management
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.memory_management.malloc_count<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

malloc_count > public {semipure} (0 calls)
0: malloc_count(?x:int @memory_management:11:34):
    foreign c {impure} malloc_count(?x @memory_management:12:38)

LLVM code       : None

--------------------------------------------------
 Module wybe.phantom
 modifiers       : {unique} 
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : 
  imports         : 
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.predicate
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.predicate.const<0>
                    wybe.predicate.id<0>
  imports         : 
  resources       : 
  procs           : 

const > public (0 calls)
0: const(a:A @predicate:8:15, b:B @predicate:8:20, ?#result:A @predicate:8:5):
    foreign llvm move(a:A @predicate:8:29, ?#result:A @predicate:8:5)


id > public (0 calls)
0: id(a:A @predicate:6:12, ?#result:A @predicate:6:5):
    foreign llvm move(a:A @predicate:6:21, ?#result:A @predicate:6:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.range
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.range...<0>
                    wybe.range.[]<0>
                    wybe.range.[|]<0>
                    wybe.range.irange<0>
                    wybe.range.size<0>
                    wybe.range.xrange<0>
  imports         : use wybe.bool
                    use wybe.int
  resources       : 
  procs           : 

.. > public (0 calls)
0: ..(start:int @range:38:10, end:int @range:38:23, ?#result:_ @range:38:5):
    if {<=(start @range:39:27, end @range:39:37)::

        foreign llvm move(1 @range:39:44, ?tmp#1)
    else::
        foreign llvm move(-1 @range:39:56, ?tmp#1)

    }
    construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)
    foreign llvm move(tmp#0, ?#result @range:38:5)


[] > public {test} (0 calls)
0: [](r:_ @range:20:19, idx:int @range:20:24, ?value:int @range:20:34):
    <=(0 @range:21:6, idx @range:21:12)
    range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)
    *(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)
    +(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)
    =(?value @range:23:6, tmp#0)
    if {<=(0 @range:24:10, stride @range:24:16)::

        <(value @range:24:27, end @range:24:35)
    else::
        <(end @range:24:51, value @range:24:57)

    }


[|] > public {test} (0 calls)
0: [|](?value:int @range:12:23, ?rest:_ @range:12:35, current:_ @range:12:43):
    range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)
    ~=(value @range:14:6, end @range:14:16)
    +(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)
    range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)
    =(?rest @range:15:6, tmp#0)


construct > (0 calls)
0: construct(start:int @range:49:15, stride:int @range:49:26, end:int @range:49:38, ?#result:_ @range:49:1):
    -(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)
    %(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)
    =(?diff @range:50:6, tmp#0)
    if {<=(0 @range:51:19, stride @range:51:25)::

        if {=(diff @range:52:26, 0 @range:52:33)::

            max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
            -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
            max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
            foreign llvm move(tmp#5, ?tmp#3)

        }
        foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
    else::
        if {=(diff @range:55:26, 0 @range:55:33)::

            min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
            foreign llvm move(tmp#9, ?tmp#8)
        else::
            +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
            min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
            foreign llvm move(tmp#10, ?tmp#8)

        }
        foreign llvm move(tmp#8 @range:55:26, ?tmp#2)

    }
    =(?final @range:51:6, tmp#2 @range:51:19)
    range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)
    =(?r @range:58:6, tmp#12)
    foreign llvm move(r @range:49:51, ?#result @range:49:1)


irange > public (0 calls)
0: irange(start:int @range:32:16, stride:int @range:32:27, end:int @range:32:39, ?#result:_ @range:32:5):
    if {<(stride @range:33:41, 0 @range:33:50)::

        foreign llvm move(-1 @range:33:55, ?tmp#2)
    else::
        foreign llvm move(1 @range:33:68, ?tmp#2)

    }
    +(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)
    construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)
    foreign llvm move(tmp#0, ?#result @range:32:5)


size > public (0 calls)
0: size(r:_ @range:42:14, ?#result:int @range:42:5):
    range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)
    if {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
        & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
        & signum(tmp#3, ?tmp#2 @range:44:29)
        & ~=(tmp#1, tmp#2))::

        foreign llvm move(0 @range:44:52, ?tmp#0)
    else::
        if {<=(0 @range:45:10, stride @range:45:16)::

            -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
            -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
            /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
            +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
            foreign llvm move(tmp#5, ?tmp#4)
        else::
            -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
            -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
            -(stride @range:46:39, ?tmp#13 @range:46:38)
            /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
            +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
            foreign llvm move(tmp#9, ?tmp#4)

        }
        foreign llvm move(tmp#4 @range:45:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)


xrange > public (0 calls)
0: xrange(start:int @range:28:16, stride:int @range:28:27, end:int @range:28:39, ?#result:_ @range:28:5):
    construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)
    foreign llvm move(tmp#0, ?#result @range:28:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.string
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.string.,,<0>
                    wybe.string.<<0>
                    wybe.string.<=<0>
                    wybe.string.<=><0>
                    wybe.string.=<0>
                    wybe.string.><0>
                    wybe.string.>=<0>
                    wybe.string.[]<0>
                    wybe.string.[]<1>
                    wybe.string.[|]<0>
                    wybe.string.c_string<0>
                    wybe.string.length<0>
                    wybe.string.print<0>
                    wybe.string.println<0>
                    wybe.string.read<0>
                    wybe.string.string<0>
                    wybe.string.string<1>
                    wybe.string.~=<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.char
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
                    use wybe.range
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_ @string:64:10, y:_ @string:64:17, ?#result:_ @string:64:5):
    if {(   empty(?tmp#1 @string:65:14)
        & =(x @string:65:10, tmp#1))::

        foreign llvm move(y @string:65:23, ?tmp#0)
    else::
        if {(   empty(?tmp#3 @string:66:14)
            & =(y @string:66:10, tmp#3))::

            foreign llvm move(x @string:66:23, ?tmp#2)
        else::
            concat(x @string:67:25, y @string:67:28, ?tmp#4 @string:67:18)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:66:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:65:10, ?#result @string:64:5)


< > public (0 calls)
0: <(x:_ @string:119:10, y:_ @string:119:17, ?#result:bool @string:119:5):
    <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
    equal(?tmp#2 @string:119:44)
    <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
    foreign llvm move(tmp#0, ?#result @string:119:5)


<= > public (0 calls)
0: <=(x:_ @string:120:10, y:_ @string:120:18, ?#result:bool @string:120:5):
    <=>(x @string:120:31, y @string:120:39, ?tmp#1 @string:120:31)
    equal(?tmp#2 @string:120:46)
    <=(tmp#1, tmp#2, ?tmp#0 @string:120:30)
    foreign llvm move(tmp#0, ?#result @string:120:5)


<=> > public (0 calls)
0: <=>(x:_ @string:125:10, y:_ @string:125:20, ?#result:comparison @string:125:5):
    equal(?tmp#0 @string:126:10)
    =(?c @string:126:6, tmp#0)
    foreign llvm move(x @string:127:16, ?tmp#1)
    foreign llvm move(y @string:127:26, ?tmp#2)
    do {
        if {[|](?cx @string:127:10, ?tmp#1, tmp#1)::

            if {[|](?cy @string:127:20, ?tmp#2, tmp#2)::

                if {<(cx @string:128:14, cy @string:128:19)::

                    lesser(?tmp#3 @string:128:30)
                    =(?c @string:128:26, tmp#3)
                    break
                else::
                    if {>(cx @string:129:14, cy @string:129:19)::

                        greater(?tmp#4 @string:129:30)
                        =(?c @string:129:26, tmp#4)
                        break
                    else::
                        pass

                    }

                }
            else::
                break

            }
        else::
            break

        }
    }
    if {(   equal(?tmp#5 @string:132:14)
        & =(c @string:132:10, tmp#5))::

        length(x @string:133:22, ?tmp#6 @string:133:15)
        =(?lx @string:133:10, tmp#6)
        length(y @string:134:22, ?tmp#7 @string:134:15)
        =(?ly @string:134:10, tmp#7)
        if {<(lx @string:135:14, ly @string:135:19)::

            lesser(?tmp#8 @string:135:30)
            =(?c @string:135:26, tmp#8)
        else::
            if {>(lx @string:135:39, ly @string:135:44)::

                greater(?tmp#9 @string:135:55)
                =(?c @string:135:51, tmp#9)
            else::
                pass

            }

        }
    else::
        pass

    }
    foreign llvm move(c @string:125:38, ?#result @string:125:5)


= > public (0 calls)
0: =(x:_ @string:115:10, y:_ @string:115:17, ?#result:bool @string:115:5):
    <=>(x @string:115:30, y @string:115:38, ?tmp#1 @string:115:30)
    equal(?tmp#2 @string:115:44)
    =(tmp#1, tmp#2, ?tmp#0 @string:115:29)
    foreign llvm move(tmp#0, ?#result @string:115:5)


> > public (0 calls)
0: >(x:_ @string:121:10, y:_ @string:121:17, ?#result:bool @string:121:5):
    <=>(x @string:121:30, y @string:121:38, ?tmp#1 @string:121:30)
    equal(?tmp#2 @string:121:44)
    >(tmp#1, tmp#2, ?tmp#0 @string:121:29)
    foreign llvm move(tmp#0, ?#result @string:121:5)


>= > public (0 calls)
0: >=(x:_ @string:122:10, y:_ @string:122:18, ?#result:bool @string:122:5):
    <=>(x @string:122:31, y @string:122:39, ?tmp#1 @string:122:31)
    equal(?tmp#2 @string:122:46)
    >=(tmp#1, tmp#2, ?tmp#0 @string:122:30)
    foreign llvm move(tmp#0, ?#result @string:122:5)


[] > public {test} (0 calls)
0: [](s:_ @string:91:19, idx:int @string:91:24, ?c:char @string:91:34):
    if {buffer(?len @string:93:17, ?str @string:93:23, s @string:92:10)::

        <=(0 @string:94:14, idx @string:94:20)
        <(idx @string:95:14, len @string:95:20)
        unsafe_c_string_index(str @string:96:35, idx @string:96:40, ?c @string:96:46)
    else::
        if {concat(?left @string:97:17, ?right @string:97:24, s @string:92:10)::

            length(left @string:98:32, ?tmp#0 @string:98:25)
            =(?left_len @string:98:14, tmp#0)
            if {<(idx @string:99:18, left_len @string:99:24)::

                [](left @string:99:41, idx @string:99:46, ?tmp#1 @string:99:41)
                =(?c @string:99:37, tmp#1)
            else::
                -(idx @string:100:37, left_len @string:100:43, ?tmp#3 @string:100:37)
                [](right @string:100:31, tmp#3, ?tmp#2 @string:100:31)
                =(?c @string:100:27, tmp#2)

            }
        else::
            if {slice(?base @string:102:16, ?range @string:102:23, s @string:92:10)::

                [](range @string:102:43, idx @string:102:49, ?tmp#5 @string:102:43)
                [](base @string:102:38, tmp#5, ?tmp#4 @string:102:38)
                =(?c @string:102:34, tmp#4)
            else::
                if {singleton(?c @string:103:20, s @string:92:10)::

                    =(idx @string:103:27, 0 @string:103:33)
                else::
                    fail

                }

            }

        }

    }
[] > public (0 calls)
1: [](s:_ @string:109:12, r:range @string:109:17, ?#result:_ @string:109:5):
    slice(s @string:109:36, r @string:109:39, ?tmp#0 @string:109:30)
    foreign llvm move(tmp#0, ?#result @string:109:5)


[|] > public {test} (0 calls)
0: [|](?head:char @string:71:23, ?tail:_ @string:71:35, s:_ @string:71:43):
    if {buffer(?len @string:73:17, ?str @string:73:23, s @string:72:10)::

        [|](?head @string:74:15, ?str @string:74:23, str @string:74:30)
        if {=(len @string:75:26, 1 @string:75:32)::

            empty(?tmp#1 @string:75:37)
            foreign llvm move(tmp#1, ?tmp#0)
        else::
            -(len @string:75:60, 1 @string:75:66, ?tmp#3 @string:75:60)
            buffer(tmp#3, str @string:75:69, ?tmp#2 @string:75:53)
            foreign llvm move(tmp#2, ?tmp#0)

        }
        =(?tail @string:75:14, tmp#0 @string:75:26)
    else::
        if {concat(?left @string:76:17, ?right @string:76:24, s @string:72:10)::

            if {[|](?head @string:77:20, ?t @string:77:28, left @string:77:33)::

                concat(t @string:77:56, right @string:77:59, ?tmp#4 @string:77:49)
                =(?tail @string:77:42, tmp#4)
            else::
                [|](?head @string:78:28, ?tail @string:78:36, right @string:78:44)

            }
        else::
            if {slice(?base @string:80:16, ?range @string:80:23, s @string:72:10)::

                do {
                    [|](?idx @string:82:19, ?range @string:82:26, range @string:82:35)
                    if {(   [](base @string:83:30, idx @string:83:35, ?tmp#5 @string:83:30)
                        & =(?head @string:83:23, tmp#5))::

                        slice(base @string:83:57, range @string:83:63, ?tmp#6 @string:83:51)
                        =(?tail @string:83:44, tmp#6)
                        break
                    else::
                        pass

                    }
                }
            else::
                if {singleton(?head @string:85:20, s @string:72:10)::

                    empty(?tmp#7 @string:85:37)
                    =(?tail @string:85:30, tmp#7)
                else::
                    fail

                }

            }

        }

    }


c_string > public (0 calls)
0: c_string(s:_ @string:40:18, ?#result:c_string @string:40:5):
    if {buffer(?tmp#0 @string:41:21, ?str @string:41:25, s @string:41:10)::

        pass
    else::
        length(s @string:43:27, ?tmp#2 @string:43:20)
        +(tmp#2, 1 @string:43:32, ?tmp#1 @string:43:20)
        =(?len @string:43:14, tmp#1)
        foreign lpvm alloc(len @string:44:32, ?str @string:44:38)
        true(?tmp#3 @string:45:49)
        foreign lpvm mutate(str @string:45:33, ?str @string:45:39, len @string:45:44, tmp#3, len @string:45:55, 0 @string:45:60, '\NUL' @string:45:63)
        =(?offset @string:46:14, 0 @string:46:23)
        pack(s @string:47:18, !str @string:47:22, len @string:47:27, !offset @string:47:33)

    }
    foreign llvm move(str @string:40:34, ?#result @string:40:5)


fixed_range_size > (0 calls)
0: fixed_range_size(hi:int @string:184:22, r:range @string:184:30, ?sz:int @string:184:40):
    range(?start @string:185:16, ?stride @string:185:24, ?end @string:185:33, r @string:185:5)
    if {<=(0 @string:186:10, stride @string:186:16)::

        -(start @string:187:39, ?tmp#4 @string:187:38)
        /(tmp#4, stride @string:187:47, ?tmp#3 @string:187:38)
        *(tmp#3, stride @string:187:56, ?tmp#2 @string:187:38)
        +(start @string:187:30, tmp#2, ?tmp#1 @string:187:30)
        max(start @string:187:23, tmp#1, ?tmp#0 @string:187:19)
        =(?lo @string:187:14, tmp#0)
        min(hi @string:188:23, end @string:188:27, ?tmp#5 @string:188:19)
        =(?hi @string:188:14, tmp#5)
    else::
        max(-1 @string:190:23, end @string:190:27, ?tmp#6 @string:190:19)
        =(?lo @string:190:14, tmp#6)
        +(hi @string:191:30, stride @string:191:35, ?tmp#10 @string:191:30)
        -(start @string:191:45, hi @string:191:53, ?tmp#13 @string:191:45)
        -(tmp#13, 1 @string:191:58, ?tmp#12 @string:191:45)
        -(stride @string:191:64, ?tmp#14 @string:191:63)
        %(tmp#12, tmp#14, ?tmp#11 @string:191:44)
        +(tmp#10, tmp#11, ?tmp#9 @string:191:30)
        +(tmp#9, 1 @string:191:73, ?tmp#8 @string:191:30)
        min(start @string:191:23, tmp#8, ?tmp#7 @string:191:19)
        =(?hi @string:191:14, tmp#7)
        -(stride @string:192:24, ?tmp#15 @string:192:23)
        =(?stride @string:192:14, tmp#15)

    }
    if {<=(hi @string:194:16, lo @string:194:23)::

        foreign llvm move(0 @string:194:29, ?tmp#16)
    else::
        -(hi @string:194:42, lo @string:194:47, ?tmp#20 @string:194:42)
        -(tmp#20, 1 @string:194:52, ?tmp#19 @string:194:42)
        /(tmp#19, stride @string:194:57, ?tmp#18 @string:194:41)
        +(tmp#18, 1 @string:194:66, ?tmp#17 @string:194:41)
        foreign llvm move(tmp#17, ?tmp#16)

    }
    =(?sz @string:194:6, tmp#16 @string:194:16)


length > public (0 calls)
0: length(s:_ @string:52:16, ?#result:int @string:52:5):
    if {buffer(?len @string:53:22, ?tmp#1 @string:53:27, s @string:53:10)::

        foreign llvm move(len @string:53:33, ?tmp#0)
    else::
        if {concat(?left @string:54:22, ?right @string:54:29, s @string:54:10)::

            length(left @string:54:46, ?tmp#4 @string:54:39)
            length(right @string:54:61, ?tmp#5 @string:54:54)
            +(tmp#4, tmp#5, ?tmp#3 @string:54:39)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            if {slice(?base @string:55:21, ?range @string:55:28, s @string:55:10)::

                length(base @string:55:62, ?tmp#8 @string:55:55)
                fixed_range_size(tmp#8, range @string:55:69, ?tmp#7 @string:55:38)
                foreign llvm move(tmp#7, ?tmp#6)
            else::
                if {singleton(?tmp#10 @string:56:24, s @string:56:10)::

                    foreign llvm move(1 @string:56:30, ?tmp#9)
                else::
                    foreign llvm move(0 @string:57:18, ?tmp#9)

                }
                foreign llvm move(tmp#9 @string:56:10, ?tmp#6)

            }
            foreign llvm move(tmp#6 @string:55:10, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:54:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:53:10, ?#result @string:52:5)


pack > (0 calls)
0: pack(s:_ @string:160:10, !raw:c_string @string:160:16, size:int @string:160:30, !offset:int @string:160:41):
    if {buffer(?tmp#0 @string:162:16, ?str @string:162:20, s @string:161:10)::

        foreign llvm move(str @string:163:23, ?tmp#1)
        do {
            if {[|](?c @string:163:18, ?tmp#1, tmp#1)::

                true(?tmp#2 @string:164:56)
                foreign lpvm mutate(raw @string:164:37, ?raw @string:164:43, offset @string:164:48, tmp#2, size @string:164:62, 0 @string:164:68, c @string:164:71)
                incr(!offset @string:165:23)
            else::
                break

            }
        }
    else::
        if {concat(?left @string:167:17, ?right @string:167:24, s @string:161:10)::

            pack(left @string:168:18, !raw @string:168:25, size @string:168:30, !offset @string:168:37)
            pack(right @string:169:18, !raw @string:169:26, size @string:169:31, !offset @string:169:38)
            incr(!offset @string:170:19)
        else::
            if {slice(?tmp#3 @string:171:15, ?tmp#4 @string:171:18, s @string:161:10)::

                foreign llvm move(s @string:172:23, ?tmp#5)
                do {
                    if {[|](?c @string:172:18, ?tmp#5, tmp#5)::

                        true(?tmp#6 @string:173:56)
                        foreign lpvm mutate(raw @string:173:37, ?raw @string:173:43, offset @string:173:48, tmp#6, size @string:173:62, 0 @string:173:68, c @string:173:71)
                        incr(!offset @string:174:23)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:176:20, s @string:161:10)::

                    true(?tmp#7 @string:177:52)
                    foreign lpvm mutate(raw @string:177:33, ?raw @string:177:39, offset @string:177:44, tmp#7, size @string:177:58, 0 @string:177:64, c @string:177:67)
                    incr(!offset @string:178:19)
                else::
                    fail

                }

            }

        }

    }


print > public (0 calls)
0: print(x:_ @string:142:15) use !io:
    if {buffer(?tmp#0 @string:144:16, ?str @string:144:20, x @string:143:10)::

        !print(str @string:144:35)
    else::
        if {concat(?left @string:145:17, ?right @string:145:24, x @string:143:10)::

            !print(left @string:145:41)
            !print(right @string:145:55)
        else::
            if {slice(?tmp#1 @string:146:15, ?tmp#2 @string:146:18, x @string:143:10)::

                foreign llvm move(x @string:146:34, ?tmp#3)
                do {
                    if {[|](?c @string:146:29, ?tmp#3, tmp#3)::

                        !print(c @string:146:45)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:147:20, x @string:143:10)::

                    !print(c @string:147:33)
                else::
                    fail

                }

            }

        }

    }


println > public (0 calls)
0: println(x:_ @string:151:17) use !io:
    !print(x @string:151:39)
    !nl


read > public (0 calls)
0: read(?x:_ @string:153:15) use !io:
    !read(?str:c_string @string:153:37)
    string(str @string:153:64, ?tmp#0 @string:153:57)
    =(?x @string:153:53, tmp#0)


string > public (0 calls)
0: string(str:c_string @string:28:16, ?#result:_ @string:28:5):
    length(str @string:29:19, ?tmp#0 @string:29:12)
    =(?len @string:29:6, tmp#0)
    if {=(len @string:30:15, 0 @string:30:21)::

        empty(?tmp#2 @string:30:26)
        foreign llvm move(tmp#2, ?tmp#1)
    else::
        if {=(len @string:31:15, 1 @string:31:21)::

            foreign lpvm access(str @string:31:56, 0 @string:31:61, 1 @string:31:64, 0 @string:31:67, ?tmp#5 @string:31:36)
            singleton(tmp#5, ?tmp#4 @string:31:26)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            buffer(len @string:32:33, str @string:32:38, ?tmp#6 @string:32:26)
            foreign llvm move(tmp#6, ?tmp#3)

        }
        foreign llvm move(tmp#3 @string:31:15, ?tmp#1)

    }
    =(?s @string:30:6, tmp#1 @string:30:15)
    foreign llvm move(s @string:28:34, ?#result @string:28:5)
string > public (0 calls)
1: string(c:char @string:37:16, ?#result:_ @string:37:5):
    singleton(c @string:37:38, ?tmp#0 @string:37:28)
    foreign llvm move(tmp#0, ?#result @string:37:5)


~= > public (0 calls)
0: ~=(x:_ @string:116:10, y:_ @string:116:18, ?#result:bool @string:116:5):
    <=>(x @string:116:31, y @string:116:39, ?tmp#1 @string:116:31)
    equal(?tmp#2 @string:116:46)
    ~=(tmp#1, tmp#2, ?tmp#0 @string:116:30)
    foreign llvm move(tmp#0, ?#result @string:116:5)

LLVM code       : None

======================================================================
AFTER FLATTENING:
 Module wybe
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : 
  imports         : public use wybe.array
                    public use wybe.bool
                    public use wybe.c_string
                    public use wybe.char
                    public use wybe.comparison
                    public use wybe.control
                    public use wybe.count
                    public use wybe.float
                    public use wybe.int
                    public use wybe.io
                    public use wybe.list
                    public use wybe.machine_word
                    public use wybe.memory_management
                    public use wybe.phantom
                    public use wybe.predicate
                    public use wybe.range
                    public use wybe.string
  resources       : 
  submodules      : wybe.array, wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.control, wybe.count, wybe.float, wybe.int, wybe.io, wybe.list, wybe.machine_word, wybe.memory_management, wybe.phantom, wybe.predicate, wybe.range, wybe.string
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.array(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.array.[]<0>
                    wybe.array.[]<1>
                    wybe.array.[|]<0>
                    wybe.array.array<0>
                    wybe.array.array<1>
                    wybe.array.inbounds<0>
                    wybe.array.unsafe_get<0>
                    wybe.array.unsafe_update<0>
  imports         : public use wybe.array.raw_array
                    use wybe.bool
                    use wybe.int
                    use wybe.list
                    use wybe.machine_word
  resources       : 
  submodules      : wybe.array.raw_array
  procs           : 

[] > public {test} (0 calls)
0: [](a:_(T) @array:67:21, idx:int @array:67:29, ?#result:T @array:67:5):
    inbounds(a @array:68:14, idx @array:68:17)
    unsafe_get(a @array:69:10, idx @array:69:23, ?tmp#0 @array:69:10)
    =(?x @array:69:6, tmp#0)
    foreign llvm move(x @array:67:42, ?#result @array:67:5)
[] > public {test} (0 calls)
1: [](!a:_(T) @array:81:22, idx:int @array:81:30, x:T @array:81:39):
    inbounds(a @array:82:14, idx @array:82:17)
    unsafe_update(!a @array:83:20, idx @array:83:23, x @array:83:28)


[|] > public {test} (0 calls)
0: [|](?head:T @array:51:23, ?tail:_(T) @array:51:32, a:_(T) @array:51:43):
    array(?length @array:52:12, ?data @array:52:21, a @array:52:29)
    >(length @array:53:6, 0 @array:53:15)
    word_size_bytes(?tmp#0 @array:54:34)
    foreign lpvm access(data @array:54:25, 0 @array:54:31, tmp#0, 0 @array:54:51, ?head @array:54:55)
    word_size_bytes(?tmp#1 @array:55:28)
    foreign llvm add(data @array:55:22, tmp#1, ?data @array:55:46)
    -(length @array:56:19, 1 @array:56:28, ?tmp#3 @array:56:19)
    array(tmp#3, data @array:56:31, ?tmp#2 @array:56:13)
    =(?tail @array:56:6, tmp#2)


array > public (0 calls)
0: array(x:T @array:18:15, len:int @array:18:20, ?#result:_(T) @array:18:5):
    word_size_bytes(?tmp#1 @array:19:19)
    *(len @array:19:13, tmp#1, ?tmp#0 @array:19:13)
    =(?size @array:19:6, tmp#0)
    foreign lpvm alloc(size @array:20:24, ?data @array:20:31)
    =(?offset @array:21:6, 0 @array:21:15)
    do {
        if {<(offset @array:23:15, size @array:23:24)::

            pass
        else::
            break

        }
        foreign lpvm mutate(data @array:24:29, ?data @array:24:36, offset @array:24:42, 1 @array:24:50, size @array:24:53, 0 @array:24:59, x @array:24:62)
        word_size_bytes(?tmp#2 @array:25:21)
        +=(!offset @array:25:10, tmp#2)
    }
    array(len @array:27:17, data @array:27:22, ?tmp#3 @array:27:11)
    =(?ar @array:27:6, tmp#3)
    foreign llvm move(ar @array:18:36, ?#result @array:18:5)
array > public (0 calls)
1: array(ls:list(T) @array:34:15, ?#result:_(T) @array:34:5):
    length(ls @array:35:19, ?tmp#0 @array:35:12)
    =(?len @array:35:6, tmp#0)
    word_size_bytes(?tmp#2 @array:36:19)
    *(len @array:36:13, tmp#2, ?tmp#1 @array:36:13)
    =(?size @array:36:6, tmp#1)
    foreign lpvm alloc(size @array:37:24, ?data @array:37:31)
    =(?offset @array:38:6, 0 @array:38:15)
    foreign llvm move(ls @array:39:15, ?tmp#3)
    do {
        if {[|](?x @array:39:10, ?tmp#3, tmp#3)::

            foreign lpvm mutate(data @array:40:29, ?data @array:40:36, offset @array:40:42, 1 @array:40:50, size @array:40:53, 0 @array:40:59, x @array:40:62)
            word_size_bytes(?tmp#4 @array:41:21)
            +=(!offset @array:41:10, tmp#4)
        else::
            break

        }
    }
    array(len @array:43:17, data @array:43:22, ?tmp#5 @array:43:11)
    =(?ar @array:43:6, tmp#5)
    foreign llvm move(ar @array:34:34, ?#result @array:34:5)


inbounds > public {test,inline} (0 calls)
0: inbounds(a:_(T) @array:60:33, idx:int @array:60:41):
    <=(0 @array:61:6, idx @array:61:12)
    length(a @array:62:12, ?tmp#0 @array:62:12)
    <(idx @array:62:6, tmp#0)


unsafe_get > public {inline} (0 calls)
0: unsafe_get(a:_(T) @array:75:29, idx:int @array:75:37, ?#result:T @array:75:5):
    raw_data(a @array:76:25, ?tmp#0 @array:76:25)
    word_size_bytes(?tmp#2 @array:76:43)
    *(idx @array:76:37, tmp#2, ?tmp#1 @array:76:37)
    word_size_bytes(?tmp#3 @array:76:60)
    foreign lpvm access(tmp#0, tmp#1, tmp#3, 0 @array:76:77, ?x @array:76:81)
    foreign llvm move(x @array:75:50, ?#result @array:75:5)


unsafe_update > public {inline} (0 calls)
0: unsafe_update(!a:_(T) @array:89:33, idx:int @array:89:41, x:T @array:89:50):
    raw_data(a @array:90:25, ?tmp#0 @array:90:25)
    word_size_bytes(?tmp#2 @array:90:50)
    *(idx @array:90:44, tmp#2, ?tmp#1 @array:90:44)
    length(a @array:91:44, ?tmp#4 @array:91:44)
    word_size_bytes(?tmp#5 @array:91:55)
    *(tmp#4, tmp#5, ?tmp#3 @array:91:44)
    foreign lpvm mutate(tmp#0, ?data @array:90:38, tmp#1, 0 @array:90:67, tmp#3, 0 @array:91:72, x @array:91:75)
    raw_data(!a @array:92:6, data @array:92:19)

LLVM code       : None

--------------------------------------------------
 Module wybe.array.raw_array(T)
  representation  : address
  public submods  : 
  public resources: 
  public procs    : 
  imports         : use wybe
                    use wybe.array
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.bool
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.bool.&&<0>
                    wybe.bool.&=<0>
                    wybe.bool.=<0>
                    wybe.bool.^=<0>
                    wybe.bool.^^<0>
                    wybe.bool.print<0>
                    wybe.bool.println<0>
                    wybe.bool.succeed<0>
                    wybe.bool.|=<0>
                    wybe.bool.||<0>
                    wybe.bool.~<0>
                    wybe.bool.~=<0>
  imports         : use wybe.c_string
                    use wybe.io
  resources       : 
  procs           : 

&& > public (0 calls)
0: &&(p:_ @bool:13:10, q:_ @bool:13:18, ?#result:_ @bool:13:5):
    foreign llvm and(p @bool:13:44, q @bool:13:47, ?tmp#0 @bool:13:27)
    foreign llvm move(tmp#0, ?#result @bool:13:5)


&= > public (0 calls)
0: &=(!p:_ @bool:16:11, q:_ @bool:16:19):
    &&(p @bool:16:32, q @bool:16:38, ?tmp#0 @bool:16:32)
    =(?p @bool:16:27, tmp#0)


= > public (0 calls)
0: =(x:_ @bool:37:10, y:_ @bool:37:17, ?#result:_ @bool:37:5):
    foreign llvm icmp_eq(x @bool:37:47, y @bool:37:50, ?tmp#0 @bool:37:26)
    foreign llvm move(tmp#0, ?#result @bool:37:5)


^= > public (0 calls)
0: ^=(!p:_ @bool:28:11, q:_ @bool:28:19):
    ^^(q @bool:28:31, p @bool:28:37, ?tmp#0 @bool:28:31)
    =(?p @bool:28:27, tmp#0)


^^ > public (0 calls)
0: ^^(p:_ @bool:25:10, q:_ @bool:25:18, ?#result:_ @bool:25:5):
    foreign llvm xor(p @bool:25:44, q @bool:25:47, ?tmp#0 @bool:25:27)
    foreign llvm move(tmp#0, ?#result @bool:25:5)


print > public (0 calls)
0: print(x:_ @bool:47:15) use !io:
    if {x::

        foreign llvm move(c"true" @bool:47:45, ?tmp#0)
    else::
        foreign llvm move(c"false" @bool:47:60, ?tmp#0)

    }
    !print(tmp#0 @bool:47:41)


println > public (0 calls)
0: println(x:_ @bool:49:17) use !io:
    !print(x @bool:49:39)
    !nl


succeed > public (0 calls)
0: succeed():
    pass


|= > public (0 calls)
0: |=(!p:_ @bool:22:11, q:_ @bool:22:19):
    ||(p @bool:22:32, q @bool:22:38, ?tmp#0 @bool:22:32)
    =(?p @bool:22:27, tmp#0)


|| > public (0 calls)
0: ||(p:_ @bool:19:10, q:_ @bool:19:18, ?#result:_ @bool:19:5):
    foreign llvm or(p @bool:19:43, q @bool:19:46, ?tmp#0 @bool:19:27)
    foreign llvm move(tmp#0, ?#result @bool:19:5)


~ > public (0 calls)
0: ~(p:_ @bool:31:11, ?#result:_ @bool:31:5):
    true(?tmp#1 @bool:31:40)
    foreign llvm xor(p @bool:31:37, tmp#1, ?tmp#0 @bool:31:20)
    foreign llvm move(tmp#0, ?#result @bool:31:5)


~= > public (0 calls)
0: ~=(x:_ @bool:38:10, y:_ @bool:38:18, ?#result:_ @bool:38:5):
    foreign llvm icmp_ne(x @bool:38:48, y @bool:38:51, ?tmp#0 @bool:38:27)
    foreign llvm move(tmp#0, ?#result @bool:38:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.c_string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.c_string.<<0>
                    wybe.c_string.<=<0>
                    wybe.c_string.=<0>
                    wybe.c_string.><0>
                    wybe.c_string.>=<0>
                    wybe.c_string.[]<0>
                    wybe.c_string.[|]<0>
                    wybe.c_string.length<0>
                    wybe.c_string.print<0>
                    wybe.c_string.println<0>
                    wybe.c_string.read<0>
                    wybe.c_string.unsafe_c_string_index<0>
                    wybe.c_string.~=<0>
  imports         : use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:_ @c_string:12:10, y:_ @c_string:12:17, ?#result:bool @c_string:12:5):
    foreign c strcmp(x @c_string:12:46, y @c_string:12:48, ?tmp#1:int @c_string:12:29)
    <(tmp#1:int, 0 @c_string:12:57, ?tmp#0 @c_string:12:29)
    foreign llvm move(tmp#0, ?#result @c_string:12:5)


<= > public (0 calls)
0: <=(x:_ @c_string:13:10, y:_ @c_string:13:18, ?#result:bool @c_string:13:5):
    foreign c strcmp(x @c_string:13:47, y @c_string:13:49, ?tmp#1:int @c_string:13:30)
    <=(tmp#1:int, 0 @c_string:13:60, ?tmp#0 @c_string:13:30)
    foreign llvm move(tmp#0, ?#result @c_string:13:5)


= > public (0 calls)
0: =(x:_ @c_string:10:10, y:_ @c_string:10:17, ?#result:bool @c_string:10:5):
    foreign c strcmp(x @c_string:10:46, y @c_string:10:48, ?tmp#1:int @c_string:10:29)
    =(tmp#1:int, 0 @c_string:10:57, ?tmp#0 @c_string:10:29)
    foreign llvm move(tmp#0, ?#result @c_string:10:5)


> > public (0 calls)
0: >(x:_ @c_string:14:10, y:_ @c_string:14:17, ?#result:bool @c_string:14:5):
    foreign c strcmp(x @c_string:14:46, y @c_string:14:48, ?tmp#1:int @c_string:14:29)
    >(tmp#1:int, 0 @c_string:14:57, ?tmp#0 @c_string:14:29)
    foreign llvm move(tmp#0, ?#result @c_string:14:5)


>= > public (0 calls)
0: >=(x:_ @c_string:15:10, y:_ @c_string:15:18, ?#result:bool @c_string:15:5):
    foreign c strcmp(x @c_string:15:47, y @c_string:15:49, ?tmp#1:int @c_string:15:30)
    >=(tmp#1:int, 0 @c_string:15:60, ?tmp#0 @c_string:15:30)
    foreign llvm move(tmp#0, ?#result @c_string:15:5)


[] > public {test} (0 calls)
0: [](str:_ @c_string:26:19, idx:int @c_string:26:26, ?#result:char @c_string:26:5):
    <=(0 @c_string:27:6, idx @c_string:27:12)
    length(str @c_string:28:19, ?tmp#0 @c_string:28:12)
    <(idx @c_string:28:6, tmp#0)
    unsafe_c_string_index(str @c_string:29:32, idx @c_string:29:37, ?tmp#1 @c_string:29:10)
    =(?c @c_string:29:6, tmp#1)
    foreign llvm move(c @c_string:26:42, ?#result @c_string:26:5)


[|] > public {test} (0 calls)
0: [|](?head:char @c_string:19:23, ?tail:_ @c_string:19:35, str:_ @c_string:19:43):
    foreign lpvm access(str @c_string:20:25, 0 @c_string:20:30, 0 @c_string:20:33, 0 @c_string:20:36, ?head @c_string:20:40)
    foreign llvm icmp_ne(head @c_string:21:26, '\NUL' @c_string:21:32, ?not_done @c_string:21:37)
    true(?tmp#0 @c_string:22:17)
    =(not_done @c_string:22:6, tmp#0)
    foreign llvm add(str @c_string:23:22, 1 @c_string:23:27, ?tail @c_string:23:31)


length > public (0 calls)
0: length(str:_ @c_string:17:16, ?#result:int @c_string:17:5):
    foreign c strlen(str @c_string:17:46, ?tmp#0 @c_string:17:29)
    foreign llvm move(tmp#0, ?#result @c_string:17:5)


print > public (0 calls)
0: print(x:_ @c_string:35:15) use !io:
    foreign c print_string(x @c_string:35:53, !io @c_string:35:57)


println > public (0 calls)
0: println(x:_ @c_string:37:17) use !io:
    !print(x @c_string:37:39)
    !nl


read > public (0 calls)
0: read(?x:_ @c_string:39:15) use !io:
    foreign c read_line(?x @c_string:39:51, !io @c_string:39:55)


unsafe_c_string_index > public (0 calls)
0: unsafe_c_string_index(str:_ @c_string:32:31, idx:int @c_string:32:38, ?#result:char @c_string:32:5):
    foreign lpvm access(str @c_string:33:27, idx @c_string:33:32, 1 @c_string:33:37, 0 @c_string:33:40, ?tmp#0 @c_string:33:7)
    foreign llvm move(tmp#0, ?#result @c_string:32:5)


~= > public (0 calls)
0: ~=(x:_ @c_string:11:10, y:_ @c_string:11:18, ?#result:bool @c_string:11:5):
    foreign c strcmp(x @c_string:11:47, y @c_string:11:49, ?tmp#1:int @c_string:11:30)
    ~=(tmp#1:int, 0 @c_string:11:60, ?tmp#0 @c_string:11:30)
    foreign llvm move(tmp#0, ?#result @c_string:11:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.char
  representation  : 8 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.char.<<0>
                    wybe.char.<=<0>
                    wybe.char.<=><0>
                    wybe.char.=<0>
                    wybe.char.><0>
                    wybe.char.>=<0>
                    wybe.char.chr<0>
                    wybe.char.ord<0>
                    wybe.char.print<0>
                    wybe.char.println<0>
                    wybe.char.read<0>
                    wybe.char.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:_ @char:17:10, y:_ @char:17:17, ?#result:bool @char:17:5):
    foreign llvm icmp_ult(x @char:17:51, y @char:17:54, ?tmp#0 @char:17:29)
    foreign llvm move(tmp#0, ?#result @char:17:5)


<= > public (0 calls)
0: <=(x:_ @char:18:10, y:_ @char:18:18, ?#result:bool @char:18:5):
    foreign llvm icmp_ule(x @char:18:52, y @char:18:55, ?tmp#0 @char:18:30)
    foreign llvm move(tmp#0, ?#result @char:18:5)


<=> > public (0 calls)
0: <=>(x:_ @char:23:10, y:_ @char:23:20, ?#result:comparison @char:23:5):
    if {<(x @char:24:10, y @char:24:14)::

        lesser(?tmp#1 @char:24:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @char:24:28, y @char:24:32)::

            equal(?tmp#3 @char:24:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @char:24:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @char:24:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @char:24:10, ?#result @char:23:5)


= > public (0 calls)
0: =(x:_ @char:13:10, y:_ @char:13:17, ?#result:bool @char:13:5):
    foreign llvm icmp_eq(x @char:13:50, y @char:13:53, ?tmp#0 @char:13:29)
    foreign llvm move(tmp#0, ?#result @char:13:5)


> > public (0 calls)
0: >(x:_ @char:19:10, y:_ @char:19:17, ?#result:bool @char:19:5):
    foreign llvm icmp_ugt(x @char:19:51, y @char:19:54, ?tmp#0 @char:19:29)
    foreign llvm move(tmp#0, ?#result @char:19:5)


>= > public (0 calls)
0: >=(x:_ @char:20:10, y:_ @char:20:18, ?#result:bool @char:20:5):
    foreign llvm icmp_uge(x @char:20:52, y @char:20:55, ?tmp#0 @char:20:30)
    foreign llvm move(tmp#0, ?#result @char:20:5)


chr > public {test} (0 calls)
0: chr(i:int @char:33:20, ?#result:_ @char:33:5):
    <=(0 @char:33:60, i @char:33:66)
    <=(i @char:33:70, 255 @char:33:76)
    foreign lpvm cast(i @char:33:49, ?tmp#0 @char:33:31)
    foreign llvm move(tmp#0, ?#result @char:33:5)


ord > public (0 calls)
0: ord(c:_ @char:30:13, ?#result:int @char:30:5):
    foreign lpvm cast(c @char:30:42, ?tmp#0 @char:30:24)
    foreign llvm move(tmp#0, ?#result @char:30:5)


print > public (0 calls)
0: print(x:_ @char:37:15) use !io:
    foreign c putchar(x @char:37:48, !io @char:37:52)


println > public (0 calls)
0: println(x:_ @char:39:17) use !io:
    !print(x @char:39:39)
    !nl


read > public (0 calls)
0: read(?x:_ @char:41:15) use !io:
    foreign c read_char(?x @char:41:51, !io @char:41:55)


~= > public (0 calls)
0: ~=(x:_ @char:14:10, y:_ @char:14:18, ?#result:bool @char:14:5):
    foreign llvm icmp_ne(x @char:14:51, y @char:14:54, ?tmp#0 @char:14:30)
    foreign llvm move(tmp#0, ?#result @char:14:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.comparison
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.comparison.<<0>
                    wybe.comparison.<=<0>
                    wybe.comparison.=<0>
                    wybe.comparison.><0>
                    wybe.comparison.>=<0>
                    wybe.comparison.~=<0>
  imports         : use wybe.bool
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:_ @comparison:12:10, y:_ @comparison:12:17, ?#result:bool @comparison:12:5):
    foreign llvm icmp_ult(x @comparison:12:51, y @comparison:12:54, ?tmp#0 @comparison:12:29)
    foreign llvm move(tmp#0, ?#result @comparison:12:5)


<= > public (0 calls)
0: <=(x:_ @comparison:13:10, y:_ @comparison:13:18, ?#result:bool @comparison:13:5):
    foreign llvm icmp_ule(x @comparison:13:52, y @comparison:13:55, ?tmp#0 @comparison:13:30)
    foreign llvm move(tmp#0, ?#result @comparison:13:5)


= > public (0 calls)
0: =(x:_ @comparison:10:10, y:_ @comparison:10:17, ?#result:bool @comparison:10:5):
    foreign llvm icmp_eq(x @comparison:10:50, y @comparison:10:53, ?tmp#0 @comparison:10:29)
    foreign llvm move(tmp#0, ?#result @comparison:10:5)


> > public (0 calls)
0: >(x:_ @comparison:14:10, y:_ @comparison:14:17, ?#result:bool @comparison:14:5):
    foreign llvm icmp_ugt(x @comparison:14:51, y @comparison:14:54, ?tmp#0 @comparison:14:29)
    foreign llvm move(tmp#0, ?#result @comparison:14:5)


>= > public (0 calls)
0: >=(x:_ @comparison:15:10, y:_ @comparison:15:18, ?#result:bool @comparison:15:5):
    foreign llvm icmp_uge(x @comparison:15:52, y @comparison:15:55, ?tmp#0 @comparison:15:30)
    foreign llvm move(tmp#0, ?#result @comparison:15:5)


~= > public (0 calls)
0: ~=(x:_ @comparison:11:10, y:_ @comparison:11:18, ?#result:bool @comparison:11:5):
    foreign llvm icmp_ne(x @comparison:11:51, y @comparison:11:54, ?tmp#0 @comparison:11:30)
    foreign llvm move(tmp#0, ?#result @comparison:11:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.control
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.control.assert<0>
                    wybe.control.error<0>
                    wybe.control.error<1>
                    wybe.control.exit<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.int
                    use wybe.string
  resources       : 
  procs           : 

assert > public {semipure} (0 calls)
0: assert(condition:bool @control:26:27) use call_source_location:
    if {~(condition @control:27:11)::

        !error(c"assertion failed" @control:27:31)
    else::
        pass

    }


error > public {terminal,semipure} (0 calls)
0: error(message:string @control:17:35) use call_source_location:
    c_string(message @control:18:77, ?tmp#0 @control:18:68)
    foreign c {terminal,semipure} error_exit(call_source_location @control:18:46, tmp#0)
error > public {terminal,semipure} (0 calls)
1: error(message:c_string @control:21:35) use call_source_location:
    foreign c {terminal,semipure} error_exit(call_source_location @control:22:46, message @control:22:68)


exit > public {terminal,semipure} (0 calls)
0: exit(code:int @control:10:34):
    foreign c {terminal,semipure} exit(code @control:11:40)

LLVM code       : None

--------------------------------------------------
 Module wybe.count
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.count.%<0>
                    wybe.count.%=<0>
                    wybe.count.*<0>
                    wybe.count.*=<0>
                    wybe.count.+<0>
                    wybe.count.+<1>
                    wybe.count.+<2>
                    wybe.count.+=<0>
                    wybe.count.-<0>
                    wybe.count.-<1>
                    wybe.count.-<2>
                    wybe.count.-=<0>
                    wybe.count./<0>
                    wybe.count./=<0>
                    wybe.count.<<0>
                    wybe.count.<=<0>
                    wybe.count.<=><0>
                    wybe.count.=<0>
                    wybe.count.><0>
                    wybe.count.>=<0>
                    wybe.count.decr<0>
                    wybe.count.incr<0>
                    wybe.count.max<0>
                    wybe.count.min<0>
                    wybe.count.print<0>
                    wybe.count.println<0>
                    wybe.count.read<0>
                    wybe.count.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public (0 calls)
0: %(x:_ @count:51:10, y:_ @count:51:16, ?#result:_ @count:51:5):
    foreign llvm urem(x @count:51:43, y @count:51:45, ?tmp#0 @count:51:25)
    foreign llvm move(tmp#0, ?#result @count:51:5)


%= > public (0 calls)
0: %=(!x:_ @count:54:11, y:_ @count:54:19):
    %(x @count:54:31, y @count:54:35, ?tmp#0 @count:54:31)
    =(?x @count:54:27, tmp#0)


* > public (0 calls)
0: *(x:_ @count:39:10, y:_ @count:39:16, ?#result:_ @count:39:5):
    foreign llvm mul(x @count:39:42, y @count:39:44, ?tmp#0 @count:39:25)
    foreign llvm move(tmp#0, ?#result @count:39:5)


*= > public (0 calls)
0: *=(!x:_ @count:42:11, y:_ @count:42:19):
    *(x @count:42:31, y @count:42:35, ?tmp#0 @count:42:31)
    =(?x @count:42:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @count:15:10, y:_ @count:15:16, ?#result:_ @count:15:5):
    foreign llvm add(x @count:15:42, y @count:15:44, ?tmp#0 @count:15:25)
    foreign llvm move(tmp#0, ?#result @count:15:5)
+ > public {test} (0 calls)
1: +(?x:_ @count:16:21, y:_ @count:16:27, z:_ @count:16:5):
    >=(z @count:17:5, y @count:17:11)
    foreign llvm sub(z @count:18:27, y @count:18:29, ?tmp#0 @count:18:10)
    =(?x @count:18:6, tmp#0)
+ > public {test} (0 calls)
2: +(x:_ @count:20:20, ?y:_ @count:20:27, z:_ @count:20:5):
    >=(z @count:21:5, x @count:21:11)
    foreign llvm sub(z @count:22:27, x @count:22:29, ?tmp#0 @count:22:10)
    =(?y @count:22:6, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @count:26:11, y:_ @count:26:19):
    +(x @count:26:31, y @count:26:35, ?tmp#0 @count:26:31)
    =(?x @count:26:27, tmp#0)


- > public {test} (0 calls)
0: -(x:_ @count:31:20, y:_ @count:31:26, ?#result:_ @count:31:5):
    >=(y @count:31:65, x @count:31:71)
    foreign llvm sub(x @count:31:52, y @count:31:54, ?tmp#0 @count:31:35)
    foreign llvm move(tmp#0, ?#result @count:31:5)
- > public (0 calls)
1: -(?x:_ @count:32:11, y:_ @count:32:17, z:_ @count:32:5):
    foreign llvm add(z @count:32:59, y @count:32:61, ?tmp#0 @count:32:42)
    =(?x @count:32:38, tmp#0)
- > public (0 calls)
2: -(x:_ @count:33:10, ?y:_ @count:33:17, z:_ @count:33:5):
    foreign llvm sub(z @count:33:59, x @count:33:61, ?tmp#0 @count:33:42)
    =(?y @count:33:38, tmp#0)


-= > public {test} (0 calls)
0: -=(!x:_ @count:36:21, y:_ @count:36:29):
    -(x @count:36:41, y @count:36:45, ?tmp#0 @count:36:41)
    =(?x @count:36:37, tmp#0)


/ > public (0 calls)
0: /(x:_ @count:45:10, y:_ @count:45:16, ?#result:_ @count:45:5):
    foreign llvm udiv(x @count:45:43, y @count:45:45, ?tmp#0 @count:45:25)
    foreign llvm move(tmp#0, ?#result @count:45:5)


/= > public (0 calls)
0: /=(!x:_ @count:48:11, y:_ @count:48:19):
    /(x @count:48:31, y @count:48:35, ?tmp#0 @count:48:31)
    =(?x @count:48:27, tmp#0)


< > public (0 calls)
0: <(x:_ @count:64:10, y:_ @count:64:17, ?#result:bool @count:64:5):
    foreign llvm icmp_ult(x @count:64:51, y @count:64:53, ?tmp#0 @count:64:29)
    foreign llvm move(tmp#0, ?#result @count:64:5)


<= > public (0 calls)
0: <=(x:_ @count:65:10, y:_ @count:65:18, ?#result:bool @count:65:5):
    foreign llvm icmp_ule(x @count:65:52, y @count:65:54, ?tmp#0 @count:65:30)
    foreign llvm move(tmp#0, ?#result @count:65:5)


<=> > public (0 calls)
0: <=>(x:_ @count:70:10, y:_ @count:70:20, ?#result:comparison @count:70:5):
    if {<(x @count:71:10, y @count:71:14)::

        lesser(?tmp#1 @count:71:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @count:71:28, y @count:71:32)::

            equal(?tmp#3 @count:71:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @count:71:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @count:71:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:71:10, ?#result @count:70:5)


= > public (0 calls)
0: =(x:_ @count:60:10, y:_ @count:60:17, ?#result:bool @count:60:5):
    foreign llvm icmp_eq(x @count:60:50, y @count:60:52, ?tmp#0 @count:60:29)
    foreign llvm move(tmp#0, ?#result @count:60:5)


> > public (0 calls)
0: >(x:_ @count:66:10, y:_ @count:66:17, ?#result:bool @count:66:5):
    foreign llvm icmp_ugt(x @count:66:51, y @count:66:53, ?tmp#0 @count:66:29)
    foreign llvm move(tmp#0, ?#result @count:66:5)


>= > public (0 calls)
0: >=(x:_ @count:67:10, y:_ @count:67:18, ?#result:bool @count:67:5):
    foreign llvm icmp_uge(x @count:67:52, y @count:67:54, ?tmp#0 @count:67:30)
    foreign llvm move(tmp#0, ?#result @count:67:5)


decr > public {test} (0 calls)
0: decr(!x:_ @count:84:25):
    -(x @count:84:37, 1:_ @count:84:41, ?tmp#0 @count:84:37)
    =(?x @count:84:33, tmp#0)


incr > public (0 calls)
0: incr(!x:_ @count:81:15):
    +(x @count:81:27, 1:_ @count:81:31, ?tmp#0 @count:81:27)
    =(?x @count:81:23, tmp#0)


max > public (0 calls)
0: max(x:_ @count:75:13, y:_ @count:75:18, ?#result:_ @count:75:5):
    if {>=(x @count:75:31, y @count:75:35)::

        foreign llvm move(x @count:75:39, ?tmp#0)
    else::
        foreign llvm move(y @count:75:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:75:31, ?#result @count:75:5)


min > public (0 calls)
0: min(x:_ @count:74:13, y:_ @count:74:18, ?#result:_ @count:74:5):
    if {<=(x @count:74:31, y @count:74:35)::

        foreign llvm move(x @count:74:39, ?tmp#0)
    else::
        foreign llvm move(y @count:74:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:74:31, ?#result @count:74:5)


print > public (0 calls)
0: print(x:_ @count:88:15) use !io:
    foreign c print_count(x @count:88:52, !io @count:88:56)


println > public (0 calls)
0: println(x:_ @count:90:17) use !io:
    !print(x @count:90:39)
    !nl


read > public (0 calls)
0: read(?x:_ @count:92:15) use !io:
    foreign c read_count(?x @count:92:52, !io @count:92:56)


~= > public (0 calls)
0: ~=(x:_ @count:61:10, y:_ @count:61:18, ?#result:bool @count:61:5):
    foreign llvm icmp_ne(x @count:61:51, y @count:61:53, ?tmp#0 @count:61:30)
    foreign llvm move(tmp#0, ?#result @count:61:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.float
  representation  : 64 bit float
  public submods  : 
  public resources: 
  public procs    : wybe.float.*<0>
                    wybe.float.**<0>
                    wybe.float.*=<0>
                    wybe.float.+<0>
                    wybe.float.+<1>
                    wybe.float.+<2>
                    wybe.float.+=<0>
                    wybe.float.-<0>
                    wybe.float.-<1>
                    wybe.float.-<2>
                    wybe.float.-<3>
                    wybe.float.-<4>
                    wybe.float.-=<0>
                    wybe.float./<0>
                    wybe.float./=<0>
                    wybe.float.<<0>
                    wybe.float.<=<0>
                    wybe.float.<=><0>
                    wybe.float.=<0>
                    wybe.float.><0>
                    wybe.float.>=<0>
                    wybe.float.abs<0>
                    wybe.float.ceil<0>
                    wybe.float.cos<0>
                    wybe.float.e<0>
                    wybe.float.exp<0>
                    wybe.float.floor<0>
                    wybe.float.iceil<0>
                    wybe.float.ifloor<0>
                    wybe.float.iround<0>
                    wybe.float.log<0>
                    wybe.float.log10<0>
                    wybe.float.log2<0>
                    wybe.float.max<0>
                    wybe.float.min<0>
                    wybe.float.pi<0>
                    wybe.float.power<0>
                    wybe.float.print<0>
                    wybe.float.println<0>
                    wybe.float.read<0>
                    wybe.float.round<0>
                    wybe.float.sin<0>
                    wybe.float.sqrt<0>
                    wybe.float.square<0>
                    wybe.float.tan<0>
                    wybe.float.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

* > public (0 calls)
0: *(x:_ @float:45:10, y:_ @float:45:16, ?#result:_ @float:45:5):
    foreign llvm fmul(x @float:45:43, y @float:45:45, ?tmp#0 @float:45:25)
    foreign llvm move(tmp#0, ?#result @float:45:5)


** > public (0 calls)
0: **(x:_ @float:112:10, n:_ @float:112:18, ?#result:_ @float:112:5):
    foreign c llvm.pow.f64(x @float:112:52, n @float:112:54, ?tmp#0 @float:112:27)
    foreign llvm move(tmp#0, ?#result @float:112:5)


*= > public (0 calls)
0: *=(!x:_ @float:48:11, y:_ @float:48:19):
    *(x @float:48:31, y @float:48:35, ?tmp#0 @float:48:31)
    =(?x @float:48:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @float:23:10, y:_ @float:23:17, ?#result:_ @float:23:5):
    foreign llvm fadd(x @float:23:45, y @float:23:47, ?tmp#0 @float:23:27)
    foreign llvm move(tmp#0, ?#result @float:23:5)
+ > public (0 calls)
1: +(?x:_ @float:24:11, y:_ @float:24:17, z:_ @float:24:5):
    foreign llvm fsub(z @float:24:61, y @float:24:63, ?tmp#0 @float:24:43)
    =(?x @float:24:39, tmp#0)
+ > public (0 calls)
2: +(x:_ @float:25:10, ?y:_ @float:25:18, z:_ @float:25:5):
    foreign llvm fsub(z @float:25:61, x @float:25:63, ?tmp#0 @float:25:43)
    =(?y @float:25:39, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @float:28:11, y:_ @float:28:19):
    +(x @float:28:31, y @float:28:35, ?tmp#0 @float:28:31)
    =(?x @float:28:27, tmp#0)


- > public (0 calls)
0: -(x:_ @float:32:10, y:_ @float:32:17, ?#result:_ @float:32:5):
    foreign llvm fsub(x @float:32:45, y @float:32:47, ?tmp#0 @float:32:27)
    foreign llvm move(tmp#0, ?#result @float:32:5)
- > public (0 calls)
1: -(?x:_ @float:33:11, y:_ @float:33:17, z:_ @float:33:5):
    foreign llvm fadd(z @float:33:61, y @float:33:63, ?tmp#0 @float:33:43)
    =(?x @float:33:39, tmp#0)
- > public (0 calls)
2: -(x:_ @float:34:10, ?y:_ @float:34:18, z:_ @float:34:5):
    foreign llvm fsub(z @float:34:61, x @float:34:63, ?tmp#0 @float:34:43)
    =(?y @float:34:39, tmp#0)
- > public (0 calls)
3: -(x:_ @float:38:11, ?#result:_ @float:38:5):
    foreign llvm fsub(0.0 @float:38:39, x @float:38:43, ?tmp#0 @float:38:21)
    foreign llvm move(tmp#0, ?#result @float:38:5)
- > public (0 calls)
4: -(?x:_ @float:39:12, y:_ @float:39:5):
    foreign llvm fsub(0.0 @float:39:55, y @float:39:59, ?tmp#0 @float:39:37)
    =(?x @float:39:33, tmp#0)


-= > public (0 calls)
0: -=(!x:_ @float:42:11, y:_ @float:42:19):
    -(x @float:42:31, y @float:42:35, ?tmp#0 @float:42:31)
    =(?x @float:42:27, tmp#0)


/ > public (0 calls)
0: /(x:_ @float:51:10, y:_ @float:51:16, ?#result:_ @float:51:5):
    foreign llvm fdiv(x @float:51:43, y @float:51:45, ?tmp#0 @float:51:25)
    foreign llvm move(tmp#0, ?#result @float:51:5)


/= > public (0 calls)
0: /=(!x:_ @float:54:11, y:_ @float:54:19):
    /(x @float:54:31, y @float:54:35, ?tmp#0 @float:54:31)
    =(?x @float:54:27, tmp#0)


< > public (0 calls)
0: <(x:_ @float:70:10, y:_ @float:70:17, ?#result:bool @float:70:5):
    foreign llvm fcmp_slt(x @float:70:51, y @float:70:53, ?tmp#0 @float:70:29)
    foreign llvm move(tmp#0, ?#result @float:70:5)


<= > public (0 calls)
0: <=(x:_ @float:71:10, y:_ @float:71:18, ?#result:bool @float:71:5):
    foreign llvm fcmp_sle(x @float:71:52, y @float:71:54, ?tmp#0 @float:71:30)
    foreign llvm move(tmp#0, ?#result @float:71:5)


<=> > public (0 calls)
0: <=>(x:_ @float:76:10, y:_ @float:76:20, ?#result:comparison @float:76:5):
    if {<(x @float:77:10, y @float:77:14)::

        lesser(?tmp#1 @float:77:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @float:77:28, y @float:77:32)::

            equal(?tmp#3 @float:77:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @float:77:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @float:77:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @float:77:10, ?#result @float:76:5)


= > public (0 calls)
0: =(x:_ @float:66:10, y:_ @float:66:17, ?#result:bool @float:66:5):
    foreign llvm fcmp_eq(x @float:66:50, y @float:66:52, ?tmp#0 @float:66:29)
    foreign llvm move(tmp#0, ?#result @float:66:5)


> > public (0 calls)
0: >(x:_ @float:72:10, y:_ @float:72:17, ?#result:bool @float:72:5):
    foreign llvm fcmp_sgt(x @float:72:51, y @float:72:53, ?tmp#0 @float:72:29)
    foreign llvm move(tmp#0, ?#result @float:72:5)


>= > public (0 calls)
0: >=(x:_ @float:73:10, y:_ @float:73:18, ?#result:bool @float:73:5):
    foreign llvm fcmp_sge(x @float:73:52, y @float:73:54, ?tmp#0 @float:73:30)
    foreign llvm move(tmp#0, ?#result @float:73:5)


abs > public (0 calls)
0: abs(x:_ @float:60:13, ?#result:_ @float:60:5):
    foreign c llvm.fabs.f64(x @float:60:48, ?tmp#0 @float:60:22)
    foreign llvm move(tmp#0, ?#result @float:60:5)


ceil > public (0 calls)
0: ceil(x:_ @float:87:14, ?#result:_ @float:87:5):
    foreign c llvm.ceil.f64(x @float:87:49, ?tmp#0 @float:87:23)
    foreign llvm move(tmp#0, ?#result @float:87:5)


cos > public (0 calls)
0: cos(x:_ @float:116:13, ?#result:_ @float:116:5):
    foreign c llvm.cos.f64(x @float:116:47, ?tmp#0 @float:116:22)
    foreign llvm move(tmp#0, ?#result @float:116:5)


e > public (0 calls)
0: e(?#result:_ @float:16:5):
    foreign llvm move(2.7182818284590455 @float:16:15, ?#result @float:16:5)


exp > public (0 calls)
0: exp(x:_ @float:120:13, ?#result:_ @float:120:5):
    foreign c llvm.exp.f64(x @float:120:47, ?tmp#0 @float:120:22)
    foreign llvm move(tmp#0, ?#result @float:120:5)


floor > public (0 calls)
0: floor(x:_ @float:90:15, ?#result:_ @float:90:5):
    foreign c llvm.floor.f64(x @float:90:51, ?tmp#0 @float:90:24)
    foreign llvm move(tmp#0, ?#result @float:90:5)


iceil > public (0 calls)
0: iceil(x:_ @float:99:15, ?#result:int @float:99:5):
    ceil(x @float:99:51, ?tmp#1 @float:99:46)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:99:26)
    foreign llvm move(tmp#0, ?#result @float:99:5)


ifloor > public (0 calls)
0: ifloor(x:_ @float:102:16, ?#result:int @float:102:5):
    floor(x @float:102:53, ?tmp#1 @float:102:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:102:27)
    foreign llvm move(tmp#0, ?#result @float:102:5)


iround > public (0 calls)
0: iround(x:_ @float:96:16, ?#result:int @float:96:5):
    round(x @float:96:53, ?tmp#1 @float:96:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:96:27)
    foreign llvm move(tmp#0, ?#result @float:96:5)


log > public (0 calls)
0: log(x:_ @float:123:13, ?#result:_ @float:123:5):
    foreign c llvm.log.f64(x @float:123:47, ?tmp#0 @float:123:22)
    foreign llvm move(tmp#0, ?#result @float:123:5)


log10 > public (0 calls)
0: log10(x:_ @float:126:15, ?#result:_ @float:126:5):
    foreign c llvm.log10.f64(x @float:126:51, ?tmp#0 @float:126:24)
    foreign llvm move(tmp#0, ?#result @float:126:5)


log2 > public (0 calls)
0: log2(x:_ @float:129:14, ?#result:_ @float:129:5):
    foreign c llvm.log2.f64(x @float:129:49, ?tmp#0 @float:129:23)
    foreign llvm move(tmp#0, ?#result @float:129:5)


max > public (0 calls)
0: max(x:_ @float:81:13, y:_ @float:81:18, ?#result:_ @float:81:5):
    foreign c llvm.maxnum.f64(x @float:81:55, y @float:81:57, ?tmp#0 @float:81:27)
    foreign llvm move(tmp#0, ?#result @float:81:5)


min > public (0 calls)
0: min(x:_ @float:80:13, y:_ @float:80:18, ?#result:_ @float:80:5):
    foreign c llvm.minnum.f64(x @float:80:55, y @float:80:57, ?tmp#0 @float:80:27)
    foreign llvm move(tmp#0, ?#result @float:80:5)


pi > public (0 calls)
0: pi(?#result:_ @float:13:5):
    foreign llvm move(3.141592653589793 @float:13:16, ?#result @float:13:5)


power > public (0 calls)
0: power(x:_ @float:111:15, n:_ @float:111:19, ?#result:_ @float:111:5):
    foreign c llvm.pow.f64(x @float:111:53, n @float:111:55, ?tmp#0 @float:111:28)
    foreign llvm move(tmp#0, ?#result @float:111:5)


print > public (0 calls)
0: print(x:_ @float:133:15) use !io:
    foreign c print_float(x @float:133:52, !io @float:133:56)


println > public (0 calls)
0: println(x:_ @float:135:17) use !io:
    !print(x @float:135:39)
    !nl


read > public (0 calls)
0: read(?x:_ @float:137:15) use !io:
    foreign c read_float(?x @float:137:52, !io @float:137:56)


round > public (0 calls)
0: round(x:_ @float:93:15, ?#result:_ @float:93:5):
    foreign c llvm.round.f64(x @float:93:51, ?tmp#0 @float:93:24)
    foreign llvm move(tmp#0, ?#result @float:93:5)


sin > public (0 calls)
0: sin(x:_ @float:115:13, ?#result:_ @float:115:5):
    foreign c llvm.sin.f64(x @float:115:47, ?tmp#0 @float:115:22)
    foreign llvm move(tmp#0, ?#result @float:115:5)


sqrt > public (0 calls)
0: sqrt(x:_ @float:108:14, ?#result:_ @float:108:5):
    foreign c llvm.sqrt.f64(x @float:108:49, ?tmp#0 @float:108:23)
    foreign llvm move(tmp#0, ?#result @float:108:5)


square > public (0 calls)
0: square(x:_ @float:57:16, ?#result:_ @float:57:5):
    foreign llvm fmul(x @float:57:43, x @float:57:45, ?tmp#0 @float:57:25)
    foreign llvm move(tmp#0, ?#result @float:57:5)


tan > public (0 calls)
0: tan(x:_ @float:117:13, ?#result:_ @float:117:5):
    foreign c llvm.sin.f64(x @float:117:47, ?tmp#1 @float:117:22)
    foreign c llvm.cos.f64(x @float:117:77, ?tmp#2 @float:117:52)
    /(tmp#1, tmp#2, ?tmp#0 @float:117:22)
    foreign llvm move(tmp#0, ?#result @float:117:5)


~= > public (0 calls)
0: ~=(x:_ @float:67:10, y:_ @float:67:18, ?#result:bool @float:67:5):
    foreign llvm fcmp_ne(x @float:67:51, y @float:67:53, ?tmp#0 @float:67:30)
    foreign llvm move(tmp#0, ?#result @float:67:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.int
  representation  : 64 bit signed
  public submods  : 
  public resources: 
  public procs    : wybe.int.%<0>
                    wybe.int.%=<0>
                    wybe.int.*<0>
                    wybe.int.*=<0>
                    wybe.int.+<0>
                    wybe.int.+<1>
                    wybe.int.+<2>
                    wybe.int.+=<0>
                    wybe.int.-<0>
                    wybe.int.-<1>
                    wybe.int.-<2>
                    wybe.int.-<3>
                    wybe.int.-<4>
                    wybe.int.-=<0>
                    wybe.int./<0>
                    wybe.int./=<0>
                    wybe.int.<<0>
                    wybe.int.<<<0>
                    wybe.int.<<=<0>
                    wybe.int.<=<0>
                    wybe.int.<=><0>
                    wybe.int.=<0>
                    wybe.int.><0>
                    wybe.int.>=<0>
                    wybe.int.>><0>
                    wybe.int.>>=<0>
                    wybe.int.decr<0>
                    wybe.int.incr<0>
                    wybe.int.logical_bitshift<0>
                    wybe.int.logical_bitshift<1>
                    wybe.int.max<0>
                    wybe.int.min<0>
                    wybe.int.power<0>
                    wybe.int.print<0>
                    wybe.int.println<0>
                    wybe.int.read<0>
                    wybe.int.signum<0>
                    wybe.int.sqrt<0>
                    wybe.int.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public (0 calls)
0: %(x:_ @int:50:10, y:_ @int:50:16, ?#result:_ @int:50:5):
    foreign llvm srem(x @int:50:43, y @int:50:45, ?tmp#0 @int:50:25)
    foreign llvm move(tmp#0, ?#result @int:50:5)


%= > public (0 calls)
0: %=(!x:_ @int:53:11, y:_ @int:53:19):
    %(x @int:53:31, y @int:53:35, ?tmp#0 @int:53:31)
    =(?x @int:53:27, tmp#0)


* > public (0 calls)
0: *(x:_ @int:38:10, y:_ @int:38:16, ?#result:_ @int:38:5):
    foreign llvm mul(x @int:38:42, y @int:38:44, ?tmp#0 @int:38:25)
    foreign llvm move(tmp#0, ?#result @int:38:5)


*= > public (0 calls)
0: *=(!x:_ @int:41:11, y:_ @int:41:19):
    *(x @int:41:31, y @int:41:35, ?tmp#0 @int:41:31)
    =(?x @int:41:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @int:16:10, y:_ @int:16:17, ?#result:_ @int:16:5):
    foreign llvm add(x @int:16:44, y @int:16:46, ?tmp#0 @int:16:27)
    foreign llvm move(tmp#0, ?#result @int:16:5)
+ > public (0 calls)
1: +(?x:_ @int:17:11, y:_ @int:17:17, z:_ @int:17:5):
    foreign llvm sub(z @int:17:60, y @int:17:62, ?tmp#0 @int:17:43)
    =(?x @int:17:39, tmp#0)
+ > public (0 calls)
2: +(x:_ @int:18:10, ?y:_ @int:18:18, z:_ @int:18:5):
    foreign llvm sub(z @int:18:60, x @int:18:62, ?tmp#0 @int:18:43)
    =(?y @int:18:39, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @int:21:11, y:_ @int:21:19):
    +(x @int:21:31, y @int:21:35, ?tmp#0 @int:21:31)
    =(?x @int:21:27, tmp#0)


- > public (0 calls)
0: -(x:_ @int:25:10, y:_ @int:25:17, ?#result:_ @int:25:5):
    foreign llvm sub(x @int:25:44, y @int:25:46, ?tmp#0 @int:25:27)
    foreign llvm move(tmp#0, ?#result @int:25:5)
- > public (0 calls)
1: -(?x:_ @int:26:11, y:_ @int:26:17, z:_ @int:26:5):
    foreign llvm add(z @int:26:60, y @int:26:62, ?tmp#0 @int:26:43)
    =(?x @int:26:39, tmp#0)
- > public (0 calls)
2: -(x:_ @int:27:10, ?y:_ @int:27:18, z:_ @int:27:5):
    foreign llvm sub(z @int:27:60, x @int:27:62, ?tmp#0 @int:27:43)
    =(?y @int:27:39, tmp#0)
- > public (0 calls)
3: -(x:_ @int:31:11, ?#result:_ @int:31:5):
    foreign llvm sub(0 @int:31:38, x @int:31:40, ?tmp#0 @int:31:21)
    foreign llvm move(tmp#0, ?#result @int:31:5)
- > public (0 calls)
4: -(?x:_ @int:32:12, y:_ @int:32:5):
    foreign llvm sub(0 @int:32:54, y @int:32:56, ?tmp#0 @int:32:37)
    =(?x @int:32:33, tmp#0)


-= > public (0 calls)
0: -=(!x:_ @int:35:11, y:_ @int:35:19):
    -(x @int:35:31, y @int:35:35, ?tmp#0 @int:35:31)
    =(?x @int:35:27, tmp#0)


/ > public (0 calls)
0: /(x:_ @int:44:10, y:_ @int:44:16, ?#result:_ @int:44:5):
    foreign llvm sdiv(x @int:44:43, y @int:44:45, ?tmp#0 @int:44:25)
    foreign llvm move(tmp#0, ?#result @int:44:5)


/= > public (0 calls)
0: /=(!x:_ @int:47:11, y:_ @int:47:19):
    /(x @int:47:31, y @int:47:35, ?tmp#0 @int:47:31)
    =(?x @int:47:27, tmp#0)


< > public (0 calls)
0: <(x:_ @int:87:10, y:_ @int:87:17, ?#result:bool @int:87:5):
    foreign llvm icmp_slt(x @int:87:51, y @int:87:53, ?tmp#0 @int:87:29)
    foreign llvm move(tmp#0, ?#result @int:87:5)


<< > public (0 calls)
0: <<(x:_ @int:56:10, s:_ @int:56:18, ?#result:_ @int:56:5):
    foreign llvm shl(x @int:56:44, s @int:56:47, ?tmp#0 @int:56:27)
    foreign llvm move(tmp#0, ?#result @int:56:5)


<<= > public (0 calls)
0: <<=(!x:_ @int:59:11, s:_ @int:59:21):
    <<(x @int:59:33, s @int:59:39, ?tmp#0 @int:59:33)
    =(?x @int:59:29, tmp#0)


<= > public (0 calls)
0: <=(x:_ @int:88:10, y:_ @int:88:18, ?#result:bool @int:88:5):
    foreign llvm icmp_sle(x @int:88:52, y @int:88:54, ?tmp#0 @int:88:30)
    foreign llvm move(tmp#0, ?#result @int:88:5)


<=> > public (0 calls)
0: <=>(x:_ @int:93:10, y:_ @int:93:20, ?#result:comparison @int:93:5):
    if {<(x @int:94:10, y @int:94:14)::

        lesser(?tmp#1 @int:94:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @int:94:28, y @int:94:32)::

            equal(?tmp#3 @int:94:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @int:94:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @int:94:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @int:94:10, ?#result @int:93:5)


= > public (0 calls)
0: =(x:_ @int:83:10, y:_ @int:83:17, ?#result:bool @int:83:5):
    foreign llvm icmp_eq(x @int:83:50, y @int:83:52, ?tmp#0 @int:83:29)
    foreign llvm move(tmp#0, ?#result @int:83:5)


> > public (0 calls)
0: >(x:_ @int:89:10, y:_ @int:89:17, ?#result:bool @int:89:5):
    foreign llvm icmp_sgt(x @int:89:51, y @int:89:53, ?tmp#0 @int:89:29)
    foreign llvm move(tmp#0, ?#result @int:89:5)


>= > public (0 calls)
0: >=(x:_ @int:90:10, y:_ @int:90:18, ?#result:bool @int:90:5):
    foreign llvm icmp_sge(x @int:90:52, y @int:90:54, ?tmp#0 @int:90:30)
    foreign llvm move(tmp#0, ?#result @int:90:5)


>> > public (0 calls)
0: >>(x:_ @int:65:10, s:_ @int:65:18, ?#result:_ @int:65:5):
    foreign llvm ashr(x @int:65:45, s @int:65:48, ?tmp#0 @int:65:27)
    foreign llvm move(tmp#0, ?#result @int:65:5)


>>= > public (0 calls)
0: >>=(!x:_ @int:68:11, s:_ @int:68:21):
    >>(x @int:68:33, s @int:68:39, ?tmp#0 @int:68:33)
    =(?x @int:68:29, tmp#0)


decr > public (0 calls)
0: decr(!x:_ @int:111:15):
    -(x @int:111:27, 1 @int:111:31, ?tmp#0 @int:111:27)
    =(?x @int:111:23, tmp#0)


incr > public (0 calls)
0: incr(!x:_ @int:110:15):
    +(x @int:110:27, 1 @int:110:31, ?tmp#0 @int:110:27)
    =(?x @int:110:23, tmp#0)


logical_bitshift > public (0 calls)
0: logical_bitshift(x:_ @int:74:26, s:_ @int:74:31, ?#result:_ @int:74:5):
    foreign llvm lshr(x @int:74:58, s @int:74:61, ?tmp#0 @int:74:40)
    foreign llvm move(tmp#0, ?#result @int:74:5)
logical_bitshift > public (0 calls)
1: logical_bitshift(!x:_ @int:77:27, s:_ @int:77:32):
    logical_bitshift(x @int:77:61, s @int:77:64, ?tmp#0 @int:77:44)
    =(?x @int:77:40, tmp#0)


max > public (0 calls)
0: max(x:_ @int:98:13, y:_ @int:98:18, ?#result:_ @int:98:5):
    if {>=(x @int:98:31, y @int:98:35)::

        foreign llvm move(x @int:98:39, ?tmp#0)
    else::
        foreign llvm move(y @int:98:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @int:98:31, ?#result @int:98:5)


min > public (0 calls)
0: min(x:_ @int:97:13, y:_ @int:97:18, ?#result:_ @int:97:5):
    if {<=(x @int:97:31, y @int:97:35)::

        foreign llvm move(x @int:97:39, ?tmp#0)
    else::
        foreign llvm move(y @int:97:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @int:97:31, ?#result @int:97:5)


power > public (0 calls)
0: power(x:_ @int:107:15, y:_ @int:107:20, ?#result:_ @int:107:5):
    foreign c ipow(x @int:107:44, y @int:107:46, ?tmp#0 @int:107:29)
    foreign llvm move(tmp#0, ?#result @int:107:5)


print > public (0 calls)
0: print(x:_ @int:119:15) use !io:
    foreign c print_int(x @int:119:50, !io @int:119:54)


println > public (0 calls)
0: println(x:_ @int:121:17) use !io:
    !print(x @int:121:39)
    !nl


read > public (0 calls)
0: read(?x:_ @int:123:15) use !io:
    foreign c read_int(?x @int:123:50, !io @int:123:54)


signum > public (0 calls)
0: signum(x:_ @int:114:16, ?#result:_ @int:114:5):
    foreign c signum(x @int:114:42, ?tmp#0 @int:114:25)
    foreign llvm move(tmp#0, ?#result @int:114:5)


sqrt > public (0 calls)
0: sqrt(x:_ @int:104:14, ?#result:_ @int:104:5):
    foreign c isqrt(x @int:104:39, ?tmp#0 @int:104:23)
    foreign llvm move(tmp#0, ?#result @int:104:5)


~= > public (0 calls)
0: ~=(x:_ @int:84:10, y:_ @int:84:18, ?#result:bool @int:84:5):
    foreign llvm icmp_ne(x @int:84:51, y @int:84:53, ?tmp#0 @int:84:30)
    foreign llvm move(tmp#0, ?#result @int:84:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.io
  representation  : (not a type)
  public submods  : 
  public resources: io: wybe.io.io
  public procs    : wybe.io.eof<0>
                    wybe.io.nl<0>
  imports         : use wybe.char
                    public use wybe.phantom
  resources       : io: fromList [(wybe.io.io,phantom = 0:phantom @io:13:27 @io:13:5)]
  procs           : 

eof > public {inline} (0 calls)
0: eof(?#result:char @io:20:5):
    foreign lpvm cast(-1 @io:20:47, ?tmp#0 @io:20:29)
    foreign llvm move(tmp#0, ?#result @io:20:5)


nl > public {inline} (0 calls)
0: nl() use !io:
    foreign c putchar('\n' @io:17:49, !io @io:17:54)

LLVM code       : None

--------------------------------------------------
 Module wybe.list(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.list.,,<0>
                    wybe.list.[]<0>
                    wybe.list.all<0>
                    wybe.list.any<0>
                    wybe.list.empty<0>
                    wybe.list.filter<0>
                    wybe.list.foldl<0>
                    wybe.list.foldr<0>
                    wybe.list.length<0>
                    wybe.list.list<0>
                    wybe.list.map<0>
                    wybe.list.map<1>
                    wybe.list.map<2>
                    wybe.list.print<0>
                    wybe.list.println<0>
                    wybe.list.reverse<0>
  imports         : use wybe.array
                    use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
                    use wybe.machine_word
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_(T) @list:20:10, y:_(T) @list:20:20, ?#result:_(T) @list:20:5):
    if {[|](?h @list:21:16, ?t @list:21:21, x @list:21:10)::

        ,,(t @list:21:32, y @list:21:37, ?tmp#2 @list:21:32)
        [|](h @list:21:28, tmp#2, ?tmp#1 @list:21:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(y @list:21:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:21:10, ?#result @list:20:5)


[] > public {test} (0 calls)
0: [](xs:_(T) @list:31:21, idx:int @list:31:30, ?#result:T @list:31:5):
    >=(idx @list:32:5, 0 @list:32:13)
    index1(xs @list:33:17, idx @list:33:21, ?tmp#0 @list:33:10)
    =(?x @list:33:6, tmp#0)
    foreign llvm move(x @list:31:43, ?#result @list:31:5)


all > public {test} (0 calls)
0: all(p:{test}(T) @list:61:20, xs:_(T) @list:61:33):
    foreign llvm move(xs @list:62:15, ?tmp#0)
    do {
        if {[|](?x @list:62:10, ?tmp#0, tmp#0)::

            p(x @list:63:11)
        else::
            break

        }
    }


any > public {test} (0 calls)
0: any(p:{test}(T) @list:69:20, xs:_(T) @list:69:33):
    [|](?x @list:70:7, ?xs @list:70:12, xs @list:70:18)
    (   p(x @list:71:8)
    | any(p @list:71:17, xs @list:71:20))


empty > public {test} (0 calls)
0: empty(xs:_(T) @list:15:22):
    if {[|](?tmp#0 @list:16:11, ?tmp#1 @list:16:15, xs @list:16:20)::

        fail
    else::
        pass

    }


filter > public (0 calls)
0: filter(p:{test}(T) @list:95:16, !xs:_(T) @list:95:30):
    [](?tmp#0 @list:96:12)
    =(?out @list:96:6, tmp#0)
    foreign llvm move(xs @list:97:15, ?tmp#1)
    do {
        if {[|](?x @list:97:10, ?tmp#1, tmp#1)::

            if {p(x @list:98:16)::

                [|](x @list:98:30, out @list:98:34, ?tmp#2 @list:98:29)
                =(?out @list:98:23, tmp#2)
            else::
                pass

            }
        else::
            break

        }
    }
    reverse(out @list:100:19, ?tmp#3 @list:100:11)
    =(?as @list:100:6, tmp#3)


foldl > public (0 calls)
0: foldl(f:(A, !B) @list:77:15, as:_(A) @list:77:26, !b:B @list:77:36):
    foreign llvm move(as @list:78:15, ?tmp#0)
    do {
        if {[|](?a @list:78:10, ?tmp#0, tmp#0)::

            f(a @list:79:11, !b @list:79:15)
        else::
            break

        }
    }


foldr > public (0 calls)
0: foldr(f:(A, !B) @list:86:15, as:_(A) @list:86:26, !b:B @list:86:36):
    if {[|](?a @list:87:12, ?as @list:87:17, as @list:87:23)::

        foldr(f @list:88:15, as @list:88:18, !b @list:88:23)
        f(a @list:89:11, !b @list:89:15)
    else::
        pass

    }


index1 > {test} (0 calls)
0: index1(xs:_(T) @list:148:19, idx:int @list:148:28, ?#result:T @list:148:1):
    [|](?x @list:149:7, ?xs @list:149:12, xs @list:149:18)
    (   =(idx @list:150:6, 0 @list:150:12)
    | (   -(idx @list:150:27, 1 @list:150:33, ?tmp#0 @list:150:27)
        & index1(xs @list:150:23, tmp#0, ?x @list:150:37)))
    foreign llvm move(x @list:148:41, ?#result @list:148:1)


length > public (0 calls)
0: length(x:_(T) @list:24:16, ?#result:int @list:24:5):
    length1(x @list:24:38, 0 @list:24:41, ?tmp#0 @list:24:30)
    foreign llvm move(tmp#0, ?#result @list:24:5)


length1 > (0 calls)
0: length1(x:_(T) @list:140:13, acc:int @list:140:21, ?#result:int @list:140:1):
    if {[|](?h @list:141:16, ?t @list:141:21, x @list:141:10)::

        +(acc @list:141:38, 1 @list:141:44, ?tmp#2 @list:141:38)
        length1(t @list:141:35, tmp#2, ?tmp#1 @list:141:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(acc @list:141:57, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:141:10, ?#result @list:140:1)


list > public (0 calls)
0: list(ar:array(T) @list:128:14, ?#result:_(T) @list:128:5):
    [](?tmp#0 @list:129:11)
    =(?ls @list:129:6, tmp#0)
    foreign llvm move(ar @list:130:15, ?tmp#1)
    do {
        if {[|](?x @list:130:10, ?tmp#1, tmp#1)::

            [|](x @list:131:16, ls @list:131:20, ?tmp#2 @list:131:15)
            =(?ls @list:131:10, tmp#2)
        else::
            break

        }
    }
    reverse(ls @list:133:13, ?ls @list:133:18)
    foreign llvm move(ls @list:128:34, ?#result @list:128:5)


map > public (0 calls)
0: map(f:{resource}(T) @list:41:13, xs:_(T) @list:41:30):
    foreign llvm move(xs @list:42:15, ?tmp#0)
    do {
        if {[|](?x @list:42:10, ?tmp#0, tmp#0)::

            !f(x @list:43:12)
        else::
            break

        }
    }
map > public (0 calls)
1: map(f:(A, ?B) @list:49:13, as:_(A) @list:49:24, ?#result:_(B) @list:49:5):
    if {[|](?a @list:50:12, ?as @list:50:17, as @list:50:23)::

        f(a @list:50:33, ?tmp#2 @list:50:31)
        map(f @list:50:42, as @list:50:45, ?tmp#3 @list:50:38)
        [|](tmp#2, tmp#3, ?tmp#1 @list:50:29)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:50:61)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:50:10, ?#result @list:49:5)
map > public (0 calls)
2: map(f:(A, B, ?C) @list:55:13, as:_(A) @list:55:27, bs:_(B) @list:55:36, ?#result:_(C) @list:55:5):
    if {(   [|](?a @list:56:12, ?as @list:56:17, as @list:56:23)
        & [|](?b @list:56:30, ?bs @list:56:35, bs @list:56:41))::

        f(a @list:56:51, b @list:56:54, ?tmp#2 @list:56:49)
        map(f @list:56:63, as @list:56:66, bs @list:56:70, ?tmp#3 @list:56:59)
        [|](tmp#2, tmp#3, ?tmp#1 @list:56:47)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:57:47)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:56:10, ?#result @list:55:5)


print > public (0 calls)
0: print(printer:{resource}(T) @list:108:15, xs:_(T) @list:108:38) use !io:
    !print('[' @list:109:12)
    if {[|](?x @list:110:12, ?xs @list:110:17, xs @list:110:23)::

        !printer(x @list:111:18)
        !print1(printer @list:112:17, xs @list:112:26)
    else::
        pass

    }
    !print(']' @list:114:12)


print1 > (0 calls)
0: print1(printer:{resource}(T) @list:154:12, xs:_(T) @list:154:35) use !io:
    if {[|](?x @list:155:12, ?xs @list:155:17, xs @list:155:23)::

        !print(',' @list:156:16)
        !printer(x @list:157:18)
        !print1(printer @list:158:17, xs @list:158:26)
    else::
        pass

    }


println > public (0 calls)
0: println(printer:{resource}(T) @list:119:17, xs:_(T) @list:119:40) use !io:
    !print(printer @list:120:12, xs @list:120:21)
    !nl


reverse > public (0 calls)
0: reverse(x:_(T) @list:27:17, ?#result:_(T) @list:27:5):
    [](?tmp#1 @list:27:44)
    reverse1(x @list:27:41, tmp#1, ?tmp#0 @list:27:32)
    foreign llvm move(tmp#0, ?#result @list:27:5)


reverse1 > (0 calls)
0: reverse1(x:_(T) @list:144:14, tail:_(T) @list:144:22, ?#result:_(T) @list:144:1):
    if {[|](?h @list:145:16, ?t @list:145:21, x @list:145:10)::

        [|](h @list:145:40, tail @list:145:44, ?tmp#2 @list:145:39)
        reverse1(t @list:145:36, tmp#2, ?tmp#1 @list:145:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(tail @list:145:61, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:145:10, ?#result @list:144:1)

LLVM code       : None

--------------------------------------------------
 Module wybe.machine_word
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.machine_word.word_size_bits<0>
                    wybe.machine_word.word_size_bytes<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

word_size_bits > public (0 calls)
0: word_size_bits(?#result:int @machine_word:12:5):
    word_size_bytes(?tmp#1 @machine_word:12:34)
    *(8 @machine_word:12:30, tmp#1, ?tmp#0 @machine_word:12:30)
    foreign llvm move(tmp#0, ?#result @machine_word:12:5)


word_size_bytes > public (0 calls)
0: word_size_bytes(?#result:int @machine_word:10:5):
    foreign llvm move(8 @machine_word:10:31, ?#result @machine_word:10:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.memory_management
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.memory_management.malloc_count<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

malloc_count > public {semipure} (0 calls)
0: malloc_count(?x:int @memory_management:11:34):
    foreign c {impure} malloc_count(?x @memory_management:12:38)

LLVM code       : None

--------------------------------------------------
 Module wybe.phantom
 modifiers       : {unique} 
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : 
  imports         : 
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.predicate
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.predicate.const<0>
                    wybe.predicate.id<0>
  imports         : 
  resources       : 
  procs           : 

const > public {inline} (0 calls)
0: wybe.predicate.const<0>
const(a##0:A <{}; {}; {0}>, [b##0:B <{}; {}; {1}>], ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:8:5


id > public {inline} (0 calls)
0: wybe.predicate.id<0>
id(a##0:A <{}; {}; {0}>, ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:6:5

LLVM code       : None

--------------------------------------------------
 Module wybe.range
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.range...<0>
                    wybe.range.[]<0>
                    wybe.range.[|]<0>
                    wybe.range.irange<0>
                    wybe.range.size<0>
                    wybe.range.xrange<0>
  imports         : use wybe.bool
                    use wybe.int
  resources       : 
  procs           : 

.. > public (0 calls)
0: ..(start:int @range:38:10, end:int @range:38:23, ?#result:_ @range:38:5):
    if {<=(start @range:39:27, end @range:39:37)::

        foreign llvm move(1 @range:39:44, ?tmp#1)
    else::
        foreign llvm move(-1 @range:39:56, ?tmp#1)

    }
    construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)
    foreign llvm move(tmp#0, ?#result @range:38:5)


[] > public {test} (0 calls)
0: [](r:_ @range:20:19, idx:int @range:20:24, ?value:int @range:20:34):
    <=(0 @range:21:6, idx @range:21:12)
    range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)
    *(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)
    +(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)
    =(?value @range:23:6, tmp#0)
    if {<=(0 @range:24:10, stride @range:24:16)::

        <(value @range:24:27, end @range:24:35)
    else::
        <(end @range:24:51, value @range:24:57)

    }


[|] > public {test} (0 calls)
0: [|](?value:int @range:12:23, ?rest:_ @range:12:35, current:_ @range:12:43):
    range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)
    ~=(value @range:14:6, end @range:14:16)
    +(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)
    range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)
    =(?rest @range:15:6, tmp#0)


construct > (0 calls)
0: construct(start:int @range:49:15, stride:int @range:49:26, end:int @range:49:38, ?#result:_ @range:49:1):
    -(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)
    %(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)
    =(?diff @range:50:6, tmp#0)
    if {<=(0 @range:51:19, stride @range:51:25)::

        if {=(diff @range:52:26, 0 @range:52:33)::

            max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
            -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
            max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
            foreign llvm move(tmp#5, ?tmp#3)

        }
        foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
    else::
        if {=(diff @range:55:26, 0 @range:55:33)::

            min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
            foreign llvm move(tmp#9, ?tmp#8)
        else::
            +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
            min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
            foreign llvm move(tmp#10, ?tmp#8)

        }
        foreign llvm move(tmp#8 @range:55:26, ?tmp#2)

    }
    =(?final @range:51:6, tmp#2 @range:51:19)
    range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)
    =(?r @range:58:6, tmp#12)
    foreign llvm move(r @range:49:51, ?#result @range:49:1)


irange > public (0 calls)
0: irange(start:int @range:32:16, stride:int @range:32:27, end:int @range:32:39, ?#result:_ @range:32:5):
    if {<(stride @range:33:41, 0 @range:33:50)::

        foreign llvm move(-1 @range:33:55, ?tmp#2)
    else::
        foreign llvm move(1 @range:33:68, ?tmp#2)

    }
    +(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)
    construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)
    foreign llvm move(tmp#0, ?#result @range:32:5)


size > public (0 calls)
0: size(r:_ @range:42:14, ?#result:int @range:42:5):
    range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)
    if {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
        & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
        & signum(tmp#3, ?tmp#2 @range:44:29)
        & ~=(tmp#1, tmp#2))::

        foreign llvm move(0 @range:44:52, ?tmp#0)
    else::
        if {<=(0 @range:45:10, stride @range:45:16)::

            -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
            -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
            /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
            +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
            foreign llvm move(tmp#5, ?tmp#4)
        else::
            -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
            -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
            -(stride @range:46:39, ?tmp#13 @range:46:38)
            /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
            +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
            foreign llvm move(tmp#9, ?tmp#4)

        }
        foreign llvm move(tmp#4 @range:45:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)


xrange > public (0 calls)
0: xrange(start:int @range:28:16, stride:int @range:28:27, end:int @range:28:39, ?#result:_ @range:28:5):
    construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)
    foreign llvm move(tmp#0, ?#result @range:28:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.string
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.string.,,<0>
                    wybe.string.<<0>
                    wybe.string.<=<0>
                    wybe.string.<=><0>
                    wybe.string.=<0>
                    wybe.string.><0>
                    wybe.string.>=<0>
                    wybe.string.[]<0>
                    wybe.string.[]<1>
                    wybe.string.[|]<0>
                    wybe.string.c_string<0>
                    wybe.string.length<0>
                    wybe.string.print<0>
                    wybe.string.println<0>
                    wybe.string.read<0>
                    wybe.string.string<0>
                    wybe.string.string<1>
                    wybe.string.~=<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.char
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
                    use wybe.range
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_ @string:64:10, y:_ @string:64:17, ?#result:_ @string:64:5):
    if {(   empty(?tmp#1 @string:65:14)
        & =(x @string:65:10, tmp#1))::

        foreign llvm move(y @string:65:23, ?tmp#0)
    else::
        if {(   empty(?tmp#3 @string:66:14)
            & =(y @string:66:10, tmp#3))::

            foreign llvm move(x @string:66:23, ?tmp#2)
        else::
            concat(x @string:67:25, y @string:67:28, ?tmp#4 @string:67:18)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:66:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:65:10, ?#result @string:64:5)


< > public (0 calls)
0: <(x:_ @string:119:10, y:_ @string:119:17, ?#result:bool @string:119:5):
    <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
    equal(?tmp#2 @string:119:44)
    <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
    foreign llvm move(tmp#0, ?#result @string:119:5)


<= > public (0 calls)
0: <=(x:_ @string:120:10, y:_ @string:120:18, ?#result:bool @string:120:5):
    <=>(x @string:120:31, y @string:120:39, ?tmp#1 @string:120:31)
    equal(?tmp#2 @string:120:46)
    <=(tmp#1, tmp#2, ?tmp#0 @string:120:30)
    foreign llvm move(tmp#0, ?#result @string:120:5)


<=> > public (0 calls)
0: <=>(x:_ @string:125:10, y:_ @string:125:20, ?#result:comparison @string:125:5):
    equal(?tmp#0 @string:126:10)
    =(?c @string:126:6, tmp#0)
    foreign llvm move(x @string:127:16, ?tmp#1)
    foreign llvm move(y @string:127:26, ?tmp#2)
    do {
        if {[|](?cx @string:127:10, ?tmp#1, tmp#1)::

            if {[|](?cy @string:127:20, ?tmp#2, tmp#2)::

                if {<(cx @string:128:14, cy @string:128:19)::

                    lesser(?tmp#3 @string:128:30)
                    =(?c @string:128:26, tmp#3)
                    break
                else::
                    if {>(cx @string:129:14, cy @string:129:19)::

                        greater(?tmp#4 @string:129:30)
                        =(?c @string:129:26, tmp#4)
                        break
                    else::
                        pass

                    }

                }
            else::
                break

            }
        else::
            break

        }
    }
    if {(   equal(?tmp#5 @string:132:14)
        & =(c @string:132:10, tmp#5))::

        length(x @string:133:22, ?tmp#6 @string:133:15)
        =(?lx @string:133:10, tmp#6)
        length(y @string:134:22, ?tmp#7 @string:134:15)
        =(?ly @string:134:10, tmp#7)
        if {<(lx @string:135:14, ly @string:135:19)::

            lesser(?tmp#8 @string:135:30)
            =(?c @string:135:26, tmp#8)
        else::
            if {>(lx @string:135:39, ly @string:135:44)::

                greater(?tmp#9 @string:135:55)
                =(?c @string:135:51, tmp#9)
            else::
                pass

            }

        }
    else::
        pass

    }
    foreign llvm move(c @string:125:38, ?#result @string:125:5)


= > public (0 calls)
0: =(x:_ @string:115:10, y:_ @string:115:17, ?#result:bool @string:115:5):
    <=>(x @string:115:30, y @string:115:38, ?tmp#1 @string:115:30)
    equal(?tmp#2 @string:115:44)
    =(tmp#1, tmp#2, ?tmp#0 @string:115:29)
    foreign llvm move(tmp#0, ?#result @string:115:5)


> > public (0 calls)
0: >(x:_ @string:121:10, y:_ @string:121:17, ?#result:bool @string:121:5):
    <=>(x @string:121:30, y @string:121:38, ?tmp#1 @string:121:30)
    equal(?tmp#2 @string:121:44)
    >(tmp#1, tmp#2, ?tmp#0 @string:121:29)
    foreign llvm move(tmp#0, ?#result @string:121:5)


>= > public (0 calls)
0: >=(x:_ @string:122:10, y:_ @string:122:18, ?#result:bool @string:122:5):
    <=>(x @string:122:31, y @string:122:39, ?tmp#1 @string:122:31)
    equal(?tmp#2 @string:122:46)
    >=(tmp#1, tmp#2, ?tmp#0 @string:122:30)
    foreign llvm move(tmp#0, ?#result @string:122:5)


[] > public {test} (0 calls)
0: [](s:_ @string:91:19, idx:int @string:91:24, ?c:char @string:91:34):
    if {buffer(?len @string:93:17, ?str @string:93:23, s @string:92:10)::

        <=(0 @string:94:14, idx @string:94:20)
        <(idx @string:95:14, len @string:95:20)
        unsafe_c_string_index(str @string:96:35, idx @string:96:40, ?c @string:96:46)
    else::
        if {concat(?left @string:97:17, ?right @string:97:24, s @string:92:10)::

            length(left @string:98:32, ?tmp#0 @string:98:25)
            =(?left_len @string:98:14, tmp#0)
            if {<(idx @string:99:18, left_len @string:99:24)::

                [](left @string:99:41, idx @string:99:46, ?tmp#1 @string:99:41)
                =(?c @string:99:37, tmp#1)
            else::
                -(idx @string:100:37, left_len @string:100:43, ?tmp#3 @string:100:37)
                [](right @string:100:31, tmp#3, ?tmp#2 @string:100:31)
                =(?c @string:100:27, tmp#2)

            }
        else::
            if {slice(?base @string:102:16, ?range @string:102:23, s @string:92:10)::

                [](range @string:102:43, idx @string:102:49, ?tmp#5 @string:102:43)
                [](base @string:102:38, tmp#5, ?tmp#4 @string:102:38)
                =(?c @string:102:34, tmp#4)
            else::
                if {singleton(?c @string:103:20, s @string:92:10)::

                    =(idx @string:103:27, 0 @string:103:33)
                else::
                    fail

                }

            }

        }

    }
[] > public (0 calls)
1: [](s:_ @string:109:12, r:range @string:109:17, ?#result:_ @string:109:5):
    slice(s @string:109:36, r @string:109:39, ?tmp#0 @string:109:30)
    foreign llvm move(tmp#0, ?#result @string:109:5)


[|] > public {test} (0 calls)
0: [|](?head:char @string:71:23, ?tail:_ @string:71:35, s:_ @string:71:43):
    if {buffer(?len @string:73:17, ?str @string:73:23, s @string:72:10)::

        [|](?head @string:74:15, ?str @string:74:23, str @string:74:30)
        if {=(len @string:75:26, 1 @string:75:32)::

            empty(?tmp#1 @string:75:37)
            foreign llvm move(tmp#1, ?tmp#0)
        else::
            -(len @string:75:60, 1 @string:75:66, ?tmp#3 @string:75:60)
            buffer(tmp#3, str @string:75:69, ?tmp#2 @string:75:53)
            foreign llvm move(tmp#2, ?tmp#0)

        }
        =(?tail @string:75:14, tmp#0 @string:75:26)
    else::
        if {concat(?left @string:76:17, ?right @string:76:24, s @string:72:10)::

            if {[|](?head @string:77:20, ?t @string:77:28, left @string:77:33)::

                concat(t @string:77:56, right @string:77:59, ?tmp#4 @string:77:49)
                =(?tail @string:77:42, tmp#4)
            else::
                [|](?head @string:78:28, ?tail @string:78:36, right @string:78:44)

            }
        else::
            if {slice(?base @string:80:16, ?range @string:80:23, s @string:72:10)::

                do {
                    [|](?idx @string:82:19, ?range @string:82:26, range @string:82:35)
                    if {(   [](base @string:83:30, idx @string:83:35, ?tmp#5 @string:83:30)
                        & =(?head @string:83:23, tmp#5))::

                        slice(base @string:83:57, range @string:83:63, ?tmp#6 @string:83:51)
                        =(?tail @string:83:44, tmp#6)
                        break
                    else::
                        pass

                    }
                }
            else::
                if {singleton(?head @string:85:20, s @string:72:10)::

                    empty(?tmp#7 @string:85:37)
                    =(?tail @string:85:30, tmp#7)
                else::
                    fail

                }

            }

        }

    }


c_string > public (0 calls)
0: c_string(s:_ @string:40:18, ?#result:c_string @string:40:5):
    if {buffer(?tmp#0 @string:41:21, ?str @string:41:25, s @string:41:10)::

        pass
    else::
        length(s @string:43:27, ?tmp#2 @string:43:20)
        +(tmp#2, 1 @string:43:32, ?tmp#1 @string:43:20)
        =(?len @string:43:14, tmp#1)
        foreign lpvm alloc(len @string:44:32, ?str @string:44:38)
        true(?tmp#3 @string:45:49)
        foreign lpvm mutate(str @string:45:33, ?str @string:45:39, len @string:45:44, tmp#3, len @string:45:55, 0 @string:45:60, '\NUL' @string:45:63)
        =(?offset @string:46:14, 0 @string:46:23)
        pack(s @string:47:18, !str @string:47:22, len @string:47:27, !offset @string:47:33)

    }
    foreign llvm move(str @string:40:34, ?#result @string:40:5)


fixed_range_size > (0 calls)
0: fixed_range_size(hi:int @string:184:22, r:range @string:184:30, ?sz:int @string:184:40):
    range(?start @string:185:16, ?stride @string:185:24, ?end @string:185:33, r @string:185:5)
    if {<=(0 @string:186:10, stride @string:186:16)::

        -(start @string:187:39, ?tmp#4 @string:187:38)
        /(tmp#4, stride @string:187:47, ?tmp#3 @string:187:38)
        *(tmp#3, stride @string:187:56, ?tmp#2 @string:187:38)
        +(start @string:187:30, tmp#2, ?tmp#1 @string:187:30)
        max(start @string:187:23, tmp#1, ?tmp#0 @string:187:19)
        =(?lo @string:187:14, tmp#0)
        min(hi @string:188:23, end @string:188:27, ?tmp#5 @string:188:19)
        =(?hi @string:188:14, tmp#5)
    else::
        max(-1 @string:190:23, end @string:190:27, ?tmp#6 @string:190:19)
        =(?lo @string:190:14, tmp#6)
        +(hi @string:191:30, stride @string:191:35, ?tmp#10 @string:191:30)
        -(start @string:191:45, hi @string:191:53, ?tmp#13 @string:191:45)
        -(tmp#13, 1 @string:191:58, ?tmp#12 @string:191:45)
        -(stride @string:191:64, ?tmp#14 @string:191:63)
        %(tmp#12, tmp#14, ?tmp#11 @string:191:44)
        +(tmp#10, tmp#11, ?tmp#9 @string:191:30)
        +(tmp#9, 1 @string:191:73, ?tmp#8 @string:191:30)
        min(start @string:191:23, tmp#8, ?tmp#7 @string:191:19)
        =(?hi @string:191:14, tmp#7)
        -(stride @string:192:24, ?tmp#15 @string:192:23)
        =(?stride @string:192:14, tmp#15)

    }
    if {<=(hi @string:194:16, lo @string:194:23)::

        foreign llvm move(0 @string:194:29, ?tmp#16)
    else::
        -(hi @string:194:42, lo @string:194:47, ?tmp#20 @string:194:42)
        -(tmp#20, 1 @string:194:52, ?tmp#19 @string:194:42)
        /(tmp#19, stride @string:194:57, ?tmp#18 @string:194:41)
        +(tmp#18, 1 @string:194:66, ?tmp#17 @string:194:41)
        foreign llvm move(tmp#17, ?tmp#16)

    }
    =(?sz @string:194:6, tmp#16 @string:194:16)


length > public (0 calls)
0: length(s:_ @string:52:16, ?#result:int @string:52:5):
    if {buffer(?len @string:53:22, ?tmp#1 @string:53:27, s @string:53:10)::

        foreign llvm move(len @string:53:33, ?tmp#0)
    else::
        if {concat(?left @string:54:22, ?right @string:54:29, s @string:54:10)::

            length(left @string:54:46, ?tmp#4 @string:54:39)
            length(right @string:54:61, ?tmp#5 @string:54:54)
            +(tmp#4, tmp#5, ?tmp#3 @string:54:39)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            if {slice(?base @string:55:21, ?range @string:55:28, s @string:55:10)::

                length(base @string:55:62, ?tmp#8 @string:55:55)
                fixed_range_size(tmp#8, range @string:55:69, ?tmp#7 @string:55:38)
                foreign llvm move(tmp#7, ?tmp#6)
            else::
                if {singleton(?tmp#10 @string:56:24, s @string:56:10)::

                    foreign llvm move(1 @string:56:30, ?tmp#9)
                else::
                    foreign llvm move(0 @string:57:18, ?tmp#9)

                }
                foreign llvm move(tmp#9 @string:56:10, ?tmp#6)

            }
            foreign llvm move(tmp#6 @string:55:10, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:54:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:53:10, ?#result @string:52:5)


pack > (0 calls)
0: pack(s:_ @string:160:10, !raw:c_string @string:160:16, size:int @string:160:30, !offset:int @string:160:41):
    if {buffer(?tmp#0 @string:162:16, ?str @string:162:20, s @string:161:10)::

        foreign llvm move(str @string:163:23, ?tmp#1)
        do {
            if {[|](?c @string:163:18, ?tmp#1, tmp#1)::

                true(?tmp#2 @string:164:56)
                foreign lpvm mutate(raw @string:164:37, ?raw @string:164:43, offset @string:164:48, tmp#2, size @string:164:62, 0 @string:164:68, c @string:164:71)
                incr(!offset @string:165:23)
            else::
                break

            }
        }
    else::
        if {concat(?left @string:167:17, ?right @string:167:24, s @string:161:10)::

            pack(left @string:168:18, !raw @string:168:25, size @string:168:30, !offset @string:168:37)
            pack(right @string:169:18, !raw @string:169:26, size @string:169:31, !offset @string:169:38)
            incr(!offset @string:170:19)
        else::
            if {slice(?tmp#3 @string:171:15, ?tmp#4 @string:171:18, s @string:161:10)::

                foreign llvm move(s @string:172:23, ?tmp#5)
                do {
                    if {[|](?c @string:172:18, ?tmp#5, tmp#5)::

                        true(?tmp#6 @string:173:56)
                        foreign lpvm mutate(raw @string:173:37, ?raw @string:173:43, offset @string:173:48, tmp#6, size @string:173:62, 0 @string:173:68, c @string:173:71)
                        incr(!offset @string:174:23)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:176:20, s @string:161:10)::

                    true(?tmp#7 @string:177:52)
                    foreign lpvm mutate(raw @string:177:33, ?raw @string:177:39, offset @string:177:44, tmp#7, size @string:177:58, 0 @string:177:64, c @string:177:67)
                    incr(!offset @string:178:19)
                else::
                    fail

                }

            }

        }

    }


print > public (0 calls)
0: print(x:_ @string:142:15) use !io:
    if {buffer(?tmp#0 @string:144:16, ?str @string:144:20, x @string:143:10)::

        !print(str @string:144:35)
    else::
        if {concat(?left @string:145:17, ?right @string:145:24, x @string:143:10)::

            !print(left @string:145:41)
            !print(right @string:145:55)
        else::
            if {slice(?tmp#1 @string:146:15, ?tmp#2 @string:146:18, x @string:143:10)::

                foreign llvm move(x @string:146:34, ?tmp#3)
                do {
                    if {[|](?c @string:146:29, ?tmp#3, tmp#3)::

                        !print(c @string:146:45)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:147:20, x @string:143:10)::

                    !print(c @string:147:33)
                else::
                    fail

                }

            }

        }

    }


println > public (0 calls)
0: println(x:_ @string:151:17) use !io:
    !print(x @string:151:39)
    !nl


read > public (0 calls)
0: read(?x:_ @string:153:15) use !io:
    !read(?str:c_string @string:153:37)
    string(str @string:153:64, ?tmp#0 @string:153:57)
    =(?x @string:153:53, tmp#0)


string > public (0 calls)
0: string(str:c_string @string:28:16, ?#result:_ @string:28:5):
    length(str @string:29:19, ?tmp#0 @string:29:12)
    =(?len @string:29:6, tmp#0)
    if {=(len @string:30:15, 0 @string:30:21)::

        empty(?tmp#2 @string:30:26)
        foreign llvm move(tmp#2, ?tmp#1)
    else::
        if {=(len @string:31:15, 1 @string:31:21)::

            foreign lpvm access(str @string:31:56, 0 @string:31:61, 1 @string:31:64, 0 @string:31:67, ?tmp#5 @string:31:36)
            singleton(tmp#5, ?tmp#4 @string:31:26)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            buffer(len @string:32:33, str @string:32:38, ?tmp#6 @string:32:26)
            foreign llvm move(tmp#6, ?tmp#3)

        }
        foreign llvm move(tmp#3 @string:31:15, ?tmp#1)

    }
    =(?s @string:30:6, tmp#1 @string:30:15)
    foreign llvm move(s @string:28:34, ?#result @string:28:5)
string > public (0 calls)
1: string(c:char @string:37:16, ?#result:_ @string:37:5):
    singleton(c @string:37:38, ?tmp#0 @string:37:28)
    foreign llvm move(tmp#0, ?#result @string:37:5)


~= > public (0 calls)
0: ~=(x:_ @string:116:10, y:_ @string:116:18, ?#result:bool @string:116:5):
    <=>(x @string:116:31, y @string:116:39, ?tmp#1 @string:116:31)
    equal(?tmp#2 @string:116:46)
    ~=(tmp#1, tmp#2, ?tmp#0 @string:116:30)
    foreign llvm move(tmp#0, ?#result @string:116:5)

LLVM code       : None

Types: **** Validating parameter types in module wybe.phantom
Types: **** Re-exiting module wybe.phantom
Types: **** Type checking modules wybe.phantom
Types: **** Strongly connected components:
======================================================================
AFTER TYPE CHECK:
 Module wybe
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : 
  imports         : public use wybe.array
                    public use wybe.bool
                    public use wybe.c_string
                    public use wybe.char
                    public use wybe.comparison
                    public use wybe.control
                    public use wybe.count
                    public use wybe.float
                    public use wybe.int
                    public use wybe.io
                    public use wybe.list
                    public use wybe.machine_word
                    public use wybe.memory_management
                    public use wybe.phantom
                    public use wybe.predicate
                    public use wybe.range
                    public use wybe.string
  resources       : 
  submodules      : wybe.array, wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.control, wybe.count, wybe.float, wybe.int, wybe.io, wybe.list, wybe.machine_word, wybe.memory_management, wybe.phantom, wybe.predicate, wybe.range, wybe.string
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.array(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.array.[]<0>
                    wybe.array.[]<1>
                    wybe.array.[|]<0>
                    wybe.array.array<0>
                    wybe.array.array<1>
                    wybe.array.inbounds<0>
                    wybe.array.unsafe_get<0>
                    wybe.array.unsafe_update<0>
  imports         : public use wybe.array.raw_array
                    use wybe.bool
                    use wybe.int
                    use wybe.list
                    use wybe.machine_word
  resources       : 
  submodules      : wybe.array.raw_array
  procs           : 

[] > public {test} (0 calls)
0: [](a:_(T) @array:67:21, idx:int @array:67:29, ?#result:T @array:67:5):
    inbounds(a @array:68:14, idx @array:68:17)
    unsafe_get(a @array:69:10, idx @array:69:23, ?tmp#0 @array:69:10)
    =(?x @array:69:6, tmp#0)
    foreign llvm move(x @array:67:42, ?#result @array:67:5)
[] > public {test} (0 calls)
1: [](!a:_(T) @array:81:22, idx:int @array:81:30, x:T @array:81:39):
    inbounds(a @array:82:14, idx @array:82:17)
    unsafe_update(!a @array:83:20, idx @array:83:23, x @array:83:28)


[|] > public {test} (0 calls)
0: [|](?head:T @array:51:23, ?tail:_(T) @array:51:32, a:_(T) @array:51:43):
    array(?length @array:52:12, ?data @array:52:21, a @array:52:29)
    >(length @array:53:6, 0 @array:53:15)
    word_size_bytes(?tmp#0 @array:54:34)
    foreign lpvm access(data @array:54:25, 0 @array:54:31, tmp#0, 0 @array:54:51, ?head @array:54:55)
    word_size_bytes(?tmp#1 @array:55:28)
    foreign llvm add(data @array:55:22, tmp#1, ?data @array:55:46)
    -(length @array:56:19, 1 @array:56:28, ?tmp#3 @array:56:19)
    array(tmp#3, data @array:56:31, ?tmp#2 @array:56:13)
    =(?tail @array:56:6, tmp#2)


array > public (0 calls)
0: array(x:T @array:18:15, len:int @array:18:20, ?#result:_(T) @array:18:5):
    word_size_bytes(?tmp#1 @array:19:19)
    *(len @array:19:13, tmp#1, ?tmp#0 @array:19:13)
    =(?size @array:19:6, tmp#0)
    foreign lpvm alloc(size @array:20:24, ?data @array:20:31)
    =(?offset @array:21:6, 0 @array:21:15)
    do {
        if {<(offset @array:23:15, size @array:23:24)::

            pass
        else::
            break

        }
        foreign lpvm mutate(data @array:24:29, ?data @array:24:36, offset @array:24:42, 1 @array:24:50, size @array:24:53, 0 @array:24:59, x @array:24:62)
        word_size_bytes(?tmp#2 @array:25:21)
        +=(!offset @array:25:10, tmp#2)
    }
    array(len @array:27:17, data @array:27:22, ?tmp#3 @array:27:11)
    =(?ar @array:27:6, tmp#3)
    foreign llvm move(ar @array:18:36, ?#result @array:18:5)
array > public (0 calls)
1: array(ls:list(T) @array:34:15, ?#result:_(T) @array:34:5):
    length(ls @array:35:19, ?tmp#0 @array:35:12)
    =(?len @array:35:6, tmp#0)
    word_size_bytes(?tmp#2 @array:36:19)
    *(len @array:36:13, tmp#2, ?tmp#1 @array:36:13)
    =(?size @array:36:6, tmp#1)
    foreign lpvm alloc(size @array:37:24, ?data @array:37:31)
    =(?offset @array:38:6, 0 @array:38:15)
    foreign llvm move(ls @array:39:15, ?tmp#3)
    do {
        if {[|](?x @array:39:10, ?tmp#3, tmp#3)::

            foreign lpvm mutate(data @array:40:29, ?data @array:40:36, offset @array:40:42, 1 @array:40:50, size @array:40:53, 0 @array:40:59, x @array:40:62)
            word_size_bytes(?tmp#4 @array:41:21)
            +=(!offset @array:41:10, tmp#4)
        else::
            break

        }
    }
    array(len @array:43:17, data @array:43:22, ?tmp#5 @array:43:11)
    =(?ar @array:43:6, tmp#5)
    foreign llvm move(ar @array:34:34, ?#result @array:34:5)


inbounds > public {test,inline} (0 calls)
0: inbounds(a:_(T) @array:60:33, idx:int @array:60:41):
    <=(0 @array:61:6, idx @array:61:12)
    length(a @array:62:12, ?tmp#0 @array:62:12)
    <(idx @array:62:6, tmp#0)


unsafe_get > public {inline} (0 calls)
0: unsafe_get(a:_(T) @array:75:29, idx:int @array:75:37, ?#result:T @array:75:5):
    raw_data(a @array:76:25, ?tmp#0 @array:76:25)
    word_size_bytes(?tmp#2 @array:76:43)
    *(idx @array:76:37, tmp#2, ?tmp#1 @array:76:37)
    word_size_bytes(?tmp#3 @array:76:60)
    foreign lpvm access(tmp#0, tmp#1, tmp#3, 0 @array:76:77, ?x @array:76:81)
    foreign llvm move(x @array:75:50, ?#result @array:75:5)


unsafe_update > public {inline} (0 calls)
0: unsafe_update(!a:_(T) @array:89:33, idx:int @array:89:41, x:T @array:89:50):
    raw_data(a @array:90:25, ?tmp#0 @array:90:25)
    word_size_bytes(?tmp#2 @array:90:50)
    *(idx @array:90:44, tmp#2, ?tmp#1 @array:90:44)
    length(a @array:91:44, ?tmp#4 @array:91:44)
    word_size_bytes(?tmp#5 @array:91:55)
    *(tmp#4, tmp#5, ?tmp#3 @array:91:44)
    foreign lpvm mutate(tmp#0, ?data @array:90:38, tmp#1, 0 @array:90:67, tmp#3, 0 @array:91:72, x @array:91:75)
    raw_data(!a @array:92:6, data @array:92:19)

LLVM code       : None

--------------------------------------------------
 Module wybe.array.raw_array(T)
  representation  : address
  public submods  : 
  public resources: 
  public procs    : 
  imports         : use wybe
                    use wybe.array
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.bool
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.bool.&&<0>
                    wybe.bool.&=<0>
                    wybe.bool.=<0>
                    wybe.bool.^=<0>
                    wybe.bool.^^<0>
                    wybe.bool.print<0>
                    wybe.bool.println<0>
                    wybe.bool.succeed<0>
                    wybe.bool.|=<0>
                    wybe.bool.||<0>
                    wybe.bool.~<0>
                    wybe.bool.~=<0>
  imports         : use wybe.c_string
                    use wybe.io
  resources       : 
  procs           : 

&& > public (0 calls)
0: &&(p:_ @bool:13:10, q:_ @bool:13:18, ?#result:_ @bool:13:5):
    foreign llvm and(p @bool:13:44, q @bool:13:47, ?tmp#0 @bool:13:27)
    foreign llvm move(tmp#0, ?#result @bool:13:5)


&= > public (0 calls)
0: &=(!p:_ @bool:16:11, q:_ @bool:16:19):
    &&(p @bool:16:32, q @bool:16:38, ?tmp#0 @bool:16:32)
    =(?p @bool:16:27, tmp#0)


= > public (0 calls)
0: =(x:_ @bool:37:10, y:_ @bool:37:17, ?#result:_ @bool:37:5):
    foreign llvm icmp_eq(x @bool:37:47, y @bool:37:50, ?tmp#0 @bool:37:26)
    foreign llvm move(tmp#0, ?#result @bool:37:5)


^= > public (0 calls)
0: ^=(!p:_ @bool:28:11, q:_ @bool:28:19):
    ^^(q @bool:28:31, p @bool:28:37, ?tmp#0 @bool:28:31)
    =(?p @bool:28:27, tmp#0)


^^ > public (0 calls)
0: ^^(p:_ @bool:25:10, q:_ @bool:25:18, ?#result:_ @bool:25:5):
    foreign llvm xor(p @bool:25:44, q @bool:25:47, ?tmp#0 @bool:25:27)
    foreign llvm move(tmp#0, ?#result @bool:25:5)


print > public (0 calls)
0: print(x:_ @bool:47:15) use !io:
    if {x::

        foreign llvm move(c"true" @bool:47:45, ?tmp#0)
    else::
        foreign llvm move(c"false" @bool:47:60, ?tmp#0)

    }
    !print(tmp#0 @bool:47:41)


println > public (0 calls)
0: println(x:_ @bool:49:17) use !io:
    !print(x @bool:49:39)
    !nl


succeed > public (0 calls)
0: succeed():
    pass


|= > public (0 calls)
0: |=(!p:_ @bool:22:11, q:_ @bool:22:19):
    ||(p @bool:22:32, q @bool:22:38, ?tmp#0 @bool:22:32)
    =(?p @bool:22:27, tmp#0)


|| > public (0 calls)
0: ||(p:_ @bool:19:10, q:_ @bool:19:18, ?#result:_ @bool:19:5):
    foreign llvm or(p @bool:19:43, q @bool:19:46, ?tmp#0 @bool:19:27)
    foreign llvm move(tmp#0, ?#result @bool:19:5)


~ > public (0 calls)
0: ~(p:_ @bool:31:11, ?#result:_ @bool:31:5):
    true(?tmp#1 @bool:31:40)
    foreign llvm xor(p @bool:31:37, tmp#1, ?tmp#0 @bool:31:20)
    foreign llvm move(tmp#0, ?#result @bool:31:5)


~= > public (0 calls)
0: ~=(x:_ @bool:38:10, y:_ @bool:38:18, ?#result:_ @bool:38:5):
    foreign llvm icmp_ne(x @bool:38:48, y @bool:38:51, ?tmp#0 @bool:38:27)
    foreign llvm move(tmp#0, ?#result @bool:38:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.c_string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.c_string.<<0>
                    wybe.c_string.<=<0>
                    wybe.c_string.=<0>
                    wybe.c_string.><0>
                    wybe.c_string.>=<0>
                    wybe.c_string.[]<0>
                    wybe.c_string.[|]<0>
                    wybe.c_string.length<0>
                    wybe.c_string.print<0>
                    wybe.c_string.println<0>
                    wybe.c_string.read<0>
                    wybe.c_string.unsafe_c_string_index<0>
                    wybe.c_string.~=<0>
  imports         : use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:_ @c_string:12:10, y:_ @c_string:12:17, ?#result:bool @c_string:12:5):
    foreign c strcmp(x @c_string:12:46, y @c_string:12:48, ?tmp#1:int @c_string:12:29)
    <(tmp#1:int, 0 @c_string:12:57, ?tmp#0 @c_string:12:29)
    foreign llvm move(tmp#0, ?#result @c_string:12:5)


<= > public (0 calls)
0: <=(x:_ @c_string:13:10, y:_ @c_string:13:18, ?#result:bool @c_string:13:5):
    foreign c strcmp(x @c_string:13:47, y @c_string:13:49, ?tmp#1:int @c_string:13:30)
    <=(tmp#1:int, 0 @c_string:13:60, ?tmp#0 @c_string:13:30)
    foreign llvm move(tmp#0, ?#result @c_string:13:5)


= > public (0 calls)
0: =(x:_ @c_string:10:10, y:_ @c_string:10:17, ?#result:bool @c_string:10:5):
    foreign c strcmp(x @c_string:10:46, y @c_string:10:48, ?tmp#1:int @c_string:10:29)
    =(tmp#1:int, 0 @c_string:10:57, ?tmp#0 @c_string:10:29)
    foreign llvm move(tmp#0, ?#result @c_string:10:5)


> > public (0 calls)
0: >(x:_ @c_string:14:10, y:_ @c_string:14:17, ?#result:bool @c_string:14:5):
    foreign c strcmp(x @c_string:14:46, y @c_string:14:48, ?tmp#1:int @c_string:14:29)
    >(tmp#1:int, 0 @c_string:14:57, ?tmp#0 @c_string:14:29)
    foreign llvm move(tmp#0, ?#result @c_string:14:5)


>= > public (0 calls)
0: >=(x:_ @c_string:15:10, y:_ @c_string:15:18, ?#result:bool @c_string:15:5):
    foreign c strcmp(x @c_string:15:47, y @c_string:15:49, ?tmp#1:int @c_string:15:30)
    >=(tmp#1:int, 0 @c_string:15:60, ?tmp#0 @c_string:15:30)
    foreign llvm move(tmp#0, ?#result @c_string:15:5)


[] > public {test} (0 calls)
0: [](str:_ @c_string:26:19, idx:int @c_string:26:26, ?#result:char @c_string:26:5):
    <=(0 @c_string:27:6, idx @c_string:27:12)
    length(str @c_string:28:19, ?tmp#0 @c_string:28:12)
    <(idx @c_string:28:6, tmp#0)
    unsafe_c_string_index(str @c_string:29:32, idx @c_string:29:37, ?tmp#1 @c_string:29:10)
    =(?c @c_string:29:6, tmp#1)
    foreign llvm move(c @c_string:26:42, ?#result @c_string:26:5)


[|] > public {test} (0 calls)
0: [|](?head:char @c_string:19:23, ?tail:_ @c_string:19:35, str:_ @c_string:19:43):
    foreign lpvm access(str @c_string:20:25, 0 @c_string:20:30, 0 @c_string:20:33, 0 @c_string:20:36, ?head @c_string:20:40)
    foreign llvm icmp_ne(head @c_string:21:26, '\NUL' @c_string:21:32, ?not_done @c_string:21:37)
    true(?tmp#0 @c_string:22:17)
    =(not_done @c_string:22:6, tmp#0)
    foreign llvm add(str @c_string:23:22, 1 @c_string:23:27, ?tail @c_string:23:31)


length > public (0 calls)
0: length(str:_ @c_string:17:16, ?#result:int @c_string:17:5):
    foreign c strlen(str @c_string:17:46, ?tmp#0 @c_string:17:29)
    foreign llvm move(tmp#0, ?#result @c_string:17:5)


print > public (0 calls)
0: print(x:_ @c_string:35:15) use !io:
    foreign c print_string(x @c_string:35:53, !io @c_string:35:57)


println > public (0 calls)
0: println(x:_ @c_string:37:17) use !io:
    !print(x @c_string:37:39)
    !nl


read > public (0 calls)
0: read(?x:_ @c_string:39:15) use !io:
    foreign c read_line(?x @c_string:39:51, !io @c_string:39:55)


unsafe_c_string_index > public (0 calls)
0: unsafe_c_string_index(str:_ @c_string:32:31, idx:int @c_string:32:38, ?#result:char @c_string:32:5):
    foreign lpvm access(str @c_string:33:27, idx @c_string:33:32, 1 @c_string:33:37, 0 @c_string:33:40, ?tmp#0 @c_string:33:7)
    foreign llvm move(tmp#0, ?#result @c_string:32:5)


~= > public (0 calls)
0: ~=(x:_ @c_string:11:10, y:_ @c_string:11:18, ?#result:bool @c_string:11:5):
    foreign c strcmp(x @c_string:11:47, y @c_string:11:49, ?tmp#1:int @c_string:11:30)
    ~=(tmp#1:int, 0 @c_string:11:60, ?tmp#0 @c_string:11:30)
    foreign llvm move(tmp#0, ?#result @c_string:11:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.char
  representation  : 8 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.char.<<0>
                    wybe.char.<=<0>
                    wybe.char.<=><0>
                    wybe.char.=<0>
                    wybe.char.><0>
                    wybe.char.>=<0>
                    wybe.char.chr<0>
                    wybe.char.ord<0>
                    wybe.char.print<0>
                    wybe.char.println<0>
                    wybe.char.read<0>
                    wybe.char.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:_ @char:17:10, y:_ @char:17:17, ?#result:bool @char:17:5):
    foreign llvm icmp_ult(x @char:17:51, y @char:17:54, ?tmp#0 @char:17:29)
    foreign llvm move(tmp#0, ?#result @char:17:5)


<= > public (0 calls)
0: <=(x:_ @char:18:10, y:_ @char:18:18, ?#result:bool @char:18:5):
    foreign llvm icmp_ule(x @char:18:52, y @char:18:55, ?tmp#0 @char:18:30)
    foreign llvm move(tmp#0, ?#result @char:18:5)


<=> > public (0 calls)
0: <=>(x:_ @char:23:10, y:_ @char:23:20, ?#result:comparison @char:23:5):
    if {<(x @char:24:10, y @char:24:14)::

        lesser(?tmp#1 @char:24:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @char:24:28, y @char:24:32)::

            equal(?tmp#3 @char:24:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @char:24:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @char:24:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @char:24:10, ?#result @char:23:5)


= > public (0 calls)
0: =(x:_ @char:13:10, y:_ @char:13:17, ?#result:bool @char:13:5):
    foreign llvm icmp_eq(x @char:13:50, y @char:13:53, ?tmp#0 @char:13:29)
    foreign llvm move(tmp#0, ?#result @char:13:5)


> > public (0 calls)
0: >(x:_ @char:19:10, y:_ @char:19:17, ?#result:bool @char:19:5):
    foreign llvm icmp_ugt(x @char:19:51, y @char:19:54, ?tmp#0 @char:19:29)
    foreign llvm move(tmp#0, ?#result @char:19:5)


>= > public (0 calls)
0: >=(x:_ @char:20:10, y:_ @char:20:18, ?#result:bool @char:20:5):
    foreign llvm icmp_uge(x @char:20:52, y @char:20:55, ?tmp#0 @char:20:30)
    foreign llvm move(tmp#0, ?#result @char:20:5)


chr > public {test} (0 calls)
0: chr(i:int @char:33:20, ?#result:_ @char:33:5):
    <=(0 @char:33:60, i @char:33:66)
    <=(i @char:33:70, 255 @char:33:76)
    foreign lpvm cast(i @char:33:49, ?tmp#0 @char:33:31)
    foreign llvm move(tmp#0, ?#result @char:33:5)


ord > public (0 calls)
0: ord(c:_ @char:30:13, ?#result:int @char:30:5):
    foreign lpvm cast(c @char:30:42, ?tmp#0 @char:30:24)
    foreign llvm move(tmp#0, ?#result @char:30:5)


print > public (0 calls)
0: print(x:_ @char:37:15) use !io:
    foreign c putchar(x @char:37:48, !io @char:37:52)


println > public (0 calls)
0: println(x:_ @char:39:17) use !io:
    !print(x @char:39:39)
    !nl


read > public (0 calls)
0: read(?x:_ @char:41:15) use !io:
    foreign c read_char(?x @char:41:51, !io @char:41:55)


~= > public (0 calls)
0: ~=(x:_ @char:14:10, y:_ @char:14:18, ?#result:bool @char:14:5):
    foreign llvm icmp_ne(x @char:14:51, y @char:14:54, ?tmp#0 @char:14:30)
    foreign llvm move(tmp#0, ?#result @char:14:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.comparison
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.comparison.<<0>
                    wybe.comparison.<=<0>
                    wybe.comparison.=<0>
                    wybe.comparison.><0>
                    wybe.comparison.>=<0>
                    wybe.comparison.~=<0>
  imports         : use wybe.bool
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:_ @comparison:12:10, y:_ @comparison:12:17, ?#result:bool @comparison:12:5):
    foreign llvm icmp_ult(x @comparison:12:51, y @comparison:12:54, ?tmp#0 @comparison:12:29)
    foreign llvm move(tmp#0, ?#result @comparison:12:5)


<= > public (0 calls)
0: <=(x:_ @comparison:13:10, y:_ @comparison:13:18, ?#result:bool @comparison:13:5):
    foreign llvm icmp_ule(x @comparison:13:52, y @comparison:13:55, ?tmp#0 @comparison:13:30)
    foreign llvm move(tmp#0, ?#result @comparison:13:5)


= > public (0 calls)
0: =(x:_ @comparison:10:10, y:_ @comparison:10:17, ?#result:bool @comparison:10:5):
    foreign llvm icmp_eq(x @comparison:10:50, y @comparison:10:53, ?tmp#0 @comparison:10:29)
    foreign llvm move(tmp#0, ?#result @comparison:10:5)


> > public (0 calls)
0: >(x:_ @comparison:14:10, y:_ @comparison:14:17, ?#result:bool @comparison:14:5):
    foreign llvm icmp_ugt(x @comparison:14:51, y @comparison:14:54, ?tmp#0 @comparison:14:29)
    foreign llvm move(tmp#0, ?#result @comparison:14:5)


>= > public (0 calls)
0: >=(x:_ @comparison:15:10, y:_ @comparison:15:18, ?#result:bool @comparison:15:5):
    foreign llvm icmp_uge(x @comparison:15:52, y @comparison:15:55, ?tmp#0 @comparison:15:30)
    foreign llvm move(tmp#0, ?#result @comparison:15:5)


~= > public (0 calls)
0: ~=(x:_ @comparison:11:10, y:_ @comparison:11:18, ?#result:bool @comparison:11:5):
    foreign llvm icmp_ne(x @comparison:11:51, y @comparison:11:54, ?tmp#0 @comparison:11:30)
    foreign llvm move(tmp#0, ?#result @comparison:11:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.control
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.control.assert<0>
                    wybe.control.error<0>
                    wybe.control.error<1>
                    wybe.control.exit<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.int
                    use wybe.string
  resources       : 
  procs           : 

assert > public {semipure} (0 calls)
0: assert(condition:bool @control:26:27) use call_source_location:
    if {~(condition @control:27:11)::

        !error(c"assertion failed" @control:27:31)
    else::
        pass

    }


error > public {terminal,semipure} (0 calls)
0: error(message:string @control:17:35) use call_source_location:
    c_string(message @control:18:77, ?tmp#0 @control:18:68)
    foreign c {terminal,semipure} error_exit(call_source_location @control:18:46, tmp#0)
error > public {terminal,semipure} (0 calls)
1: error(message:c_string @control:21:35) use call_source_location:
    foreign c {terminal,semipure} error_exit(call_source_location @control:22:46, message @control:22:68)


exit > public {terminal,semipure} (0 calls)
0: exit(code:int @control:10:34):
    foreign c {terminal,semipure} exit(code @control:11:40)

LLVM code       : None

--------------------------------------------------
 Module wybe.count
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.count.%<0>
                    wybe.count.%=<0>
                    wybe.count.*<0>
                    wybe.count.*=<0>
                    wybe.count.+<0>
                    wybe.count.+<1>
                    wybe.count.+<2>
                    wybe.count.+=<0>
                    wybe.count.-<0>
                    wybe.count.-<1>
                    wybe.count.-<2>
                    wybe.count.-=<0>
                    wybe.count./<0>
                    wybe.count./=<0>
                    wybe.count.<<0>
                    wybe.count.<=<0>
                    wybe.count.<=><0>
                    wybe.count.=<0>
                    wybe.count.><0>
                    wybe.count.>=<0>
                    wybe.count.decr<0>
                    wybe.count.incr<0>
                    wybe.count.max<0>
                    wybe.count.min<0>
                    wybe.count.print<0>
                    wybe.count.println<0>
                    wybe.count.read<0>
                    wybe.count.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public (0 calls)
0: %(x:_ @count:51:10, y:_ @count:51:16, ?#result:_ @count:51:5):
    foreign llvm urem(x @count:51:43, y @count:51:45, ?tmp#0 @count:51:25)
    foreign llvm move(tmp#0, ?#result @count:51:5)


%= > public (0 calls)
0: %=(!x:_ @count:54:11, y:_ @count:54:19):
    %(x @count:54:31, y @count:54:35, ?tmp#0 @count:54:31)
    =(?x @count:54:27, tmp#0)


* > public (0 calls)
0: *(x:_ @count:39:10, y:_ @count:39:16, ?#result:_ @count:39:5):
    foreign llvm mul(x @count:39:42, y @count:39:44, ?tmp#0 @count:39:25)
    foreign llvm move(tmp#0, ?#result @count:39:5)


*= > public (0 calls)
0: *=(!x:_ @count:42:11, y:_ @count:42:19):
    *(x @count:42:31, y @count:42:35, ?tmp#0 @count:42:31)
    =(?x @count:42:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @count:15:10, y:_ @count:15:16, ?#result:_ @count:15:5):
    foreign llvm add(x @count:15:42, y @count:15:44, ?tmp#0 @count:15:25)
    foreign llvm move(tmp#0, ?#result @count:15:5)
+ > public {test} (0 calls)
1: +(?x:_ @count:16:21, y:_ @count:16:27, z:_ @count:16:5):
    >=(z @count:17:5, y @count:17:11)
    foreign llvm sub(z @count:18:27, y @count:18:29, ?tmp#0 @count:18:10)
    =(?x @count:18:6, tmp#0)
+ > public {test} (0 calls)
2: +(x:_ @count:20:20, ?y:_ @count:20:27, z:_ @count:20:5):
    >=(z @count:21:5, x @count:21:11)
    foreign llvm sub(z @count:22:27, x @count:22:29, ?tmp#0 @count:22:10)
    =(?y @count:22:6, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @count:26:11, y:_ @count:26:19):
    +(x @count:26:31, y @count:26:35, ?tmp#0 @count:26:31)
    =(?x @count:26:27, tmp#0)


- > public {test} (0 calls)
0: -(x:_ @count:31:20, y:_ @count:31:26, ?#result:_ @count:31:5):
    >=(y @count:31:65, x @count:31:71)
    foreign llvm sub(x @count:31:52, y @count:31:54, ?tmp#0 @count:31:35)
    foreign llvm move(tmp#0, ?#result @count:31:5)
- > public (0 calls)
1: -(?x:_ @count:32:11, y:_ @count:32:17, z:_ @count:32:5):
    foreign llvm add(z @count:32:59, y @count:32:61, ?tmp#0 @count:32:42)
    =(?x @count:32:38, tmp#0)
- > public (0 calls)
2: -(x:_ @count:33:10, ?y:_ @count:33:17, z:_ @count:33:5):
    foreign llvm sub(z @count:33:59, x @count:33:61, ?tmp#0 @count:33:42)
    =(?y @count:33:38, tmp#0)


-= > public {test} (0 calls)
0: -=(!x:_ @count:36:21, y:_ @count:36:29):
    -(x @count:36:41, y @count:36:45, ?tmp#0 @count:36:41)
    =(?x @count:36:37, tmp#0)


/ > public (0 calls)
0: /(x:_ @count:45:10, y:_ @count:45:16, ?#result:_ @count:45:5):
    foreign llvm udiv(x @count:45:43, y @count:45:45, ?tmp#0 @count:45:25)
    foreign llvm move(tmp#0, ?#result @count:45:5)


/= > public (0 calls)
0: /=(!x:_ @count:48:11, y:_ @count:48:19):
    /(x @count:48:31, y @count:48:35, ?tmp#0 @count:48:31)
    =(?x @count:48:27, tmp#0)


< > public (0 calls)
0: <(x:_ @count:64:10, y:_ @count:64:17, ?#result:bool @count:64:5):
    foreign llvm icmp_ult(x @count:64:51, y @count:64:53, ?tmp#0 @count:64:29)
    foreign llvm move(tmp#0, ?#result @count:64:5)


<= > public (0 calls)
0: <=(x:_ @count:65:10, y:_ @count:65:18, ?#result:bool @count:65:5):
    foreign llvm icmp_ule(x @count:65:52, y @count:65:54, ?tmp#0 @count:65:30)
    foreign llvm move(tmp#0, ?#result @count:65:5)


<=> > public (0 calls)
0: <=>(x:_ @count:70:10, y:_ @count:70:20, ?#result:comparison @count:70:5):
    if {<(x @count:71:10, y @count:71:14)::

        lesser(?tmp#1 @count:71:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @count:71:28, y @count:71:32)::

            equal(?tmp#3 @count:71:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @count:71:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @count:71:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:71:10, ?#result @count:70:5)


= > public (0 calls)
0: =(x:_ @count:60:10, y:_ @count:60:17, ?#result:bool @count:60:5):
    foreign llvm icmp_eq(x @count:60:50, y @count:60:52, ?tmp#0 @count:60:29)
    foreign llvm move(tmp#0, ?#result @count:60:5)


> > public (0 calls)
0: >(x:_ @count:66:10, y:_ @count:66:17, ?#result:bool @count:66:5):
    foreign llvm icmp_ugt(x @count:66:51, y @count:66:53, ?tmp#0 @count:66:29)
    foreign llvm move(tmp#0, ?#result @count:66:5)


>= > public (0 calls)
0: >=(x:_ @count:67:10, y:_ @count:67:18, ?#result:bool @count:67:5):
    foreign llvm icmp_uge(x @count:67:52, y @count:67:54, ?tmp#0 @count:67:30)
    foreign llvm move(tmp#0, ?#result @count:67:5)


decr > public {test} (0 calls)
0: decr(!x:_ @count:84:25):
    -(x @count:84:37, 1:_ @count:84:41, ?tmp#0 @count:84:37)
    =(?x @count:84:33, tmp#0)


incr > public (0 calls)
0: incr(!x:_ @count:81:15):
    +(x @count:81:27, 1:_ @count:81:31, ?tmp#0 @count:81:27)
    =(?x @count:81:23, tmp#0)


max > public (0 calls)
0: max(x:_ @count:75:13, y:_ @count:75:18, ?#result:_ @count:75:5):
    if {>=(x @count:75:31, y @count:75:35)::

        foreign llvm move(x @count:75:39, ?tmp#0)
    else::
        foreign llvm move(y @count:75:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:75:31, ?#result @count:75:5)


min > public (0 calls)
0: min(x:_ @count:74:13, y:_ @count:74:18, ?#result:_ @count:74:5):
    if {<=(x @count:74:31, y @count:74:35)::

        foreign llvm move(x @count:74:39, ?tmp#0)
    else::
        foreign llvm move(y @count:74:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:74:31, ?#result @count:74:5)


print > public (0 calls)
0: print(x:_ @count:88:15) use !io:
    foreign c print_count(x @count:88:52, !io @count:88:56)


println > public (0 calls)
0: println(x:_ @count:90:17) use !io:
    !print(x @count:90:39)
    !nl


read > public (0 calls)
0: read(?x:_ @count:92:15) use !io:
    foreign c read_count(?x @count:92:52, !io @count:92:56)


~= > public (0 calls)
0: ~=(x:_ @count:61:10, y:_ @count:61:18, ?#result:bool @count:61:5):
    foreign llvm icmp_ne(x @count:61:51, y @count:61:53, ?tmp#0 @count:61:30)
    foreign llvm move(tmp#0, ?#result @count:61:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.float
  representation  : 64 bit float
  public submods  : 
  public resources: 
  public procs    : wybe.float.*<0>
                    wybe.float.**<0>
                    wybe.float.*=<0>
                    wybe.float.+<0>
                    wybe.float.+<1>
                    wybe.float.+<2>
                    wybe.float.+=<0>
                    wybe.float.-<0>
                    wybe.float.-<1>
                    wybe.float.-<2>
                    wybe.float.-<3>
                    wybe.float.-<4>
                    wybe.float.-=<0>
                    wybe.float./<0>
                    wybe.float./=<0>
                    wybe.float.<<0>
                    wybe.float.<=<0>
                    wybe.float.<=><0>
                    wybe.float.=<0>
                    wybe.float.><0>
                    wybe.float.>=<0>
                    wybe.float.abs<0>
                    wybe.float.ceil<0>
                    wybe.float.cos<0>
                    wybe.float.e<0>
                    wybe.float.exp<0>
                    wybe.float.floor<0>
                    wybe.float.iceil<0>
                    wybe.float.ifloor<0>
                    wybe.float.iround<0>
                    wybe.float.log<0>
                    wybe.float.log10<0>
                    wybe.float.log2<0>
                    wybe.float.max<0>
                    wybe.float.min<0>
                    wybe.float.pi<0>
                    wybe.float.power<0>
                    wybe.float.print<0>
                    wybe.float.println<0>
                    wybe.float.read<0>
                    wybe.float.round<0>
                    wybe.float.sin<0>
                    wybe.float.sqrt<0>
                    wybe.float.square<0>
                    wybe.float.tan<0>
                    wybe.float.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

* > public (0 calls)
0: *(x:_ @float:45:10, y:_ @float:45:16, ?#result:_ @float:45:5):
    foreign llvm fmul(x @float:45:43, y @float:45:45, ?tmp#0 @float:45:25)
    foreign llvm move(tmp#0, ?#result @float:45:5)


** > public (0 calls)
0: **(x:_ @float:112:10, n:_ @float:112:18, ?#result:_ @float:112:5):
    foreign c llvm.pow.f64(x @float:112:52, n @float:112:54, ?tmp#0 @float:112:27)
    foreign llvm move(tmp#0, ?#result @float:112:5)


*= > public (0 calls)
0: *=(!x:_ @float:48:11, y:_ @float:48:19):
    *(x @float:48:31, y @float:48:35, ?tmp#0 @float:48:31)
    =(?x @float:48:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @float:23:10, y:_ @float:23:17, ?#result:_ @float:23:5):
    foreign llvm fadd(x @float:23:45, y @float:23:47, ?tmp#0 @float:23:27)
    foreign llvm move(tmp#0, ?#result @float:23:5)
+ > public (0 calls)
1: +(?x:_ @float:24:11, y:_ @float:24:17, z:_ @float:24:5):
    foreign llvm fsub(z @float:24:61, y @float:24:63, ?tmp#0 @float:24:43)
    =(?x @float:24:39, tmp#0)
+ > public (0 calls)
2: +(x:_ @float:25:10, ?y:_ @float:25:18, z:_ @float:25:5):
    foreign llvm fsub(z @float:25:61, x @float:25:63, ?tmp#0 @float:25:43)
    =(?y @float:25:39, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @float:28:11, y:_ @float:28:19):
    +(x @float:28:31, y @float:28:35, ?tmp#0 @float:28:31)
    =(?x @float:28:27, tmp#0)


- > public (0 calls)
0: -(x:_ @float:32:10, y:_ @float:32:17, ?#result:_ @float:32:5):
    foreign llvm fsub(x @float:32:45, y @float:32:47, ?tmp#0 @float:32:27)
    foreign llvm move(tmp#0, ?#result @float:32:5)
- > public (0 calls)
1: -(?x:_ @float:33:11, y:_ @float:33:17, z:_ @float:33:5):
    foreign llvm fadd(z @float:33:61, y @float:33:63, ?tmp#0 @float:33:43)
    =(?x @float:33:39, tmp#0)
- > public (0 calls)
2: -(x:_ @float:34:10, ?y:_ @float:34:18, z:_ @float:34:5):
    foreign llvm fsub(z @float:34:61, x @float:34:63, ?tmp#0 @float:34:43)
    =(?y @float:34:39, tmp#0)
- > public (0 calls)
3: -(x:_ @float:38:11, ?#result:_ @float:38:5):
    foreign llvm fsub(0.0 @float:38:39, x @float:38:43, ?tmp#0 @float:38:21)
    foreign llvm move(tmp#0, ?#result @float:38:5)
- > public (0 calls)
4: -(?x:_ @float:39:12, y:_ @float:39:5):
    foreign llvm fsub(0.0 @float:39:55, y @float:39:59, ?tmp#0 @float:39:37)
    =(?x @float:39:33, tmp#0)


-= > public (0 calls)
0: -=(!x:_ @float:42:11, y:_ @float:42:19):
    -(x @float:42:31, y @float:42:35, ?tmp#0 @float:42:31)
    =(?x @float:42:27, tmp#0)


/ > public (0 calls)
0: /(x:_ @float:51:10, y:_ @float:51:16, ?#result:_ @float:51:5):
    foreign llvm fdiv(x @float:51:43, y @float:51:45, ?tmp#0 @float:51:25)
    foreign llvm move(tmp#0, ?#result @float:51:5)


/= > public (0 calls)
0: /=(!x:_ @float:54:11, y:_ @float:54:19):
    /(x @float:54:31, y @float:54:35, ?tmp#0 @float:54:31)
    =(?x @float:54:27, tmp#0)


< > public (0 calls)
0: <(x:_ @float:70:10, y:_ @float:70:17, ?#result:bool @float:70:5):
    foreign llvm fcmp_slt(x @float:70:51, y @float:70:53, ?tmp#0 @float:70:29)
    foreign llvm move(tmp#0, ?#result @float:70:5)


<= > public (0 calls)
0: <=(x:_ @float:71:10, y:_ @float:71:18, ?#result:bool @float:71:5):
    foreign llvm fcmp_sle(x @float:71:52, y @float:71:54, ?tmp#0 @float:71:30)
    foreign llvm move(tmp#0, ?#result @float:71:5)


<=> > public (0 calls)
0: <=>(x:_ @float:76:10, y:_ @float:76:20, ?#result:comparison @float:76:5):
    if {<(x @float:77:10, y @float:77:14)::

        lesser(?tmp#1 @float:77:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @float:77:28, y @float:77:32)::

            equal(?tmp#3 @float:77:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @float:77:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @float:77:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @float:77:10, ?#result @float:76:5)


= > public (0 calls)
0: =(x:_ @float:66:10, y:_ @float:66:17, ?#result:bool @float:66:5):
    foreign llvm fcmp_eq(x @float:66:50, y @float:66:52, ?tmp#0 @float:66:29)
    foreign llvm move(tmp#0, ?#result @float:66:5)


> > public (0 calls)
0: >(x:_ @float:72:10, y:_ @float:72:17, ?#result:bool @float:72:5):
    foreign llvm fcmp_sgt(x @float:72:51, y @float:72:53, ?tmp#0 @float:72:29)
    foreign llvm move(tmp#0, ?#result @float:72:5)


>= > public (0 calls)
0: >=(x:_ @float:73:10, y:_ @float:73:18, ?#result:bool @float:73:5):
    foreign llvm fcmp_sge(x @float:73:52, y @float:73:54, ?tmp#0 @float:73:30)
    foreign llvm move(tmp#0, ?#result @float:73:5)


abs > public (0 calls)
0: abs(x:_ @float:60:13, ?#result:_ @float:60:5):
    foreign c llvm.fabs.f64(x @float:60:48, ?tmp#0 @float:60:22)
    foreign llvm move(tmp#0, ?#result @float:60:5)


ceil > public (0 calls)
0: ceil(x:_ @float:87:14, ?#result:_ @float:87:5):
    foreign c llvm.ceil.f64(x @float:87:49, ?tmp#0 @float:87:23)
    foreign llvm move(tmp#0, ?#result @float:87:5)


cos > public (0 calls)
0: cos(x:_ @float:116:13, ?#result:_ @float:116:5):
    foreign c llvm.cos.f64(x @float:116:47, ?tmp#0 @float:116:22)
    foreign llvm move(tmp#0, ?#result @float:116:5)


e > public (0 calls)
0: e(?#result:_ @float:16:5):
    foreign llvm move(2.7182818284590455 @float:16:15, ?#result @float:16:5)


exp > public (0 calls)
0: exp(x:_ @float:120:13, ?#result:_ @float:120:5):
    foreign c llvm.exp.f64(x @float:120:47, ?tmp#0 @float:120:22)
    foreign llvm move(tmp#0, ?#result @float:120:5)


floor > public (0 calls)
0: floor(x:_ @float:90:15, ?#result:_ @float:90:5):
    foreign c llvm.floor.f64(x @float:90:51, ?tmp#0 @float:90:24)
    foreign llvm move(tmp#0, ?#result @float:90:5)


iceil > public (0 calls)
0: iceil(x:_ @float:99:15, ?#result:int @float:99:5):
    ceil(x @float:99:51, ?tmp#1 @float:99:46)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:99:26)
    foreign llvm move(tmp#0, ?#result @float:99:5)


ifloor > public (0 calls)
0: ifloor(x:_ @float:102:16, ?#result:int @float:102:5):
    floor(x @float:102:53, ?tmp#1 @float:102:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:102:27)
    foreign llvm move(tmp#0, ?#result @float:102:5)


iround > public (0 calls)
0: iround(x:_ @float:96:16, ?#result:int @float:96:5):
    round(x @float:96:53, ?tmp#1 @float:96:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:96:27)
    foreign llvm move(tmp#0, ?#result @float:96:5)


log > public (0 calls)
0: log(x:_ @float:123:13, ?#result:_ @float:123:5):
    foreign c llvm.log.f64(x @float:123:47, ?tmp#0 @float:123:22)
    foreign llvm move(tmp#0, ?#result @float:123:5)


log10 > public (0 calls)
0: log10(x:_ @float:126:15, ?#result:_ @float:126:5):
    foreign c llvm.log10.f64(x @float:126:51, ?tmp#0 @float:126:24)
    foreign llvm move(tmp#0, ?#result @float:126:5)


log2 > public (0 calls)
0: log2(x:_ @float:129:14, ?#result:_ @float:129:5):
    foreign c llvm.log2.f64(x @float:129:49, ?tmp#0 @float:129:23)
    foreign llvm move(tmp#0, ?#result @float:129:5)


max > public (0 calls)
0: max(x:_ @float:81:13, y:_ @float:81:18, ?#result:_ @float:81:5):
    foreign c llvm.maxnum.f64(x @float:81:55, y @float:81:57, ?tmp#0 @float:81:27)
    foreign llvm move(tmp#0, ?#result @float:81:5)


min > public (0 calls)
0: min(x:_ @float:80:13, y:_ @float:80:18, ?#result:_ @float:80:5):
    foreign c llvm.minnum.f64(x @float:80:55, y @float:80:57, ?tmp#0 @float:80:27)
    foreign llvm move(tmp#0, ?#result @float:80:5)


pi > public (0 calls)
0: pi(?#result:_ @float:13:5):
    foreign llvm move(3.141592653589793 @float:13:16, ?#result @float:13:5)


power > public (0 calls)
0: power(x:_ @float:111:15, n:_ @float:111:19, ?#result:_ @float:111:5):
    foreign c llvm.pow.f64(x @float:111:53, n @float:111:55, ?tmp#0 @float:111:28)
    foreign llvm move(tmp#0, ?#result @float:111:5)


print > public (0 calls)
0: print(x:_ @float:133:15) use !io:
    foreign c print_float(x @float:133:52, !io @float:133:56)


println > public (0 calls)
0: println(x:_ @float:135:17) use !io:
    !print(x @float:135:39)
    !nl


read > public (0 calls)
0: read(?x:_ @float:137:15) use !io:
    foreign c read_float(?x @float:137:52, !io @float:137:56)


round > public (0 calls)
0: round(x:_ @float:93:15, ?#result:_ @float:93:5):
    foreign c llvm.round.f64(x @float:93:51, ?tmp#0 @float:93:24)
    foreign llvm move(tmp#0, ?#result @float:93:5)


sin > public (0 calls)
0: sin(x:_ @float:115:13, ?#result:_ @float:115:5):
    foreign c llvm.sin.f64(x @float:115:47, ?tmp#0 @float:115:22)
    foreign llvm move(tmp#0, ?#result @float:115:5)


sqrt > public (0 calls)
0: sqrt(x:_ @float:108:14, ?#result:_ @float:108:5):
    foreign c llvm.sqrt.f64(x @float:108:49, ?tmp#0 @float:108:23)
    foreign llvm move(tmp#0, ?#result @float:108:5)


square > public (0 calls)
0: square(x:_ @float:57:16, ?#result:_ @float:57:5):
    foreign llvm fmul(x @float:57:43, x @float:57:45, ?tmp#0 @float:57:25)
    foreign llvm move(tmp#0, ?#result @float:57:5)


tan > public (0 calls)
0: tan(x:_ @float:117:13, ?#result:_ @float:117:5):
    foreign c llvm.sin.f64(x @float:117:47, ?tmp#1 @float:117:22)
    foreign c llvm.cos.f64(x @float:117:77, ?tmp#2 @float:117:52)
    /(tmp#1, tmp#2, ?tmp#0 @float:117:22)
    foreign llvm move(tmp#0, ?#result @float:117:5)


~= > public (0 calls)
0: ~=(x:_ @float:67:10, y:_ @float:67:18, ?#result:bool @float:67:5):
    foreign llvm fcmp_ne(x @float:67:51, y @float:67:53, ?tmp#0 @float:67:30)
    foreign llvm move(tmp#0, ?#result @float:67:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.int
  representation  : 64 bit signed
  public submods  : 
  public resources: 
  public procs    : wybe.int.%<0>
                    wybe.int.%=<0>
                    wybe.int.*<0>
                    wybe.int.*=<0>
                    wybe.int.+<0>
                    wybe.int.+<1>
                    wybe.int.+<2>
                    wybe.int.+=<0>
                    wybe.int.-<0>
                    wybe.int.-<1>
                    wybe.int.-<2>
                    wybe.int.-<3>
                    wybe.int.-<4>
                    wybe.int.-=<0>
                    wybe.int./<0>
                    wybe.int./=<0>
                    wybe.int.<<0>
                    wybe.int.<<<0>
                    wybe.int.<<=<0>
                    wybe.int.<=<0>
                    wybe.int.<=><0>
                    wybe.int.=<0>
                    wybe.int.><0>
                    wybe.int.>=<0>
                    wybe.int.>><0>
                    wybe.int.>>=<0>
                    wybe.int.decr<0>
                    wybe.int.incr<0>
                    wybe.int.logical_bitshift<0>
                    wybe.int.logical_bitshift<1>
                    wybe.int.max<0>
                    wybe.int.min<0>
                    wybe.int.power<0>
                    wybe.int.print<0>
                    wybe.int.println<0>
                    wybe.int.read<0>
                    wybe.int.signum<0>
                    wybe.int.sqrt<0>
                    wybe.int.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public (0 calls)
0: %(x:_ @int:50:10, y:_ @int:50:16, ?#result:_ @int:50:5):
    foreign llvm srem(x @int:50:43, y @int:50:45, ?tmp#0 @int:50:25)
    foreign llvm move(tmp#0, ?#result @int:50:5)


%= > public (0 calls)
0: %=(!x:_ @int:53:11, y:_ @int:53:19):
    %(x @int:53:31, y @int:53:35, ?tmp#0 @int:53:31)
    =(?x @int:53:27, tmp#0)


* > public (0 calls)
0: *(x:_ @int:38:10, y:_ @int:38:16, ?#result:_ @int:38:5):
    foreign llvm mul(x @int:38:42, y @int:38:44, ?tmp#0 @int:38:25)
    foreign llvm move(tmp#0, ?#result @int:38:5)


*= > public (0 calls)
0: *=(!x:_ @int:41:11, y:_ @int:41:19):
    *(x @int:41:31, y @int:41:35, ?tmp#0 @int:41:31)
    =(?x @int:41:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @int:16:10, y:_ @int:16:17, ?#result:_ @int:16:5):
    foreign llvm add(x @int:16:44, y @int:16:46, ?tmp#0 @int:16:27)
    foreign llvm move(tmp#0, ?#result @int:16:5)
+ > public (0 calls)
1: +(?x:_ @int:17:11, y:_ @int:17:17, z:_ @int:17:5):
    foreign llvm sub(z @int:17:60, y @int:17:62, ?tmp#0 @int:17:43)
    =(?x @int:17:39, tmp#0)
+ > public (0 calls)
2: +(x:_ @int:18:10, ?y:_ @int:18:18, z:_ @int:18:5):
    foreign llvm sub(z @int:18:60, x @int:18:62, ?tmp#0 @int:18:43)
    =(?y @int:18:39, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @int:21:11, y:_ @int:21:19):
    +(x @int:21:31, y @int:21:35, ?tmp#0 @int:21:31)
    =(?x @int:21:27, tmp#0)


- > public (0 calls)
0: -(x:_ @int:25:10, y:_ @int:25:17, ?#result:_ @int:25:5):
    foreign llvm sub(x @int:25:44, y @int:25:46, ?tmp#0 @int:25:27)
    foreign llvm move(tmp#0, ?#result @int:25:5)
- > public (0 calls)
1: -(?x:_ @int:26:11, y:_ @int:26:17, z:_ @int:26:5):
    foreign llvm add(z @int:26:60, y @int:26:62, ?tmp#0 @int:26:43)
    =(?x @int:26:39, tmp#0)
- > public (0 calls)
2: -(x:_ @int:27:10, ?y:_ @int:27:18, z:_ @int:27:5):
    foreign llvm sub(z @int:27:60, x @int:27:62, ?tmp#0 @int:27:43)
    =(?y @int:27:39, tmp#0)
- > public (0 calls)
3: -(x:_ @int:31:11, ?#result:_ @int:31:5):
    foreign llvm sub(0 @int:31:38, x @int:31:40, ?tmp#0 @int:31:21)
    foreign llvm move(tmp#0, ?#result @int:31:5)
- > public (0 calls)
4: -(?x:_ @int:32:12, y:_ @int:32:5):
    foreign llvm sub(0 @int:32:54, y @int:32:56, ?tmp#0 @int:32:37)
    =(?x @int:32:33, tmp#0)


-= > public (0 calls)
0: -=(!x:_ @int:35:11, y:_ @int:35:19):
    -(x @int:35:31, y @int:35:35, ?tmp#0 @int:35:31)
    =(?x @int:35:27, tmp#0)


/ > public (0 calls)
0: /(x:_ @int:44:10, y:_ @int:44:16, ?#result:_ @int:44:5):
    foreign llvm sdiv(x @int:44:43, y @int:44:45, ?tmp#0 @int:44:25)
    foreign llvm move(tmp#0, ?#result @int:44:5)


/= > public (0 calls)
0: /=(!x:_ @int:47:11, y:_ @int:47:19):
    /(x @int:47:31, y @int:47:35, ?tmp#0 @int:47:31)
    =(?x @int:47:27, tmp#0)


< > public (0 calls)
0: <(x:_ @int:87:10, y:_ @int:87:17, ?#result:bool @int:87:5):
    foreign llvm icmp_slt(x @int:87:51, y @int:87:53, ?tmp#0 @int:87:29)
    foreign llvm move(tmp#0, ?#result @int:87:5)


<< > public (0 calls)
0: <<(x:_ @int:56:10, s:_ @int:56:18, ?#result:_ @int:56:5):
    foreign llvm shl(x @int:56:44, s @int:56:47, ?tmp#0 @int:56:27)
    foreign llvm move(tmp#0, ?#result @int:56:5)


<<= > public (0 calls)
0: <<=(!x:_ @int:59:11, s:_ @int:59:21):
    <<(x @int:59:33, s @int:59:39, ?tmp#0 @int:59:33)
    =(?x @int:59:29, tmp#0)


<= > public (0 calls)
0: <=(x:_ @int:88:10, y:_ @int:88:18, ?#result:bool @int:88:5):
    foreign llvm icmp_sle(x @int:88:52, y @int:88:54, ?tmp#0 @int:88:30)
    foreign llvm move(tmp#0, ?#result @int:88:5)


<=> > public (0 calls)
0: <=>(x:_ @int:93:10, y:_ @int:93:20, ?#result:comparison @int:93:5):
    if {<(x @int:94:10, y @int:94:14)::

        lesser(?tmp#1 @int:94:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @int:94:28, y @int:94:32)::

            equal(?tmp#3 @int:94:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @int:94:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @int:94:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @int:94:10, ?#result @int:93:5)


= > public (0 calls)
0: =(x:_ @int:83:10, y:_ @int:83:17, ?#result:bool @int:83:5):
    foreign llvm icmp_eq(x @int:83:50, y @int:83:52, ?tmp#0 @int:83:29)
    foreign llvm move(tmp#0, ?#result @int:83:5)


> > public (0 calls)
0: >(x:_ @int:89:10, y:_ @int:89:17, ?#result:bool @int:89:5):
    foreign llvm icmp_sgt(x @int:89:51, y @int:89:53, ?tmp#0 @int:89:29)
    foreign llvm move(tmp#0, ?#result @int:89:5)


>= > public (0 calls)
0: >=(x:_ @int:90:10, y:_ @int:90:18, ?#result:bool @int:90:5):
    foreign llvm icmp_sge(x @int:90:52, y @int:90:54, ?tmp#0 @int:90:30)
    foreign llvm move(tmp#0, ?#result @int:90:5)


>> > public (0 calls)
0: >>(x:_ @int:65:10, s:_ @int:65:18, ?#result:_ @int:65:5):
    foreign llvm ashr(x @int:65:45, s @int:65:48, ?tmp#0 @int:65:27)
    foreign llvm move(tmp#0, ?#result @int:65:5)


>>= > public (0 calls)
0: >>=(!x:_ @int:68:11, s:_ @int:68:21):
    >>(x @int:68:33, s @int:68:39, ?tmp#0 @int:68:33)
    =(?x @int:68:29, tmp#0)


decr > public (0 calls)
0: decr(!x:_ @int:111:15):
    -(x @int:111:27, 1 @int:111:31, ?tmp#0 @int:111:27)
    =(?x @int:111:23, tmp#0)


incr > public (0 calls)
0: incr(!x:_ @int:110:15):
    +(x @int:110:27, 1 @int:110:31, ?tmp#0 @int:110:27)
    =(?x @int:110:23, tmp#0)


logical_bitshift > public (0 calls)
0: logical_bitshift(x:_ @int:74:26, s:_ @int:74:31, ?#result:_ @int:74:5):
    foreign llvm lshr(x @int:74:58, s @int:74:61, ?tmp#0 @int:74:40)
    foreign llvm move(tmp#0, ?#result @int:74:5)
logical_bitshift > public (0 calls)
1: logical_bitshift(!x:_ @int:77:27, s:_ @int:77:32):
    logical_bitshift(x @int:77:61, s @int:77:64, ?tmp#0 @int:77:44)
    =(?x @int:77:40, tmp#0)


max > public (0 calls)
0: max(x:_ @int:98:13, y:_ @int:98:18, ?#result:_ @int:98:5):
    if {>=(x @int:98:31, y @int:98:35)::

        foreign llvm move(x @int:98:39, ?tmp#0)
    else::
        foreign llvm move(y @int:98:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @int:98:31, ?#result @int:98:5)


min > public (0 calls)
0: min(x:_ @int:97:13, y:_ @int:97:18, ?#result:_ @int:97:5):
    if {<=(x @int:97:31, y @int:97:35)::

        foreign llvm move(x @int:97:39, ?tmp#0)
    else::
        foreign llvm move(y @int:97:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @int:97:31, ?#result @int:97:5)


power > public (0 calls)
0: power(x:_ @int:107:15, y:_ @int:107:20, ?#result:_ @int:107:5):
    foreign c ipow(x @int:107:44, y @int:107:46, ?tmp#0 @int:107:29)
    foreign llvm move(tmp#0, ?#result @int:107:5)


print > public (0 calls)
0: print(x:_ @int:119:15) use !io:
    foreign c print_int(x @int:119:50, !io @int:119:54)


println > public (0 calls)
0: println(x:_ @int:121:17) use !io:
    !print(x @int:121:39)
    !nl


read > public (0 calls)
0: read(?x:_ @int:123:15) use !io:
    foreign c read_int(?x @int:123:50, !io @int:123:54)


signum > public (0 calls)
0: signum(x:_ @int:114:16, ?#result:_ @int:114:5):
    foreign c signum(x @int:114:42, ?tmp#0 @int:114:25)
    foreign llvm move(tmp#0, ?#result @int:114:5)


sqrt > public (0 calls)
0: sqrt(x:_ @int:104:14, ?#result:_ @int:104:5):
    foreign c isqrt(x @int:104:39, ?tmp#0 @int:104:23)
    foreign llvm move(tmp#0, ?#result @int:104:5)


~= > public (0 calls)
0: ~=(x:_ @int:84:10, y:_ @int:84:18, ?#result:bool @int:84:5):
    foreign llvm icmp_ne(x @int:84:51, y @int:84:53, ?tmp#0 @int:84:30)
    foreign llvm move(tmp#0, ?#result @int:84:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.io
  representation  : (not a type)
  public submods  : 
  public resources: io: wybe.io.io
  public procs    : wybe.io.eof<0>
                    wybe.io.nl<0>
  imports         : use wybe.char
                    public use wybe.phantom
  resources       : io: fromList [(wybe.io.io,phantom = 0:phantom @io:13:27 @io:13:5)]
  procs           : 

eof > public {inline} (0 calls)
0: eof(?#result:char @io:20:5):
    foreign lpvm cast(-1 @io:20:47, ?tmp#0 @io:20:29)
    foreign llvm move(tmp#0, ?#result @io:20:5)


nl > public {inline} (0 calls)
0: nl() use !io:
    foreign c putchar('\n' @io:17:49, !io @io:17:54)

LLVM code       : None

--------------------------------------------------
 Module wybe.list(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.list.,,<0>
                    wybe.list.[]<0>
                    wybe.list.all<0>
                    wybe.list.any<0>
                    wybe.list.empty<0>
                    wybe.list.filter<0>
                    wybe.list.foldl<0>
                    wybe.list.foldr<0>
                    wybe.list.length<0>
                    wybe.list.list<0>
                    wybe.list.map<0>
                    wybe.list.map<1>
                    wybe.list.map<2>
                    wybe.list.print<0>
                    wybe.list.println<0>
                    wybe.list.reverse<0>
  imports         : use wybe.array
                    use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
                    use wybe.machine_word
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_(T) @list:20:10, y:_(T) @list:20:20, ?#result:_(T) @list:20:5):
    if {[|](?h @list:21:16, ?t @list:21:21, x @list:21:10)::

        ,,(t @list:21:32, y @list:21:37, ?tmp#2 @list:21:32)
        [|](h @list:21:28, tmp#2, ?tmp#1 @list:21:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(y @list:21:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:21:10, ?#result @list:20:5)


[] > public {test} (0 calls)
0: [](xs:_(T) @list:31:21, idx:int @list:31:30, ?#result:T @list:31:5):
    >=(idx @list:32:5, 0 @list:32:13)
    index1(xs @list:33:17, idx @list:33:21, ?tmp#0 @list:33:10)
    =(?x @list:33:6, tmp#0)
    foreign llvm move(x @list:31:43, ?#result @list:31:5)


all > public {test} (0 calls)
0: all(p:{test}(T) @list:61:20, xs:_(T) @list:61:33):
    foreign llvm move(xs @list:62:15, ?tmp#0)
    do {
        if {[|](?x @list:62:10, ?tmp#0, tmp#0)::

            p(x @list:63:11)
        else::
            break

        }
    }


any > public {test} (0 calls)
0: any(p:{test}(T) @list:69:20, xs:_(T) @list:69:33):
    [|](?x @list:70:7, ?xs @list:70:12, xs @list:70:18)
    (   p(x @list:71:8)
    | any(p @list:71:17, xs @list:71:20))


empty > public {test} (0 calls)
0: empty(xs:_(T) @list:15:22):
    if {[|](?tmp#0 @list:16:11, ?tmp#1 @list:16:15, xs @list:16:20)::

        fail
    else::
        pass

    }


filter > public (0 calls)
0: filter(p:{test}(T) @list:95:16, !xs:_(T) @list:95:30):
    [](?tmp#0 @list:96:12)
    =(?out @list:96:6, tmp#0)
    foreign llvm move(xs @list:97:15, ?tmp#1)
    do {
        if {[|](?x @list:97:10, ?tmp#1, tmp#1)::

            if {p(x @list:98:16)::

                [|](x @list:98:30, out @list:98:34, ?tmp#2 @list:98:29)
                =(?out @list:98:23, tmp#2)
            else::
                pass

            }
        else::
            break

        }
    }
    reverse(out @list:100:19, ?tmp#3 @list:100:11)
    =(?as @list:100:6, tmp#3)


foldl > public (0 calls)
0: foldl(f:(A, !B) @list:77:15, as:_(A) @list:77:26, !b:B @list:77:36):
    foreign llvm move(as @list:78:15, ?tmp#0)
    do {
        if {[|](?a @list:78:10, ?tmp#0, tmp#0)::

            f(a @list:79:11, !b @list:79:15)
        else::
            break

        }
    }


foldr > public (0 calls)
0: foldr(f:(A, !B) @list:86:15, as:_(A) @list:86:26, !b:B @list:86:36):
    if {[|](?a @list:87:12, ?as @list:87:17, as @list:87:23)::

        foldr(f @list:88:15, as @list:88:18, !b @list:88:23)
        f(a @list:89:11, !b @list:89:15)
    else::
        pass

    }


index1 > {test} (0 calls)
0: index1(xs:_(T) @list:148:19, idx:int @list:148:28, ?#result:T @list:148:1):
    [|](?x @list:149:7, ?xs @list:149:12, xs @list:149:18)
    (   =(idx @list:150:6, 0 @list:150:12)
    | (   -(idx @list:150:27, 1 @list:150:33, ?tmp#0 @list:150:27)
        & index1(xs @list:150:23, tmp#0, ?x @list:150:37)))
    foreign llvm move(x @list:148:41, ?#result @list:148:1)


length > public (0 calls)
0: length(x:_(T) @list:24:16, ?#result:int @list:24:5):
    length1(x @list:24:38, 0 @list:24:41, ?tmp#0 @list:24:30)
    foreign llvm move(tmp#0, ?#result @list:24:5)


length1 > (0 calls)
0: length1(x:_(T) @list:140:13, acc:int @list:140:21, ?#result:int @list:140:1):
    if {[|](?h @list:141:16, ?t @list:141:21, x @list:141:10)::

        +(acc @list:141:38, 1 @list:141:44, ?tmp#2 @list:141:38)
        length1(t @list:141:35, tmp#2, ?tmp#1 @list:141:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(acc @list:141:57, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:141:10, ?#result @list:140:1)


list > public (0 calls)
0: list(ar:array(T) @list:128:14, ?#result:_(T) @list:128:5):
    [](?tmp#0 @list:129:11)
    =(?ls @list:129:6, tmp#0)
    foreign llvm move(ar @list:130:15, ?tmp#1)
    do {
        if {[|](?x @list:130:10, ?tmp#1, tmp#1)::

            [|](x @list:131:16, ls @list:131:20, ?tmp#2 @list:131:15)
            =(?ls @list:131:10, tmp#2)
        else::
            break

        }
    }
    reverse(ls @list:133:13, ?ls @list:133:18)
    foreign llvm move(ls @list:128:34, ?#result @list:128:5)


map > public (0 calls)
0: map(f:{resource}(T) @list:41:13, xs:_(T) @list:41:30):
    foreign llvm move(xs @list:42:15, ?tmp#0)
    do {
        if {[|](?x @list:42:10, ?tmp#0, tmp#0)::

            !f(x @list:43:12)
        else::
            break

        }
    }
map > public (0 calls)
1: map(f:(A, ?B) @list:49:13, as:_(A) @list:49:24, ?#result:_(B) @list:49:5):
    if {[|](?a @list:50:12, ?as @list:50:17, as @list:50:23)::

        f(a @list:50:33, ?tmp#2 @list:50:31)
        map(f @list:50:42, as @list:50:45, ?tmp#3 @list:50:38)
        [|](tmp#2, tmp#3, ?tmp#1 @list:50:29)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:50:61)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:50:10, ?#result @list:49:5)
map > public (0 calls)
2: map(f:(A, B, ?C) @list:55:13, as:_(A) @list:55:27, bs:_(B) @list:55:36, ?#result:_(C) @list:55:5):
    if {(   [|](?a @list:56:12, ?as @list:56:17, as @list:56:23)
        & [|](?b @list:56:30, ?bs @list:56:35, bs @list:56:41))::

        f(a @list:56:51, b @list:56:54, ?tmp#2 @list:56:49)
        map(f @list:56:63, as @list:56:66, bs @list:56:70, ?tmp#3 @list:56:59)
        [|](tmp#2, tmp#3, ?tmp#1 @list:56:47)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:57:47)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:56:10, ?#result @list:55:5)


print > public (0 calls)
0: print(printer:{resource}(T) @list:108:15, xs:_(T) @list:108:38) use !io:
    !print('[' @list:109:12)
    if {[|](?x @list:110:12, ?xs @list:110:17, xs @list:110:23)::

        !printer(x @list:111:18)
        !print1(printer @list:112:17, xs @list:112:26)
    else::
        pass

    }
    !print(']' @list:114:12)


print1 > (0 calls)
0: print1(printer:{resource}(T) @list:154:12, xs:_(T) @list:154:35) use !io:
    if {[|](?x @list:155:12, ?xs @list:155:17, xs @list:155:23)::

        !print(',' @list:156:16)
        !printer(x @list:157:18)
        !print1(printer @list:158:17, xs @list:158:26)
    else::
        pass

    }


println > public (0 calls)
0: println(printer:{resource}(T) @list:119:17, xs:_(T) @list:119:40) use !io:
    !print(printer @list:120:12, xs @list:120:21)
    !nl


reverse > public (0 calls)
0: reverse(x:_(T) @list:27:17, ?#result:_(T) @list:27:5):
    [](?tmp#1 @list:27:44)
    reverse1(x @list:27:41, tmp#1, ?tmp#0 @list:27:32)
    foreign llvm move(tmp#0, ?#result @list:27:5)


reverse1 > (0 calls)
0: reverse1(x:_(T) @list:144:14, tail:_(T) @list:144:22, ?#result:_(T) @list:144:1):
    if {[|](?h @list:145:16, ?t @list:145:21, x @list:145:10)::

        [|](h @list:145:40, tail @list:145:44, ?tmp#2 @list:145:39)
        reverse1(t @list:145:36, tmp#2, ?tmp#1 @list:145:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(tail @list:145:61, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:145:10, ?#result @list:144:1)

LLVM code       : None

--------------------------------------------------
 Module wybe.machine_word
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.machine_word.word_size_bits<0>
                    wybe.machine_word.word_size_bytes<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

word_size_bits > public (0 calls)
0: word_size_bits(?#result:int @machine_word:12:5):
    word_size_bytes(?tmp#1 @machine_word:12:34)
    *(8 @machine_word:12:30, tmp#1, ?tmp#0 @machine_word:12:30)
    foreign llvm move(tmp#0, ?#result @machine_word:12:5)


word_size_bytes > public (0 calls)
0: word_size_bytes(?#result:int @machine_word:10:5):
    foreign llvm move(8 @machine_word:10:31, ?#result @machine_word:10:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.memory_management
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.memory_management.malloc_count<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

malloc_count > public {semipure} (0 calls)
0: malloc_count(?x:int @memory_management:11:34):
    foreign c {impure} malloc_count(?x @memory_management:12:38)

LLVM code       : None

--------------------------------------------------
 Module wybe.phantom
 modifiers       : {unique} 
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : 
  imports         : 
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.predicate
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.predicate.const<0>
                    wybe.predicate.id<0>
  imports         : 
  resources       : 
  procs           : 

const > public {inline} (0 calls)
0: wybe.predicate.const<0>
const(a##0:A <{}; {}; {0}>, [b##0:B <{}; {}; {1}>], ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:8:5


id > public {inline} (0 calls)
0: wybe.predicate.id<0>
id(a##0:A <{}; {}; {0}>, ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:6:5

LLVM code       : None

--------------------------------------------------
 Module wybe.range
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.range...<0>
                    wybe.range.[]<0>
                    wybe.range.[|]<0>
                    wybe.range.irange<0>
                    wybe.range.size<0>
                    wybe.range.xrange<0>
  imports         : use wybe.bool
                    use wybe.int
  resources       : 
  procs           : 

.. > public (0 calls)
0: ..(start:int @range:38:10, end:int @range:38:23, ?#result:_ @range:38:5):
    if {<=(start @range:39:27, end @range:39:37)::

        foreign llvm move(1 @range:39:44, ?tmp#1)
    else::
        foreign llvm move(-1 @range:39:56, ?tmp#1)

    }
    construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)
    foreign llvm move(tmp#0, ?#result @range:38:5)


[] > public {test} (0 calls)
0: [](r:_ @range:20:19, idx:int @range:20:24, ?value:int @range:20:34):
    <=(0 @range:21:6, idx @range:21:12)
    range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)
    *(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)
    +(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)
    =(?value @range:23:6, tmp#0)
    if {<=(0 @range:24:10, stride @range:24:16)::

        <(value @range:24:27, end @range:24:35)
    else::
        <(end @range:24:51, value @range:24:57)

    }


[|] > public {test} (0 calls)
0: [|](?value:int @range:12:23, ?rest:_ @range:12:35, current:_ @range:12:43):
    range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)
    ~=(value @range:14:6, end @range:14:16)
    +(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)
    range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)
    =(?rest @range:15:6, tmp#0)


construct > (0 calls)
0: construct(start:int @range:49:15, stride:int @range:49:26, end:int @range:49:38, ?#result:_ @range:49:1):
    -(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)
    %(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)
    =(?diff @range:50:6, tmp#0)
    if {<=(0 @range:51:19, stride @range:51:25)::

        if {=(diff @range:52:26, 0 @range:52:33)::

            max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
            -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
            max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
            foreign llvm move(tmp#5, ?tmp#3)

        }
        foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
    else::
        if {=(diff @range:55:26, 0 @range:55:33)::

            min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
            foreign llvm move(tmp#9, ?tmp#8)
        else::
            +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
            min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
            foreign llvm move(tmp#10, ?tmp#8)

        }
        foreign llvm move(tmp#8 @range:55:26, ?tmp#2)

    }
    =(?final @range:51:6, tmp#2 @range:51:19)
    range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)
    =(?r @range:58:6, tmp#12)
    foreign llvm move(r @range:49:51, ?#result @range:49:1)


irange > public (0 calls)
0: irange(start:int @range:32:16, stride:int @range:32:27, end:int @range:32:39, ?#result:_ @range:32:5):
    if {<(stride @range:33:41, 0 @range:33:50)::

        foreign llvm move(-1 @range:33:55, ?tmp#2)
    else::
        foreign llvm move(1 @range:33:68, ?tmp#2)

    }
    +(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)
    construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)
    foreign llvm move(tmp#0, ?#result @range:32:5)


size > public (0 calls)
0: size(r:_ @range:42:14, ?#result:int @range:42:5):
    range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)
    if {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
        & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
        & signum(tmp#3, ?tmp#2 @range:44:29)
        & ~=(tmp#1, tmp#2))::

        foreign llvm move(0 @range:44:52, ?tmp#0)
    else::
        if {<=(0 @range:45:10, stride @range:45:16)::

            -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
            -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
            /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
            +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
            foreign llvm move(tmp#5, ?tmp#4)
        else::
            -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
            -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
            -(stride @range:46:39, ?tmp#13 @range:46:38)
            /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
            +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
            foreign llvm move(tmp#9, ?tmp#4)

        }
        foreign llvm move(tmp#4 @range:45:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)


xrange > public (0 calls)
0: xrange(start:int @range:28:16, stride:int @range:28:27, end:int @range:28:39, ?#result:_ @range:28:5):
    construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)
    foreign llvm move(tmp#0, ?#result @range:28:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.string
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.string.,,<0>
                    wybe.string.<<0>
                    wybe.string.<=<0>
                    wybe.string.<=><0>
                    wybe.string.=<0>
                    wybe.string.><0>
                    wybe.string.>=<0>
                    wybe.string.[]<0>
                    wybe.string.[]<1>
                    wybe.string.[|]<0>
                    wybe.string.c_string<0>
                    wybe.string.length<0>
                    wybe.string.print<0>
                    wybe.string.println<0>
                    wybe.string.read<0>
                    wybe.string.string<0>
                    wybe.string.string<1>
                    wybe.string.~=<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.char
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
                    use wybe.range
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_ @string:64:10, y:_ @string:64:17, ?#result:_ @string:64:5):
    if {(   empty(?tmp#1 @string:65:14)
        & =(x @string:65:10, tmp#1))::

        foreign llvm move(y @string:65:23, ?tmp#0)
    else::
        if {(   empty(?tmp#3 @string:66:14)
            & =(y @string:66:10, tmp#3))::

            foreign llvm move(x @string:66:23, ?tmp#2)
        else::
            concat(x @string:67:25, y @string:67:28, ?tmp#4 @string:67:18)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:66:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:65:10, ?#result @string:64:5)


< > public (0 calls)
0: <(x:_ @string:119:10, y:_ @string:119:17, ?#result:bool @string:119:5):
    <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
    equal(?tmp#2 @string:119:44)
    <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
    foreign llvm move(tmp#0, ?#result @string:119:5)


<= > public (0 calls)
0: <=(x:_ @string:120:10, y:_ @string:120:18, ?#result:bool @string:120:5):
    <=>(x @string:120:31, y @string:120:39, ?tmp#1 @string:120:31)
    equal(?tmp#2 @string:120:46)
    <=(tmp#1, tmp#2, ?tmp#0 @string:120:30)
    foreign llvm move(tmp#0, ?#result @string:120:5)


<=> > public (0 calls)
0: <=>(x:_ @string:125:10, y:_ @string:125:20, ?#result:comparison @string:125:5):
    equal(?tmp#0 @string:126:10)
    =(?c @string:126:6, tmp#0)
    foreign llvm move(x @string:127:16, ?tmp#1)
    foreign llvm move(y @string:127:26, ?tmp#2)
    do {
        if {[|](?cx @string:127:10, ?tmp#1, tmp#1)::

            if {[|](?cy @string:127:20, ?tmp#2, tmp#2)::

                if {<(cx @string:128:14, cy @string:128:19)::

                    lesser(?tmp#3 @string:128:30)
                    =(?c @string:128:26, tmp#3)
                    break
                else::
                    if {>(cx @string:129:14, cy @string:129:19)::

                        greater(?tmp#4 @string:129:30)
                        =(?c @string:129:26, tmp#4)
                        break
                    else::
                        pass

                    }

                }
            else::
                break

            }
        else::
            break

        }
    }
    if {(   equal(?tmp#5 @string:132:14)
        & =(c @string:132:10, tmp#5))::

        length(x @string:133:22, ?tmp#6 @string:133:15)
        =(?lx @string:133:10, tmp#6)
        length(y @string:134:22, ?tmp#7 @string:134:15)
        =(?ly @string:134:10, tmp#7)
        if {<(lx @string:135:14, ly @string:135:19)::

            lesser(?tmp#8 @string:135:30)
            =(?c @string:135:26, tmp#8)
        else::
            if {>(lx @string:135:39, ly @string:135:44)::

                greater(?tmp#9 @string:135:55)
                =(?c @string:135:51, tmp#9)
            else::
                pass

            }

        }
    else::
        pass

    }
    foreign llvm move(c @string:125:38, ?#result @string:125:5)


= > public (0 calls)
0: =(x:_ @string:115:10, y:_ @string:115:17, ?#result:bool @string:115:5):
    <=>(x @string:115:30, y @string:115:38, ?tmp#1 @string:115:30)
    equal(?tmp#2 @string:115:44)
    =(tmp#1, tmp#2, ?tmp#0 @string:115:29)
    foreign llvm move(tmp#0, ?#result @string:115:5)


> > public (0 calls)
0: >(x:_ @string:121:10, y:_ @string:121:17, ?#result:bool @string:121:5):
    <=>(x @string:121:30, y @string:121:38, ?tmp#1 @string:121:30)
    equal(?tmp#2 @string:121:44)
    >(tmp#1, tmp#2, ?tmp#0 @string:121:29)
    foreign llvm move(tmp#0, ?#result @string:121:5)


>= > public (0 calls)
0: >=(x:_ @string:122:10, y:_ @string:122:18, ?#result:bool @string:122:5):
    <=>(x @string:122:31, y @string:122:39, ?tmp#1 @string:122:31)
    equal(?tmp#2 @string:122:46)
    >=(tmp#1, tmp#2, ?tmp#0 @string:122:30)
    foreign llvm move(tmp#0, ?#result @string:122:5)


[] > public {test} (0 calls)
0: [](s:_ @string:91:19, idx:int @string:91:24, ?c:char @string:91:34):
    if {buffer(?len @string:93:17, ?str @string:93:23, s @string:92:10)::

        <=(0 @string:94:14, idx @string:94:20)
        <(idx @string:95:14, len @string:95:20)
        unsafe_c_string_index(str @string:96:35, idx @string:96:40, ?c @string:96:46)
    else::
        if {concat(?left @string:97:17, ?right @string:97:24, s @string:92:10)::

            length(left @string:98:32, ?tmp#0 @string:98:25)
            =(?left_len @string:98:14, tmp#0)
            if {<(idx @string:99:18, left_len @string:99:24)::

                [](left @string:99:41, idx @string:99:46, ?tmp#1 @string:99:41)
                =(?c @string:99:37, tmp#1)
            else::
                -(idx @string:100:37, left_len @string:100:43, ?tmp#3 @string:100:37)
                [](right @string:100:31, tmp#3, ?tmp#2 @string:100:31)
                =(?c @string:100:27, tmp#2)

            }
        else::
            if {slice(?base @string:102:16, ?range @string:102:23, s @string:92:10)::

                [](range @string:102:43, idx @string:102:49, ?tmp#5 @string:102:43)
                [](base @string:102:38, tmp#5, ?tmp#4 @string:102:38)
                =(?c @string:102:34, tmp#4)
            else::
                if {singleton(?c @string:103:20, s @string:92:10)::

                    =(idx @string:103:27, 0 @string:103:33)
                else::
                    fail

                }

            }

        }

    }
[] > public (0 calls)
1: [](s:_ @string:109:12, r:range @string:109:17, ?#result:_ @string:109:5):
    slice(s @string:109:36, r @string:109:39, ?tmp#0 @string:109:30)
    foreign llvm move(tmp#0, ?#result @string:109:5)


[|] > public {test} (0 calls)
0: [|](?head:char @string:71:23, ?tail:_ @string:71:35, s:_ @string:71:43):
    if {buffer(?len @string:73:17, ?str @string:73:23, s @string:72:10)::

        [|](?head @string:74:15, ?str @string:74:23, str @string:74:30)
        if {=(len @string:75:26, 1 @string:75:32)::

            empty(?tmp#1 @string:75:37)
            foreign llvm move(tmp#1, ?tmp#0)
        else::
            -(len @string:75:60, 1 @string:75:66, ?tmp#3 @string:75:60)
            buffer(tmp#3, str @string:75:69, ?tmp#2 @string:75:53)
            foreign llvm move(tmp#2, ?tmp#0)

        }
        =(?tail @string:75:14, tmp#0 @string:75:26)
    else::
        if {concat(?left @string:76:17, ?right @string:76:24, s @string:72:10)::

            if {[|](?head @string:77:20, ?t @string:77:28, left @string:77:33)::

                concat(t @string:77:56, right @string:77:59, ?tmp#4 @string:77:49)
                =(?tail @string:77:42, tmp#4)
            else::
                [|](?head @string:78:28, ?tail @string:78:36, right @string:78:44)

            }
        else::
            if {slice(?base @string:80:16, ?range @string:80:23, s @string:72:10)::

                do {
                    [|](?idx @string:82:19, ?range @string:82:26, range @string:82:35)
                    if {(   [](base @string:83:30, idx @string:83:35, ?tmp#5 @string:83:30)
                        & =(?head @string:83:23, tmp#5))::

                        slice(base @string:83:57, range @string:83:63, ?tmp#6 @string:83:51)
                        =(?tail @string:83:44, tmp#6)
                        break
                    else::
                        pass

                    }
                }
            else::
                if {singleton(?head @string:85:20, s @string:72:10)::

                    empty(?tmp#7 @string:85:37)
                    =(?tail @string:85:30, tmp#7)
                else::
                    fail

                }

            }

        }

    }


c_string > public (0 calls)
0: c_string(s:_ @string:40:18, ?#result:c_string @string:40:5):
    if {buffer(?tmp#0 @string:41:21, ?str @string:41:25, s @string:41:10)::

        pass
    else::
        length(s @string:43:27, ?tmp#2 @string:43:20)
        +(tmp#2, 1 @string:43:32, ?tmp#1 @string:43:20)
        =(?len @string:43:14, tmp#1)
        foreign lpvm alloc(len @string:44:32, ?str @string:44:38)
        true(?tmp#3 @string:45:49)
        foreign lpvm mutate(str @string:45:33, ?str @string:45:39, len @string:45:44, tmp#3, len @string:45:55, 0 @string:45:60, '\NUL' @string:45:63)
        =(?offset @string:46:14, 0 @string:46:23)
        pack(s @string:47:18, !str @string:47:22, len @string:47:27, !offset @string:47:33)

    }
    foreign llvm move(str @string:40:34, ?#result @string:40:5)


fixed_range_size > (0 calls)
0: fixed_range_size(hi:int @string:184:22, r:range @string:184:30, ?sz:int @string:184:40):
    range(?start @string:185:16, ?stride @string:185:24, ?end @string:185:33, r @string:185:5)
    if {<=(0 @string:186:10, stride @string:186:16)::

        -(start @string:187:39, ?tmp#4 @string:187:38)
        /(tmp#4, stride @string:187:47, ?tmp#3 @string:187:38)
        *(tmp#3, stride @string:187:56, ?tmp#2 @string:187:38)
        +(start @string:187:30, tmp#2, ?tmp#1 @string:187:30)
        max(start @string:187:23, tmp#1, ?tmp#0 @string:187:19)
        =(?lo @string:187:14, tmp#0)
        min(hi @string:188:23, end @string:188:27, ?tmp#5 @string:188:19)
        =(?hi @string:188:14, tmp#5)
    else::
        max(-1 @string:190:23, end @string:190:27, ?tmp#6 @string:190:19)
        =(?lo @string:190:14, tmp#6)
        +(hi @string:191:30, stride @string:191:35, ?tmp#10 @string:191:30)
        -(start @string:191:45, hi @string:191:53, ?tmp#13 @string:191:45)
        -(tmp#13, 1 @string:191:58, ?tmp#12 @string:191:45)
        -(stride @string:191:64, ?tmp#14 @string:191:63)
        %(tmp#12, tmp#14, ?tmp#11 @string:191:44)
        +(tmp#10, tmp#11, ?tmp#9 @string:191:30)
        +(tmp#9, 1 @string:191:73, ?tmp#8 @string:191:30)
        min(start @string:191:23, tmp#8, ?tmp#7 @string:191:19)
        =(?hi @string:191:14, tmp#7)
        -(stride @string:192:24, ?tmp#15 @string:192:23)
        =(?stride @string:192:14, tmp#15)

    }
    if {<=(hi @string:194:16, lo @string:194:23)::

        foreign llvm move(0 @string:194:29, ?tmp#16)
    else::
        -(hi @string:194:42, lo @string:194:47, ?tmp#20 @string:194:42)
        -(tmp#20, 1 @string:194:52, ?tmp#19 @string:194:42)
        /(tmp#19, stride @string:194:57, ?tmp#18 @string:194:41)
        +(tmp#18, 1 @string:194:66, ?tmp#17 @string:194:41)
        foreign llvm move(tmp#17, ?tmp#16)

    }
    =(?sz @string:194:6, tmp#16 @string:194:16)


length > public (0 calls)
0: length(s:_ @string:52:16, ?#result:int @string:52:5):
    if {buffer(?len @string:53:22, ?tmp#1 @string:53:27, s @string:53:10)::

        foreign llvm move(len @string:53:33, ?tmp#0)
    else::
        if {concat(?left @string:54:22, ?right @string:54:29, s @string:54:10)::

            length(left @string:54:46, ?tmp#4 @string:54:39)
            length(right @string:54:61, ?tmp#5 @string:54:54)
            +(tmp#4, tmp#5, ?tmp#3 @string:54:39)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            if {slice(?base @string:55:21, ?range @string:55:28, s @string:55:10)::

                length(base @string:55:62, ?tmp#8 @string:55:55)
                fixed_range_size(tmp#8, range @string:55:69, ?tmp#7 @string:55:38)
                foreign llvm move(tmp#7, ?tmp#6)
            else::
                if {singleton(?tmp#10 @string:56:24, s @string:56:10)::

                    foreign llvm move(1 @string:56:30, ?tmp#9)
                else::
                    foreign llvm move(0 @string:57:18, ?tmp#9)

                }
                foreign llvm move(tmp#9 @string:56:10, ?tmp#6)

            }
            foreign llvm move(tmp#6 @string:55:10, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:54:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:53:10, ?#result @string:52:5)


pack > (0 calls)
0: pack(s:_ @string:160:10, !raw:c_string @string:160:16, size:int @string:160:30, !offset:int @string:160:41):
    if {buffer(?tmp#0 @string:162:16, ?str @string:162:20, s @string:161:10)::

        foreign llvm move(str @string:163:23, ?tmp#1)
        do {
            if {[|](?c @string:163:18, ?tmp#1, tmp#1)::

                true(?tmp#2 @string:164:56)
                foreign lpvm mutate(raw @string:164:37, ?raw @string:164:43, offset @string:164:48, tmp#2, size @string:164:62, 0 @string:164:68, c @string:164:71)
                incr(!offset @string:165:23)
            else::
                break

            }
        }
    else::
        if {concat(?left @string:167:17, ?right @string:167:24, s @string:161:10)::

            pack(left @string:168:18, !raw @string:168:25, size @string:168:30, !offset @string:168:37)
            pack(right @string:169:18, !raw @string:169:26, size @string:169:31, !offset @string:169:38)
            incr(!offset @string:170:19)
        else::
            if {slice(?tmp#3 @string:171:15, ?tmp#4 @string:171:18, s @string:161:10)::

                foreign llvm move(s @string:172:23, ?tmp#5)
                do {
                    if {[|](?c @string:172:18, ?tmp#5, tmp#5)::

                        true(?tmp#6 @string:173:56)
                        foreign lpvm mutate(raw @string:173:37, ?raw @string:173:43, offset @string:173:48, tmp#6, size @string:173:62, 0 @string:173:68, c @string:173:71)
                        incr(!offset @string:174:23)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:176:20, s @string:161:10)::

                    true(?tmp#7 @string:177:52)
                    foreign lpvm mutate(raw @string:177:33, ?raw @string:177:39, offset @string:177:44, tmp#7, size @string:177:58, 0 @string:177:64, c @string:177:67)
                    incr(!offset @string:178:19)
                else::
                    fail

                }

            }

        }

    }


print > public (0 calls)
0: print(x:_ @string:142:15) use !io:
    if {buffer(?tmp#0 @string:144:16, ?str @string:144:20, x @string:143:10)::

        !print(str @string:144:35)
    else::
        if {concat(?left @string:145:17, ?right @string:145:24, x @string:143:10)::

            !print(left @string:145:41)
            !print(right @string:145:55)
        else::
            if {slice(?tmp#1 @string:146:15, ?tmp#2 @string:146:18, x @string:143:10)::

                foreign llvm move(x @string:146:34, ?tmp#3)
                do {
                    if {[|](?c @string:146:29, ?tmp#3, tmp#3)::

                        !print(c @string:146:45)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:147:20, x @string:143:10)::

                    !print(c @string:147:33)
                else::
                    fail

                }

            }

        }

    }


println > public (0 calls)
0: println(x:_ @string:151:17) use !io:
    !print(x @string:151:39)
    !nl


read > public (0 calls)
0: read(?x:_ @string:153:15) use !io:
    !read(?str:c_string @string:153:37)
    string(str @string:153:64, ?tmp#0 @string:153:57)
    =(?x @string:153:53, tmp#0)


string > public (0 calls)
0: string(str:c_string @string:28:16, ?#result:_ @string:28:5):
    length(str @string:29:19, ?tmp#0 @string:29:12)
    =(?len @string:29:6, tmp#0)
    if {=(len @string:30:15, 0 @string:30:21)::

        empty(?tmp#2 @string:30:26)
        foreign llvm move(tmp#2, ?tmp#1)
    else::
        if {=(len @string:31:15, 1 @string:31:21)::

            foreign lpvm access(str @string:31:56, 0 @string:31:61, 1 @string:31:64, 0 @string:31:67, ?tmp#5 @string:31:36)
            singleton(tmp#5, ?tmp#4 @string:31:26)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            buffer(len @string:32:33, str @string:32:38, ?tmp#6 @string:32:26)
            foreign llvm move(tmp#6, ?tmp#3)

        }
        foreign llvm move(tmp#3 @string:31:15, ?tmp#1)

    }
    =(?s @string:30:6, tmp#1 @string:30:15)
    foreign llvm move(s @string:28:34, ?#result @string:28:5)
string > public (0 calls)
1: string(c:char @string:37:16, ?#result:_ @string:37:5):
    singleton(c @string:37:38, ?tmp#0 @string:37:28)
    foreign llvm move(tmp#0, ?#result @string:37:5)


~= > public (0 calls)
0: ~=(x:_ @string:116:10, y:_ @string:116:18, ?#result:bool @string:116:5):
    <=>(x @string:116:31, y @string:116:39, ?tmp#1 @string:116:31)
    equal(?tmp#2 @string:116:46)
    ~=(tmp#1, tmp#2, ?tmp#0 @string:116:30)
    foreign llvm move(tmp#0, ?#result @string:116:5)

LLVM code       : None

======================================================================
AFTER FLATTENING:
 Module wybe
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : 
  imports         : public use wybe.array
                    public use wybe.bool
                    public use wybe.c_string
                    public use wybe.char
                    public use wybe.comparison
                    public use wybe.control
                    public use wybe.count
                    public use wybe.float
                    public use wybe.int
                    public use wybe.io
                    public use wybe.list
                    public use wybe.machine_word
                    public use wybe.memory_management
                    public use wybe.phantom
                    public use wybe.predicate
                    public use wybe.range
                    public use wybe.string
  resources       : 
  submodules      : wybe.array, wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.control, wybe.count, wybe.float, wybe.int, wybe.io, wybe.list, wybe.machine_word, wybe.memory_management, wybe.phantom, wybe.predicate, wybe.range, wybe.string
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.array(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.array.[]<0>
                    wybe.array.[]<1>
                    wybe.array.[|]<0>
                    wybe.array.array<0>
                    wybe.array.array<1>
                    wybe.array.inbounds<0>
                    wybe.array.unsafe_get<0>
                    wybe.array.unsafe_update<0>
  imports         : public use wybe.array.raw_array
                    use wybe.bool
                    use wybe.int
                    use wybe.list
                    use wybe.machine_word
  resources       : 
  submodules      : wybe.array.raw_array
  procs           : 

[] > public {test} (0 calls)
0: [](a:_(T) @array:67:21, idx:int @array:67:29, ?#result:T @array:67:5):
    inbounds(a @array:68:14, idx @array:68:17)
    unsafe_get(a @array:69:10, idx @array:69:23, ?tmp#0 @array:69:10)
    =(?x @array:69:6, tmp#0)
    foreign llvm move(x @array:67:42, ?#result @array:67:5)
[] > public {test} (0 calls)
1: [](!a:_(T) @array:81:22, idx:int @array:81:30, x:T @array:81:39):
    inbounds(a @array:82:14, idx @array:82:17)
    unsafe_update(!a @array:83:20, idx @array:83:23, x @array:83:28)


[|] > public {test} (0 calls)
0: [|](?head:T @array:51:23, ?tail:_(T) @array:51:32, a:_(T) @array:51:43):
    array(?length @array:52:12, ?data @array:52:21, a @array:52:29)
    >(length @array:53:6, 0 @array:53:15)
    word_size_bytes(?tmp#0 @array:54:34)
    foreign lpvm access(data @array:54:25, 0 @array:54:31, tmp#0, 0 @array:54:51, ?head @array:54:55)
    word_size_bytes(?tmp#1 @array:55:28)
    foreign llvm add(data @array:55:22, tmp#1, ?data @array:55:46)
    -(length @array:56:19, 1 @array:56:28, ?tmp#3 @array:56:19)
    array(tmp#3, data @array:56:31, ?tmp#2 @array:56:13)
    =(?tail @array:56:6, tmp#2)


array > public (0 calls)
0: array(x:T @array:18:15, len:int @array:18:20, ?#result:_(T) @array:18:5):
    word_size_bytes(?tmp#1 @array:19:19)
    *(len @array:19:13, tmp#1, ?tmp#0 @array:19:13)
    =(?size @array:19:6, tmp#0)
    foreign lpvm alloc(size @array:20:24, ?data @array:20:31)
    =(?offset @array:21:6, 0 @array:21:15)
    do {
        if {<(offset @array:23:15, size @array:23:24)::

            pass
        else::
            break

        }
        foreign lpvm mutate(data @array:24:29, ?data @array:24:36, offset @array:24:42, 1 @array:24:50, size @array:24:53, 0 @array:24:59, x @array:24:62)
        word_size_bytes(?tmp#2 @array:25:21)
        +=(!offset @array:25:10, tmp#2)
    }
    array(len @array:27:17, data @array:27:22, ?tmp#3 @array:27:11)
    =(?ar @array:27:6, tmp#3)
    foreign llvm move(ar @array:18:36, ?#result @array:18:5)
array > public (0 calls)
1: array(ls:list(T) @array:34:15, ?#result:_(T) @array:34:5):
    length(ls @array:35:19, ?tmp#0 @array:35:12)
    =(?len @array:35:6, tmp#0)
    word_size_bytes(?tmp#2 @array:36:19)
    *(len @array:36:13, tmp#2, ?tmp#1 @array:36:13)
    =(?size @array:36:6, tmp#1)
    foreign lpvm alloc(size @array:37:24, ?data @array:37:31)
    =(?offset @array:38:6, 0 @array:38:15)
    foreign llvm move(ls @array:39:15, ?tmp#3)
    do {
        if {[|](?x @array:39:10, ?tmp#3, tmp#3)::

            foreign lpvm mutate(data @array:40:29, ?data @array:40:36, offset @array:40:42, 1 @array:40:50, size @array:40:53, 0 @array:40:59, x @array:40:62)
            word_size_bytes(?tmp#4 @array:41:21)
            +=(!offset @array:41:10, tmp#4)
        else::
            break

        }
    }
    array(len @array:43:17, data @array:43:22, ?tmp#5 @array:43:11)
    =(?ar @array:43:6, tmp#5)
    foreign llvm move(ar @array:34:34, ?#result @array:34:5)


inbounds > public {test,inline} (0 calls)
0: inbounds(a:_(T) @array:60:33, idx:int @array:60:41):
    <=(0 @array:61:6, idx @array:61:12)
    length(a @array:62:12, ?tmp#0 @array:62:12)
    <(idx @array:62:6, tmp#0)


unsafe_get > public {inline} (0 calls)
0: unsafe_get(a:_(T) @array:75:29, idx:int @array:75:37, ?#result:T @array:75:5):
    raw_data(a @array:76:25, ?tmp#0 @array:76:25)
    word_size_bytes(?tmp#2 @array:76:43)
    *(idx @array:76:37, tmp#2, ?tmp#1 @array:76:37)
    word_size_bytes(?tmp#3 @array:76:60)
    foreign lpvm access(tmp#0, tmp#1, tmp#3, 0 @array:76:77, ?x @array:76:81)
    foreign llvm move(x @array:75:50, ?#result @array:75:5)


unsafe_update > public {inline} (0 calls)
0: unsafe_update(!a:_(T) @array:89:33, idx:int @array:89:41, x:T @array:89:50):
    raw_data(a @array:90:25, ?tmp#0 @array:90:25)
    word_size_bytes(?tmp#2 @array:90:50)
    *(idx @array:90:44, tmp#2, ?tmp#1 @array:90:44)
    length(a @array:91:44, ?tmp#4 @array:91:44)
    word_size_bytes(?tmp#5 @array:91:55)
    *(tmp#4, tmp#5, ?tmp#3 @array:91:44)
    foreign lpvm mutate(tmp#0, ?data @array:90:38, tmp#1, 0 @array:90:67, tmp#3, 0 @array:91:72, x @array:91:75)
    raw_data(!a @array:92:6, data @array:92:19)

LLVM code       : None

--------------------------------------------------
 Module wybe.array.raw_array(T)
  representation  : address
  public submods  : 
  public resources: 
  public procs    : 
  imports         : use wybe
                    use wybe.array
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.bool
  representation  : 1 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.bool.&&<0>
                    wybe.bool.&=<0>
                    wybe.bool.=<0>
                    wybe.bool.^=<0>
                    wybe.bool.^^<0>
                    wybe.bool.false<0>
                    wybe.bool.print<0>
                    wybe.bool.println<0>
                    wybe.bool.succeed<0>
                    wybe.bool.true<0>
                    wybe.bool.|=<0>
                    wybe.bool.||<0>
                    wybe.bool.~<0>
                    wybe.bool.~=<0>
  imports         : use wybe.c_string
                    use wybe.io
  resources       : 
  procs           : 

&& > public (0 calls)
0: &&(p:_ @bool:13:10, q:_ @bool:13:18, ?#result:_ @bool:13:5):
    foreign llvm and(p @bool:13:44, q @bool:13:47, ?tmp#0 @bool:13:27)
    foreign llvm move(tmp#0, ?#result @bool:13:5)


&= > public (0 calls)
0: &=(!p:_ @bool:16:11, q:_ @bool:16:19):
    &&(p @bool:16:32, q @bool:16:38, ?tmp#0 @bool:16:32)
    =(?p @bool:16:27, tmp#0)


= > public (0 calls)
0: =(x:_ @bool:37:10, y:_ @bool:37:17, ?#result:_ @bool:37:5):
    foreign llvm icmp_eq(x @bool:37:47, y @bool:37:50, ?tmp#0 @bool:37:26)
    foreign llvm move(tmp#0, ?#result @bool:37:5)


^= > public (0 calls)
0: ^=(!p:_ @bool:28:11, q:_ @bool:28:19):
    ^^(q @bool:28:31, p @bool:28:37, ?tmp#0 @bool:28:31)
    =(?p @bool:28:27, tmp#0)


^^ > public (0 calls)
0: ^^(p:_ @bool:25:10, q:_ @bool:25:18, ?#result:_ @bool:25:5):
    foreign llvm xor(p @bool:25:44, q @bool:25:47, ?tmp#0 @bool:25:27)
    foreign llvm move(tmp#0, ?#result @bool:25:5)


false > public {inline} (0 calls)
0: false(?#result:_ @bool:8:18):
    foreign lpvm cast(0:!_, ?#result)


print > public (0 calls)
0: print(x:_ @bool:47:15) use !io:
    if {x::

        foreign llvm move(c"true" @bool:47:45, ?tmp#0)
    else::
        foreign llvm move(c"false" @bool:47:60, ?tmp#0)

    }
    !print(tmp#0 @bool:47:41)


println > public (0 calls)
0: println(x:_ @bool:49:17) use !io:
    !print(x @bool:49:39)
    !nl


succeed > public (0 calls)
0: succeed():
    pass


true > public {inline} (0 calls)
0: true(?#result:_ @bool:8:26):
    foreign lpvm cast(1:!_, ?#result)


|= > public (0 calls)
0: |=(!p:_ @bool:22:11, q:_ @bool:22:19):
    ||(p @bool:22:32, q @bool:22:38, ?tmp#0 @bool:22:32)
    =(?p @bool:22:27, tmp#0)


|| > public (0 calls)
0: ||(p:_ @bool:19:10, q:_ @bool:19:18, ?#result:_ @bool:19:5):
    foreign llvm or(p @bool:19:43, q @bool:19:46, ?tmp#0 @bool:19:27)
    foreign llvm move(tmp#0, ?#result @bool:19:5)


~ > public (0 calls)
0: ~(p:_ @bool:31:11, ?#result:_ @bool:31:5):
    true(?tmp#1 @bool:31:40)
    foreign llvm xor(p @bool:31:37, tmp#1, ?tmp#0 @bool:31:20)
    foreign llvm move(tmp#0, ?#result @bool:31:5)


~= > public (0 calls)
0: ~=(x:_ @bool:38:10, y:_ @bool:38:18, ?#result:_ @bool:38:5):
    foreign llvm icmp_ne(x @bool:38:48, y @bool:38:51, ?tmp#0 @bool:38:27)
    foreign llvm move(tmp#0, ?#result @bool:38:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.c_string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.c_string.<<0>
                    wybe.c_string.<=<0>
                    wybe.c_string.=<0>
                    wybe.c_string.><0>
                    wybe.c_string.>=<0>
                    wybe.c_string.[]<0>
                    wybe.c_string.[|]<0>
                    wybe.c_string.length<0>
                    wybe.c_string.print<0>
                    wybe.c_string.println<0>
                    wybe.c_string.read<0>
                    wybe.c_string.unsafe_c_string_index<0>
                    wybe.c_string.~=<0>
  imports         : use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:_ @c_string:12:10, y:_ @c_string:12:17, ?#result:bool @c_string:12:5):
    foreign c strcmp(x @c_string:12:46, y @c_string:12:48, ?tmp#1:int @c_string:12:29)
    <(tmp#1:int, 0 @c_string:12:57, ?tmp#0 @c_string:12:29)
    foreign llvm move(tmp#0, ?#result @c_string:12:5)


<= > public (0 calls)
0: <=(x:_ @c_string:13:10, y:_ @c_string:13:18, ?#result:bool @c_string:13:5):
    foreign c strcmp(x @c_string:13:47, y @c_string:13:49, ?tmp#1:int @c_string:13:30)
    <=(tmp#1:int, 0 @c_string:13:60, ?tmp#0 @c_string:13:30)
    foreign llvm move(tmp#0, ?#result @c_string:13:5)


= > public (0 calls)
0: =(x:_ @c_string:10:10, y:_ @c_string:10:17, ?#result:bool @c_string:10:5):
    foreign c strcmp(x @c_string:10:46, y @c_string:10:48, ?tmp#1:int @c_string:10:29)
    =(tmp#1:int, 0 @c_string:10:57, ?tmp#0 @c_string:10:29)
    foreign llvm move(tmp#0, ?#result @c_string:10:5)


> > public (0 calls)
0: >(x:_ @c_string:14:10, y:_ @c_string:14:17, ?#result:bool @c_string:14:5):
    foreign c strcmp(x @c_string:14:46, y @c_string:14:48, ?tmp#1:int @c_string:14:29)
    >(tmp#1:int, 0 @c_string:14:57, ?tmp#0 @c_string:14:29)
    foreign llvm move(tmp#0, ?#result @c_string:14:5)


>= > public (0 calls)
0: >=(x:_ @c_string:15:10, y:_ @c_string:15:18, ?#result:bool @c_string:15:5):
    foreign c strcmp(x @c_string:15:47, y @c_string:15:49, ?tmp#1:int @c_string:15:30)
    >=(tmp#1:int, 0 @c_string:15:60, ?tmp#0 @c_string:15:30)
    foreign llvm move(tmp#0, ?#result @c_string:15:5)


[] > public {test} (0 calls)
0: [](str:_ @c_string:26:19, idx:int @c_string:26:26, ?#result:char @c_string:26:5):
    <=(0 @c_string:27:6, idx @c_string:27:12)
    length(str @c_string:28:19, ?tmp#0 @c_string:28:12)
    <(idx @c_string:28:6, tmp#0)
    unsafe_c_string_index(str @c_string:29:32, idx @c_string:29:37, ?tmp#1 @c_string:29:10)
    =(?c @c_string:29:6, tmp#1)
    foreign llvm move(c @c_string:26:42, ?#result @c_string:26:5)


[|] > public {test} (0 calls)
0: [|](?head:char @c_string:19:23, ?tail:_ @c_string:19:35, str:_ @c_string:19:43):
    foreign lpvm access(str @c_string:20:25, 0 @c_string:20:30, 0 @c_string:20:33, 0 @c_string:20:36, ?head @c_string:20:40)
    foreign llvm icmp_ne(head @c_string:21:26, '\NUL' @c_string:21:32, ?not_done @c_string:21:37)
    true(?tmp#0 @c_string:22:17)
    =(not_done @c_string:22:6, tmp#0)
    foreign llvm add(str @c_string:23:22, 1 @c_string:23:27, ?tail @c_string:23:31)


length > public (0 calls)
0: length(str:_ @c_string:17:16, ?#result:int @c_string:17:5):
    foreign c strlen(str @c_string:17:46, ?tmp#0 @c_string:17:29)
    foreign llvm move(tmp#0, ?#result @c_string:17:5)


print > public (0 calls)
0: print(x:_ @c_string:35:15) use !io:
    foreign c print_string(x @c_string:35:53, !io @c_string:35:57)


println > public (0 calls)
0: println(x:_ @c_string:37:17) use !io:
    !print(x @c_string:37:39)
    !nl


read > public (0 calls)
0: read(?x:_ @c_string:39:15) use !io:
    foreign c read_line(?x @c_string:39:51, !io @c_string:39:55)


unsafe_c_string_index > public (0 calls)
0: unsafe_c_string_index(str:_ @c_string:32:31, idx:int @c_string:32:38, ?#result:char @c_string:32:5):
    foreign lpvm access(str @c_string:33:27, idx @c_string:33:32, 1 @c_string:33:37, 0 @c_string:33:40, ?tmp#0 @c_string:33:7)
    foreign llvm move(tmp#0, ?#result @c_string:32:5)


~= > public (0 calls)
0: ~=(x:_ @c_string:11:10, y:_ @c_string:11:18, ?#result:bool @c_string:11:5):
    foreign c strcmp(x @c_string:11:47, y @c_string:11:49, ?tmp#1:int @c_string:11:30)
    ~=(tmp#1:int, 0 @c_string:11:60, ?tmp#0 @c_string:11:30)
    foreign llvm move(tmp#0, ?#result @c_string:11:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.char
  representation  : 8 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.char.<<0>
                    wybe.char.<=<0>
                    wybe.char.<=><0>
                    wybe.char.=<0>
                    wybe.char.><0>
                    wybe.char.>=<0>
                    wybe.char.chr<0>
                    wybe.char.ord<0>
                    wybe.char.print<0>
                    wybe.char.println<0>
                    wybe.char.read<0>
                    wybe.char.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:_ @char:17:10, y:_ @char:17:17, ?#result:bool @char:17:5):
    foreign llvm icmp_ult(x @char:17:51, y @char:17:54, ?tmp#0 @char:17:29)
    foreign llvm move(tmp#0, ?#result @char:17:5)


<= > public (0 calls)
0: <=(x:_ @char:18:10, y:_ @char:18:18, ?#result:bool @char:18:5):
    foreign llvm icmp_ule(x @char:18:52, y @char:18:55, ?tmp#0 @char:18:30)
    foreign llvm move(tmp#0, ?#result @char:18:5)


<=> > public (0 calls)
0: <=>(x:_ @char:23:10, y:_ @char:23:20, ?#result:comparison @char:23:5):
    if {<(x @char:24:10, y @char:24:14)::

        lesser(?tmp#1 @char:24:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @char:24:28, y @char:24:32)::

            equal(?tmp#3 @char:24:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @char:24:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @char:24:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @char:24:10, ?#result @char:23:5)


= > public (0 calls)
0: =(x:_ @char:13:10, y:_ @char:13:17, ?#result:bool @char:13:5):
    foreign llvm icmp_eq(x @char:13:50, y @char:13:53, ?tmp#0 @char:13:29)
    foreign llvm move(tmp#0, ?#result @char:13:5)


> > public (0 calls)
0: >(x:_ @char:19:10, y:_ @char:19:17, ?#result:bool @char:19:5):
    foreign llvm icmp_ugt(x @char:19:51, y @char:19:54, ?tmp#0 @char:19:29)
    foreign llvm move(tmp#0, ?#result @char:19:5)


>= > public (0 calls)
0: >=(x:_ @char:20:10, y:_ @char:20:18, ?#result:bool @char:20:5):
    foreign llvm icmp_uge(x @char:20:52, y @char:20:55, ?tmp#0 @char:20:30)
    foreign llvm move(tmp#0, ?#result @char:20:5)


chr > public {test} (0 calls)
0: chr(i:int @char:33:20, ?#result:_ @char:33:5):
    <=(0 @char:33:60, i @char:33:66)
    <=(i @char:33:70, 255 @char:33:76)
    foreign lpvm cast(i @char:33:49, ?tmp#0 @char:33:31)
    foreign llvm move(tmp#0, ?#result @char:33:5)


ord > public (0 calls)
0: ord(c:_ @char:30:13, ?#result:int @char:30:5):
    foreign lpvm cast(c @char:30:42, ?tmp#0 @char:30:24)
    foreign llvm move(tmp#0, ?#result @char:30:5)


print > public (0 calls)
0: print(x:_ @char:37:15) use !io:
    foreign c putchar(x @char:37:48, !io @char:37:52)


println > public (0 calls)
0: println(x:_ @char:39:17) use !io:
    !print(x @char:39:39)
    !nl


read > public (0 calls)
0: read(?x:_ @char:41:15) use !io:
    foreign c read_char(?x @char:41:51, !io @char:41:55)


~= > public (0 calls)
0: ~=(x:_ @char:14:10, y:_ @char:14:18, ?#result:bool @char:14:5):
    foreign llvm icmp_ne(x @char:14:51, y @char:14:54, ?tmp#0 @char:14:30)
    foreign llvm move(tmp#0, ?#result @char:14:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.comparison
  representation  : 2 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.comparison.<<0>
                    wybe.comparison.<=<0>
                    wybe.comparison.=<0>
                    wybe.comparison.><0>
                    wybe.comparison.>=<0>
                    wybe.comparison.equal<0>
                    wybe.comparison.greater<0>
                    wybe.comparison.lesser<0>
                    wybe.comparison.~=<0>
  imports         : use wybe.bool
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:_ @comparison:12:10, y:_ @comparison:12:17, ?#result:bool @comparison:12:5):
    foreign llvm icmp_ult(x @comparison:12:51, y @comparison:12:54, ?tmp#0 @comparison:12:29)
    foreign llvm move(tmp#0, ?#result @comparison:12:5)


<= > public (0 calls)
0: <=(x:_ @comparison:13:10, y:_ @comparison:13:18, ?#result:bool @comparison:13:5):
    foreign llvm icmp_ule(x @comparison:13:52, y @comparison:13:55, ?tmp#0 @comparison:13:30)
    foreign llvm move(tmp#0, ?#result @comparison:13:5)


= > public (0 calls)
0: =(x:_ @comparison:10:10, y:_ @comparison:10:17, ?#result:bool @comparison:10:5):
    foreign llvm icmp_eq(x @comparison:10:50, y @comparison:10:53, ?tmp#0 @comparison:10:29)
    foreign llvm move(tmp#0, ?#result @comparison:10:5)


> > public (0 calls)
0: >(x:_ @comparison:14:10, y:_ @comparison:14:17, ?#result:bool @comparison:14:5):
    foreign llvm icmp_ugt(x @comparison:14:51, y @comparison:14:54, ?tmp#0 @comparison:14:29)
    foreign llvm move(tmp#0, ?#result @comparison:14:5)


>= > public (0 calls)
0: >=(x:_ @comparison:15:10, y:_ @comparison:15:18, ?#result:bool @comparison:15:5):
    foreign llvm icmp_uge(x @comparison:15:52, y @comparison:15:55, ?tmp#0 @comparison:15:30)
    foreign llvm move(tmp#0, ?#result @comparison:15:5)


equal > public {inline} (0 calls)
0: equal(?#result:_ @comparison:8:27):
    foreign lpvm cast(1:!_, ?#result)


greater > public {inline} (0 calls)
0: greater(?#result:_ @comparison:8:35):
    foreign lpvm cast(2:!_, ?#result)


lesser > public {inline} (0 calls)
0: lesser(?#result:_ @comparison:8:18):
    foreign lpvm cast(0:!_, ?#result)


~= > public (0 calls)
0: ~=(x:_ @comparison:11:10, y:_ @comparison:11:18, ?#result:bool @comparison:11:5):
    foreign llvm icmp_ne(x @comparison:11:51, y @comparison:11:54, ?tmp#0 @comparison:11:30)
    foreign llvm move(tmp#0, ?#result @comparison:11:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.control
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.control.assert<0>
                    wybe.control.error<0>
                    wybe.control.error<1>
                    wybe.control.exit<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.int
                    use wybe.string
  resources       : 
  procs           : 

assert > public {semipure} (0 calls)
0: assert(condition:bool @control:26:27) use call_source_location:
    if {~(condition @control:27:11)::

        !error(c"assertion failed" @control:27:31)
    else::
        pass

    }


error > public {terminal,semipure} (0 calls)
0: error(message:string @control:17:35) use call_source_location:
    c_string(message @control:18:77, ?tmp#0 @control:18:68)
    foreign c {terminal,semipure} error_exit(call_source_location @control:18:46, tmp#0)
error > public {terminal,semipure} (0 calls)
1: error(message:c_string @control:21:35) use call_source_location:
    foreign c {terminal,semipure} error_exit(call_source_location @control:22:46, message @control:22:68)


exit > public {terminal,semipure} (0 calls)
0: exit(code:int @control:10:34):
    foreign c {terminal,semipure} exit(code @control:11:40)

LLVM code       : None

--------------------------------------------------
 Module wybe.count
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.count.%<0>
                    wybe.count.%=<0>
                    wybe.count.*<0>
                    wybe.count.*=<0>
                    wybe.count.+<0>
                    wybe.count.+<1>
                    wybe.count.+<2>
                    wybe.count.+=<0>
                    wybe.count.-<0>
                    wybe.count.-<1>
                    wybe.count.-<2>
                    wybe.count.-=<0>
                    wybe.count./<0>
                    wybe.count./=<0>
                    wybe.count.<<0>
                    wybe.count.<=<0>
                    wybe.count.<=><0>
                    wybe.count.=<0>
                    wybe.count.><0>
                    wybe.count.>=<0>
                    wybe.count.decr<0>
                    wybe.count.incr<0>
                    wybe.count.max<0>
                    wybe.count.min<0>
                    wybe.count.print<0>
                    wybe.count.println<0>
                    wybe.count.read<0>
                    wybe.count.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public (0 calls)
0: %(x:_ @count:51:10, y:_ @count:51:16, ?#result:_ @count:51:5):
    foreign llvm urem(x @count:51:43, y @count:51:45, ?tmp#0 @count:51:25)
    foreign llvm move(tmp#0, ?#result @count:51:5)


%= > public (0 calls)
0: %=(!x:_ @count:54:11, y:_ @count:54:19):
    %(x @count:54:31, y @count:54:35, ?tmp#0 @count:54:31)
    =(?x @count:54:27, tmp#0)


* > public (0 calls)
0: *(x:_ @count:39:10, y:_ @count:39:16, ?#result:_ @count:39:5):
    foreign llvm mul(x @count:39:42, y @count:39:44, ?tmp#0 @count:39:25)
    foreign llvm move(tmp#0, ?#result @count:39:5)


*= > public (0 calls)
0: *=(!x:_ @count:42:11, y:_ @count:42:19):
    *(x @count:42:31, y @count:42:35, ?tmp#0 @count:42:31)
    =(?x @count:42:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @count:15:10, y:_ @count:15:16, ?#result:_ @count:15:5):
    foreign llvm add(x @count:15:42, y @count:15:44, ?tmp#0 @count:15:25)
    foreign llvm move(tmp#0, ?#result @count:15:5)
+ > public {test} (0 calls)
1: +(?x:_ @count:16:21, y:_ @count:16:27, z:_ @count:16:5):
    >=(z @count:17:5, y @count:17:11)
    foreign llvm sub(z @count:18:27, y @count:18:29, ?tmp#0 @count:18:10)
    =(?x @count:18:6, tmp#0)
+ > public {test} (0 calls)
2: +(x:_ @count:20:20, ?y:_ @count:20:27, z:_ @count:20:5):
    >=(z @count:21:5, x @count:21:11)
    foreign llvm sub(z @count:22:27, x @count:22:29, ?tmp#0 @count:22:10)
    =(?y @count:22:6, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @count:26:11, y:_ @count:26:19):
    +(x @count:26:31, y @count:26:35, ?tmp#0 @count:26:31)
    =(?x @count:26:27, tmp#0)


- > public {test} (0 calls)
0: -(x:_ @count:31:20, y:_ @count:31:26, ?#result:_ @count:31:5):
    >=(y @count:31:65, x @count:31:71)
    foreign llvm sub(x @count:31:52, y @count:31:54, ?tmp#0 @count:31:35)
    foreign llvm move(tmp#0, ?#result @count:31:5)
- > public (0 calls)
1: -(?x:_ @count:32:11, y:_ @count:32:17, z:_ @count:32:5):
    foreign llvm add(z @count:32:59, y @count:32:61, ?tmp#0 @count:32:42)
    =(?x @count:32:38, tmp#0)
- > public (0 calls)
2: -(x:_ @count:33:10, ?y:_ @count:33:17, z:_ @count:33:5):
    foreign llvm sub(z @count:33:59, x @count:33:61, ?tmp#0 @count:33:42)
    =(?y @count:33:38, tmp#0)


-= > public {test} (0 calls)
0: -=(!x:_ @count:36:21, y:_ @count:36:29):
    -(x @count:36:41, y @count:36:45, ?tmp#0 @count:36:41)
    =(?x @count:36:37, tmp#0)


/ > public (0 calls)
0: /(x:_ @count:45:10, y:_ @count:45:16, ?#result:_ @count:45:5):
    foreign llvm udiv(x @count:45:43, y @count:45:45, ?tmp#0 @count:45:25)
    foreign llvm move(tmp#0, ?#result @count:45:5)


/= > public (0 calls)
0: /=(!x:_ @count:48:11, y:_ @count:48:19):
    /(x @count:48:31, y @count:48:35, ?tmp#0 @count:48:31)
    =(?x @count:48:27, tmp#0)


< > public (0 calls)
0: <(x:_ @count:64:10, y:_ @count:64:17, ?#result:bool @count:64:5):
    foreign llvm icmp_ult(x @count:64:51, y @count:64:53, ?tmp#0 @count:64:29)
    foreign llvm move(tmp#0, ?#result @count:64:5)


<= > public (0 calls)
0: <=(x:_ @count:65:10, y:_ @count:65:18, ?#result:bool @count:65:5):
    foreign llvm icmp_ule(x @count:65:52, y @count:65:54, ?tmp#0 @count:65:30)
    foreign llvm move(tmp#0, ?#result @count:65:5)


<=> > public (0 calls)
0: <=>(x:_ @count:70:10, y:_ @count:70:20, ?#result:comparison @count:70:5):
    if {<(x @count:71:10, y @count:71:14)::

        lesser(?tmp#1 @count:71:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @count:71:28, y @count:71:32)::

            equal(?tmp#3 @count:71:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @count:71:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @count:71:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:71:10, ?#result @count:70:5)


= > public (0 calls)
0: =(x:_ @count:60:10, y:_ @count:60:17, ?#result:bool @count:60:5):
    foreign llvm icmp_eq(x @count:60:50, y @count:60:52, ?tmp#0 @count:60:29)
    foreign llvm move(tmp#0, ?#result @count:60:5)


> > public (0 calls)
0: >(x:_ @count:66:10, y:_ @count:66:17, ?#result:bool @count:66:5):
    foreign llvm icmp_ugt(x @count:66:51, y @count:66:53, ?tmp#0 @count:66:29)
    foreign llvm move(tmp#0, ?#result @count:66:5)


>= > public (0 calls)
0: >=(x:_ @count:67:10, y:_ @count:67:18, ?#result:bool @count:67:5):
    foreign llvm icmp_uge(x @count:67:52, y @count:67:54, ?tmp#0 @count:67:30)
    foreign llvm move(tmp#0, ?#result @count:67:5)


decr > public {test} (0 calls)
0: decr(!x:_ @count:84:25):
    -(x @count:84:37, 1:_ @count:84:41, ?tmp#0 @count:84:37)
    =(?x @count:84:33, tmp#0)


incr > public (0 calls)
0: incr(!x:_ @count:81:15):
    +(x @count:81:27, 1:_ @count:81:31, ?tmp#0 @count:81:27)
    =(?x @count:81:23, tmp#0)


max > public (0 calls)
0: max(x:_ @count:75:13, y:_ @count:75:18, ?#result:_ @count:75:5):
    if {>=(x @count:75:31, y @count:75:35)::

        foreign llvm move(x @count:75:39, ?tmp#0)
    else::
        foreign llvm move(y @count:75:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:75:31, ?#result @count:75:5)


min > public (0 calls)
0: min(x:_ @count:74:13, y:_ @count:74:18, ?#result:_ @count:74:5):
    if {<=(x @count:74:31, y @count:74:35)::

        foreign llvm move(x @count:74:39, ?tmp#0)
    else::
        foreign llvm move(y @count:74:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:74:31, ?#result @count:74:5)


print > public (0 calls)
0: print(x:_ @count:88:15) use !io:
    foreign c print_count(x @count:88:52, !io @count:88:56)


println > public (0 calls)
0: println(x:_ @count:90:17) use !io:
    !print(x @count:90:39)
    !nl


read > public (0 calls)
0: read(?x:_ @count:92:15) use !io:
    foreign c read_count(?x @count:92:52, !io @count:92:56)


~= > public (0 calls)
0: ~=(x:_ @count:61:10, y:_ @count:61:18, ?#result:bool @count:61:5):
    foreign llvm icmp_ne(x @count:61:51, y @count:61:53, ?tmp#0 @count:61:30)
    foreign llvm move(tmp#0, ?#result @count:61:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.float
  representation  : 64 bit float
  public submods  : 
  public resources: 
  public procs    : wybe.float.*<0>
                    wybe.float.**<0>
                    wybe.float.*=<0>
                    wybe.float.+<0>
                    wybe.float.+<1>
                    wybe.float.+<2>
                    wybe.float.+=<0>
                    wybe.float.-<0>
                    wybe.float.-<1>
                    wybe.float.-<2>
                    wybe.float.-<3>
                    wybe.float.-<4>
                    wybe.float.-=<0>
                    wybe.float./<0>
                    wybe.float./=<0>
                    wybe.float.<<0>
                    wybe.float.<=<0>
                    wybe.float.<=><0>
                    wybe.float.=<0>
                    wybe.float.><0>
                    wybe.float.>=<0>
                    wybe.float.abs<0>
                    wybe.float.ceil<0>
                    wybe.float.cos<0>
                    wybe.float.e<0>
                    wybe.float.exp<0>
                    wybe.float.floor<0>
                    wybe.float.iceil<0>
                    wybe.float.ifloor<0>
                    wybe.float.iround<0>
                    wybe.float.log<0>
                    wybe.float.log10<0>
                    wybe.float.log2<0>
                    wybe.float.max<0>
                    wybe.float.min<0>
                    wybe.float.pi<0>
                    wybe.float.power<0>
                    wybe.float.print<0>
                    wybe.float.println<0>
                    wybe.float.read<0>
                    wybe.float.round<0>
                    wybe.float.sin<0>
                    wybe.float.sqrt<0>
                    wybe.float.square<0>
                    wybe.float.tan<0>
                    wybe.float.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

* > public (0 calls)
0: *(x:_ @float:45:10, y:_ @float:45:16, ?#result:_ @float:45:5):
    foreign llvm fmul(x @float:45:43, y @float:45:45, ?tmp#0 @float:45:25)
    foreign llvm move(tmp#0, ?#result @float:45:5)


** > public (0 calls)
0: **(x:_ @float:112:10, n:_ @float:112:18, ?#result:_ @float:112:5):
    foreign c llvm.pow.f64(x @float:112:52, n @float:112:54, ?tmp#0 @float:112:27)
    foreign llvm move(tmp#0, ?#result @float:112:5)


*= > public (0 calls)
0: *=(!x:_ @float:48:11, y:_ @float:48:19):
    *(x @float:48:31, y @float:48:35, ?tmp#0 @float:48:31)
    =(?x @float:48:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @float:23:10, y:_ @float:23:17, ?#result:_ @float:23:5):
    foreign llvm fadd(x @float:23:45, y @float:23:47, ?tmp#0 @float:23:27)
    foreign llvm move(tmp#0, ?#result @float:23:5)
+ > public (0 calls)
1: +(?x:_ @float:24:11, y:_ @float:24:17, z:_ @float:24:5):
    foreign llvm fsub(z @float:24:61, y @float:24:63, ?tmp#0 @float:24:43)
    =(?x @float:24:39, tmp#0)
+ > public (0 calls)
2: +(x:_ @float:25:10, ?y:_ @float:25:18, z:_ @float:25:5):
    foreign llvm fsub(z @float:25:61, x @float:25:63, ?tmp#0 @float:25:43)
    =(?y @float:25:39, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @float:28:11, y:_ @float:28:19):
    +(x @float:28:31, y @float:28:35, ?tmp#0 @float:28:31)
    =(?x @float:28:27, tmp#0)


- > public (0 calls)
0: -(x:_ @float:32:10, y:_ @float:32:17, ?#result:_ @float:32:5):
    foreign llvm fsub(x @float:32:45, y @float:32:47, ?tmp#0 @float:32:27)
    foreign llvm move(tmp#0, ?#result @float:32:5)
- > public (0 calls)
1: -(?x:_ @float:33:11, y:_ @float:33:17, z:_ @float:33:5):
    foreign llvm fadd(z @float:33:61, y @float:33:63, ?tmp#0 @float:33:43)
    =(?x @float:33:39, tmp#0)
- > public (0 calls)
2: -(x:_ @float:34:10, ?y:_ @float:34:18, z:_ @float:34:5):
    foreign llvm fsub(z @float:34:61, x @float:34:63, ?tmp#0 @float:34:43)
    =(?y @float:34:39, tmp#0)
- > public (0 calls)
3: -(x:_ @float:38:11, ?#result:_ @float:38:5):
    foreign llvm fsub(0.0 @float:38:39, x @float:38:43, ?tmp#0 @float:38:21)
    foreign llvm move(tmp#0, ?#result @float:38:5)
- > public (0 calls)
4: -(?x:_ @float:39:12, y:_ @float:39:5):
    foreign llvm fsub(0.0 @float:39:55, y @float:39:59, ?tmp#0 @float:39:37)
    =(?x @float:39:33, tmp#0)


-= > public (0 calls)
0: -=(!x:_ @float:42:11, y:_ @float:42:19):
    -(x @float:42:31, y @float:42:35, ?tmp#0 @float:42:31)
    =(?x @float:42:27, tmp#0)


/ > public (0 calls)
0: /(x:_ @float:51:10, y:_ @float:51:16, ?#result:_ @float:51:5):
    foreign llvm fdiv(x @float:51:43, y @float:51:45, ?tmp#0 @float:51:25)
    foreign llvm move(tmp#0, ?#result @float:51:5)


/= > public (0 calls)
0: /=(!x:_ @float:54:11, y:_ @float:54:19):
    /(x @float:54:31, y @float:54:35, ?tmp#0 @float:54:31)
    =(?x @float:54:27, tmp#0)


< > public (0 calls)
0: <(x:_ @float:70:10, y:_ @float:70:17, ?#result:bool @float:70:5):
    foreign llvm fcmp_slt(x @float:70:51, y @float:70:53, ?tmp#0 @float:70:29)
    foreign llvm move(tmp#0, ?#result @float:70:5)


<= > public (0 calls)
0: <=(x:_ @float:71:10, y:_ @float:71:18, ?#result:bool @float:71:5):
    foreign llvm fcmp_sle(x @float:71:52, y @float:71:54, ?tmp#0 @float:71:30)
    foreign llvm move(tmp#0, ?#result @float:71:5)


<=> > public (0 calls)
0: <=>(x:_ @float:76:10, y:_ @float:76:20, ?#result:comparison @float:76:5):
    if {<(x @float:77:10, y @float:77:14)::

        lesser(?tmp#1 @float:77:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @float:77:28, y @float:77:32)::

            equal(?tmp#3 @float:77:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @float:77:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @float:77:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @float:77:10, ?#result @float:76:5)


= > public (0 calls)
0: =(x:_ @float:66:10, y:_ @float:66:17, ?#result:bool @float:66:5):
    foreign llvm fcmp_eq(x @float:66:50, y @float:66:52, ?tmp#0 @float:66:29)
    foreign llvm move(tmp#0, ?#result @float:66:5)


> > public (0 calls)
0: >(x:_ @float:72:10, y:_ @float:72:17, ?#result:bool @float:72:5):
    foreign llvm fcmp_sgt(x @float:72:51, y @float:72:53, ?tmp#0 @float:72:29)
    foreign llvm move(tmp#0, ?#result @float:72:5)


>= > public (0 calls)
0: >=(x:_ @float:73:10, y:_ @float:73:18, ?#result:bool @float:73:5):
    foreign llvm fcmp_sge(x @float:73:52, y @float:73:54, ?tmp#0 @float:73:30)
    foreign llvm move(tmp#0, ?#result @float:73:5)


abs > public (0 calls)
0: abs(x:_ @float:60:13, ?#result:_ @float:60:5):
    foreign c llvm.fabs.f64(x @float:60:48, ?tmp#0 @float:60:22)
    foreign llvm move(tmp#0, ?#result @float:60:5)


ceil > public (0 calls)
0: ceil(x:_ @float:87:14, ?#result:_ @float:87:5):
    foreign c llvm.ceil.f64(x @float:87:49, ?tmp#0 @float:87:23)
    foreign llvm move(tmp#0, ?#result @float:87:5)


cos > public (0 calls)
0: cos(x:_ @float:116:13, ?#result:_ @float:116:5):
    foreign c llvm.cos.f64(x @float:116:47, ?tmp#0 @float:116:22)
    foreign llvm move(tmp#0, ?#result @float:116:5)


e > public (0 calls)
0: e(?#result:_ @float:16:5):
    foreign llvm move(2.7182818284590455 @float:16:15, ?#result @float:16:5)


exp > public (0 calls)
0: exp(x:_ @float:120:13, ?#result:_ @float:120:5):
    foreign c llvm.exp.f64(x @float:120:47, ?tmp#0 @float:120:22)
    foreign llvm move(tmp#0, ?#result @float:120:5)


floor > public (0 calls)
0: floor(x:_ @float:90:15, ?#result:_ @float:90:5):
    foreign c llvm.floor.f64(x @float:90:51, ?tmp#0 @float:90:24)
    foreign llvm move(tmp#0, ?#result @float:90:5)


iceil > public (0 calls)
0: iceil(x:_ @float:99:15, ?#result:int @float:99:5):
    ceil(x @float:99:51, ?tmp#1 @float:99:46)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:99:26)
    foreign llvm move(tmp#0, ?#result @float:99:5)


ifloor > public (0 calls)
0: ifloor(x:_ @float:102:16, ?#result:int @float:102:5):
    floor(x @float:102:53, ?tmp#1 @float:102:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:102:27)
    foreign llvm move(tmp#0, ?#result @float:102:5)


iround > public (0 calls)
0: iround(x:_ @float:96:16, ?#result:int @float:96:5):
    round(x @float:96:53, ?tmp#1 @float:96:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:96:27)
    foreign llvm move(tmp#0, ?#result @float:96:5)


log > public (0 calls)
0: log(x:_ @float:123:13, ?#result:_ @float:123:5):
    foreign c llvm.log.f64(x @float:123:47, ?tmp#0 @float:123:22)
    foreign llvm move(tmp#0, ?#result @float:123:5)


log10 > public (0 calls)
0: log10(x:_ @float:126:15, ?#result:_ @float:126:5):
    foreign c llvm.log10.f64(x @float:126:51, ?tmp#0 @float:126:24)
    foreign llvm move(tmp#0, ?#result @float:126:5)


log2 > public (0 calls)
0: log2(x:_ @float:129:14, ?#result:_ @float:129:5):
    foreign c llvm.log2.f64(x @float:129:49, ?tmp#0 @float:129:23)
    foreign llvm move(tmp#0, ?#result @float:129:5)


max > public (0 calls)
0: max(x:_ @float:81:13, y:_ @float:81:18, ?#result:_ @float:81:5):
    foreign c llvm.maxnum.f64(x @float:81:55, y @float:81:57, ?tmp#0 @float:81:27)
    foreign llvm move(tmp#0, ?#result @float:81:5)


min > public (0 calls)
0: min(x:_ @float:80:13, y:_ @float:80:18, ?#result:_ @float:80:5):
    foreign c llvm.minnum.f64(x @float:80:55, y @float:80:57, ?tmp#0 @float:80:27)
    foreign llvm move(tmp#0, ?#result @float:80:5)


pi > public (0 calls)
0: pi(?#result:_ @float:13:5):
    foreign llvm move(3.141592653589793 @float:13:16, ?#result @float:13:5)


power > public (0 calls)
0: power(x:_ @float:111:15, n:_ @float:111:19, ?#result:_ @float:111:5):
    foreign c llvm.pow.f64(x @float:111:53, n @float:111:55, ?tmp#0 @float:111:28)
    foreign llvm move(tmp#0, ?#result @float:111:5)


print > public (0 calls)
0: print(x:_ @float:133:15) use !io:
    foreign c print_float(x @float:133:52, !io @float:133:56)


println > public (0 calls)
0: println(x:_ @float:135:17) use !io:
    !print(x @float:135:39)
    !nl


read > public (0 calls)
0: read(?x:_ @float:137:15) use !io:
    foreign c read_float(?x @float:137:52, !io @float:137:56)


round > public (0 calls)
0: round(x:_ @float:93:15, ?#result:_ @float:93:5):
    foreign c llvm.round.f64(x @float:93:51, ?tmp#0 @float:93:24)
    foreign llvm move(tmp#0, ?#result @float:93:5)


sin > public (0 calls)
0: sin(x:_ @float:115:13, ?#result:_ @float:115:5):
    foreign c llvm.sin.f64(x @float:115:47, ?tmp#0 @float:115:22)
    foreign llvm move(tmp#0, ?#result @float:115:5)


sqrt > public (0 calls)
0: sqrt(x:_ @float:108:14, ?#result:_ @float:108:5):
    foreign c llvm.sqrt.f64(x @float:108:49, ?tmp#0 @float:108:23)
    foreign llvm move(tmp#0, ?#result @float:108:5)


square > public (0 calls)
0: square(x:_ @float:57:16, ?#result:_ @float:57:5):
    foreign llvm fmul(x @float:57:43, x @float:57:45, ?tmp#0 @float:57:25)
    foreign llvm move(tmp#0, ?#result @float:57:5)


tan > public (0 calls)
0: tan(x:_ @float:117:13, ?#result:_ @float:117:5):
    foreign c llvm.sin.f64(x @float:117:47, ?tmp#1 @float:117:22)
    foreign c llvm.cos.f64(x @float:117:77, ?tmp#2 @float:117:52)
    /(tmp#1, tmp#2, ?tmp#0 @float:117:22)
    foreign llvm move(tmp#0, ?#result @float:117:5)


~= > public (0 calls)
0: ~=(x:_ @float:67:10, y:_ @float:67:18, ?#result:bool @float:67:5):
    foreign llvm fcmp_ne(x @float:67:51, y @float:67:53, ?tmp#0 @float:67:30)
    foreign llvm move(tmp#0, ?#result @float:67:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.int
  representation  : 64 bit signed
  public submods  : 
  public resources: 
  public procs    : wybe.int.%<0>
                    wybe.int.%=<0>
                    wybe.int.*<0>
                    wybe.int.*=<0>
                    wybe.int.+<0>
                    wybe.int.+<1>
                    wybe.int.+<2>
                    wybe.int.+=<0>
                    wybe.int.-<0>
                    wybe.int.-<1>
                    wybe.int.-<2>
                    wybe.int.-<3>
                    wybe.int.-<4>
                    wybe.int.-=<0>
                    wybe.int./<0>
                    wybe.int./=<0>
                    wybe.int.<<0>
                    wybe.int.<<<0>
                    wybe.int.<<=<0>
                    wybe.int.<=<0>
                    wybe.int.<=><0>
                    wybe.int.=<0>
                    wybe.int.><0>
                    wybe.int.>=<0>
                    wybe.int.>><0>
                    wybe.int.>>=<0>
                    wybe.int.decr<0>
                    wybe.int.incr<0>
                    wybe.int.logical_bitshift<0>
                    wybe.int.logical_bitshift<1>
                    wybe.int.max<0>
                    wybe.int.min<0>
                    wybe.int.power<0>
                    wybe.int.print<0>
                    wybe.int.println<0>
                    wybe.int.read<0>
                    wybe.int.signum<0>
                    wybe.int.sqrt<0>
                    wybe.int.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public (0 calls)
0: %(x:_ @int:50:10, y:_ @int:50:16, ?#result:_ @int:50:5):
    foreign llvm srem(x @int:50:43, y @int:50:45, ?tmp#0 @int:50:25)
    foreign llvm move(tmp#0, ?#result @int:50:5)


%= > public (0 calls)
0: %=(!x:_ @int:53:11, y:_ @int:53:19):
    %(x @int:53:31, y @int:53:35, ?tmp#0 @int:53:31)
    =(?x @int:53:27, tmp#0)


* > public (0 calls)
0: *(x:_ @int:38:10, y:_ @int:38:16, ?#result:_ @int:38:5):
    foreign llvm mul(x @int:38:42, y @int:38:44, ?tmp#0 @int:38:25)
    foreign llvm move(tmp#0, ?#result @int:38:5)


*= > public (0 calls)
0: *=(!x:_ @int:41:11, y:_ @int:41:19):
    *(x @int:41:31, y @int:41:35, ?tmp#0 @int:41:31)
    =(?x @int:41:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @int:16:10, y:_ @int:16:17, ?#result:_ @int:16:5):
    foreign llvm add(x @int:16:44, y @int:16:46, ?tmp#0 @int:16:27)
    foreign llvm move(tmp#0, ?#result @int:16:5)
+ > public (0 calls)
1: +(?x:_ @int:17:11, y:_ @int:17:17, z:_ @int:17:5):
    foreign llvm sub(z @int:17:60, y @int:17:62, ?tmp#0 @int:17:43)
    =(?x @int:17:39, tmp#0)
+ > public (0 calls)
2: +(x:_ @int:18:10, ?y:_ @int:18:18, z:_ @int:18:5):
    foreign llvm sub(z @int:18:60, x @int:18:62, ?tmp#0 @int:18:43)
    =(?y @int:18:39, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @int:21:11, y:_ @int:21:19):
    +(x @int:21:31, y @int:21:35, ?tmp#0 @int:21:31)
    =(?x @int:21:27, tmp#0)


- > public (0 calls)
0: -(x:_ @int:25:10, y:_ @int:25:17, ?#result:_ @int:25:5):
    foreign llvm sub(x @int:25:44, y @int:25:46, ?tmp#0 @int:25:27)
    foreign llvm move(tmp#0, ?#result @int:25:5)
- > public (0 calls)
1: -(?x:_ @int:26:11, y:_ @int:26:17, z:_ @int:26:5):
    foreign llvm add(z @int:26:60, y @int:26:62, ?tmp#0 @int:26:43)
    =(?x @int:26:39, tmp#0)
- > public (0 calls)
2: -(x:_ @int:27:10, ?y:_ @int:27:18, z:_ @int:27:5):
    foreign llvm sub(z @int:27:60, x @int:27:62, ?tmp#0 @int:27:43)
    =(?y @int:27:39, tmp#0)
- > public (0 calls)
3: -(x:_ @int:31:11, ?#result:_ @int:31:5):
    foreign llvm sub(0 @int:31:38, x @int:31:40, ?tmp#0 @int:31:21)
    foreign llvm move(tmp#0, ?#result @int:31:5)
- > public (0 calls)
4: -(?x:_ @int:32:12, y:_ @int:32:5):
    foreign llvm sub(0 @int:32:54, y @int:32:56, ?tmp#0 @int:32:37)
    =(?x @int:32:33, tmp#0)


-= > public (0 calls)
0: -=(!x:_ @int:35:11, y:_ @int:35:19):
    -(x @int:35:31, y @int:35:35, ?tmp#0 @int:35:31)
    =(?x @int:35:27, tmp#0)


/ > public (0 calls)
0: /(x:_ @int:44:10, y:_ @int:44:16, ?#result:_ @int:44:5):
    foreign llvm sdiv(x @int:44:43, y @int:44:45, ?tmp#0 @int:44:25)
    foreign llvm move(tmp#0, ?#result @int:44:5)


/= > public (0 calls)
0: /=(!x:_ @int:47:11, y:_ @int:47:19):
    /(x @int:47:31, y @int:47:35, ?tmp#0 @int:47:31)
    =(?x @int:47:27, tmp#0)


< > public (0 calls)
0: <(x:_ @int:87:10, y:_ @int:87:17, ?#result:bool @int:87:5):
    foreign llvm icmp_slt(x @int:87:51, y @int:87:53, ?tmp#0 @int:87:29)
    foreign llvm move(tmp#0, ?#result @int:87:5)


<< > public (0 calls)
0: <<(x:_ @int:56:10, s:_ @int:56:18, ?#result:_ @int:56:5):
    foreign llvm shl(x @int:56:44, s @int:56:47, ?tmp#0 @int:56:27)
    foreign llvm move(tmp#0, ?#result @int:56:5)


<<= > public (0 calls)
0: <<=(!x:_ @int:59:11, s:_ @int:59:21):
    <<(x @int:59:33, s @int:59:39, ?tmp#0 @int:59:33)
    =(?x @int:59:29, tmp#0)


<= > public (0 calls)
0: <=(x:_ @int:88:10, y:_ @int:88:18, ?#result:bool @int:88:5):
    foreign llvm icmp_sle(x @int:88:52, y @int:88:54, ?tmp#0 @int:88:30)
    foreign llvm move(tmp#0, ?#result @int:88:5)


<=> > public (0 calls)
0: <=>(x:_ @int:93:10, y:_ @int:93:20, ?#result:comparison @int:93:5):
    if {<(x @int:94:10, y @int:94:14)::

        lesser(?tmp#1 @int:94:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @int:94:28, y @int:94:32)::

            equal(?tmp#3 @int:94:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @int:94:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @int:94:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @int:94:10, ?#result @int:93:5)


= > public (0 calls)
0: =(x:_ @int:83:10, y:_ @int:83:17, ?#result:bool @int:83:5):
    foreign llvm icmp_eq(x @int:83:50, y @int:83:52, ?tmp#0 @int:83:29)
    foreign llvm move(tmp#0, ?#result @int:83:5)


> > public (0 calls)
0: >(x:_ @int:89:10, y:_ @int:89:17, ?#result:bool @int:89:5):
    foreign llvm icmp_sgt(x @int:89:51, y @int:89:53, ?tmp#0 @int:89:29)
    foreign llvm move(tmp#0, ?#result @int:89:5)


>= > public (0 calls)
0: >=(x:_ @int:90:10, y:_ @int:90:18, ?#result:bool @int:90:5):
    foreign llvm icmp_sge(x @int:90:52, y @int:90:54, ?tmp#0 @int:90:30)
    foreign llvm move(tmp#0, ?#result @int:90:5)


>> > public (0 calls)
0: >>(x:_ @int:65:10, s:_ @int:65:18, ?#result:_ @int:65:5):
    foreign llvm ashr(x @int:65:45, s @int:65:48, ?tmp#0 @int:65:27)
    foreign llvm move(tmp#0, ?#result @int:65:5)


>>= > public (0 calls)
0: >>=(!x:_ @int:68:11, s:_ @int:68:21):
    >>(x @int:68:33, s @int:68:39, ?tmp#0 @int:68:33)
    =(?x @int:68:29, tmp#0)


decr > public (0 calls)
0: decr(!x:_ @int:111:15):
    -(x @int:111:27, 1 @int:111:31, ?tmp#0 @int:111:27)
    =(?x @int:111:23, tmp#0)


incr > public (0 calls)
0: incr(!x:_ @int:110:15):
    +(x @int:110:27, 1 @int:110:31, ?tmp#0 @int:110:27)
    =(?x @int:110:23, tmp#0)


logical_bitshift > public (0 calls)
0: logical_bitshift(x:_ @int:74:26, s:_ @int:74:31, ?#result:_ @int:74:5):
    foreign llvm lshr(x @int:74:58, s @int:74:61, ?tmp#0 @int:74:40)
    foreign llvm move(tmp#0, ?#result @int:74:5)
logical_bitshift > public (0 calls)
1: logical_bitshift(!x:_ @int:77:27, s:_ @int:77:32):
    logical_bitshift(x @int:77:61, s @int:77:64, ?tmp#0 @int:77:44)
    =(?x @int:77:40, tmp#0)


max > public (0 calls)
0: max(x:_ @int:98:13, y:_ @int:98:18, ?#result:_ @int:98:5):
    if {>=(x @int:98:31, y @int:98:35)::

        foreign llvm move(x @int:98:39, ?tmp#0)
    else::
        foreign llvm move(y @int:98:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @int:98:31, ?#result @int:98:5)


min > public (0 calls)
0: min(x:_ @int:97:13, y:_ @int:97:18, ?#result:_ @int:97:5):
    if {<=(x @int:97:31, y @int:97:35)::

        foreign llvm move(x @int:97:39, ?tmp#0)
    else::
        foreign llvm move(y @int:97:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @int:97:31, ?#result @int:97:5)


power > public (0 calls)
0: power(x:_ @int:107:15, y:_ @int:107:20, ?#result:_ @int:107:5):
    foreign c ipow(x @int:107:44, y @int:107:46, ?tmp#0 @int:107:29)
    foreign llvm move(tmp#0, ?#result @int:107:5)


print > public (0 calls)
0: print(x:_ @int:119:15) use !io:
    foreign c print_int(x @int:119:50, !io @int:119:54)


println > public (0 calls)
0: println(x:_ @int:121:17) use !io:
    !print(x @int:121:39)
    !nl


read > public (0 calls)
0: read(?x:_ @int:123:15) use !io:
    foreign c read_int(?x @int:123:50, !io @int:123:54)


signum > public (0 calls)
0: signum(x:_ @int:114:16, ?#result:_ @int:114:5):
    foreign c signum(x @int:114:42, ?tmp#0 @int:114:25)
    foreign llvm move(tmp#0, ?#result @int:114:5)


sqrt > public (0 calls)
0: sqrt(x:_ @int:104:14, ?#result:_ @int:104:5):
    foreign c isqrt(x @int:104:39, ?tmp#0 @int:104:23)
    foreign llvm move(tmp#0, ?#result @int:104:5)


~= > public (0 calls)
0: ~=(x:_ @int:84:10, y:_ @int:84:18, ?#result:bool @int:84:5):
    foreign llvm icmp_ne(x @int:84:51, y @int:84:53, ?tmp#0 @int:84:30)
    foreign llvm move(tmp#0, ?#result @int:84:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.io
  representation  : (not a type)
  public submods  : phantom -> wybe.phantom
  public resources: io: wybe.io.io
  public procs    : wybe.io.<0>
                    wybe.io.eof<0>
                    wybe.io.nl<0>
  imports         : use wybe.char
                    public use wybe.phantom
  resources       : io: fromList [(wybe.io.io,phantom = 0:phantom @io:13:27 @io:13:5)]
  procs           : 

module top-level code > public {semipure} (0 calls)
0: () use ?wybe.io.io:
    =(?io @io:13:5, 0:phantom @io:13:27)


eof > public {inline} (0 calls)
0: eof(?#result:char @io:20:5):
    foreign lpvm cast(-1 @io:20:47, ?tmp#0 @io:20:29)
    foreign llvm move(tmp#0, ?#result @io:20:5)


nl > public {inline} (0 calls)
0: nl() use !io:
    foreign c putchar('\n' @io:17:49, !io @io:17:54)

LLVM code       : None

--------------------------------------------------
 Module wybe.list(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.list.,,<0>
                    wybe.list.[]<0>
                    wybe.list.all<0>
                    wybe.list.any<0>
                    wybe.list.empty<0>
                    wybe.list.filter<0>
                    wybe.list.foldl<0>
                    wybe.list.foldr<0>
                    wybe.list.length<0>
                    wybe.list.list<0>
                    wybe.list.map<0>
                    wybe.list.map<1>
                    wybe.list.map<2>
                    wybe.list.print<0>
                    wybe.list.println<0>
                    wybe.list.reverse<0>
  imports         : use wybe.array
                    use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
                    use wybe.machine_word
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_(T) @list:20:10, y:_(T) @list:20:20, ?#result:_(T) @list:20:5):
    if {[|](?h @list:21:16, ?t @list:21:21, x @list:21:10)::

        ,,(t @list:21:32, y @list:21:37, ?tmp#2 @list:21:32)
        [|](h @list:21:28, tmp#2, ?tmp#1 @list:21:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(y @list:21:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:21:10, ?#result @list:20:5)


[] > public {test} (0 calls)
0: [](xs:_(T) @list:31:21, idx:int @list:31:30, ?#result:T @list:31:5):
    >=(idx @list:32:5, 0 @list:32:13)
    index1(xs @list:33:17, idx @list:33:21, ?tmp#0 @list:33:10)
    =(?x @list:33:6, tmp#0)
    foreign llvm move(x @list:31:43, ?#result @list:31:5)


all > public {test} (0 calls)
0: all(p:{test}(T) @list:61:20, xs:_(T) @list:61:33):
    foreign llvm move(xs @list:62:15, ?tmp#0)
    do {
        if {[|](?x @list:62:10, ?tmp#0, tmp#0)::

            p(x @list:63:11)
        else::
            break

        }
    }


any > public {test} (0 calls)
0: any(p:{test}(T) @list:69:20, xs:_(T) @list:69:33):
    [|](?x @list:70:7, ?xs @list:70:12, xs @list:70:18)
    (   p(x @list:71:8)
    | any(p @list:71:17, xs @list:71:20))


empty > public {test} (0 calls)
0: empty(xs:_(T) @list:15:22):
    if {[|](?tmp#0 @list:16:11, ?tmp#1 @list:16:15, xs @list:16:20)::

        fail
    else::
        pass

    }


filter > public (0 calls)
0: filter(p:{test}(T) @list:95:16, !xs:_(T) @list:95:30):
    [](?tmp#0 @list:96:12)
    =(?out @list:96:6, tmp#0)
    foreign llvm move(xs @list:97:15, ?tmp#1)
    do {
        if {[|](?x @list:97:10, ?tmp#1, tmp#1)::

            if {p(x @list:98:16)::

                [|](x @list:98:30, out @list:98:34, ?tmp#2 @list:98:29)
                =(?out @list:98:23, tmp#2)
            else::
                pass

            }
        else::
            break

        }
    }
    reverse(out @list:100:19, ?tmp#3 @list:100:11)
    =(?as @list:100:6, tmp#3)


foldl > public (0 calls)
0: foldl(f:(A, !B) @list:77:15, as:_(A) @list:77:26, !b:B @list:77:36):
    foreign llvm move(as @list:78:15, ?tmp#0)
    do {
        if {[|](?a @list:78:10, ?tmp#0, tmp#0)::

            f(a @list:79:11, !b @list:79:15)
        else::
            break

        }
    }


foldr > public (0 calls)
0: foldr(f:(A, !B) @list:86:15, as:_(A) @list:86:26, !b:B @list:86:36):
    if {[|](?a @list:87:12, ?as @list:87:17, as @list:87:23)::

        foldr(f @list:88:15, as @list:88:18, !b @list:88:23)
        f(a @list:89:11, !b @list:89:15)
    else::
        pass

    }


index1 > {test} (0 calls)
0: index1(xs:_(T) @list:148:19, idx:int @list:148:28, ?#result:T @list:148:1):
    [|](?x @list:149:7, ?xs @list:149:12, xs @list:149:18)
    (   =(idx @list:150:6, 0 @list:150:12)
    | (   -(idx @list:150:27, 1 @list:150:33, ?tmp#0 @list:150:27)
        & index1(xs @list:150:23, tmp#0, ?x @list:150:37)))
    foreign llvm move(x @list:148:41, ?#result @list:148:1)


length > public (0 calls)
0: length(x:_(T) @list:24:16, ?#result:int @list:24:5):
    length1(x @list:24:38, 0 @list:24:41, ?tmp#0 @list:24:30)
    foreign llvm move(tmp#0, ?#result @list:24:5)


length1 > (0 calls)
0: length1(x:_(T) @list:140:13, acc:int @list:140:21, ?#result:int @list:140:1):
    if {[|](?h @list:141:16, ?t @list:141:21, x @list:141:10)::

        +(acc @list:141:38, 1 @list:141:44, ?tmp#2 @list:141:38)
        length1(t @list:141:35, tmp#2, ?tmp#1 @list:141:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(acc @list:141:57, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:141:10, ?#result @list:140:1)


list > public (0 calls)
0: list(ar:array(T) @list:128:14, ?#result:_(T) @list:128:5):
    [](?tmp#0 @list:129:11)
    =(?ls @list:129:6, tmp#0)
    foreign llvm move(ar @list:130:15, ?tmp#1)
    do {
        if {[|](?x @list:130:10, ?tmp#1, tmp#1)::

            [|](x @list:131:16, ls @list:131:20, ?tmp#2 @list:131:15)
            =(?ls @list:131:10, tmp#2)
        else::
            break

        }
    }
    reverse(ls @list:133:13, ?ls @list:133:18)
    foreign llvm move(ls @list:128:34, ?#result @list:128:5)


map > public (0 calls)
0: map(f:{resource}(T) @list:41:13, xs:_(T) @list:41:30):
    foreign llvm move(xs @list:42:15, ?tmp#0)
    do {
        if {[|](?x @list:42:10, ?tmp#0, tmp#0)::

            !f(x @list:43:12)
        else::
            break

        }
    }
map > public (0 calls)
1: map(f:(A, ?B) @list:49:13, as:_(A) @list:49:24, ?#result:_(B) @list:49:5):
    if {[|](?a @list:50:12, ?as @list:50:17, as @list:50:23)::

        f(a @list:50:33, ?tmp#2 @list:50:31)
        map(f @list:50:42, as @list:50:45, ?tmp#3 @list:50:38)
        [|](tmp#2, tmp#3, ?tmp#1 @list:50:29)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:50:61)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:50:10, ?#result @list:49:5)
map > public (0 calls)
2: map(f:(A, B, ?C) @list:55:13, as:_(A) @list:55:27, bs:_(B) @list:55:36, ?#result:_(C) @list:55:5):
    if {(   [|](?a @list:56:12, ?as @list:56:17, as @list:56:23)
        & [|](?b @list:56:30, ?bs @list:56:35, bs @list:56:41))::

        f(a @list:56:51, b @list:56:54, ?tmp#2 @list:56:49)
        map(f @list:56:63, as @list:56:66, bs @list:56:70, ?tmp#3 @list:56:59)
        [|](tmp#2, tmp#3, ?tmp#1 @list:56:47)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:57:47)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:56:10, ?#result @list:55:5)


print > public (0 calls)
0: print(printer:{resource}(T) @list:108:15, xs:_(T) @list:108:38) use !io:
    !print('[' @list:109:12)
    if {[|](?x @list:110:12, ?xs @list:110:17, xs @list:110:23)::

        !printer(x @list:111:18)
        !print1(printer @list:112:17, xs @list:112:26)
    else::
        pass

    }
    !print(']' @list:114:12)


print1 > (0 calls)
0: print1(printer:{resource}(T) @list:154:12, xs:_(T) @list:154:35) use !io:
    if {[|](?x @list:155:12, ?xs @list:155:17, xs @list:155:23)::

        !print(',' @list:156:16)
        !printer(x @list:157:18)
        !print1(printer @list:158:17, xs @list:158:26)
    else::
        pass

    }


println > public (0 calls)
0: println(printer:{resource}(T) @list:119:17, xs:_(T) @list:119:40) use !io:
    !print(printer @list:120:12, xs @list:120:21)
    !nl


reverse > public (0 calls)
0: reverse(x:_(T) @list:27:17, ?#result:_(T) @list:27:5):
    [](?tmp#1 @list:27:44)
    reverse1(x @list:27:41, tmp#1, ?tmp#0 @list:27:32)
    foreign llvm move(tmp#0, ?#result @list:27:5)


reverse1 > (0 calls)
0: reverse1(x:_(T) @list:144:14, tail:_(T) @list:144:22, ?#result:_(T) @list:144:1):
    if {[|](?h @list:145:16, ?t @list:145:21, x @list:145:10)::

        [|](h @list:145:40, tail @list:145:44, ?tmp#2 @list:145:39)
        reverse1(t @list:145:36, tmp#2, ?tmp#1 @list:145:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(tail @list:145:61, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:145:10, ?#result @list:144:1)

LLVM code       : None

--------------------------------------------------
 Module wybe.machine_word
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.machine_word.word_size_bits<0>
                    wybe.machine_word.word_size_bytes<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

word_size_bits > public (0 calls)
0: word_size_bits(?#result:int @machine_word:12:5):
    word_size_bytes(?tmp#1 @machine_word:12:34)
    *(8 @machine_word:12:30, tmp#1, ?tmp#0 @machine_word:12:30)
    foreign llvm move(tmp#0, ?#result @machine_word:12:5)


word_size_bytes > public (0 calls)
0: word_size_bytes(?#result:int @machine_word:10:5):
    foreign llvm move(8 @machine_word:10:31, ?#result @machine_word:10:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.memory_management
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.memory_management.malloc_count<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

malloc_count > public {semipure} (0 calls)
0: malloc_count(?x:int @memory_management:11:34):
    foreign c {impure} malloc_count(?x @memory_management:12:38)

LLVM code       : None

--------------------------------------------------
 Module wybe.phantom
 modifiers       : {unique} 
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : 
  imports         : 
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.predicate
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.predicate.const<0>
                    wybe.predicate.id<0>
  imports         : 
  resources       : 
  procs           : 

const > public {inline} (0 calls)
0: wybe.predicate.const<0>
const(a##0:A <{}; {}; {0}>, [b##0:B <{}; {}; {1}>], ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:8:5


id > public {inline} (0 calls)
0: wybe.predicate.id<0>
id(a##0:A <{}; {}; {0}>, ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:6:5

LLVM code       : None

--------------------------------------------------
 Module wybe.range
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.range...<0>
                    wybe.range.[]<0>
                    wybe.range.[|]<0>
                    wybe.range.irange<0>
                    wybe.range.size<0>
                    wybe.range.xrange<0>
  imports         : use wybe.bool
                    use wybe.int
  resources       : 
  procs           : 

.. > public (0 calls)
0: ..(start:int @range:38:10, end:int @range:38:23, ?#result:_ @range:38:5):
    if {<=(start @range:39:27, end @range:39:37)::

        foreign llvm move(1 @range:39:44, ?tmp#1)
    else::
        foreign llvm move(-1 @range:39:56, ?tmp#1)

    }
    construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)
    foreign llvm move(tmp#0, ?#result @range:38:5)


[] > public {test} (0 calls)
0: [](r:_ @range:20:19, idx:int @range:20:24, ?value:int @range:20:34):
    <=(0 @range:21:6, idx @range:21:12)
    range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)
    *(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)
    +(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)
    =(?value @range:23:6, tmp#0)
    if {<=(0 @range:24:10, stride @range:24:16)::

        <(value @range:24:27, end @range:24:35)
    else::
        <(end @range:24:51, value @range:24:57)

    }


[|] > public {test} (0 calls)
0: [|](?value:int @range:12:23, ?rest:_ @range:12:35, current:_ @range:12:43):
    range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)
    ~=(value @range:14:6, end @range:14:16)
    +(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)
    range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)
    =(?rest @range:15:6, tmp#0)


construct > (0 calls)
0: construct(start:int @range:49:15, stride:int @range:49:26, end:int @range:49:38, ?#result:_ @range:49:1):
    -(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)
    %(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)
    =(?diff @range:50:6, tmp#0)
    if {<=(0 @range:51:19, stride @range:51:25)::

        if {=(diff @range:52:26, 0 @range:52:33)::

            max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
            -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
            max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
            foreign llvm move(tmp#5, ?tmp#3)

        }
        foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
    else::
        if {=(diff @range:55:26, 0 @range:55:33)::

            min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
            foreign llvm move(tmp#9, ?tmp#8)
        else::
            +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
            min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
            foreign llvm move(tmp#10, ?tmp#8)

        }
        foreign llvm move(tmp#8 @range:55:26, ?tmp#2)

    }
    =(?final @range:51:6, tmp#2 @range:51:19)
    range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)
    =(?r @range:58:6, tmp#12)
    foreign llvm move(r @range:49:51, ?#result @range:49:1)


irange > public (0 calls)
0: irange(start:int @range:32:16, stride:int @range:32:27, end:int @range:32:39, ?#result:_ @range:32:5):
    if {<(stride @range:33:41, 0 @range:33:50)::

        foreign llvm move(-1 @range:33:55, ?tmp#2)
    else::
        foreign llvm move(1 @range:33:68, ?tmp#2)

    }
    +(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)
    construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)
    foreign llvm move(tmp#0, ?#result @range:32:5)


size > public (0 calls)
0: size(r:_ @range:42:14, ?#result:int @range:42:5):
    range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)
    if {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
        & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
        & signum(tmp#3, ?tmp#2 @range:44:29)
        & ~=(tmp#1, tmp#2))::

        foreign llvm move(0 @range:44:52, ?tmp#0)
    else::
        if {<=(0 @range:45:10, stride @range:45:16)::

            -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
            -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
            /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
            +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
            foreign llvm move(tmp#5, ?tmp#4)
        else::
            -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
            -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
            -(stride @range:46:39, ?tmp#13 @range:46:38)
            /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
            +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
            foreign llvm move(tmp#9, ?tmp#4)

        }
        foreign llvm move(tmp#4 @range:45:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)


xrange > public (0 calls)
0: xrange(start:int @range:28:16, stride:int @range:28:27, end:int @range:28:39, ?#result:_ @range:28:5):
    construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)
    foreign llvm move(tmp#0, ?#result @range:28:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.string
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.string.,,<0>
                    wybe.string.<<0>
                    wybe.string.<=<0>
                    wybe.string.<=><0>
                    wybe.string.=<0>
                    wybe.string.><0>
                    wybe.string.>=<0>
                    wybe.string.[]<0>
                    wybe.string.[]<1>
                    wybe.string.[|]<0>
                    wybe.string.c_string<0>
                    wybe.string.length<0>
                    wybe.string.print<0>
                    wybe.string.println<0>
                    wybe.string.read<0>
                    wybe.string.string<0>
                    wybe.string.string<1>
                    wybe.string.~=<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.char
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
                    use wybe.range
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_ @string:64:10, y:_ @string:64:17, ?#result:_ @string:64:5):
    if {(   empty(?tmp#1 @string:65:14)
        & =(x @string:65:10, tmp#1))::

        foreign llvm move(y @string:65:23, ?tmp#0)
    else::
        if {(   empty(?tmp#3 @string:66:14)
            & =(y @string:66:10, tmp#3))::

            foreign llvm move(x @string:66:23, ?tmp#2)
        else::
            concat(x @string:67:25, y @string:67:28, ?tmp#4 @string:67:18)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:66:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:65:10, ?#result @string:64:5)


< > public (0 calls)
0: <(x:_ @string:119:10, y:_ @string:119:17, ?#result:bool @string:119:5):
    <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
    equal(?tmp#2 @string:119:44)
    <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
    foreign llvm move(tmp#0, ?#result @string:119:5)


<= > public (0 calls)
0: <=(x:_ @string:120:10, y:_ @string:120:18, ?#result:bool @string:120:5):
    <=>(x @string:120:31, y @string:120:39, ?tmp#1 @string:120:31)
    equal(?tmp#2 @string:120:46)
    <=(tmp#1, tmp#2, ?tmp#0 @string:120:30)
    foreign llvm move(tmp#0, ?#result @string:120:5)


<=> > public (0 calls)
0: <=>(x:_ @string:125:10, y:_ @string:125:20, ?#result:comparison @string:125:5):
    equal(?tmp#0 @string:126:10)
    =(?c @string:126:6, tmp#0)
    foreign llvm move(x @string:127:16, ?tmp#1)
    foreign llvm move(y @string:127:26, ?tmp#2)
    do {
        if {[|](?cx @string:127:10, ?tmp#1, tmp#1)::

            if {[|](?cy @string:127:20, ?tmp#2, tmp#2)::

                if {<(cx @string:128:14, cy @string:128:19)::

                    lesser(?tmp#3 @string:128:30)
                    =(?c @string:128:26, tmp#3)
                    break
                else::
                    if {>(cx @string:129:14, cy @string:129:19)::

                        greater(?tmp#4 @string:129:30)
                        =(?c @string:129:26, tmp#4)
                        break
                    else::
                        pass

                    }

                }
            else::
                break

            }
        else::
            break

        }
    }
    if {(   equal(?tmp#5 @string:132:14)
        & =(c @string:132:10, tmp#5))::

        length(x @string:133:22, ?tmp#6 @string:133:15)
        =(?lx @string:133:10, tmp#6)
        length(y @string:134:22, ?tmp#7 @string:134:15)
        =(?ly @string:134:10, tmp#7)
        if {<(lx @string:135:14, ly @string:135:19)::

            lesser(?tmp#8 @string:135:30)
            =(?c @string:135:26, tmp#8)
        else::
            if {>(lx @string:135:39, ly @string:135:44)::

                greater(?tmp#9 @string:135:55)
                =(?c @string:135:51, tmp#9)
            else::
                pass

            }

        }
    else::
        pass

    }
    foreign llvm move(c @string:125:38, ?#result @string:125:5)


= > public (0 calls)
0: =(x:_ @string:115:10, y:_ @string:115:17, ?#result:bool @string:115:5):
    <=>(x @string:115:30, y @string:115:38, ?tmp#1 @string:115:30)
    equal(?tmp#2 @string:115:44)
    =(tmp#1, tmp#2, ?tmp#0 @string:115:29)
    foreign llvm move(tmp#0, ?#result @string:115:5)


> > public (0 calls)
0: >(x:_ @string:121:10, y:_ @string:121:17, ?#result:bool @string:121:5):
    <=>(x @string:121:30, y @string:121:38, ?tmp#1 @string:121:30)
    equal(?tmp#2 @string:121:44)
    >(tmp#1, tmp#2, ?tmp#0 @string:121:29)
    foreign llvm move(tmp#0, ?#result @string:121:5)


>= > public (0 calls)
0: >=(x:_ @string:122:10, y:_ @string:122:18, ?#result:bool @string:122:5):
    <=>(x @string:122:31, y @string:122:39, ?tmp#1 @string:122:31)
    equal(?tmp#2 @string:122:46)
    >=(tmp#1, tmp#2, ?tmp#0 @string:122:30)
    foreign llvm move(tmp#0, ?#result @string:122:5)


[] > public {test} (0 calls)
0: [](s:_ @string:91:19, idx:int @string:91:24, ?c:char @string:91:34):
    if {buffer(?len @string:93:17, ?str @string:93:23, s @string:92:10)::

        <=(0 @string:94:14, idx @string:94:20)
        <(idx @string:95:14, len @string:95:20)
        unsafe_c_string_index(str @string:96:35, idx @string:96:40, ?c @string:96:46)
    else::
        if {concat(?left @string:97:17, ?right @string:97:24, s @string:92:10)::

            length(left @string:98:32, ?tmp#0 @string:98:25)
            =(?left_len @string:98:14, tmp#0)
            if {<(idx @string:99:18, left_len @string:99:24)::

                [](left @string:99:41, idx @string:99:46, ?tmp#1 @string:99:41)
                =(?c @string:99:37, tmp#1)
            else::
                -(idx @string:100:37, left_len @string:100:43, ?tmp#3 @string:100:37)
                [](right @string:100:31, tmp#3, ?tmp#2 @string:100:31)
                =(?c @string:100:27, tmp#2)

            }
        else::
            if {slice(?base @string:102:16, ?range @string:102:23, s @string:92:10)::

                [](range @string:102:43, idx @string:102:49, ?tmp#5 @string:102:43)
                [](base @string:102:38, tmp#5, ?tmp#4 @string:102:38)
                =(?c @string:102:34, tmp#4)
            else::
                if {singleton(?c @string:103:20, s @string:92:10)::

                    =(idx @string:103:27, 0 @string:103:33)
                else::
                    fail

                }

            }

        }

    }
[] > public (0 calls)
1: [](s:_ @string:109:12, r:range @string:109:17, ?#result:_ @string:109:5):
    slice(s @string:109:36, r @string:109:39, ?tmp#0 @string:109:30)
    foreign llvm move(tmp#0, ?#result @string:109:5)


[|] > public {test} (0 calls)
0: [|](?head:char @string:71:23, ?tail:_ @string:71:35, s:_ @string:71:43):
    if {buffer(?len @string:73:17, ?str @string:73:23, s @string:72:10)::

        [|](?head @string:74:15, ?str @string:74:23, str @string:74:30)
        if {=(len @string:75:26, 1 @string:75:32)::

            empty(?tmp#1 @string:75:37)
            foreign llvm move(tmp#1, ?tmp#0)
        else::
            -(len @string:75:60, 1 @string:75:66, ?tmp#3 @string:75:60)
            buffer(tmp#3, str @string:75:69, ?tmp#2 @string:75:53)
            foreign llvm move(tmp#2, ?tmp#0)

        }
        =(?tail @string:75:14, tmp#0 @string:75:26)
    else::
        if {concat(?left @string:76:17, ?right @string:76:24, s @string:72:10)::

            if {[|](?head @string:77:20, ?t @string:77:28, left @string:77:33)::

                concat(t @string:77:56, right @string:77:59, ?tmp#4 @string:77:49)
                =(?tail @string:77:42, tmp#4)
            else::
                [|](?head @string:78:28, ?tail @string:78:36, right @string:78:44)

            }
        else::
            if {slice(?base @string:80:16, ?range @string:80:23, s @string:72:10)::

                do {
                    [|](?idx @string:82:19, ?range @string:82:26, range @string:82:35)
                    if {(   [](base @string:83:30, idx @string:83:35, ?tmp#5 @string:83:30)
                        & =(?head @string:83:23, tmp#5))::

                        slice(base @string:83:57, range @string:83:63, ?tmp#6 @string:83:51)
                        =(?tail @string:83:44, tmp#6)
                        break
                    else::
                        pass

                    }
                }
            else::
                if {singleton(?head @string:85:20, s @string:72:10)::

                    empty(?tmp#7 @string:85:37)
                    =(?tail @string:85:30, tmp#7)
                else::
                    fail

                }

            }

        }

    }


c_string > public (0 calls)
0: c_string(s:_ @string:40:18, ?#result:c_string @string:40:5):
    if {buffer(?tmp#0 @string:41:21, ?str @string:41:25, s @string:41:10)::

        pass
    else::
        length(s @string:43:27, ?tmp#2 @string:43:20)
        +(tmp#2, 1 @string:43:32, ?tmp#1 @string:43:20)
        =(?len @string:43:14, tmp#1)
        foreign lpvm alloc(len @string:44:32, ?str @string:44:38)
        true(?tmp#3 @string:45:49)
        foreign lpvm mutate(str @string:45:33, ?str @string:45:39, len @string:45:44, tmp#3, len @string:45:55, 0 @string:45:60, '\NUL' @string:45:63)
        =(?offset @string:46:14, 0 @string:46:23)
        pack(s @string:47:18, !str @string:47:22, len @string:47:27, !offset @string:47:33)

    }
    foreign llvm move(str @string:40:34, ?#result @string:40:5)


fixed_range_size > (0 calls)
0: fixed_range_size(hi:int @string:184:22, r:range @string:184:30, ?sz:int @string:184:40):
    range(?start @string:185:16, ?stride @string:185:24, ?end @string:185:33, r @string:185:5)
    if {<=(0 @string:186:10, stride @string:186:16)::

        -(start @string:187:39, ?tmp#4 @string:187:38)
        /(tmp#4, stride @string:187:47, ?tmp#3 @string:187:38)
        *(tmp#3, stride @string:187:56, ?tmp#2 @string:187:38)
        +(start @string:187:30, tmp#2, ?tmp#1 @string:187:30)
        max(start @string:187:23, tmp#1, ?tmp#0 @string:187:19)
        =(?lo @string:187:14, tmp#0)
        min(hi @string:188:23, end @string:188:27, ?tmp#5 @string:188:19)
        =(?hi @string:188:14, tmp#5)
    else::
        max(-1 @string:190:23, end @string:190:27, ?tmp#6 @string:190:19)
        =(?lo @string:190:14, tmp#6)
        +(hi @string:191:30, stride @string:191:35, ?tmp#10 @string:191:30)
        -(start @string:191:45, hi @string:191:53, ?tmp#13 @string:191:45)
        -(tmp#13, 1 @string:191:58, ?tmp#12 @string:191:45)
        -(stride @string:191:64, ?tmp#14 @string:191:63)
        %(tmp#12, tmp#14, ?tmp#11 @string:191:44)
        +(tmp#10, tmp#11, ?tmp#9 @string:191:30)
        +(tmp#9, 1 @string:191:73, ?tmp#8 @string:191:30)
        min(start @string:191:23, tmp#8, ?tmp#7 @string:191:19)
        =(?hi @string:191:14, tmp#7)
        -(stride @string:192:24, ?tmp#15 @string:192:23)
        =(?stride @string:192:14, tmp#15)

    }
    if {<=(hi @string:194:16, lo @string:194:23)::

        foreign llvm move(0 @string:194:29, ?tmp#16)
    else::
        -(hi @string:194:42, lo @string:194:47, ?tmp#20 @string:194:42)
        -(tmp#20, 1 @string:194:52, ?tmp#19 @string:194:42)
        /(tmp#19, stride @string:194:57, ?tmp#18 @string:194:41)
        +(tmp#18, 1 @string:194:66, ?tmp#17 @string:194:41)
        foreign llvm move(tmp#17, ?tmp#16)

    }
    =(?sz @string:194:6, tmp#16 @string:194:16)


length > public (0 calls)
0: length(s:_ @string:52:16, ?#result:int @string:52:5):
    if {buffer(?len @string:53:22, ?tmp#1 @string:53:27, s @string:53:10)::

        foreign llvm move(len @string:53:33, ?tmp#0)
    else::
        if {concat(?left @string:54:22, ?right @string:54:29, s @string:54:10)::

            length(left @string:54:46, ?tmp#4 @string:54:39)
            length(right @string:54:61, ?tmp#5 @string:54:54)
            +(tmp#4, tmp#5, ?tmp#3 @string:54:39)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            if {slice(?base @string:55:21, ?range @string:55:28, s @string:55:10)::

                length(base @string:55:62, ?tmp#8 @string:55:55)
                fixed_range_size(tmp#8, range @string:55:69, ?tmp#7 @string:55:38)
                foreign llvm move(tmp#7, ?tmp#6)
            else::
                if {singleton(?tmp#10 @string:56:24, s @string:56:10)::

                    foreign llvm move(1 @string:56:30, ?tmp#9)
                else::
                    foreign llvm move(0 @string:57:18, ?tmp#9)

                }
                foreign llvm move(tmp#9 @string:56:10, ?tmp#6)

            }
            foreign llvm move(tmp#6 @string:55:10, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:54:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:53:10, ?#result @string:52:5)


pack > (0 calls)
0: pack(s:_ @string:160:10, !raw:c_string @string:160:16, size:int @string:160:30, !offset:int @string:160:41):
    if {buffer(?tmp#0 @string:162:16, ?str @string:162:20, s @string:161:10)::

        foreign llvm move(str @string:163:23, ?tmp#1)
        do {
            if {[|](?c @string:163:18, ?tmp#1, tmp#1)::

                true(?tmp#2 @string:164:56)
                foreign lpvm mutate(raw @string:164:37, ?raw @string:164:43, offset @string:164:48, tmp#2, size @string:164:62, 0 @string:164:68, c @string:164:71)
                incr(!offset @string:165:23)
            else::
                break

            }
        }
    else::
        if {concat(?left @string:167:17, ?right @string:167:24, s @string:161:10)::

            pack(left @string:168:18, !raw @string:168:25, size @string:168:30, !offset @string:168:37)
            pack(right @string:169:18, !raw @string:169:26, size @string:169:31, !offset @string:169:38)
            incr(!offset @string:170:19)
        else::
            if {slice(?tmp#3 @string:171:15, ?tmp#4 @string:171:18, s @string:161:10)::

                foreign llvm move(s @string:172:23, ?tmp#5)
                do {
                    if {[|](?c @string:172:18, ?tmp#5, tmp#5)::

                        true(?tmp#6 @string:173:56)
                        foreign lpvm mutate(raw @string:173:37, ?raw @string:173:43, offset @string:173:48, tmp#6, size @string:173:62, 0 @string:173:68, c @string:173:71)
                        incr(!offset @string:174:23)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:176:20, s @string:161:10)::

                    true(?tmp#7 @string:177:52)
                    foreign lpvm mutate(raw @string:177:33, ?raw @string:177:39, offset @string:177:44, tmp#7, size @string:177:58, 0 @string:177:64, c @string:177:67)
                    incr(!offset @string:178:19)
                else::
                    fail

                }

            }

        }

    }


print > public (0 calls)
0: print(x:_ @string:142:15) use !io:
    if {buffer(?tmp#0 @string:144:16, ?str @string:144:20, x @string:143:10)::

        !print(str @string:144:35)
    else::
        if {concat(?left @string:145:17, ?right @string:145:24, x @string:143:10)::

            !print(left @string:145:41)
            !print(right @string:145:55)
        else::
            if {slice(?tmp#1 @string:146:15, ?tmp#2 @string:146:18, x @string:143:10)::

                foreign llvm move(x @string:146:34, ?tmp#3)
                do {
                    if {[|](?c @string:146:29, ?tmp#3, tmp#3)::

                        !print(c @string:146:45)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:147:20, x @string:143:10)::

                    !print(c @string:147:33)
                else::
                    fail

                }

            }

        }

    }


println > public (0 calls)
0: println(x:_ @string:151:17) use !io:
    !print(x @string:151:39)
    !nl


read > public (0 calls)
0: read(?x:_ @string:153:15) use !io:
    !read(?str:c_string @string:153:37)
    string(str @string:153:64, ?tmp#0 @string:153:57)
    =(?x @string:153:53, tmp#0)


string > public (0 calls)
0: string(str:c_string @string:28:16, ?#result:_ @string:28:5):
    length(str @string:29:19, ?tmp#0 @string:29:12)
    =(?len @string:29:6, tmp#0)
    if {=(len @string:30:15, 0 @string:30:21)::

        empty(?tmp#2 @string:30:26)
        foreign llvm move(tmp#2, ?tmp#1)
    else::
        if {=(len @string:31:15, 1 @string:31:21)::

            foreign lpvm access(str @string:31:56, 0 @string:31:61, 1 @string:31:64, 0 @string:31:67, ?tmp#5 @string:31:36)
            singleton(tmp#5, ?tmp#4 @string:31:26)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            buffer(len @string:32:33, str @string:32:38, ?tmp#6 @string:32:26)
            foreign llvm move(tmp#6, ?tmp#3)

        }
        foreign llvm move(tmp#3 @string:31:15, ?tmp#1)

    }
    =(?s @string:30:6, tmp#1 @string:30:15)
    foreign llvm move(s @string:28:34, ?#result @string:28:5)
string > public (0 calls)
1: string(c:char @string:37:16, ?#result:_ @string:37:5):
    singleton(c @string:37:38, ?tmp#0 @string:37:28)
    foreign llvm move(tmp#0, ?#result @string:37:5)


~= > public (0 calls)
0: ~=(x:_ @string:116:10, y:_ @string:116:18, ?#result:bool @string:116:5):
    <=>(x @string:116:31, y @string:116:39, ?tmp#1 @string:116:31)
    equal(?tmp#2 @string:116:46)
    ~=(tmp#1, tmp#2, ?tmp#0 @string:116:30)
    foreign llvm move(tmp#0, ?#result @string:116:5)

LLVM code       : None

Types: **** Validating parameter types in module wybe.bool
Types: Validating def of &&
Types: Checking type _ of param p:_
Types: Param is p:wybe.bool
Types: Checking type _ of param q:_
Types: Param is q:wybe.bool
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.bool
Types: Validating def of &=
Types: Checking type _ of param !p:_
Types: Param is !p:wybe.bool
Types: Checking type _ of param q:_
Types: Param is q:wybe.bool
Types: Validating def of =
Types: Checking type _ of param x:_
Types: Param is x:wybe.bool
Types: Checking type _ of param y:_
Types: Param is y:wybe.bool
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.bool
Types: Validating def of ^=
Types: Checking type _ of param !p:_
Types: Param is !p:wybe.bool
Types: Checking type _ of param q:_
Types: Param is q:wybe.bool
Types: Validating def of ^^
Types: Checking type _ of param p:_
Types: Param is p:wybe.bool
Types: Checking type _ of param q:_
Types: Param is q:wybe.bool
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.bool
Types: Validating def of false
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.bool
Types: Validating def of print
Types: Checking type _ of param x:_
Types: Param is x:wybe.bool
Types: Validating def of println
Types: Checking type _ of param x:_
Types: Param is x:wybe.bool
Types: Validating def of succeed
Types: Validating def of true
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.bool
Types: Validating def of |=
Types: Checking type _ of param !p:_
Types: Param is !p:wybe.bool
Types: Checking type _ of param q:_
Types: Param is q:wybe.bool
Types: Validating def of ||
Types: Checking type _ of param p:_
Types: Param is p:wybe.bool
Types: Checking type _ of param q:_
Types: Param is q:wybe.bool
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.bool
Types: Validating def of ~
Types: Checking type _ of param p:_
Types: Param is p:wybe.bool
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.bool
Types: Validating def of ~=
Types: Checking type _ of param x:_
Types: Param is x:wybe.bool
Types: Checking type _ of param y:_
Types: Param is y:wybe.bool
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.bool
Types: **** Re-exiting module wybe.bool
Types: **** Validating parameter types in module wybe.c_string
Types: Validating def of <
Types: Checking type _ of param x:_
Types: Param is x:wybe.c_string
Types: Checking type _ of param y:_
Types: Param is y:wybe.c_string
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of <=
Types: Checking type _ of param x:_
Types: Param is x:wybe.c_string
Types: Checking type _ of param y:_
Types: Param is y:wybe.c_string
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of =
Types: Checking type _ of param x:_
Types: Param is x:wybe.c_string
Types: Checking type _ of param y:_
Types: Param is y:wybe.c_string
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of >
Types: Checking type _ of param x:_
Types: Param is x:wybe.c_string
Types: Checking type _ of param y:_
Types: Param is y:wybe.c_string
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of >=
Types: Checking type _ of param x:_
Types: Param is x:wybe.c_string
Types: Checking type _ of param y:_
Types: Param is y:wybe.c_string
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of []
Types: Checking type _ of param str:_
Types: Param is str:wybe.c_string
Types: Checking type int of param idx:int
Types: Param is idx:wybe.int
Types: Checking type char of param ?#result:char
Types: Param is ?#result:wybe.char
Types: Validating def of [|]
Types: Checking type char of param ?head:char
Types: Param is ?head:wybe.char
Types: Checking type _ of param ?tail:_
Types: Param is ?tail:wybe.c_string
Types: Checking type _ of param str:_
Types: Param is str:wybe.c_string
Types: Validating def of length
Types: Checking type _ of param str:_
Types: Param is str:wybe.c_string
Types: Checking type int of param ?#result:int
Types: Param is ?#result:wybe.int
Types: Validating def of print
Types: Checking type _ of param x:_
Types: Param is x:wybe.c_string
Types: Validating def of println
Types: Checking type _ of param x:_
Types: Param is x:wybe.c_string
Types: Validating def of read
Types: Checking type _ of param ?x:_
Types: Param is ?x:wybe.c_string
Types: Validating def of unsafe_c_string_index
Types: Checking type _ of param str:_
Types: Param is str:wybe.c_string
Types: Checking type int of param idx:int
Types: Param is idx:wybe.int
Types: Checking type char of param ?#result:char
Types: Param is ?#result:wybe.char
Types: Validating def of ~=
Types: Checking type _ of param x:_
Types: Param is x:wybe.c_string
Types: Checking type _ of param y:_
Types: Param is y:wybe.c_string
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: **** Re-exiting module wybe.c_string
Types: **** Validating parameter types in module wybe.char
Types: Validating def of <
Types: Checking type _ of param x:_
Types: Param is x:wybe.char
Types: Checking type _ of param y:_
Types: Param is y:wybe.char
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of <=
Types: Checking type _ of param x:_
Types: Param is x:wybe.char
Types: Checking type _ of param y:_
Types: Param is y:wybe.char
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of <=>
Types: Checking type _ of param x:_
Types: Param is x:wybe.char
Types: Checking type _ of param y:_
Types: Param is y:wybe.char
Types: Checking type comparison of param ?#result:comparison
Types: Param is ?#result:wybe.comparison
Types: Validating def of =
Types: Checking type _ of param x:_
Types: Param is x:wybe.char
Types: Checking type _ of param y:_
Types: Param is y:wybe.char
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of >
Types: Checking type _ of param x:_
Types: Param is x:wybe.char
Types: Checking type _ of param y:_
Types: Param is y:wybe.char
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of >=
Types: Checking type _ of param x:_
Types: Param is x:wybe.char
Types: Checking type _ of param y:_
Types: Param is y:wybe.char
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of chr
Types: Checking type int of param i:int
Types: Param is i:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.char
Types: Validating def of ord
Types: Checking type _ of param c:_
Types: Param is c:wybe.char
Types: Checking type int of param ?#result:int
Types: Param is ?#result:wybe.int
Types: Validating def of print
Types: Checking type _ of param x:_
Types: Param is x:wybe.char
Types: Validating def of println
Types: Checking type _ of param x:_
Types: Param is x:wybe.char
Types: Validating def of read
Types: Checking type _ of param ?x:_
Types: Param is ?x:wybe.char
Types: Validating def of ~=
Types: Checking type _ of param x:_
Types: Param is x:wybe.char
Types: Checking type _ of param y:_
Types: Param is y:wybe.char
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: **** Re-exiting module wybe.char
Types: **** Validating parameter types in module wybe.comparison
Types: Validating def of <
Types: Checking type _ of param x:_
Types: Param is x:wybe.comparison
Types: Checking type _ of param y:_
Types: Param is y:wybe.comparison
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of <=
Types: Checking type _ of param x:_
Types: Param is x:wybe.comparison
Types: Checking type _ of param y:_
Types: Param is y:wybe.comparison
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of =
Types: Checking type _ of param x:_
Types: Param is x:wybe.comparison
Types: Checking type _ of param y:_
Types: Param is y:wybe.comparison
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of >
Types: Checking type _ of param x:_
Types: Param is x:wybe.comparison
Types: Checking type _ of param y:_
Types: Param is y:wybe.comparison
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of >=
Types: Checking type _ of param x:_
Types: Param is x:wybe.comparison
Types: Checking type _ of param y:_
Types: Param is y:wybe.comparison
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of equal
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.comparison
Types: Validating def of greater
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.comparison
Types: Validating def of lesser
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.comparison
Types: Validating def of ~=
Types: Checking type _ of param x:_
Types: Param is x:wybe.comparison
Types: Checking type _ of param y:_
Types: Param is y:wybe.comparison
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: **** Re-exiting module wybe.comparison
Types: **** Validating parameter types in module wybe.int
Types: Validating def of %
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.int
Types: Validating def of %=
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Validating def of *
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.int
Types: Validating def of *=
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Validating def of +
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.int
Types: Validating def of +
Types: Checking type _ of param ?x:_
Types: Param is ?x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Checking type _ of param z:_
Types: Param is z:wybe.int
Types: Validating def of +
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param ?y:_
Types: Param is ?y:wybe.int
Types: Checking type _ of param z:_
Types: Param is z:wybe.int
Types: Validating def of +=
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Validating def of -
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.int
Types: Validating def of -
Types: Checking type _ of param ?x:_
Types: Param is ?x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Checking type _ of param z:_
Types: Param is z:wybe.int
Types: Validating def of -
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param ?y:_
Types: Param is ?y:wybe.int
Types: Checking type _ of param z:_
Types: Param is z:wybe.int
Types: Validating def of -
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.int
Types: Validating def of -
Types: Checking type _ of param ?x:_
Types: Param is ?x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Validating def of -=
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Validating def of /
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.int
Types: Validating def of /=
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Validating def of <
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of <<
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param s:_
Types: Param is s:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.int
Types: Validating def of <<=
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.int
Types: Checking type _ of param s:_
Types: Param is s:wybe.int
Types: Validating def of <=
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of <=>
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Checking type comparison of param ?#result:comparison
Types: Param is ?#result:wybe.comparison
Types: Validating def of =
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of >
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of >=
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of >>
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param s:_
Types: Param is s:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.int
Types: Validating def of >>=
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.int
Types: Checking type _ of param s:_
Types: Param is s:wybe.int
Types: Validating def of decr
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.int
Types: Validating def of incr
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.int
Types: Validating def of logical_bitshift
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param s:_
Types: Param is s:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.int
Types: Validating def of logical_bitshift
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.int
Types: Checking type _ of param s:_
Types: Param is s:wybe.int
Types: Validating def of max
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.int
Types: Validating def of min
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.int
Types: Validating def of power
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.int
Types: Validating def of print
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Validating def of println
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Validating def of read
Types: Checking type _ of param ?x:_
Types: Param is ?x:wybe.int
Types: Validating def of signum
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.int
Types: Validating def of sqrt
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.int
Types: Validating def of ~=
Types: Checking type _ of param x:_
Types: Param is x:wybe.int
Types: Checking type _ of param y:_
Types: Param is y:wybe.int
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: **** Re-exiting module wybe.int
Types: **** Validating parameter types in module wybe.io
Types: Validating def of 
Types: Validating def of eof
Types: Checking type char of param ?#result:char
Types: Param is ?#result:wybe.char
Types: Validating def of nl
Types: **** Re-exiting module wybe.io
Types: **** Type checking modules wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.int, wybe.io
Types: **** Strongly connected components:
Types:     wybe.io.nl
Types:     wybe.io.eof
Types:     wybe.int.~=
Types:     wybe.int.sqrt
Types:     wybe.int.signum
Types:     wybe.int.read
Types:     wybe.int.print
Types:     wybe.int.power
Types:     wybe.int.>>
Types:     wybe.int.>=
Types:     wybe.int.>
Types:     wybe.int.=
Types:     wybe.int.<=
Types:     wybe.int.<<
Types:     wybe.int.<
Types:     wybe.int./
Types:     wybe.int.*
Types:     wybe.int.%
Types:     wybe.comparison.~=
Types:     wybe.comparison.lesser
Types:     wybe.comparison.greater
Types:     wybe.comparison.equal
Types:     wybe.comparison.>=
Types:     wybe.int.max
Types:     wybe.comparison.>
Types:     wybe.comparison.=
Types:     wybe.comparison.<=
Types:     wybe.int.min
Types:     wybe.comparison.<
Types:     wybe.char.~=
Types:     wybe.char.read
Types:     wybe.char.print
Types:     wybe.char.ord
Types:     wybe.char.>=
Types:     wybe.char.>
Types:     wybe.char.=
Types:     wybe.io.
Types:     wybe.char.<=
Types:     wybe.char.chr
Types:     wybe.char.<
Types:     wybe.c_string.unsafe_c_string_index
Types:     wybe.c_string.read
Types:     wybe.c_string.print
Types:     wybe.c_string.length
Types:     wybe.c_string.>=
Types:     wybe.c_string.>
Types:     wybe.c_string.<=
Types:     wybe.c_string.<
Types:     wybe.bool.~=
Types:     wybe.c_string.~=
Types:     wybe.bool.||
Types:     wybe.bool.true
Types:     wybe.bool.~
Types:     wybe.bool.succeed
Types:     wybe.bool.print
Types:     wybe.bool.println
Types:     wybe.c_string.println
Types:     wybe.char.println
Types:     wybe.int.println
Types:     wybe.bool.false
Types:     wybe.bool.^^
Types:     wybe.bool.=
Types:     wybe.c_string.=
Types:     wybe.bool.^=
Types:     wybe.bool.|=
Types:     wybe.c_string.[]
Types:     wybe.c_string.[|]
Types:     wybe.char.<=>
Types:     wybe.int.%=
Types:     wybe.int.*=
Types:     wybe.int.+
Types:     wybe.int.+=
Types:     wybe.int.-
Types:     wybe.int.-=
Types:     wybe.int./=
Types:     wybe.int.<<=
Types:     wybe.int.<=>
Types:     wybe.int.>>=
Types:     wybe.int.decr
Types:     wybe.int.incr
Types:     wybe.int.logical_bitshift
Types:     wybe.bool.&&
Types:     wybe.bool.&=
Types: Type checking non-recursive proc wybe.io.nl
Types: ** Type checking decl of proc nl
Types: found 1 definition(s)
Types: Type checking nl
Types: ** Type checking nl: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         foreign c putchar('\n' @io:17:49, !io @io:17:54)
Types:    and defaults: 
Types:    with assigned vars: fromList ["io"]
Types: Recording parameter types: 
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {foreign c putchar('\n' @io:17:49, !io @io:17:54)}
Types: *** Before calls Typing {io::wybe.phantom}; {} (with no errors)
Types:   With calls:
Types:   Typing {io::wybe.phantom}; {} (with no errors)
Types: Finding type of expr '\n' @io:17:49
Types:   Type = wybe.char
Types: Finding type of expr !io @io:17:54
Types:   Type = wybe.phantom
Types: Type checking foreign c call putchar(8 bit unsigned)
Types: Now mode checking proc nl
Types: bound vars: semipure normal (total) computation binding {io}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt foreign c putchar('\n' @io:17:49, !io @io:17:54)
Types: Mode checking foreign call {foreign c putchar('\n' @io:17:49, !io @io:17:54)}
Types:     with assigned semipure normal (total) computation binding {io}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp '\n'
Types: Mode check exp resulted in '\n'
Types: Mode check exp !io
Types: Mode check exp resulted in !io
Types: Finding type of expr '\n' @io:17:49
Types:   Type = wybe.char
Types: Finding type of expr !io @io:17:54
Types:   Type = wybe.phantom
Types:     types and modes = [wybe.char,!wybe.phantom]
Types: New instr = {foreign c putchar('\n':wybe.char @io:17:49, !io:wybe.phantom @io:17:54)}
Types: Now assigned = semipure normal (total) computation binding {io}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'nl'
Types: Mode checked body   : [{foreign c putchar('\n':wybe.char @io:17:49, !io:wybe.phantom @io:17:54)} @io:17:31]
Types: Vars defined by body: semipure normal (total) computation binding {io}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : 
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of nl:
Types: 
Types: nl > public {inline} (0 calls)
Types: 4: nl() use !wybe.io.io:
Types:     foreign c putchar('\n':wybe.char @io:17:49, !io:wybe.phantom @io:17:54)
Types: Type checking non-recursive proc wybe.io.eof
Types: ** Type checking decl of proc eof
Types: found 1 definition(s)
Types: Type checking eof
Types: ** Type checking eof: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm cast(-1 @io:20:47, ?tmp#0 @io:20:29)
Types:         foreign llvm move(tmp#0, ?#result @io:20:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0"]
Types: Recording parameter types: ?#result:wybe.char
Types:     type of '#result' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable #result type constrained to wybe.char
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm cast(-1 @io:20:47, ?tmp#0 @io:20:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @io:20:5)}
Types: Unifying move argument types tmp#0 and ?#result @io:20:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @io:20:5
Types:   Type = wybe.char
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: *** Before calls Typing {#result::wybe.char, tmp#0::0}; {0::wybe.char} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.char, tmp#0::0}; {0::wybe.char} (with no errors)
Types: Finding type of expr -1 @io:20:47
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @io:20:29
Types: Type variable 0 is bound to Just wybe.char
Types:   Type = wybe.char
Types: Type checking foreign lpvm call cast(64 bit signed, 8 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.char
Types:   Type = wybe.char
Types: Finding type of expr ?#result @io:20:5
Types:   Type = wybe.char
Types: Type checking foreign llvm call move(8 bit unsigned, 8 bit unsigned)
Types: Now mode checking proc eof
Types: bound vars: semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm cast(-1 @io:20:47, ?tmp#0 @io:20:29)
Types: Mode checking foreign call {foreign lpvm cast(-1 @io:20:47, ?tmp#0 @io:20:29)}
Types:     with assigned semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check exp -1
Types: Mode check exp resulted in -1
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr -1 @io:20:47
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @io:20:29
Types: Type variable 0 is bound to Just wybe.char
Types:   Type = wybe.char
Types:     types and modes = [wybe.int,?wybe.char]
Types: New instr = {foreign lpvm cast(-1:wybe.int @io:20:47, ?tmp#0:wybe.char @io:20:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @io:20:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @io:20:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.char
Types:   Type = wybe.char
Types: Finding type of expr ?#result @io:20:5
Types:   Type = wybe.char
Types:     types and modes = [wybe.char,?wybe.char]
Types: New instr = {foreign llvm move(tmp#0:wybe.char, ?#result:wybe.char @io:20:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'eof'
Types: Mode checked body   : [{foreign lpvm cast(-1:wybe.int @io:20:47, ?tmp#0:wybe.char @io:20:29)} @io:20:29,{foreign llvm move(tmp#0:wybe.char, ?#result:wybe.char @io:20:5)} @io:20:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of eof:
Types: 
Types: eof > public {inline} (0 calls)
Types: 4: eof(?#result:wybe.char @io:20:5):
Types:     foreign lpvm cast(-1:wybe.int @io:20:47, ?tmp#0:wybe.char @io:20:29)
Types:     foreign llvm move(tmp#0:wybe.char, ?#result:wybe.char @io:20:5)
Types: Type checking non-recursive proc wybe.int.~=
Types: ** Type checking decl of proc ~=
Types: found 1 definition(s)
Types: Type checking ~=
Types: ** Type checking ~=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_ne(x @int:84:51, y @int:84:53, ?tmp#0 @int:84:30)
Types:         foreign llvm move(tmp#0, ?#result @int:84:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.int, y:wybe.int, ?#result:wybe.bool
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_ne(x @int:84:51, y @int:84:53, ?tmp#0 @int:84:30)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:84:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:84:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:84:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @int:84:51
Types:   Type = wybe.int
Types: Finding type of expr y @int:84:53
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:84:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_ne(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @int:84:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc ~=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_ne(x @int:84:51, y @int:84:53, ?tmp#0 @int:84:30)
Types: Mode checking foreign call {foreign llvm icmp_ne(x @int:84:51, y @int:84:53, ?tmp#0 @int:84:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:84:51
Types:   Type = wybe.int
Types: Finding type of expr y @int:84:53
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:84:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_ne(x:wybe.int @int:84:51, y:wybe.int @int:84:53, ?tmp#0:wybe.bool @int:84:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:84:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:84:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @int:84:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:84:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '~='
Types: Mode checked body   : [{foreign llvm icmp_ne(x:wybe.int @int:84:51, y:wybe.int @int:84:53, ?tmp#0:wybe.bool @int:84:30)} @int:84:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:84:5)} @int:84:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of ~=:
Types: 
Types: ~= > public (0 calls)
Types: 4: ~=(x:wybe.int @int:84:10, y:wybe.int @int:84:18, ?#result:wybe.bool @int:84:5):
Types:     foreign llvm icmp_ne(x:wybe.int @int:84:51, y:wybe.int @int:84:53, ?tmp#0:wybe.bool @int:84:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:84:5)
Types: Type checking non-recursive proc wybe.int.sqrt
Types: ** Type checking decl of proc sqrt
Types: found 1 definition(s)
Types: Type checking sqrt
Types: ** Type checking sqrt: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c isqrt(x @int:104:39, ?tmp#0 @int:104:23)
Types:         foreign llvm move(tmp#0, ?#result @int:104:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x"]
Types: Recording parameter types: x:wybe.int, ?#result:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign c isqrt(x @int:104:39, ?tmp#0 @int:104:23)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:104:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:104:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:104:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr x @int:104:39
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:104:23
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign c call isqrt(64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:104:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc sqrt
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt foreign c isqrt(x @int:104:39, ?tmp#0 @int:104:23)
Types: Mode checking foreign call {foreign c isqrt(x @int:104:39, ?tmp#0 @int:104:23)}
Types:     with assigned semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:104:39
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:104:23
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign c isqrt(x:wybe.int @int:104:39, ?tmp#0:wybe.int @int:104:23)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:104:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:104:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:104:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:104:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'sqrt'
Types: Mode checked body   : [{foreign c isqrt(x:wybe.int @int:104:39, ?tmp#0:wybe.int @int:104:23)} @int:104:23,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:104:5)} @int:104:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of sqrt:
Types: 
Types: sqrt > public (0 calls)
Types: 4: sqrt(x:wybe.int @int:104:14, ?#result:wybe.int @int:104:5):
Types:     foreign c isqrt(x:wybe.int @int:104:39, ?tmp#0:wybe.int @int:104:23)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:104:5)
Types: Type checking non-recursive proc wybe.int.signum
Types: ** Type checking decl of proc signum
Types: found 1 definition(s)
Types: Type checking signum
Types: ** Type checking signum: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c signum(x @int:114:42, ?tmp#0 @int:114:25)
Types:         foreign llvm move(tmp#0, ?#result @int:114:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x"]
Types: Recording parameter types: x:wybe.int, ?#result:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign c signum(x @int:114:42, ?tmp#0 @int:114:25)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:114:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:114:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:114:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr x @int:114:42
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:114:25
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign c call signum(64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:114:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc signum
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt foreign c signum(x @int:114:42, ?tmp#0 @int:114:25)
Types: Mode checking foreign call {foreign c signum(x @int:114:42, ?tmp#0 @int:114:25)}
Types:     with assigned semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:114:42
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:114:25
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign c signum(x:wybe.int @int:114:42, ?tmp#0:wybe.int @int:114:25)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:114:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:114:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:114:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:114:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'signum'
Types: Mode checked body   : [{foreign c signum(x:wybe.int @int:114:42, ?tmp#0:wybe.int @int:114:25)} @int:114:25,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:114:5)} @int:114:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of signum:
Types: 
Types: signum > public (0 calls)
Types: 4: signum(x:wybe.int @int:114:16, ?#result:wybe.int @int:114:5):
Types:     foreign c signum(x:wybe.int @int:114:42, ?tmp#0:wybe.int @int:114:25)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:114:5)
Types: Type checking non-recursive proc wybe.int.read
Types: ** Type checking decl of proc read
Types: found 1 definition(s)
Types: Type checking read
Types: ** Type checking read: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         foreign c read_int(?x @int:123:50, !io @int:123:54)
Types:    and defaults: 
Types:    with assigned vars: fromList ["io","x"]
Types: Recording parameter types: ?x:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {foreign c read_int(?x @int:123:50, !io @int:123:54)}
Types: *** Before calls Typing {io::wybe.phantom, x::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   Typing {io::wybe.phantom, x::wybe.int}; {} (with no errors)
Types: Finding type of expr ?x @int:123:50
Types:   Type = wybe.int
Types: Finding type of expr !io @int:123:54
Types:   Type = wybe.phantom
Types: Type checking foreign c call read_int(64 bit signed)
Types: Now mode checking proc read
Types: bound vars: semipure normal (total) computation binding {io}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt foreign c read_int(?x @int:123:50, !io @int:123:54)
Types: Mode checking foreign call {foreign c read_int(?x @int:123:50, !io @int:123:54)}
Types:     with assigned semipure normal (total) computation binding {io}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp !io
Types: Mode check exp resulted in !io
Types: Finding type of expr ?x @int:123:50
Types:   Type = wybe.int
Types: Finding type of expr !io @int:123:54
Types:   Type = wybe.phantom
Types:     types and modes = [?wybe.int,!wybe.phantom]
Types: New instr = {foreign c read_int(?x:wybe.int @int:123:50, !io:wybe.phantom @int:123:54)}
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'read'
Types: Mode checked body   : [{foreign c read_int(?x:wybe.int @int:123:50, !io:wybe.phantom @int:123:54)} @int:123:30]
Types: Vars defined by body: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : x
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of read:
Types: 
Types: read > public (0 calls)
Types: 4: read(?x:wybe.int @int:123:15) use !wybe.io.io:
Types:     foreign c read_int(?x:wybe.int @int:123:50, !io:wybe.phantom @int:123:54)
Types: Type checking non-recursive proc wybe.int.print
Types: ** Type checking decl of proc print
Types: found 1 definition(s)
Types: Type checking print
Types: ** Type checking print: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         foreign c print_int(x @int:119:50, !io @int:119:54)
Types:    and defaults: 
Types:    with assigned vars: fromList ["io","x"]
Types: Recording parameter types: x:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {foreign c print_int(x @int:119:50, !io @int:119:54)}
Types: *** Before calls Typing {io::wybe.phantom, x::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   Typing {io::wybe.phantom, x::wybe.int}; {} (with no errors)
Types: Finding type of expr x @int:119:50
Types:   Type = wybe.int
Types: Finding type of expr !io @int:119:54
Types:   Type = wybe.phantom
Types: Type checking foreign c call print_int(64 bit signed)
Types: Now mode checking proc print
Types: bound vars: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt foreign c print_int(x @int:119:50, !io @int:119:54)
Types: Mode checking foreign call {foreign c print_int(x @int:119:50, !io @int:119:54)}
Types:     with assigned semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp !io
Types: Mode check exp resulted in !io
Types: Finding type of expr x @int:119:50
Types:   Type = wybe.int
Types: Finding type of expr !io @int:119:54
Types:   Type = wybe.phantom
Types:     types and modes = [wybe.int,!wybe.phantom]
Types: New instr = {foreign c print_int(x:wybe.int @int:119:50, !io:wybe.phantom @int:119:54)}
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'print'
Types: Mode checked body   : [{foreign c print_int(x:wybe.int @int:119:50, !io:wybe.phantom @int:119:54)} @int:119:30]
Types: Vars defined by body: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : 
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of print:
Types: 
Types: print > public (0 calls)
Types: 4: print(x:wybe.int @int:119:15) use !wybe.io.io:
Types:     foreign c print_int(x:wybe.int @int:119:50, !io:wybe.phantom @int:119:54)
Types: Type checking non-recursive proc wybe.int.power
Types: ** Type checking decl of proc power
Types: found 1 definition(s)
Types: Type checking power
Types: ** Type checking power: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c ipow(x @int:107:44, y @int:107:46, ?tmp#0 @int:107:29)
Types:         foreign llvm move(tmp#0, ?#result @int:107:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.int, y:wybe.int, ?#result:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign c ipow(x @int:107:44, y @int:107:46, ?tmp#0 @int:107:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:107:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:107:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:107:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr x @int:107:44
Types:   Type = wybe.int
Types: Finding type of expr y @int:107:46
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:107:29
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign c call ipow(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:107:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc power
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign c ipow(x @int:107:44, y @int:107:46, ?tmp#0 @int:107:29)
Types: Mode checking foreign call {foreign c ipow(x @int:107:44, y @int:107:46, ?tmp#0 @int:107:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:107:44
Types:   Type = wybe.int
Types: Finding type of expr y @int:107:46
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:107:29
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign c ipow(x:wybe.int @int:107:44, y:wybe.int @int:107:46, ?tmp#0:wybe.int @int:107:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:107:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:107:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:107:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:107:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'power'
Types: Mode checked body   : [{foreign c ipow(x:wybe.int @int:107:44, y:wybe.int @int:107:46, ?tmp#0:wybe.int @int:107:29)} @int:107:29,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:107:5)} @int:107:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of power:
Types: 
Types: power > public (0 calls)
Types: 4: power(x:wybe.int @int:107:15, y:wybe.int @int:107:20, ?#result:wybe.int @int:107:5):
Types:     foreign c ipow(x:wybe.int @int:107:44, y:wybe.int @int:107:46, ?tmp#0:wybe.int @int:107:29)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:107:5)
Types: Type checking non-recursive proc wybe.int.>>
Types: ** Type checking decl of proc >>
Types: found 1 definition(s)
Types: Type checking >>
Types: ** Type checking >>: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm ashr(x @int:65:45, s @int:65:48, ?tmp#0 @int:65:27)
Types:         foreign llvm move(tmp#0, ?#result @int:65:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","s","tmp#0","x"]
Types: Recording parameter types: x:wybe.int, s:wybe.int, ?#result:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 's' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable s type constrained to wybe.int
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign llvm ashr(x @int:65:45, s @int:65:48, ?tmp#0 @int:65:27)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:65:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:65:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:65:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.int, s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr x @int:65:45
Types:   Type = wybe.int
Types: Finding type of expr s @int:65:48
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:65:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call ashr(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:65:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc >>
Types: bound vars: semipure normal (total) computation binding {s, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm ashr(x @int:65:45, s @int:65:48, ?tmp#0 @int:65:27)
Types: Mode checking foreign call {foreign llvm ashr(x @int:65:45, s @int:65:48, ?tmp#0 @int:65:27)}
Types:     with assigned semipure normal (total) computation binding {s, x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp s
Types: Mode check exp resulted in s
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:65:45
Types:   Type = wybe.int
Types: Finding type of expr s @int:65:48
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:65:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm ashr(x:wybe.int @int:65:45, s:wybe.int @int:65:48, ?tmp#0:wybe.int @int:65:27)}
Types: Now assigned = semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:65:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:65:5)}
Types:     with assigned semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:65:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:65:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc '>>'
Types: Mode checked body   : [{foreign llvm ashr(x:wybe.int @int:65:45, s:wybe.int @int:65:48, ?tmp#0:wybe.int @int:65:27)} @int:65:27,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:65:5)} @int:65:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, s, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of >>:
Types: 
Types: >> > public (0 calls)
Types: 4: >>(x:wybe.int @int:65:10, s:wybe.int @int:65:18, ?#result:wybe.int @int:65:5):
Types:     foreign llvm ashr(x:wybe.int @int:65:45, s:wybe.int @int:65:48, ?tmp#0:wybe.int @int:65:27)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:65:5)
Types: Type checking non-recursive proc wybe.int.>=
Types: ** Type checking decl of proc >=
Types: found 1 definition(s)
Types: Type checking >=
Types: ** Type checking >=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_sge(x @int:90:52, y @int:90:54, ?tmp#0 @int:90:30)
Types:         foreign llvm move(tmp#0, ?#result @int:90:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.int, y:wybe.int, ?#result:wybe.bool
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_sge(x @int:90:52, y @int:90:54, ?tmp#0 @int:90:30)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:90:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:90:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:90:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @int:90:52
Types:   Type = wybe.int
Types: Finding type of expr y @int:90:54
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:90:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_sge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @int:90:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc >=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_sge(x @int:90:52, y @int:90:54, ?tmp#0 @int:90:30)
Types: Mode checking foreign call {foreign llvm icmp_sge(x @int:90:52, y @int:90:54, ?tmp#0 @int:90:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:90:52
Types:   Type = wybe.int
Types: Finding type of expr y @int:90:54
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:90:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_sge(x:wybe.int @int:90:52, y:wybe.int @int:90:54, ?tmp#0:wybe.bool @int:90:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:90:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:90:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @int:90:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:90:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '>='
Types: Mode checked body   : [{foreign llvm icmp_sge(x:wybe.int @int:90:52, y:wybe.int @int:90:54, ?tmp#0:wybe.bool @int:90:30)} @int:90:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:90:5)} @int:90:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of >=:
Types: 
Types: >= > public (0 calls)
Types: 4: >=(x:wybe.int @int:90:10, y:wybe.int @int:90:18, ?#result:wybe.bool @int:90:5):
Types:     foreign llvm icmp_sge(x:wybe.int @int:90:52, y:wybe.int @int:90:54, ?tmp#0:wybe.bool @int:90:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:90:5)
Types: Type checking non-recursive proc wybe.int.>
Types: ** Type checking decl of proc >
Types: found 1 definition(s)
Types: Type checking >
Types: ** Type checking >: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_sgt(x @int:89:51, y @int:89:53, ?tmp#0 @int:89:29)
Types:         foreign llvm move(tmp#0, ?#result @int:89:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.int, y:wybe.int, ?#result:wybe.bool
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_sgt(x @int:89:51, y @int:89:53, ?tmp#0 @int:89:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:89:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:89:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:89:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @int:89:51
Types:   Type = wybe.int
Types: Finding type of expr y @int:89:53
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:89:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_sgt(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @int:89:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc >
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_sgt(x @int:89:51, y @int:89:53, ?tmp#0 @int:89:29)
Types: Mode checking foreign call {foreign llvm icmp_sgt(x @int:89:51, y @int:89:53, ?tmp#0 @int:89:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:89:51
Types:   Type = wybe.int
Types: Finding type of expr y @int:89:53
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:89:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_sgt(x:wybe.int @int:89:51, y:wybe.int @int:89:53, ?tmp#0:wybe.bool @int:89:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:89:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:89:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @int:89:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:89:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '>'
Types: Mode checked body   : [{foreign llvm icmp_sgt(x:wybe.int @int:89:51, y:wybe.int @int:89:53, ?tmp#0:wybe.bool @int:89:29)} @int:89:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:89:5)} @int:89:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of >:
Types: 
Types: > > public (0 calls)
Types: 4: >(x:wybe.int @int:89:10, y:wybe.int @int:89:17, ?#result:wybe.bool @int:89:5):
Types:     foreign llvm icmp_sgt(x:wybe.int @int:89:51, y:wybe.int @int:89:53, ?tmp#0:wybe.bool @int:89:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:89:5)
Types: Type checking non-recursive proc wybe.int.=
Types: ** Type checking decl of proc =
Types: found 1 definition(s)
Types: Type checking =
Types: ** Type checking =: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_eq(x @int:83:50, y @int:83:52, ?tmp#0 @int:83:29)
Types:         foreign llvm move(tmp#0, ?#result @int:83:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.int, y:wybe.int, ?#result:wybe.bool
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_eq(x @int:83:50, y @int:83:52, ?tmp#0 @int:83:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:83:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:83:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:83:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @int:83:50
Types:   Type = wybe.int
Types: Finding type of expr y @int:83:52
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:83:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @int:83:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc =
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(x @int:83:50, y @int:83:52, ?tmp#0 @int:83:29)
Types: Mode checking foreign call {foreign llvm icmp_eq(x @int:83:50, y @int:83:52, ?tmp#0 @int:83:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:83:50
Types:   Type = wybe.int
Types: Finding type of expr y @int:83:52
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:83:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(x:wybe.int @int:83:50, y:wybe.int @int:83:52, ?tmp#0:wybe.bool @int:83:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:83:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:83:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @int:83:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:83:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '='
Types: Mode checked body   : [{foreign llvm icmp_eq(x:wybe.int @int:83:50, y:wybe.int @int:83:52, ?tmp#0:wybe.bool @int:83:29)} @int:83:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:83:5)} @int:83:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of =:
Types: 
Types: = > public (0 calls)
Types: 4: =(x:wybe.int @int:83:10, y:wybe.int @int:83:17, ?#result:wybe.bool @int:83:5):
Types:     foreign llvm icmp_eq(x:wybe.int @int:83:50, y:wybe.int @int:83:52, ?tmp#0:wybe.bool @int:83:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:83:5)
Types: Type checking non-recursive proc wybe.int.<=
Types: ** Type checking decl of proc <=
Types: found 1 definition(s)
Types: Type checking <=
Types: ** Type checking <=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_sle(x @int:88:52, y @int:88:54, ?tmp#0 @int:88:30)
Types:         foreign llvm move(tmp#0, ?#result @int:88:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.int, y:wybe.int, ?#result:wybe.bool
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_sle(x @int:88:52, y @int:88:54, ?tmp#0 @int:88:30)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:88:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:88:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:88:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @int:88:52
Types:   Type = wybe.int
Types: Finding type of expr y @int:88:54
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:88:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_sle(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @int:88:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc <=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_sle(x @int:88:52, y @int:88:54, ?tmp#0 @int:88:30)
Types: Mode checking foreign call {foreign llvm icmp_sle(x @int:88:52, y @int:88:54, ?tmp#0 @int:88:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:88:52
Types:   Type = wybe.int
Types: Finding type of expr y @int:88:54
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:88:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_sle(x:wybe.int @int:88:52, y:wybe.int @int:88:54, ?tmp#0:wybe.bool @int:88:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:88:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:88:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @int:88:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:88:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<='
Types: Mode checked body   : [{foreign llvm icmp_sle(x:wybe.int @int:88:52, y:wybe.int @int:88:54, ?tmp#0:wybe.bool @int:88:30)} @int:88:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:88:5)} @int:88:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <=:
Types: 
Types: <= > public (0 calls)
Types: 4: <=(x:wybe.int @int:88:10, y:wybe.int @int:88:18, ?#result:wybe.bool @int:88:5):
Types:     foreign llvm icmp_sle(x:wybe.int @int:88:52, y:wybe.int @int:88:54, ?tmp#0:wybe.bool @int:88:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:88:5)
Types: Type checking non-recursive proc wybe.int.<<
Types: ** Type checking decl of proc <<
Types: found 1 definition(s)
Types: Type checking <<
Types: ** Type checking <<: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm shl(x @int:56:44, s @int:56:47, ?tmp#0 @int:56:27)
Types:         foreign llvm move(tmp#0, ?#result @int:56:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","s","tmp#0","x"]
Types: Recording parameter types: x:wybe.int, s:wybe.int, ?#result:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 's' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable s type constrained to wybe.int
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign llvm shl(x @int:56:44, s @int:56:47, ?tmp#0 @int:56:27)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:56:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:56:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:56:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.int, s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr x @int:56:44
Types:   Type = wybe.int
Types: Finding type of expr s @int:56:47
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:56:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call shl(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:56:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc <<
Types: bound vars: semipure normal (total) computation binding {s, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm shl(x @int:56:44, s @int:56:47, ?tmp#0 @int:56:27)
Types: Mode checking foreign call {foreign llvm shl(x @int:56:44, s @int:56:47, ?tmp#0 @int:56:27)}
Types:     with assigned semipure normal (total) computation binding {s, x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp s
Types: Mode check exp resulted in s
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:56:44
Types:   Type = wybe.int
Types: Finding type of expr s @int:56:47
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:56:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm shl(x:wybe.int @int:56:44, s:wybe.int @int:56:47, ?tmp#0:wybe.int @int:56:27)}
Types: Now assigned = semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:56:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:56:5)}
Types:     with assigned semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:56:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:56:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<<'
Types: Mode checked body   : [{foreign llvm shl(x:wybe.int @int:56:44, s:wybe.int @int:56:47, ?tmp#0:wybe.int @int:56:27)} @int:56:27,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:56:5)} @int:56:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, s, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <<:
Types: 
Types: << > public (0 calls)
Types: 4: <<(x:wybe.int @int:56:10, s:wybe.int @int:56:18, ?#result:wybe.int @int:56:5):
Types:     foreign llvm shl(x:wybe.int @int:56:44, s:wybe.int @int:56:47, ?tmp#0:wybe.int @int:56:27)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:56:5)
Types: Type checking non-recursive proc wybe.int.<
Types: ** Type checking decl of proc <
Types: found 1 definition(s)
Types: Type checking <
Types: ** Type checking <: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_slt(x @int:87:51, y @int:87:53, ?tmp#0 @int:87:29)
Types:         foreign llvm move(tmp#0, ?#result @int:87:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.int, y:wybe.int, ?#result:wybe.bool
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_slt(x @int:87:51, y @int:87:53, ?tmp#0 @int:87:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:87:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:87:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:87:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @int:87:51
Types:   Type = wybe.int
Types: Finding type of expr y @int:87:53
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:87:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_slt(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @int:87:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc <
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_slt(x @int:87:51, y @int:87:53, ?tmp#0 @int:87:29)
Types: Mode checking foreign call {foreign llvm icmp_slt(x @int:87:51, y @int:87:53, ?tmp#0 @int:87:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:87:51
Types:   Type = wybe.int
Types: Finding type of expr y @int:87:53
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:87:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_slt(x:wybe.int @int:87:51, y:wybe.int @int:87:53, ?tmp#0:wybe.bool @int:87:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:87:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:87:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @int:87:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:87:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<'
Types: Mode checked body   : [{foreign llvm icmp_slt(x:wybe.int @int:87:51, y:wybe.int @int:87:53, ?tmp#0:wybe.bool @int:87:29)} @int:87:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:87:5)} @int:87:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <:
Types: 
Types: < > public (0 calls)
Types: 4: <(x:wybe.int @int:87:10, y:wybe.int @int:87:17, ?#result:wybe.bool @int:87:5):
Types:     foreign llvm icmp_slt(x:wybe.int @int:87:51, y:wybe.int @int:87:53, ?tmp#0:wybe.bool @int:87:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:87:5)
Types: Type checking non-recursive proc wybe.int./
Types: ** Type checking decl of proc /
Types: found 1 definition(s)
Types: Type checking /
Types: ** Type checking /: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm sdiv(x @int:44:43, y @int:44:45, ?tmp#0 @int:44:25)
Types:         foreign llvm move(tmp#0, ?#result @int:44:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.int, y:wybe.int, ?#result:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign llvm sdiv(x @int:44:43, y @int:44:45, ?tmp#0 @int:44:25)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:44:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:44:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:44:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr x @int:44:43
Types:   Type = wybe.int
Types: Finding type of expr y @int:44:45
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:44:25
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call sdiv(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:44:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc /
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm sdiv(x @int:44:43, y @int:44:45, ?tmp#0 @int:44:25)
Types: Mode checking foreign call {foreign llvm sdiv(x @int:44:43, y @int:44:45, ?tmp#0 @int:44:25)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:44:43
Types:   Type = wybe.int
Types: Finding type of expr y @int:44:45
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:44:25
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm sdiv(x:wybe.int @int:44:43, y:wybe.int @int:44:45, ?tmp#0:wybe.int @int:44:25)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:44:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:44:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:44:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:44:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '/'
Types: Mode checked body   : [{foreign llvm sdiv(x:wybe.int @int:44:43, y:wybe.int @int:44:45, ?tmp#0:wybe.int @int:44:25)} @int:44:25,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:44:5)} @int:44:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of /:
Types: 
Types: / > public (0 calls)
Types: 4: /(x:wybe.int @int:44:10, y:wybe.int @int:44:16, ?#result:wybe.int @int:44:5):
Types:     foreign llvm sdiv(x:wybe.int @int:44:43, y:wybe.int @int:44:45, ?tmp#0:wybe.int @int:44:25)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:44:5)
Types: Type checking non-recursive proc wybe.int.*
Types: ** Type checking decl of proc *
Types: found 1 definition(s)
Types: Type checking *
Types: ** Type checking *: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm mul(x @int:38:42, y @int:38:44, ?tmp#0 @int:38:25)
Types:         foreign llvm move(tmp#0, ?#result @int:38:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.int, y:wybe.int, ?#result:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign llvm mul(x @int:38:42, y @int:38:44, ?tmp#0 @int:38:25)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:38:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:38:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:38:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr x @int:38:42
Types:   Type = wybe.int
Types: Finding type of expr y @int:38:44
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:38:25
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call mul(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:38:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc *
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm mul(x @int:38:42, y @int:38:44, ?tmp#0 @int:38:25)
Types: Mode checking foreign call {foreign llvm mul(x @int:38:42, y @int:38:44, ?tmp#0 @int:38:25)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:38:42
Types:   Type = wybe.int
Types: Finding type of expr y @int:38:44
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:38:25
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm mul(x:wybe.int @int:38:42, y:wybe.int @int:38:44, ?tmp#0:wybe.int @int:38:25)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:38:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:38:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:38:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:38:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '*'
Types: Mode checked body   : [{foreign llvm mul(x:wybe.int @int:38:42, y:wybe.int @int:38:44, ?tmp#0:wybe.int @int:38:25)} @int:38:25,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:38:5)} @int:38:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of *:
Types: 
Types: * > public (0 calls)
Types: 4: *(x:wybe.int @int:38:10, y:wybe.int @int:38:16, ?#result:wybe.int @int:38:5):
Types:     foreign llvm mul(x:wybe.int @int:38:42, y:wybe.int @int:38:44, ?tmp#0:wybe.int @int:38:25)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:38:5)
Types: Type checking non-recursive proc wybe.int.%
Types: ** Type checking decl of proc %
Types: found 1 definition(s)
Types: Type checking %
Types: ** Type checking %: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm srem(x @int:50:43, y @int:50:45, ?tmp#0 @int:50:25)
Types:         foreign llvm move(tmp#0, ?#result @int:50:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.int, y:wybe.int, ?#result:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign llvm srem(x @int:50:43, y @int:50:45, ?tmp#0 @int:50:25)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:50:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:50:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:50:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr x @int:50:43
Types:   Type = wybe.int
Types: Finding type of expr y @int:50:45
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:50:25
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call srem(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:50:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc %
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm srem(x @int:50:43, y @int:50:45, ?tmp#0 @int:50:25)
Types: Mode checking foreign call {foreign llvm srem(x @int:50:43, y @int:50:45, ?tmp#0 @int:50:25)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:50:43
Types:   Type = wybe.int
Types: Finding type of expr y @int:50:45
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:50:25
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm srem(x:wybe.int @int:50:43, y:wybe.int @int:50:45, ?tmp#0:wybe.int @int:50:25)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:50:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:50:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:50:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:50:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '%'
Types: Mode checked body   : [{foreign llvm srem(x:wybe.int @int:50:43, y:wybe.int @int:50:45, ?tmp#0:wybe.int @int:50:25)} @int:50:25,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:50:5)} @int:50:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of %:
Types: 
Types: % > public (0 calls)
Types: 4: %(x:wybe.int @int:50:10, y:wybe.int @int:50:16, ?#result:wybe.int @int:50:5):
Types:     foreign llvm srem(x:wybe.int @int:50:43, y:wybe.int @int:50:45, ?tmp#0:wybe.int @int:50:25)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:50:5)
Types: Type checking non-recursive proc wybe.comparison.~=
Types: ** Type checking decl of proc ~=
Types: found 1 definition(s)
Types: Type checking ~=
Types: ** Type checking ~=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_ne(x @comparison:11:51, y @comparison:11:54, ?tmp#0 @comparison:11:30)
Types:         foreign llvm move(tmp#0, ?#result @comparison:11:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.comparison, y:wybe.comparison, ?#result:wybe.bool
Types:     type of 'x' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable x type constrained to wybe.comparison
Types:     type of 'y' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable y type constrained to wybe.comparison
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_ne(x @comparison:11:51, y @comparison:11:54, ?tmp#0 @comparison:11:30)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @comparison:11:5)}
Types: Unifying move argument types tmp#0 and ?#result @comparison:11:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @comparison:11:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.comparison, y::wybe.comparison}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.comparison, y::wybe.comparison}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @comparison:11:51
Types:   Type = wybe.comparison
Types: Finding type of expr y @comparison:11:54
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0 @comparison:11:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_ne(2 bit unsigned, 2 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @comparison:11:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc ~=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_ne(x @comparison:11:51, y @comparison:11:54, ?tmp#0 @comparison:11:30)
Types: Mode checking foreign call {foreign llvm icmp_ne(x @comparison:11:51, y @comparison:11:54, ?tmp#0 @comparison:11:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @comparison:11:51
Types:   Type = wybe.comparison
Types: Finding type of expr y @comparison:11:54
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0 @comparison:11:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.comparison,wybe.comparison,?wybe.bool]
Types: New instr = {foreign llvm icmp_ne(x:wybe.comparison @comparison:11:51, y:wybe.comparison @comparison:11:54, ?tmp#0:wybe.bool @comparison:11:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @comparison:11:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @comparison:11:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @comparison:11:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:11:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '~='
Types: Mode checked body   : [{foreign llvm icmp_ne(x:wybe.comparison @comparison:11:51, y:wybe.comparison @comparison:11:54, ?tmp#0:wybe.bool @comparison:11:30)} @comparison:11:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:11:5)} @comparison:11:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of ~=:
Types: 
Types: ~= > public (0 calls)
Types: 4: ~=(x:wybe.comparison @comparison:11:10, y:wybe.comparison @comparison:11:18, ?#result:wybe.bool @comparison:11:5):
Types:     foreign llvm icmp_ne(x:wybe.comparison @comparison:11:51, y:wybe.comparison @comparison:11:54, ?tmp#0:wybe.bool @comparison:11:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:11:5)
Types: Type checking non-recursive proc wybe.comparison.lesser
Types: ** Type checking decl of proc lesser
Types: found 1 definition(s)
Types: Type checking lesser
Types: ** Type checking lesser: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm cast(0:!_, ?#result)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result"]
Types: Recording parameter types: ?#result:wybe.comparison
Types:     type of '#result' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable #result type constrained to wybe.comparison
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm cast(0:!_, ?#result)}
Types: *** Before calls Typing {#result::wybe.comparison}; {} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.comparison}; {} (with no errors)
Types: Finding type of expr 0:!_
Types:   Type = wybe.comparison
Types: Finding type of expr ?#result
Types:   Type = wybe.comparison
Types: Type checking foreign lpvm call cast(2 bit unsigned, 2 bit unsigned)
Types: Now mode checking proc lesser
Types: bound vars: semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm cast(0:!_, ?#result)
Types: Mode checking foreign call {foreign lpvm cast(0:!_, ?#result)}
Types:     with assigned semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check exp 0:!_
Types: Mode check exp resulted in 0:!_
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr 0:!_
Types:   Type = wybe.comparison
Types: Finding type of expr ?#result
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign lpvm cast(0:!wybe.comparison, ?#result:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'lesser'
Types: Mode checked body   : [{foreign lpvm cast(0:!wybe.comparison, ?#result:wybe.comparison)}]
Types: Vars defined by body: semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of lesser:
Types: 
Types: lesser > public {inline} (0 calls)
Types: 4: lesser(?#result:wybe.comparison @comparison:8:18):
Types:     foreign lpvm cast(0:!wybe.comparison, ?#result:wybe.comparison)
Types: Type checking non-recursive proc wybe.comparison.greater
Types: ** Type checking decl of proc greater
Types: found 1 definition(s)
Types: Type checking greater
Types: ** Type checking greater: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm cast(2:!_, ?#result)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result"]
Types: Recording parameter types: ?#result:wybe.comparison
Types:     type of '#result' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable #result type constrained to wybe.comparison
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm cast(2:!_, ?#result)}
Types: *** Before calls Typing {#result::wybe.comparison}; {} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.comparison}; {} (with no errors)
Types: Finding type of expr 2:!_
Types:   Type = wybe.comparison
Types: Finding type of expr ?#result
Types:   Type = wybe.comparison
Types: Type checking foreign lpvm call cast(2 bit unsigned, 2 bit unsigned)
Types: Now mode checking proc greater
Types: bound vars: semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm cast(2:!_, ?#result)
Types: Mode checking foreign call {foreign lpvm cast(2:!_, ?#result)}
Types:     with assigned semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check exp 2:!_
Types: Mode check exp resulted in 2:!_
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr 2:!_
Types:   Type = wybe.comparison
Types: Finding type of expr ?#result
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign lpvm cast(2:!wybe.comparison, ?#result:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'greater'
Types: Mode checked body   : [{foreign lpvm cast(2:!wybe.comparison, ?#result:wybe.comparison)}]
Types: Vars defined by body: semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of greater:
Types: 
Types: greater > public {inline} (0 calls)
Types: 4: greater(?#result:wybe.comparison @comparison:8:35):
Types:     foreign lpvm cast(2:!wybe.comparison, ?#result:wybe.comparison)
Types: Type checking non-recursive proc wybe.comparison.equal
Types: ** Type checking decl of proc equal
Types: found 1 definition(s)
Types: Type checking equal
Types: ** Type checking equal: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm cast(1:!_, ?#result)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result"]
Types: Recording parameter types: ?#result:wybe.comparison
Types:     type of '#result' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable #result type constrained to wybe.comparison
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm cast(1:!_, ?#result)}
Types: *** Before calls Typing {#result::wybe.comparison}; {} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.comparison}; {} (with no errors)
Types: Finding type of expr 1:!_
Types:   Type = wybe.comparison
Types: Finding type of expr ?#result
Types:   Type = wybe.comparison
Types: Type checking foreign lpvm call cast(2 bit unsigned, 2 bit unsigned)
Types: Now mode checking proc equal
Types: bound vars: semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm cast(1:!_, ?#result)
Types: Mode checking foreign call {foreign lpvm cast(1:!_, ?#result)}
Types:     with assigned semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check exp 1:!_
Types: Mode check exp resulted in 1:!_
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr 1:!_
Types:   Type = wybe.comparison
Types: Finding type of expr ?#result
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign lpvm cast(1:!wybe.comparison, ?#result:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'equal'
Types: Mode checked body   : [{foreign lpvm cast(1:!wybe.comparison, ?#result:wybe.comparison)}]
Types: Vars defined by body: semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of equal:
Types: 
Types: equal > public {inline} (0 calls)
Types: 4: equal(?#result:wybe.comparison @comparison:8:27):
Types:     foreign lpvm cast(1:!wybe.comparison, ?#result:wybe.comparison)
Types: Type checking non-recursive proc wybe.comparison.>=
Types: ** Type checking decl of proc >=
Types: found 1 definition(s)
Types: Type checking >=
Types: ** Type checking >=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_uge(x @comparison:15:52, y @comparison:15:55, ?tmp#0 @comparison:15:30)
Types:         foreign llvm move(tmp#0, ?#result @comparison:15:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.comparison, y:wybe.comparison, ?#result:wybe.bool
Types:     type of 'x' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable x type constrained to wybe.comparison
Types:     type of 'y' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable y type constrained to wybe.comparison
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(x @comparison:15:52, y @comparison:15:55, ?tmp#0 @comparison:15:30)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @comparison:15:5)}
Types: Unifying move argument types tmp#0 and ?#result @comparison:15:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @comparison:15:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.comparison, y::wybe.comparison}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.comparison, y::wybe.comparison}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @comparison:15:52
Types:   Type = wybe.comparison
Types: Finding type of expr y @comparison:15:55
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0 @comparison:15:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(2 bit unsigned, 2 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @comparison:15:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc >=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_uge(x @comparison:15:52, y @comparison:15:55, ?tmp#0 @comparison:15:30)
Types: Mode checking foreign call {foreign llvm icmp_uge(x @comparison:15:52, y @comparison:15:55, ?tmp#0 @comparison:15:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @comparison:15:52
Types:   Type = wybe.comparison
Types: Finding type of expr y @comparison:15:55
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0 @comparison:15:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.comparison,wybe.comparison,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(x:wybe.comparison @comparison:15:52, y:wybe.comparison @comparison:15:55, ?tmp#0:wybe.bool @comparison:15:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @comparison:15:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @comparison:15:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @comparison:15:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:15:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '>='
Types: Mode checked body   : [{foreign llvm icmp_uge(x:wybe.comparison @comparison:15:52, y:wybe.comparison @comparison:15:55, ?tmp#0:wybe.bool @comparison:15:30)} @comparison:15:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:15:5)} @comparison:15:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of >=:
Types: 
Types: >= > public (0 calls)
Types: 4: >=(x:wybe.comparison @comparison:15:10, y:wybe.comparison @comparison:15:18, ?#result:wybe.bool @comparison:15:5):
Types:     foreign llvm icmp_uge(x:wybe.comparison @comparison:15:52, y:wybe.comparison @comparison:15:55, ?tmp#0:wybe.bool @comparison:15:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:15:5)
Types: Type checking non-recursive proc wybe.int.max
Types: ** Type checking decl of proc max
Types: found 1 definition(s)
Types: Type checking max
Types: ** Type checking max: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         >=(x @int:98:31, y @int:98:35)
Types:         foreign llvm move(x @int:98:39, ?tmp#0)
Types:         foreign llvm move(y @int:98:50, ?tmp#0)
Types:         foreign llvm move(tmp#0 @int:98:31, ?#result @int:98:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.int, y:wybe.int, ?#result:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {>=(x @int:98:31, y @int:98:35)}
Types: Recording casts in {foreign llvm move(x @int:98:39, ?tmp#0)}
Types: Unifying move argument types x @int:98:39 and ?tmp#0
Types: Finding type of expr x @int:98:39
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0
Types:   Type = 0
Types: Type variable 0 is bound to Nothing
Types: Unifying types wybe.int (-> wybe.int) and 0 (-> 0)
Types:   Unification yields wybe.int
Types: Recording casts in {foreign llvm move(y @int:98:50, ?tmp#0)}
Types: Unifying move argument types y @int:98:50 and ?tmp#0
Types: Finding type of expr y @int:98:50
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Recording casts in {foreign llvm move(tmp#0 @int:98:31, ?#result @int:98:5)}
Types: Unifying move argument types tmp#0 @int:98:31 and ?#result @int:98:5
Types: Finding type of expr tmp#0 @int:98:31
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:98:5
Types:   Type = wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {>=(x @int:98:31, y @int:98:35)} @int:98:31, typingInfos = [wybe.comparison.>=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.>=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Type checking call {>=(x @int:98:31, y @int:98:35)} @int:98:31
Types: Candidate types:
Types:     wybe.comparison.>=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.>=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr x @int:98:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:98:35
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.>=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 98, column 31): Type error in call to >=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 98, column 31): Type error in call to >=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.>=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr x @int:98:39
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr y @int:98:50
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#0 @int:98:31
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:98:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc max
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt if {>=(x @int:98:31, y @int:98:35)::
Types: 
Types:                     foreign llvm move(x @int:98:39, ?tmp#0)
Types:                 else::
Types:                     foreign llvm move(y @int:98:50, ?tmp#0)
Types: 
Types:                 }
Types: Mode checking conditional {if {>=(x @int:98:31, y @int:98:35)::
Types: 
Types:         foreign llvm move(x @int:98:39, ?tmp#0)
Types:     else::
Types:         foreign llvm move(y @int:98:50, ?tmp#0)
Types: 
Types:     }}
Types: Mode checking call   : {>=(x @int:98:31, y @int:98:35)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Finding type of expr x @int:98:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:98:35
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.>=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 98, column 31): Type error in call to >=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 98, column 31): Type error in call to >=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.>=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.>=<0>(wybe.int,wybe.int),Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.>=<0>(wybe.int,wybe.int),Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.>=<0>(wybe.int,wybe.int),Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Finding type of expr x @int:98:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:98:35
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>>=(x:wybe.int @int:98:31, y:wybe.int @int:98:35)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>>=(x:wybe.int @int:98:31, y:wybe.int @int:98:35)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc 'max'
Types: Assigned by test: semipure test computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(x @int:98:39, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(x @int:98:39, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:98:39
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(x:wybe.int @int:98:39, ?tmp#0:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'max'
Types: Assigned by then branch: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(y @int:98:50, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(y @int:98:50, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr y @int:98:50
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(y:wybe.int @int:98:50, ?tmp#0:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'max'
Types: Assigned by else branch: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Type variable 0 is bound to Just wybe.int
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0 @int:98:31, ?#result @int:98:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0 @int:98:31, ?#result @int:98:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0 @int:98:31
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:98:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int @int:98:31, ?#result:wybe.int @int:98:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'max'
Types: Mode checked body   : [{if {wybe.int.<0>>=(x:wybe.int @int:98:31, y:wybe.int @int:98:35)::
Types: 
Types:         foreign llvm move(x:wybe.int @int:98:39, ?tmp#0:wybe.int)
Types:     else::
Types:         foreign llvm move(y:wybe.int @int:98:50, ?tmp#0:wybe.int)
Types: 
Types:     }
Types:    condition -> {x::wybe.int, y::wybe.int}
Types:    then&else -> {tmp#0::wybe.int, x::wybe.int, y::wybe.int}} @int:98:31,{foreign llvm move(tmp#0:wybe.int @int:98:31, ?#result:wybe.int @int:98:5)} @int:98:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of max:
Types: 
Types: max > public (0 calls)
Types: 4: max(x:wybe.int @int:98:13, y:wybe.int @int:98:18, ?#result:wybe.int @int:98:5):
Types:     if {wybe.int.<0>>=(x:wybe.int @int:98:31, y:wybe.int @int:98:35)::
Types: 
Types:         foreign llvm move(x:wybe.int @int:98:39, ?tmp#0:wybe.int)
Types:     else::
Types:         foreign llvm move(y:wybe.int @int:98:50, ?tmp#0:wybe.int)
Types: 
Types:     }
Types:    condition -> {x::wybe.int, y::wybe.int}
Types:    then&else -> {tmp#0::wybe.int, x::wybe.int, y::wybe.int}
Types:     foreign llvm move(tmp#0:wybe.int @int:98:31, ?#result:wybe.int @int:98:5)
Types: Type checking non-recursive proc wybe.comparison.>
Types: ** Type checking decl of proc >
Types: found 1 definition(s)
Types: Type checking >
Types: ** Type checking >: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_ugt(x @comparison:14:51, y @comparison:14:54, ?tmp#0 @comparison:14:29)
Types:         foreign llvm move(tmp#0, ?#result @comparison:14:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.comparison, y:wybe.comparison, ?#result:wybe.bool
Types:     type of 'x' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable x type constrained to wybe.comparison
Types:     type of 'y' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable y type constrained to wybe.comparison
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_ugt(x @comparison:14:51, y @comparison:14:54, ?tmp#0 @comparison:14:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @comparison:14:5)}
Types: Unifying move argument types tmp#0 and ?#result @comparison:14:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @comparison:14:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.comparison, y::wybe.comparison}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.comparison, y::wybe.comparison}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @comparison:14:51
Types:   Type = wybe.comparison
Types: Finding type of expr y @comparison:14:54
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0 @comparison:14:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_ugt(2 bit unsigned, 2 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @comparison:14:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc >
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_ugt(x @comparison:14:51, y @comparison:14:54, ?tmp#0 @comparison:14:29)
Types: Mode checking foreign call {foreign llvm icmp_ugt(x @comparison:14:51, y @comparison:14:54, ?tmp#0 @comparison:14:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @comparison:14:51
Types:   Type = wybe.comparison
Types: Finding type of expr y @comparison:14:54
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0 @comparison:14:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.comparison,wybe.comparison,?wybe.bool]
Types: New instr = {foreign llvm icmp_ugt(x:wybe.comparison @comparison:14:51, y:wybe.comparison @comparison:14:54, ?tmp#0:wybe.bool @comparison:14:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @comparison:14:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @comparison:14:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @comparison:14:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:14:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '>'
Types: Mode checked body   : [{foreign llvm icmp_ugt(x:wybe.comparison @comparison:14:51, y:wybe.comparison @comparison:14:54, ?tmp#0:wybe.bool @comparison:14:29)} @comparison:14:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:14:5)} @comparison:14:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of >:
Types: 
Types: > > public (0 calls)
Types: 4: >(x:wybe.comparison @comparison:14:10, y:wybe.comparison @comparison:14:17, ?#result:wybe.bool @comparison:14:5):
Types:     foreign llvm icmp_ugt(x:wybe.comparison @comparison:14:51, y:wybe.comparison @comparison:14:54, ?tmp#0:wybe.bool @comparison:14:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:14:5)
Types: Type checking non-recursive proc wybe.comparison.=
Types: ** Type checking decl of proc =
Types: found 1 definition(s)
Types: Type checking =
Types: ** Type checking =: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_eq(x @comparison:10:50, y @comparison:10:53, ?tmp#0 @comparison:10:29)
Types:         foreign llvm move(tmp#0, ?#result @comparison:10:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.comparison, y:wybe.comparison, ?#result:wybe.bool
Types:     type of 'x' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable x type constrained to wybe.comparison
Types:     type of 'y' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable y type constrained to wybe.comparison
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_eq(x @comparison:10:50, y @comparison:10:53, ?tmp#0 @comparison:10:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @comparison:10:5)}
Types: Unifying move argument types tmp#0 and ?#result @comparison:10:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @comparison:10:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.comparison, y::wybe.comparison}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.comparison, y::wybe.comparison}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @comparison:10:50
Types:   Type = wybe.comparison
Types: Finding type of expr y @comparison:10:53
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0 @comparison:10:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(2 bit unsigned, 2 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @comparison:10:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc =
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(x @comparison:10:50, y @comparison:10:53, ?tmp#0 @comparison:10:29)
Types: Mode checking foreign call {foreign llvm icmp_eq(x @comparison:10:50, y @comparison:10:53, ?tmp#0 @comparison:10:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @comparison:10:50
Types:   Type = wybe.comparison
Types: Finding type of expr y @comparison:10:53
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0 @comparison:10:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.comparison,wybe.comparison,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(x:wybe.comparison @comparison:10:50, y:wybe.comparison @comparison:10:53, ?tmp#0:wybe.bool @comparison:10:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @comparison:10:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @comparison:10:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @comparison:10:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:10:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '='
Types: Mode checked body   : [{foreign llvm icmp_eq(x:wybe.comparison @comparison:10:50, y:wybe.comparison @comparison:10:53, ?tmp#0:wybe.bool @comparison:10:29)} @comparison:10:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:10:5)} @comparison:10:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of =:
Types: 
Types: = > public (0 calls)
Types: 4: =(x:wybe.comparison @comparison:10:10, y:wybe.comparison @comparison:10:17, ?#result:wybe.bool @comparison:10:5):
Types:     foreign llvm icmp_eq(x:wybe.comparison @comparison:10:50, y:wybe.comparison @comparison:10:53, ?tmp#0:wybe.bool @comparison:10:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:10:5)
Types: Type checking non-recursive proc wybe.comparison.<=
Types: ** Type checking decl of proc <=
Types: found 1 definition(s)
Types: Type checking <=
Types: ** Type checking <=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_ule(x @comparison:13:52, y @comparison:13:55, ?tmp#0 @comparison:13:30)
Types:         foreign llvm move(tmp#0, ?#result @comparison:13:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.comparison, y:wybe.comparison, ?#result:wybe.bool
Types:     type of 'x' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable x type constrained to wybe.comparison
Types:     type of 'y' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable y type constrained to wybe.comparison
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_ule(x @comparison:13:52, y @comparison:13:55, ?tmp#0 @comparison:13:30)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @comparison:13:5)}
Types: Unifying move argument types tmp#0 and ?#result @comparison:13:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @comparison:13:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.comparison, y::wybe.comparison}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.comparison, y::wybe.comparison}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @comparison:13:52
Types:   Type = wybe.comparison
Types: Finding type of expr y @comparison:13:55
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0 @comparison:13:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_ule(2 bit unsigned, 2 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @comparison:13:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc <=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_ule(x @comparison:13:52, y @comparison:13:55, ?tmp#0 @comparison:13:30)
Types: Mode checking foreign call {foreign llvm icmp_ule(x @comparison:13:52, y @comparison:13:55, ?tmp#0 @comparison:13:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @comparison:13:52
Types:   Type = wybe.comparison
Types: Finding type of expr y @comparison:13:55
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0 @comparison:13:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.comparison,wybe.comparison,?wybe.bool]
Types: New instr = {foreign llvm icmp_ule(x:wybe.comparison @comparison:13:52, y:wybe.comparison @comparison:13:55, ?tmp#0:wybe.bool @comparison:13:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @comparison:13:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @comparison:13:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @comparison:13:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:13:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<='
Types: Mode checked body   : [{foreign llvm icmp_ule(x:wybe.comparison @comparison:13:52, y:wybe.comparison @comparison:13:55, ?tmp#0:wybe.bool @comparison:13:30)} @comparison:13:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:13:5)} @comparison:13:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <=:
Types: 
Types: <= > public (0 calls)
Types: 4: <=(x:wybe.comparison @comparison:13:10, y:wybe.comparison @comparison:13:18, ?#result:wybe.bool @comparison:13:5):
Types:     foreign llvm icmp_ule(x:wybe.comparison @comparison:13:52, y:wybe.comparison @comparison:13:55, ?tmp#0:wybe.bool @comparison:13:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:13:5)
Types: Type checking non-recursive proc wybe.int.min
Types: ** Type checking decl of proc min
Types: found 1 definition(s)
Types: Type checking min
Types: ** Type checking min: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         <=(x @int:97:31, y @int:97:35)
Types:         foreign llvm move(x @int:97:39, ?tmp#0)
Types:         foreign llvm move(y @int:97:50, ?tmp#0)
Types:         foreign llvm move(tmp#0 @int:97:31, ?#result @int:97:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.int, y:wybe.int, ?#result:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {<=(x @int:97:31, y @int:97:35)}
Types: Recording casts in {foreign llvm move(x @int:97:39, ?tmp#0)}
Types: Unifying move argument types x @int:97:39 and ?tmp#0
Types: Finding type of expr x @int:97:39
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0
Types:   Type = 0
Types: Type variable 0 is bound to Nothing
Types: Unifying types wybe.int (-> wybe.int) and 0 (-> 0)
Types:   Unification yields wybe.int
Types: Recording casts in {foreign llvm move(y @int:97:50, ?tmp#0)}
Types: Unifying move argument types y @int:97:50 and ?tmp#0
Types: Finding type of expr y @int:97:50
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Recording casts in {foreign llvm move(tmp#0 @int:97:31, ?#result @int:97:5)}
Types: Unifying move argument types tmp#0 @int:97:31 and ?#result @int:97:5
Types: Finding type of expr tmp#0 @int:97:31
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:97:5
Types:   Type = wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {<=(x @int:97:31, y @int:97:35)} @int:97:31, typingInfos = [wybe.comparison.<=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Type checking call {<=(x @int:97:31, y @int:97:35)} @int:97:31
Types: Candidate types:
Types:     wybe.comparison.<=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr x @int:97:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:97:35
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.<=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 97, column 31): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 97, column 31): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr x @int:97:39
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr y @int:97:50
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#0 @int:97:31
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:97:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc min
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt if {<=(x @int:97:31, y @int:97:35)::
Types: 
Types:                     foreign llvm move(x @int:97:39, ?tmp#0)
Types:                 else::
Types:                     foreign llvm move(y @int:97:50, ?tmp#0)
Types: 
Types:                 }
Types: Mode checking conditional {if {<=(x @int:97:31, y @int:97:35)::
Types: 
Types:         foreign llvm move(x @int:97:39, ?tmp#0)
Types:     else::
Types:         foreign llvm move(y @int:97:50, ?tmp#0)
Types: 
Types:     }}
Types: Mode checking call   : {<=(x @int:97:31, y @int:97:35)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Finding type of expr x @int:97:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:97:35
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.<=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 97, column 31): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 97, column 31): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Finding type of expr x @int:97:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:97:35
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0><=(x:wybe.int @int:97:31, y:wybe.int @int:97:35)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0><=(x:wybe.int @int:97:31, y:wybe.int @int:97:35)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc 'min'
Types: Assigned by test: semipure test computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(x @int:97:39, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(x @int:97:39, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:97:39
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(x:wybe.int @int:97:39, ?tmp#0:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'min'
Types: Assigned by then branch: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(y @int:97:50, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(y @int:97:50, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr y @int:97:50
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(y:wybe.int @int:97:50, ?tmp#0:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'min'
Types: Assigned by else branch: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Type variable 0 is bound to Just wybe.int
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0 @int:97:31, ?#result @int:97:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0 @int:97:31, ?#result @int:97:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0 @int:97:31
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:97:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int @int:97:31, ?#result:wybe.int @int:97:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'min'
Types: Mode checked body   : [{if {wybe.int.<0><=(x:wybe.int @int:97:31, y:wybe.int @int:97:35)::
Types: 
Types:         foreign llvm move(x:wybe.int @int:97:39, ?tmp#0:wybe.int)
Types:     else::
Types:         foreign llvm move(y:wybe.int @int:97:50, ?tmp#0:wybe.int)
Types: 
Types:     }
Types:    condition -> {x::wybe.int, y::wybe.int}
Types:    then&else -> {tmp#0::wybe.int, x::wybe.int, y::wybe.int}} @int:97:31,{foreign llvm move(tmp#0:wybe.int @int:97:31, ?#result:wybe.int @int:97:5)} @int:97:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of min:
Types: 
Types: min > public (0 calls)
Types: 4: min(x:wybe.int @int:97:13, y:wybe.int @int:97:18, ?#result:wybe.int @int:97:5):
Types:     if {wybe.int.<0><=(x:wybe.int @int:97:31, y:wybe.int @int:97:35)::
Types: 
Types:         foreign llvm move(x:wybe.int @int:97:39, ?tmp#0:wybe.int)
Types:     else::
Types:         foreign llvm move(y:wybe.int @int:97:50, ?tmp#0:wybe.int)
Types: 
Types:     }
Types:    condition -> {x::wybe.int, y::wybe.int}
Types:    then&else -> {tmp#0::wybe.int, x::wybe.int, y::wybe.int}
Types:     foreign llvm move(tmp#0:wybe.int @int:97:31, ?#result:wybe.int @int:97:5)
Types: Type checking non-recursive proc wybe.comparison.<
Types: ** Type checking decl of proc <
Types: found 1 definition(s)
Types: Type checking <
Types: ** Type checking <: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_ult(x @comparison:12:51, y @comparison:12:54, ?tmp#0 @comparison:12:29)
Types:         foreign llvm move(tmp#0, ?#result @comparison:12:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.comparison, y:wybe.comparison, ?#result:wybe.bool
Types:     type of 'x' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable x type constrained to wybe.comparison
Types:     type of 'y' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable y type constrained to wybe.comparison
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_ult(x @comparison:12:51, y @comparison:12:54, ?tmp#0 @comparison:12:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @comparison:12:5)}
Types: Unifying move argument types tmp#0 and ?#result @comparison:12:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @comparison:12:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.comparison, y::wybe.comparison}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.comparison, y::wybe.comparison}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @comparison:12:51
Types:   Type = wybe.comparison
Types: Finding type of expr y @comparison:12:54
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0 @comparison:12:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_ult(2 bit unsigned, 2 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @comparison:12:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc <
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_ult(x @comparison:12:51, y @comparison:12:54, ?tmp#0 @comparison:12:29)
Types: Mode checking foreign call {foreign llvm icmp_ult(x @comparison:12:51, y @comparison:12:54, ?tmp#0 @comparison:12:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @comparison:12:51
Types:   Type = wybe.comparison
Types: Finding type of expr y @comparison:12:54
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0 @comparison:12:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.comparison,wybe.comparison,?wybe.bool]
Types: New instr = {foreign llvm icmp_ult(x:wybe.comparison @comparison:12:51, y:wybe.comparison @comparison:12:54, ?tmp#0:wybe.bool @comparison:12:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @comparison:12:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @comparison:12:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @comparison:12:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:12:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<'
Types: Mode checked body   : [{foreign llvm icmp_ult(x:wybe.comparison @comparison:12:51, y:wybe.comparison @comparison:12:54, ?tmp#0:wybe.bool @comparison:12:29)} @comparison:12:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:12:5)} @comparison:12:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <:
Types: 
Types: < > public (0 calls)
Types: 4: <(x:wybe.comparison @comparison:12:10, y:wybe.comparison @comparison:12:17, ?#result:wybe.bool @comparison:12:5):
Types:     foreign llvm icmp_ult(x:wybe.comparison @comparison:12:51, y:wybe.comparison @comparison:12:54, ?tmp#0:wybe.bool @comparison:12:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:12:5)
Types: Type checking non-recursive proc wybe.char.~=
Types: ** Type checking decl of proc ~=
Types: found 1 definition(s)
Types: Type checking ~=
Types: ** Type checking ~=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_ne(x @char:14:51, y @char:14:54, ?tmp#0 @char:14:30)
Types:         foreign llvm move(tmp#0, ?#result @char:14:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.char, y:wybe.char, ?#result:wybe.bool
Types:     type of 'x' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable x type constrained to wybe.char
Types:     type of 'y' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable y type constrained to wybe.char
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_ne(x @char:14:51, y @char:14:54, ?tmp#0 @char:14:30)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @char:14:5)}
Types: Unifying move argument types tmp#0 and ?#result @char:14:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @char:14:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.char, y::wybe.char}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.char, y::wybe.char}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @char:14:51
Types:   Type = wybe.char
Types: Finding type of expr y @char:14:54
Types:   Type = wybe.char
Types: Finding type of expr ?tmp#0 @char:14:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_ne(8 bit unsigned, 8 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @char:14:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc ~=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_ne(x @char:14:51, y @char:14:54, ?tmp#0 @char:14:30)
Types: Mode checking foreign call {foreign llvm icmp_ne(x @char:14:51, y @char:14:54, ?tmp#0 @char:14:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @char:14:51
Types:   Type = wybe.char
Types: Finding type of expr y @char:14:54
Types:   Type = wybe.char
Types: Finding type of expr ?tmp#0 @char:14:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.char,wybe.char,?wybe.bool]
Types: New instr = {foreign llvm icmp_ne(x:wybe.char @char:14:51, y:wybe.char @char:14:54, ?tmp#0:wybe.bool @char:14:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @char:14:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @char:14:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @char:14:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:14:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '~='
Types: Mode checked body   : [{foreign llvm icmp_ne(x:wybe.char @char:14:51, y:wybe.char @char:14:54, ?tmp#0:wybe.bool @char:14:30)} @char:14:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:14:5)} @char:14:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of ~=:
Types: 
Types: ~= > public (0 calls)
Types: 4: ~=(x:wybe.char @char:14:10, y:wybe.char @char:14:18, ?#result:wybe.bool @char:14:5):
Types:     foreign llvm icmp_ne(x:wybe.char @char:14:51, y:wybe.char @char:14:54, ?tmp#0:wybe.bool @char:14:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:14:5)
Types: Type checking non-recursive proc wybe.char.read
Types: ** Type checking decl of proc read
Types: found 1 definition(s)
Types: Type checking read
Types: ** Type checking read: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         foreign c read_char(?x @char:41:51, !io @char:41:55)
Types:    and defaults: 
Types:    with assigned vars: fromList ["io","x"]
Types: Recording parameter types: ?x:wybe.char
Types:     type of 'x' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable x type constrained to wybe.char
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {foreign c read_char(?x @char:41:51, !io @char:41:55)}
Types: *** Before calls Typing {io::wybe.phantom, x::wybe.char}; {} (with no errors)
Types:   With calls:
Types:   Typing {io::wybe.phantom, x::wybe.char}; {} (with no errors)
Types: Finding type of expr ?x @char:41:51
Types:   Type = wybe.char
Types: Finding type of expr !io @char:41:55
Types:   Type = wybe.phantom
Types: Type checking foreign c call read_char(8 bit unsigned)
Types: Now mode checking proc read
Types: bound vars: semipure normal (total) computation binding {io}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt foreign c read_char(?x @char:41:51, !io @char:41:55)
Types: Mode checking foreign call {foreign c read_char(?x @char:41:51, !io @char:41:55)}
Types:     with assigned semipure normal (total) computation binding {io}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp !io
Types: Mode check exp resulted in !io
Types: Finding type of expr ?x @char:41:51
Types:   Type = wybe.char
Types: Finding type of expr !io @char:41:55
Types:   Type = wybe.phantom
Types:     types and modes = [?wybe.char,!wybe.phantom]
Types: New instr = {foreign c read_char(?x:wybe.char @char:41:51, !io:wybe.phantom @char:41:55)}
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'read'
Types: Mode checked body   : [{foreign c read_char(?x:wybe.char @char:41:51, !io:wybe.phantom @char:41:55)} @char:41:30]
Types: Vars defined by body: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : x
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of read:
Types: 
Types: read > public (0 calls)
Types: 4: read(?x:wybe.char @char:41:15) use !wybe.io.io:
Types:     foreign c read_char(?x:wybe.char @char:41:51, !io:wybe.phantom @char:41:55)
Types: Type checking non-recursive proc wybe.char.print
Types: ** Type checking decl of proc print
Types: found 1 definition(s)
Types: Type checking print
Types: ** Type checking print: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         foreign c putchar(x @char:37:48, !io @char:37:52)
Types:    and defaults: 
Types:    with assigned vars: fromList ["io","x"]
Types: Recording parameter types: x:wybe.char
Types:     type of 'x' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable x type constrained to wybe.char
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {foreign c putchar(x @char:37:48, !io @char:37:52)}
Types: *** Before calls Typing {io::wybe.phantom, x::wybe.char}; {} (with no errors)
Types:   With calls:
Types:   Typing {io::wybe.phantom, x::wybe.char}; {} (with no errors)
Types: Finding type of expr x @char:37:48
Types:   Type = wybe.char
Types: Finding type of expr !io @char:37:52
Types:   Type = wybe.phantom
Types: Type checking foreign c call putchar(8 bit unsigned)
Types: Now mode checking proc print
Types: bound vars: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt foreign c putchar(x @char:37:48, !io @char:37:52)
Types: Mode checking foreign call {foreign c putchar(x @char:37:48, !io @char:37:52)}
Types:     with assigned semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp !io
Types: Mode check exp resulted in !io
Types: Finding type of expr x @char:37:48
Types:   Type = wybe.char
Types: Finding type of expr !io @char:37:52
Types:   Type = wybe.phantom
Types:     types and modes = [wybe.char,!wybe.phantom]
Types: New instr = {foreign c putchar(x:wybe.char @char:37:48, !io:wybe.phantom @char:37:52)}
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'print'
Types: Mode checked body   : [{foreign c putchar(x:wybe.char @char:37:48, !io:wybe.phantom @char:37:52)} @char:37:30]
Types: Vars defined by body: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : 
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of print:
Types: 
Types: print > public (0 calls)
Types: 4: print(x:wybe.char @char:37:15) use !wybe.io.io:
Types:     foreign c putchar(x:wybe.char @char:37:48, !io:wybe.phantom @char:37:52)
Types: Type checking non-recursive proc wybe.char.ord
Types: ** Type checking decl of proc ord
Types: found 1 definition(s)
Types: Type checking ord
Types: ** Type checking ord: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm cast(c @char:30:42, ?tmp#0 @char:30:24)
Types:         foreign llvm move(tmp#0, ?#result @char:30:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","c","tmp#0"]
Types: Recording parameter types: c:wybe.char, ?#result:wybe.int
Types:     type of 'c' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable c type constrained to wybe.char
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm cast(c @char:30:42, ?tmp#0 @char:30:24)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @char:30:5)}
Types: Unifying move argument types tmp#0 and ?#result @char:30:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @char:30:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, c::wybe.char, tmp#0::0}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.int, c::wybe.char, tmp#0::0}; {0::wybe.int} (with no errors)
Types: Finding type of expr c @char:30:42
Types:   Type = wybe.char
Types: Finding type of expr ?tmp#0 @char:30:24
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign lpvm call cast(8 bit unsigned, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @char:30:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc ord
Types: bound vars: semipure normal (total) computation binding {c}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm cast(c @char:30:42, ?tmp#0 @char:30:24)
Types: Mode checking foreign call {foreign lpvm cast(c @char:30:42, ?tmp#0 @char:30:24)}
Types:     with assigned semipure normal (total) computation binding {c}, break set = Everything, with resources {}
Types: Mode check exp c
Types: Mode check exp resulted in c
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr c @char:30:42
Types:   Type = wybe.char
Types: Finding type of expr ?tmp#0 @char:30:24
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.char,?wybe.int]
Types: New instr = {foreign lpvm cast(c:wybe.char @char:30:42, ?tmp#0:wybe.int @char:30:24)}
Types: Now assigned = semipure normal (total) computation binding {c, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @char:30:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @char:30:5)}
Types:     with assigned semipure normal (total) computation binding {c, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @char:30:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @char:30:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, c, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'ord'
Types: Mode checked body   : [{foreign lpvm cast(c:wybe.char @char:30:42, ?tmp#0:wybe.int @char:30:24)} @char:30:24,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @char:30:5)} @char:30:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, c, tmp#0}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of ord:
Types: 
Types: ord > public (0 calls)
Types: 4: ord(c:wybe.char @char:30:13, ?#result:wybe.int @char:30:5):
Types:     foreign lpvm cast(c:wybe.char @char:30:42, ?tmp#0:wybe.int @char:30:24)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @char:30:5)
Types: Type checking non-recursive proc wybe.char.>=
Types: ** Type checking decl of proc >=
Types: found 1 definition(s)
Types: Type checking >=
Types: ** Type checking >=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_uge(x @char:20:52, y @char:20:55, ?tmp#0 @char:20:30)
Types:         foreign llvm move(tmp#0, ?#result @char:20:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.char, y:wybe.char, ?#result:wybe.bool
Types:     type of 'x' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable x type constrained to wybe.char
Types:     type of 'y' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable y type constrained to wybe.char
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(x @char:20:52, y @char:20:55, ?tmp#0 @char:20:30)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @char:20:5)}
Types: Unifying move argument types tmp#0 and ?#result @char:20:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @char:20:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.char, y::wybe.char}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.char, y::wybe.char}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @char:20:52
Types:   Type = wybe.char
Types: Finding type of expr y @char:20:55
Types:   Type = wybe.char
Types: Finding type of expr ?tmp#0 @char:20:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(8 bit unsigned, 8 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @char:20:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc >=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_uge(x @char:20:52, y @char:20:55, ?tmp#0 @char:20:30)
Types: Mode checking foreign call {foreign llvm icmp_uge(x @char:20:52, y @char:20:55, ?tmp#0 @char:20:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @char:20:52
Types:   Type = wybe.char
Types: Finding type of expr y @char:20:55
Types:   Type = wybe.char
Types: Finding type of expr ?tmp#0 @char:20:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.char,wybe.char,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(x:wybe.char @char:20:52, y:wybe.char @char:20:55, ?tmp#0:wybe.bool @char:20:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @char:20:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @char:20:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @char:20:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:20:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '>='
Types: Mode checked body   : [{foreign llvm icmp_uge(x:wybe.char @char:20:52, y:wybe.char @char:20:55, ?tmp#0:wybe.bool @char:20:30)} @char:20:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:20:5)} @char:20:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of >=:
Types: 
Types: >= > public (0 calls)
Types: 4: >=(x:wybe.char @char:20:10, y:wybe.char @char:20:18, ?#result:wybe.bool @char:20:5):
Types:     foreign llvm icmp_uge(x:wybe.char @char:20:52, y:wybe.char @char:20:55, ?tmp#0:wybe.bool @char:20:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:20:5)
Types: Type checking non-recursive proc wybe.char.>
Types: ** Type checking decl of proc >
Types: found 1 definition(s)
Types: Type checking >
Types: ** Type checking >: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_ugt(x @char:19:51, y @char:19:54, ?tmp#0 @char:19:29)
Types:         foreign llvm move(tmp#0, ?#result @char:19:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.char, y:wybe.char, ?#result:wybe.bool
Types:     type of 'x' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable x type constrained to wybe.char
Types:     type of 'y' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable y type constrained to wybe.char
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_ugt(x @char:19:51, y @char:19:54, ?tmp#0 @char:19:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @char:19:5)}
Types: Unifying move argument types tmp#0 and ?#result @char:19:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @char:19:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.char, y::wybe.char}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.char, y::wybe.char}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @char:19:51
Types:   Type = wybe.char
Types: Finding type of expr y @char:19:54
Types:   Type = wybe.char
Types: Finding type of expr ?tmp#0 @char:19:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_ugt(8 bit unsigned, 8 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @char:19:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc >
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_ugt(x @char:19:51, y @char:19:54, ?tmp#0 @char:19:29)
Types: Mode checking foreign call {foreign llvm icmp_ugt(x @char:19:51, y @char:19:54, ?tmp#0 @char:19:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @char:19:51
Types:   Type = wybe.char
Types: Finding type of expr y @char:19:54
Types:   Type = wybe.char
Types: Finding type of expr ?tmp#0 @char:19:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.char,wybe.char,?wybe.bool]
Types: New instr = {foreign llvm icmp_ugt(x:wybe.char @char:19:51, y:wybe.char @char:19:54, ?tmp#0:wybe.bool @char:19:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @char:19:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @char:19:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @char:19:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:19:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '>'
Types: Mode checked body   : [{foreign llvm icmp_ugt(x:wybe.char @char:19:51, y:wybe.char @char:19:54, ?tmp#0:wybe.bool @char:19:29)} @char:19:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:19:5)} @char:19:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of >:
Types: 
Types: > > public (0 calls)
Types: 4: >(x:wybe.char @char:19:10, y:wybe.char @char:19:17, ?#result:wybe.bool @char:19:5):
Types:     foreign llvm icmp_ugt(x:wybe.char @char:19:51, y:wybe.char @char:19:54, ?tmp#0:wybe.bool @char:19:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:19:5)
Types: Type checking non-recursive proc wybe.char.=
Types: ** Type checking decl of proc =
Types: found 1 definition(s)
Types: Type checking =
Types: ** Type checking =: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_eq(x @char:13:50, y @char:13:53, ?tmp#0 @char:13:29)
Types:         foreign llvm move(tmp#0, ?#result @char:13:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.char, y:wybe.char, ?#result:wybe.bool
Types:     type of 'x' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable x type constrained to wybe.char
Types:     type of 'y' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable y type constrained to wybe.char
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_eq(x @char:13:50, y @char:13:53, ?tmp#0 @char:13:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @char:13:5)}
Types: Unifying move argument types tmp#0 and ?#result @char:13:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @char:13:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.char, y::wybe.char}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.char, y::wybe.char}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @char:13:50
Types:   Type = wybe.char
Types: Finding type of expr y @char:13:53
Types:   Type = wybe.char
Types: Finding type of expr ?tmp#0 @char:13:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(8 bit unsigned, 8 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @char:13:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc =
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(x @char:13:50, y @char:13:53, ?tmp#0 @char:13:29)
Types: Mode checking foreign call {foreign llvm icmp_eq(x @char:13:50, y @char:13:53, ?tmp#0 @char:13:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @char:13:50
Types:   Type = wybe.char
Types: Finding type of expr y @char:13:53
Types:   Type = wybe.char
Types: Finding type of expr ?tmp#0 @char:13:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.char,wybe.char,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(x:wybe.char @char:13:50, y:wybe.char @char:13:53, ?tmp#0:wybe.bool @char:13:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @char:13:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @char:13:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @char:13:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:13:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '='
Types: Mode checked body   : [{foreign llvm icmp_eq(x:wybe.char @char:13:50, y:wybe.char @char:13:53, ?tmp#0:wybe.bool @char:13:29)} @char:13:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:13:5)} @char:13:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of =:
Types: 
Types: = > public (0 calls)
Types: 4: =(x:wybe.char @char:13:10, y:wybe.char @char:13:17, ?#result:wybe.bool @char:13:5):
Types:     foreign llvm icmp_eq(x:wybe.char @char:13:50, y:wybe.char @char:13:53, ?tmp#0:wybe.bool @char:13:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:13:5)
Types: Type checking non-recursive proc wybe.io.
Types: ** Type checking decl of proc 
Types: found 1 definition(s)
Types: Type checking module top-level code
Types: ** Type checking module top-level code: Typing {}; {} (with no errors)
Types:    with resources: fromList [?wybe.io.io]
Types:    containing calls: 
Types:         =(?io @io:13:5, 0:phantom @io:13:27)
Types:    and defaults: 
Types:    with assigned vars: fromList ["io"]
Types: Recording parameter types: 
Types: Recording resource types: ?wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {=(?io @io:13:5, 0:phantom @io:13:27)}
Types: *** Before calls Typing {io::wybe.phantom}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {=(?io @io:13:5, 0:phantom @io:13:27)} @io:13:5, typingInfos = [wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool)]}Typing {io::wybe.phantom}; {} (with no errors)
Types: Type checking call {=(?io @io:13:5, 0:phantom @io:13:27)} @io:13:5
Types: Candidate types:
Types:     wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool)
Types: Finding type of expr ?io @io:13:5
Types:   Type = wybe.phantom
Types: Finding type of expr 0:phantom @io:13:27
Types:   Type = wybe.phantom
Types: Actual types: [wybe.phantom,wybe.phantom]
Types: Matching types [wybe.phantom,wybe.phantom] with {test} wybe.char.=<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.phantom (-> wybe.phantom) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/io.wybe" (line 13, column 5): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.phantom (-> wybe.phantom) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/io.wybe" (line 13, column 5): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = []
Types: Trying to check = call as assignment
Types: Unifying types wybe.phantom (-> wybe.phantom) and wybe.phantom (-> wybe.phantom)
Types:   Unification yields wybe.phantom
Types: Now mode checking proc 
Types: bound vars: impure normal (total) computation binding {}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt =(?io @io:13:5, 0:phantom @io:13:27)
Types: Mode checking call   : {=(?io @io:13:5, 0:phantom @io:13:27)}
Types:     with assigned    : impure normal (total) computation binding {}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp ?io
Types: Mode check exp resulted in ?io
Types: Mode check exp 0:phantom
Types: Mode check exp resulted in 0:phantom
Types: Finding type of expr ?io @io:13:5
Types:   Type = wybe.phantom
Types: Finding type of expr 0:phantom @io:13:27
Types:   Type = wybe.phantom
Types:     actual types     : [wybe.phantom,wybe.phantom]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.phantom,wybe.phantom] with {test} wybe.char.=<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.phantom (-> wybe.phantom) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/io.wybe" (line 13, column 5): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.phantom (-> wybe.phantom) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/io.wybe" (line 13, column 5): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : []
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(0:phantom @io:13:27, ?io @io:13:5)}
Types:     with assigned impure normal (total) computation binding {}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp 0:phantom
Types: Mode check exp resulted in 0:phantom
Types: Mode check exp ?io
Types: Mode check exp resulted in ?io
Types: Finding type of expr 0:phantom @io:13:27
Types:   Type = wybe.phantom
Types: Finding type of expr ?io @io:13:5
Types:   Type = wybe.phantom
Types:     types and modes = [wybe.phantom,?wybe.phantom]
Types: New instr = {foreign llvm move(0:wybe.phantom @io:13:27, ?io:wybe.phantom @io:13:5)}
Types: Now assigned = impure normal (total) computation binding {io}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc ''
Types: Mode checked body   : [{foreign llvm move(0:wybe.phantom @io:13:27, ?io:wybe.phantom @io:13:5)} @io:13:5]
Types: Vars defined by body: impure normal (total) computation binding {io}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : 
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of :
Types: 
Types: module top-level code > public {semipure} (0 calls)
Types: 4: () use ?wybe.io.io:
Types:     foreign llvm move(0:wybe.phantom @io:13:27, ?io:wybe.phantom @io:13:5)
Types: Type checking non-recursive proc wybe.char.<=
Types: ** Type checking decl of proc <=
Types: found 1 definition(s)
Types: Type checking <=
Types: ** Type checking <=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_ule(x @char:18:52, y @char:18:55, ?tmp#0 @char:18:30)
Types:         foreign llvm move(tmp#0, ?#result @char:18:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.char, y:wybe.char, ?#result:wybe.bool
Types:     type of 'x' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable x type constrained to wybe.char
Types:     type of 'y' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable y type constrained to wybe.char
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_ule(x @char:18:52, y @char:18:55, ?tmp#0 @char:18:30)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @char:18:5)}
Types: Unifying move argument types tmp#0 and ?#result @char:18:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @char:18:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.char, y::wybe.char}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.char, y::wybe.char}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @char:18:52
Types:   Type = wybe.char
Types: Finding type of expr y @char:18:55
Types:   Type = wybe.char
Types: Finding type of expr ?tmp#0 @char:18:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_ule(8 bit unsigned, 8 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @char:18:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc <=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_ule(x @char:18:52, y @char:18:55, ?tmp#0 @char:18:30)
Types: Mode checking foreign call {foreign llvm icmp_ule(x @char:18:52, y @char:18:55, ?tmp#0 @char:18:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @char:18:52
Types:   Type = wybe.char
Types: Finding type of expr y @char:18:55
Types:   Type = wybe.char
Types: Finding type of expr ?tmp#0 @char:18:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.char,wybe.char,?wybe.bool]
Types: New instr = {foreign llvm icmp_ule(x:wybe.char @char:18:52, y:wybe.char @char:18:55, ?tmp#0:wybe.bool @char:18:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @char:18:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @char:18:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @char:18:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:18:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<='
Types: Mode checked body   : [{foreign llvm icmp_ule(x:wybe.char @char:18:52, y:wybe.char @char:18:55, ?tmp#0:wybe.bool @char:18:30)} @char:18:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:18:5)} @char:18:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <=:
Types: 
Types: <= > public (0 calls)
Types: 4: <=(x:wybe.char @char:18:10, y:wybe.char @char:18:18, ?#result:wybe.bool @char:18:5):
Types:     foreign llvm icmp_ule(x:wybe.char @char:18:52, y:wybe.char @char:18:55, ?tmp#0:wybe.bool @char:18:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:18:5)
Types: Type checking non-recursive proc wybe.char.chr
Types: ** Type checking decl of proc chr
Types: found 1 definition(s)
Types: Type checking chr
Types: ** Type checking chr: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         <=(0 @char:33:60, i @char:33:66)
Types:         <=(i @char:33:70, 255 @char:33:76)
Types:         foreign lpvm cast(i @char:33:49, ?tmp#0 @char:33:31)
Types:         foreign llvm move(tmp#0, ?#result @char:33:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","i","tmp#0"]
Types: Recording parameter types: i:wybe.int, ?#result:wybe.char
Types:     type of 'i' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable i type constrained to wybe.int
Types:     type of '#result' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable #result type constrained to wybe.char
Types: Recording resource types: 
Types: Recording casts in {<=(0 @char:33:60, i @char:33:66)}
Types: Recording casts in {<=(i @char:33:70, 255 @char:33:76)}
Types: Recording casts in {foreign lpvm cast(i @char:33:49, ?tmp#0 @char:33:31)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @char:33:5)}
Types: Unifying move argument types tmp#0 and ?#result @char:33:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @char:33:5
Types:   Type = wybe.char
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: *** Before calls Typing {#result::wybe.char, i::wybe.int, tmp#0::0}; {0::wybe.char} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {<=(0 @char:33:60, i @char:33:66)} @char:33:60, typingInfos = [wybe.char.<=<0>(wybe.char,wybe.char,?wybe.bool),wybe.comparison.<=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {<=(i @char:33:70, 255 @char:33:76)} @char:33:70, typingInfos = [wybe.char.<=<0>(wybe.char,wybe.char,?wybe.bool),wybe.comparison.<=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {#result::wybe.char, i::wybe.int, tmp#0::0}; {0::wybe.char} (with no errors)
Types: Type checking call {<=(0 @char:33:60, i @char:33:66)} @char:33:60
Types: Candidate types:
Types:     wybe.char.<=<0>(wybe.char,wybe.char,?wybe.bool)
Types:     wybe.comparison.<=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr 0 @char:33:60
Types:   Type = wybe.int
Types: Finding type of expr i @char:33:66
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.char.<=<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 33, column 60): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 33, column 60): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.<=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 33, column 60): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 33, column 60): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.char, i::wybe.int, tmp#0::0}; {0::wybe.char} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.char, i::wybe.int, tmp#0::0}; {0::wybe.char} (with no errors)
Types: Type checking call {<=(i @char:33:70, 255 @char:33:76)} @char:33:70
Types: Candidate types:
Types:     wybe.char.<=<0>(wybe.char,wybe.char,?wybe.bool)
Types:     wybe.comparison.<=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr i @char:33:70
Types:   Type = wybe.int
Types: Finding type of expr 255 @char:33:76
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.char.<=<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 33, column 70): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 33, column 70): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.<=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 33, column 70): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 33, column 70): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.char, i::wybe.int, tmp#0::0}; {0::wybe.char} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.char, i::wybe.int, tmp#0::0}; {0::wybe.char} (with no errors)
Types: Finding type of expr i @char:33:49
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @char:33:31
Types: Type variable 0 is bound to Just wybe.char
Types:   Type = wybe.char
Types: Type checking foreign lpvm call cast(64 bit signed, 8 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.char
Types:   Type = wybe.char
Types: Finding type of expr ?#result @char:33:5
Types:   Type = wybe.char
Types: Type checking foreign llvm call move(8 bit unsigned, 8 bit unsigned)
Types: Now mode checking proc chr
Types: bound vars: semipure normal (total) computation binding {i}, break set = Everything, with resources {}
Types: Mode check stmt <=(0 @char:33:60, i @char:33:66)
Types: Mode checking call   : {<=(0 @char:33:60, i @char:33:66)}
Types:     with assigned    : semipure normal (total) computation binding {i}, break set = Everything, with resources {}
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp i
Types: Mode check exp resulted in i
Types: Finding type of expr 0 @char:33:60
Types:   Type = wybe.int
Types: Finding type of expr i @char:33:66
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.char.<=<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 33, column 60): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 33, column 60): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.<=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 33, column 60): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 33, column 60): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.char, i::wybe.int, tmp#0::0}; {0::wybe.char} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.char, i::wybe.int, tmp#0::0}; {0::wybe.char} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.char, i::wybe.int, tmp#0::0}; {0::wybe.char} (with no errors))]
Types: Finding type of expr 0 @char:33:60
Types:   Type = wybe.int
Types: Finding type of expr i @char:33:66
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0><=(0:wybe.int @char:33:60, i:wybe.int @char:33:66)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"i"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0><=(0:wybe.int @char:33:60, i:wybe.int @char:33:66)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc 'chr'
Types: Now assigned = semipure test computation binding {i}, break set = Everything, with resources {}
Types: Mode check stmt <=(i @char:33:70, 255 @char:33:76)
Types: Mode checking call   : {<=(i @char:33:70, 255 @char:33:76)}
Types:     with assigned    : semipure test computation binding {i}, break set = Everything, with resources {}
Types: Mode check exp i
Types: Mode check exp resulted in i
Types: Mode check exp 255
Types: Mode check exp resulted in 255
Types: Finding type of expr i @char:33:70
Types:   Type = wybe.int
Types: Finding type of expr 255 @char:33:76
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.char.<=<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 33, column 70): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 33, column 70): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.<=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 33, column 70): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 33, column 70): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.char, i::wybe.int, tmp#0::0}; {0::wybe.char} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.char, i::wybe.int, tmp#0::0}; {0::wybe.char} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.char, i::wybe.int, tmp#0::0}; {0::wybe.char} (with no errors))]
Types: Finding type of expr i @char:33:70
Types:   Type = wybe.int
Types: Finding type of expr 255 @char:33:76
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0><=(i:wybe.int @char:33:70, 255:wybe.int @char:33:76)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"i"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0><=(i:wybe.int @char:33:70, 255:wybe.int @char:33:76)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc 'chr'
Types: Now assigned = semipure test computation binding {i}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm cast(i @char:33:49, ?tmp#0 @char:33:31)
Types: Mode checking foreign call {foreign lpvm cast(i @char:33:49, ?tmp#0 @char:33:31)}
Types:     with assigned semipure test computation binding {i}, break set = Everything, with resources {}
Types: Mode check exp i
Types: Mode check exp resulted in i
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr i @char:33:49
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @char:33:31
Types: Type variable 0 is bound to Just wybe.char
Types:   Type = wybe.char
Types:     types and modes = [wybe.int,?wybe.char]
Types: New instr = {foreign lpvm cast(i:wybe.int @char:33:49, ?tmp#0:wybe.char @char:33:31)}
Types: Now assigned = semipure test computation binding {i, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @char:33:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @char:33:5)}
Types:     with assigned semipure test computation binding {i, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.char
Types:   Type = wybe.char
Types: Finding type of expr ?#result @char:33:5
Types:   Type = wybe.char
Types:     types and modes = [wybe.char,?wybe.char]
Types: New instr = {foreign llvm move(tmp#0:wybe.char, ?#result:wybe.char @char:33:5)}
Types: Now assigned = semipure test computation binding {#result, i, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'chr'
Types: Mode checked body   : [{wybe.int.<0><=(0:wybe.int @char:33:60, i:wybe.int @char:33:66)} @char:33:60,{wybe.int.<0><=(i:wybe.int @char:33:70, 255:wybe.int @char:33:76)} @char:33:70,{foreign lpvm cast(i:wybe.int @char:33:49, ?tmp#0:wybe.char @char:33:31)} @char:33:31,{foreign llvm move(tmp#0:wybe.char, ?#result:wybe.char @char:33:5)} @char:33:5]
Types: Vars defined by body: semipure test computation binding {#result, i, tmp#0}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of chr:
Types: 
Types: chr > public {test} (0 calls)
Types: 4: chr(i:wybe.int @char:33:20, ?#result:wybe.char @char:33:5):
Types:     wybe.int.<0><=(0:wybe.int @char:33:60, i:wybe.int @char:33:66)
Types:     wybe.int.<0><=(i:wybe.int @char:33:70, 255:wybe.int @char:33:76)
Types:     foreign lpvm cast(i:wybe.int @char:33:49, ?tmp#0:wybe.char @char:33:31)
Types:     foreign llvm move(tmp#0:wybe.char, ?#result:wybe.char @char:33:5)
Types: Type checking non-recursive proc wybe.char.<
Types: ** Type checking decl of proc <
Types: found 1 definition(s)
Types: Type checking <
Types: ** Type checking <: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_ult(x @char:17:51, y @char:17:54, ?tmp#0 @char:17:29)
Types:         foreign llvm move(tmp#0, ?#result @char:17:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.char, y:wybe.char, ?#result:wybe.bool
Types:     type of 'x' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable x type constrained to wybe.char
Types:     type of 'y' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable y type constrained to wybe.char
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_ult(x @char:17:51, y @char:17:54, ?tmp#0 @char:17:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @char:17:5)}
Types: Unifying move argument types tmp#0 and ?#result @char:17:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @char:17:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.char, y::wybe.char}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.char, y::wybe.char}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @char:17:51
Types:   Type = wybe.char
Types: Finding type of expr y @char:17:54
Types:   Type = wybe.char
Types: Finding type of expr ?tmp#0 @char:17:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_ult(8 bit unsigned, 8 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @char:17:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc <
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_ult(x @char:17:51, y @char:17:54, ?tmp#0 @char:17:29)
Types: Mode checking foreign call {foreign llvm icmp_ult(x @char:17:51, y @char:17:54, ?tmp#0 @char:17:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @char:17:51
Types:   Type = wybe.char
Types: Finding type of expr y @char:17:54
Types:   Type = wybe.char
Types: Finding type of expr ?tmp#0 @char:17:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.char,wybe.char,?wybe.bool]
Types: New instr = {foreign llvm icmp_ult(x:wybe.char @char:17:51, y:wybe.char @char:17:54, ?tmp#0:wybe.bool @char:17:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @char:17:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @char:17:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @char:17:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:17:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<'
Types: Mode checked body   : [{foreign llvm icmp_ult(x:wybe.char @char:17:51, y:wybe.char @char:17:54, ?tmp#0:wybe.bool @char:17:29)} @char:17:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:17:5)} @char:17:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <:
Types: 
Types: < > public (0 calls)
Types: 4: <(x:wybe.char @char:17:10, y:wybe.char @char:17:17, ?#result:wybe.bool @char:17:5):
Types:     foreign llvm icmp_ult(x:wybe.char @char:17:51, y:wybe.char @char:17:54, ?tmp#0:wybe.bool @char:17:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:17:5)
Types: Type checking non-recursive proc wybe.c_string.unsafe_c_string_index
Types: ** Type checking decl of proc unsafe_c_string_index
Types: found 1 definition(s)
Types: Type checking unsafe_c_string_index
Types: ** Type checking unsafe_c_string_index: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm access(str @c_string:33:27, idx @c_string:33:32, 1 @c_string:33:37, 0 @c_string:33:40, ?tmp#0 @c_string:33:7)
Types:         foreign llvm move(tmp#0, ?#result @c_string:32:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","idx","str","tmp#0"]
Types: Recording parameter types: str:wybe.c_string, idx:wybe.int, ?#result:wybe.char
Types:     type of 'str' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable str type constrained to wybe.c_string
Types:     type of 'idx' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable idx type constrained to wybe.int
Types:     type of '#result' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable #result type constrained to wybe.char
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm access(str @c_string:33:27, idx @c_string:33:32, 1 @c_string:33:37, 0 @c_string:33:40, ?tmp#0 @c_string:33:7)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @c_string:32:5)}
Types: Unifying move argument types tmp#0 and ?#result @c_string:32:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @c_string:32:5
Types:   Type = wybe.char
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: *** Before calls Typing {#result::wybe.char, idx::wybe.int, str::wybe.c_string, tmp#0::0}; {0::wybe.char} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.char, idx::wybe.int, str::wybe.c_string, tmp#0::0}; {0::wybe.char} (with no errors)
Types: Finding type of expr str @c_string:33:27
Types:   Type = wybe.c_string
Types: Finding type of expr idx @c_string:33:32
Types:   Type = wybe.int
Types: Finding type of expr 1 @c_string:33:37
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:33:40
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:33:7
Types: Type variable 0 is bound to Just wybe.char
Types:   Type = wybe.char
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, 8 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.char
Types:   Type = wybe.char
Types: Finding type of expr ?#result @c_string:32:5
Types:   Type = wybe.char
Types: Type checking foreign llvm call move(8 bit unsigned, 8 bit unsigned)
Types: Now mode checking proc unsafe_c_string_index
Types: bound vars: semipure normal (total) computation binding {idx, str}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(str @c_string:33:27, idx @c_string:33:32, 1 @c_string:33:37, 0 @c_string:33:40, ?tmp#0 @c_string:33:7)
Types: Mode checking foreign call {foreign lpvm access(str @c_string:33:27, idx @c_string:33:32, 1 @c_string:33:37, 0 @c_string:33:40, ?tmp#0 @c_string:33:7)}
Types:     with assigned semipure normal (total) computation binding {idx, str}, break set = Everything, with resources {}
Types: Mode check exp str
Types: Mode check exp resulted in str
Types: Mode check exp idx
Types: Mode check exp resulted in idx
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr str @c_string:33:27
Types:   Type = wybe.c_string
Types: Finding type of expr idx @c_string:33:32
Types:   Type = wybe.int
Types: Finding type of expr 1 @c_string:33:37
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:33:40
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:33:7
Types: Type variable 0 is bound to Just wybe.char
Types:   Type = wybe.char
Types:     types and modes = [wybe.c_string,wybe.int,wybe.int,wybe.int,?wybe.char]
Types: New instr = {foreign lpvm access(str:wybe.c_string @c_string:33:27, idx:wybe.int @c_string:33:32, 1:wybe.int @c_string:33:37, 0:wybe.int @c_string:33:40, ?tmp#0:wybe.char @c_string:33:7)}
Types: Now assigned = semipure normal (total) computation binding {idx, str, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @c_string:32:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @c_string:32:5)}
Types:     with assigned semipure normal (total) computation binding {idx, str, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.char
Types:   Type = wybe.char
Types: Finding type of expr ?#result @c_string:32:5
Types:   Type = wybe.char
Types:     types and modes = [wybe.char,?wybe.char]
Types: New instr = {foreign llvm move(tmp#0:wybe.char, ?#result:wybe.char @c_string:32:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, idx, str, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'unsafe_c_string_index'
Types: Mode checked body   : [{foreign lpvm access(str:wybe.c_string @c_string:33:27, idx:wybe.int @c_string:33:32, 1:wybe.int @c_string:33:37, 0:wybe.int @c_string:33:40, ?tmp#0:wybe.char @c_string:33:7)} @c_string:33:7,{foreign llvm move(tmp#0:wybe.char, ?#result:wybe.char @c_string:32:5)} @c_string:32:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, idx, str, tmp#0}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of unsafe_c_string_index:
Types: 
Types: unsafe_c_string_index > public (0 calls)
Types: 4: unsafe_c_string_index(str:wybe.c_string @c_string:32:31, idx:wybe.int @c_string:32:38, ?#result:wybe.char @c_string:32:5):
Types:     foreign lpvm access(str:wybe.c_string @c_string:33:27, idx:wybe.int @c_string:33:32, 1:wybe.int @c_string:33:37, 0:wybe.int @c_string:33:40, ?tmp#0:wybe.char @c_string:33:7)
Types:     foreign llvm move(tmp#0:wybe.char, ?#result:wybe.char @c_string:32:5)
Types: Type checking non-recursive proc wybe.c_string.read
Types: ** Type checking decl of proc read
Types: found 1 definition(s)
Types: Type checking read
Types: ** Type checking read: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         foreign c read_line(?x @c_string:39:51, !io @c_string:39:55)
Types:    and defaults: 
Types:    with assigned vars: fromList ["io","x"]
Types: Recording parameter types: ?x:wybe.c_string
Types:     type of 'x' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable x type constrained to wybe.c_string
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {foreign c read_line(?x @c_string:39:51, !io @c_string:39:55)}
Types: *** Before calls Typing {io::wybe.phantom, x::wybe.c_string}; {} (with no errors)
Types:   With calls:
Types:   Typing {io::wybe.phantom, x::wybe.c_string}; {} (with no errors)
Types: Finding type of expr ?x @c_string:39:51
Types:   Type = wybe.c_string
Types: Finding type of expr !io @c_string:39:55
Types:   Type = wybe.phantom
Types: Type checking foreign c call read_line(address)
Types: Now mode checking proc read
Types: bound vars: semipure normal (total) computation binding {io}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt foreign c read_line(?x @c_string:39:51, !io @c_string:39:55)
Types: Mode checking foreign call {foreign c read_line(?x @c_string:39:51, !io @c_string:39:55)}
Types:     with assigned semipure normal (total) computation binding {io}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp !io
Types: Mode check exp resulted in !io
Types: Finding type of expr ?x @c_string:39:51
Types:   Type = wybe.c_string
Types: Finding type of expr !io @c_string:39:55
Types:   Type = wybe.phantom
Types:     types and modes = [?wybe.c_string,!wybe.phantom]
Types: New instr = {foreign c read_line(?x:wybe.c_string @c_string:39:51, !io:wybe.phantom @c_string:39:55)}
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'read'
Types: Mode checked body   : [{foreign c read_line(?x:wybe.c_string @c_string:39:51, !io:wybe.phantom @c_string:39:55)} @c_string:39:30]
Types: Vars defined by body: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : x
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of read:
Types: 
Types: read > public (0 calls)
Types: 4: read(?x:wybe.c_string @c_string:39:15) use !wybe.io.io:
Types:     foreign c read_line(?x:wybe.c_string @c_string:39:51, !io:wybe.phantom @c_string:39:55)
Types: Type checking non-recursive proc wybe.c_string.print
Types: ** Type checking decl of proc print
Types: found 1 definition(s)
Types: Type checking print
Types: ** Type checking print: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         foreign c print_string(x @c_string:35:53, !io @c_string:35:57)
Types:    and defaults: 
Types:    with assigned vars: fromList ["io","x"]
Types: Recording parameter types: x:wybe.c_string
Types:     type of 'x' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable x type constrained to wybe.c_string
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {foreign c print_string(x @c_string:35:53, !io @c_string:35:57)}
Types: *** Before calls Typing {io::wybe.phantom, x::wybe.c_string}; {} (with no errors)
Types:   With calls:
Types:   Typing {io::wybe.phantom, x::wybe.c_string}; {} (with no errors)
Types: Finding type of expr x @c_string:35:53
Types:   Type = wybe.c_string
Types: Finding type of expr !io @c_string:35:57
Types:   Type = wybe.phantom
Types: Type checking foreign c call print_string(address)
Types: Now mode checking proc print
Types: bound vars: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt foreign c print_string(x @c_string:35:53, !io @c_string:35:57)
Types: Mode checking foreign call {foreign c print_string(x @c_string:35:53, !io @c_string:35:57)}
Types:     with assigned semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp !io
Types: Mode check exp resulted in !io
Types: Finding type of expr x @c_string:35:53
Types:   Type = wybe.c_string
Types: Finding type of expr !io @c_string:35:57
Types:   Type = wybe.phantom
Types:     types and modes = [wybe.c_string,!wybe.phantom]
Types: New instr = {foreign c print_string(x:wybe.c_string @c_string:35:53, !io:wybe.phantom @c_string:35:57)}
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'print'
Types: Mode checked body   : [{foreign c print_string(x:wybe.c_string @c_string:35:53, !io:wybe.phantom @c_string:35:57)} @c_string:35:30]
Types: Vars defined by body: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : 
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of print:
Types: 
Types: print > public (0 calls)
Types: 4: print(x:wybe.c_string @c_string:35:15) use !wybe.io.io:
Types:     foreign c print_string(x:wybe.c_string @c_string:35:53, !io:wybe.phantom @c_string:35:57)
Types: Type checking non-recursive proc wybe.c_string.length
Types: ** Type checking decl of proc length
Types: found 1 definition(s)
Types: Type checking length
Types: ** Type checking length: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c strlen(str @c_string:17:46, ?tmp#0 @c_string:17:29)
Types:         foreign llvm move(tmp#0, ?#result @c_string:17:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","str","tmp#0"]
Types: Recording parameter types: str:wybe.c_string, ?#result:wybe.int
Types:     type of 'str' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable str type constrained to wybe.c_string
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign c strlen(str @c_string:17:46, ?tmp#0 @c_string:17:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @c_string:17:5)}
Types: Unifying move argument types tmp#0 and ?#result @c_string:17:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @c_string:17:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, str::wybe.c_string, tmp#0::0}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.int, str::wybe.c_string, tmp#0::0}; {0::wybe.int} (with no errors)
Types: Finding type of expr str @c_string:17:46
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#0 @c_string:17:29
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign c call strlen(address, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @c_string:17:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc length
Types: bound vars: semipure normal (total) computation binding {str}, break set = Everything, with resources {}
Types: Mode check stmt foreign c strlen(str @c_string:17:46, ?tmp#0 @c_string:17:29)
Types: Mode checking foreign call {foreign c strlen(str @c_string:17:46, ?tmp#0 @c_string:17:29)}
Types:     with assigned semipure normal (total) computation binding {str}, break set = Everything, with resources {}
Types: Mode check exp str
Types: Mode check exp resulted in str
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr str @c_string:17:46
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#0 @c_string:17:29
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.c_string,?wybe.int]
Types: New instr = {foreign c strlen(str:wybe.c_string @c_string:17:46, ?tmp#0:wybe.int @c_string:17:29)}
Types: Now assigned = semipure normal (total) computation binding {str, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @c_string:17:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @c_string:17:5)}
Types:     with assigned semipure normal (total) computation binding {str, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @c_string:17:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @c_string:17:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, str, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'length'
Types: Mode checked body   : [{foreign c strlen(str:wybe.c_string @c_string:17:46, ?tmp#0:wybe.int @c_string:17:29)} @c_string:17:29,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @c_string:17:5)} @c_string:17:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, str, tmp#0}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of length:
Types: 
Types: length > public (0 calls)
Types: 4: length(str:wybe.c_string @c_string:17:16, ?#result:wybe.int @c_string:17:5):
Types:     foreign c strlen(str:wybe.c_string @c_string:17:46, ?tmp#0:wybe.int @c_string:17:29)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @c_string:17:5)
Types: **** Type checking recursive procs wybe.c_string.>=
Types: ** Type checking decl of proc >=
Types: found 1 definition(s)
Types: Type checking >=
Types: ** Type checking >=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c strcmp(x @c_string:15:47, y @c_string:15:49, ?tmp#1:int @c_string:15:30)
Types:         >=(tmp#1:int, 0 @c_string:15:60, ?tmp#0 @c_string:15:30)
Types:         foreign llvm move(tmp#0, ?#result @c_string:15:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","tmp#1","x","y"]
Types: Recording parameter types: x:wybe.c_string, y:wybe.c_string, ?#result:wybe.bool
Types:     type of 'x' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable x type constrained to wybe.c_string
Types:     type of 'y' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable y type constrained to wybe.c_string
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign c strcmp(x @c_string:15:47, y @c_string:15:49, ?tmp#1:int @c_string:15:30)}
Types: Unifying types int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable tmp#1 type constrained to wybe.int
Types: Recording casts in {>=(tmp#1:int, 0 @c_string:15:60, ?tmp#0 @c_string:15:30)}
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable tmp#1 type constrained to wybe.int
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @c_string:15:5)}
Types: Unifying move argument types tmp#0 and ?#result @c_string:15:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @c_string:15:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {>=(tmp#1:int, 0 @c_string:15:60, ?tmp#0 @c_string:15:30)} @c_string:15:30, typingInfos = [wybe.c_string.>=<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.>=<0>(wybe.char,wybe.char,?wybe.bool),wybe.int.>=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types: Type checking call {>=(tmp#1:int, 0 @c_string:15:60, ?tmp#0 @c_string:15:30)} @c_string:15:30
Types: Candidate types:
Types:     wybe.c_string.>=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types:     wybe.char.>=<0>(wybe.char,wybe.char,?wybe.bool)
Types:     wybe.int.>=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:15:60
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:15:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Actual types: [wybe.int,wybe.int,wybe.bool]
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.c_string.>=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 15, column 30): Type error in call to >=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 15, column 30): Type error in call to >=, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.char.>=<0>(wybe.char,wybe.char,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 15, column 30): Type error in call to >=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 15, column 30): Type error in call to >=, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.int.>=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Valid types = [Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @c_string:15:47
Types:   Type = wybe.c_string
Types: Finding type of expr y @c_string:15:49
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#1:int @c_string:15:30
Types:   Type = wybe.int
Types: Type checking foreign c call strcmp(address, address, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @c_string:15:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc >=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign c strcmp(x @c_string:15:47, y @c_string:15:49, ?tmp#1:int @c_string:15:30)
Types: Mode checking foreign call {foreign c strcmp(x @c_string:15:47, y @c_string:15:49, ?tmp#1:int @c_string:15:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#1:int
Types: Mode check exp resulted in ?tmp#1:int
Types: Finding type of expr x @c_string:15:47
Types:   Type = wybe.c_string
Types: Finding type of expr y @c_string:15:49
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#1:int @c_string:15:30
Types:   Type = wybe.int
Types:     types and modes = [wybe.c_string,wybe.c_string,?wybe.int]
Types: New instr = {foreign c strcmp(x:wybe.c_string @c_string:15:47, y:wybe.c_string @c_string:15:49, ?tmp#1:wybe.int @c_string:15:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt >=(tmp#1:int, 0 @c_string:15:60, ?tmp#0 @c_string:15:30)
Types: Mode checking call   : {>=(tmp#1:int, 0 @c_string:15:60, ?tmp#0 @c_string:15:30)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#1:int
Types: Mode check exp resulted in tmp#1:int
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:15:60
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:15:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     actual types     : [wybe.int,wybe.int,wybe.bool]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.c_string.>=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 15, column 30): Type error in call to >=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 15, column 30): Type error in call to >=, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.char.>=<0>(wybe.char,wybe.char,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 15, column 30): Type error in call to >=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 15, column 30): Type error in call to >=, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.int.>=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Type-correct modes   : [(wybe.int.>=<0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Possible mode matches: [(wybe.int.>=<0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Exact mode matches: [(wybe.int.>=<0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:15:60
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:15:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finalising call    :  {wybe.int.<0>>=(tmp#1:wybe.int, 0:wybe.int @c_string:15:60, ?tmp#0:wybe.bool @c_string:15:30)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"tmp#1", "x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>>=(tmp#1:wybe.int, 0:wybe.int @c_string:15:60, ?tmp#0:wybe.bool @c_string:15:30)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '>='
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @c_string:15:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @c_string:15:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @c_string:15:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:15:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '>='
Types: Mode checked body   : [{foreign c strcmp(x:wybe.c_string @c_string:15:47, y:wybe.c_string @c_string:15:49, ?tmp#1:wybe.int @c_string:15:30)} @c_string:15:30,{wybe.int.<0>>=(tmp#1:wybe.int, 0:wybe.int @c_string:15:60, ?tmp#0:wybe.bool @c_string:15:30)} @c_string:15:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:15:5)} @c_string:15:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of >=:
Types: 
Types: >= > public (0 calls)
Types: 4: >=(x:wybe.c_string @c_string:15:10, y:wybe.c_string @c_string:15:18, ?#result:wybe.bool @c_string:15:5):
Types:     foreign c strcmp(x:wybe.c_string @c_string:15:47, y:wybe.c_string @c_string:15:49, ?tmp#1:wybe.int @c_string:15:30)
Types:     wybe.int.<0>>=(tmp#1:wybe.int, 0:wybe.int @c_string:15:60, ?tmp#0:wybe.bool @c_string:15:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:15:5)
Types: **** Completed checking of wybe.c_string.>= with 0 errors
Types: **** Type checking recursive procs wybe.c_string.>
Types: ** Type checking decl of proc >
Types: found 1 definition(s)
Types: Type checking >
Types: ** Type checking >: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c strcmp(x @c_string:14:46, y @c_string:14:48, ?tmp#1:int @c_string:14:29)
Types:         >(tmp#1:int, 0 @c_string:14:57, ?tmp#0 @c_string:14:29)
Types:         foreign llvm move(tmp#0, ?#result @c_string:14:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","tmp#1","x","y"]
Types: Recording parameter types: x:wybe.c_string, y:wybe.c_string, ?#result:wybe.bool
Types:     type of 'x' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable x type constrained to wybe.c_string
Types:     type of 'y' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable y type constrained to wybe.c_string
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign c strcmp(x @c_string:14:46, y @c_string:14:48, ?tmp#1:int @c_string:14:29)}
Types: Unifying types int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable tmp#1 type constrained to wybe.int
Types: Recording casts in {>(tmp#1:int, 0 @c_string:14:57, ?tmp#0 @c_string:14:29)}
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable tmp#1 type constrained to wybe.int
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @c_string:14:5)}
Types: Unifying move argument types tmp#0 and ?#result @c_string:14:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @c_string:14:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {>(tmp#1:int, 0 @c_string:14:57, ?tmp#0 @c_string:14:29)} @c_string:14:29, typingInfos = [wybe.c_string.><0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.><0>(wybe.char,wybe.char,?wybe.bool),wybe.int.><0>(wybe.int,wybe.int,?wybe.bool)]}Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types: Type checking call {>(tmp#1:int, 0 @c_string:14:57, ?tmp#0 @c_string:14:29)} @c_string:14:29
Types: Candidate types:
Types:     wybe.c_string.><0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types:     wybe.char.><0>(wybe.char,wybe.char,?wybe.bool)
Types:     wybe.int.><0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:14:57
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:14:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Actual types: [wybe.int,wybe.int,wybe.bool]
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.c_string.><0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 14, column 29): Type error in call to >, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 14, column 29): Type error in call to >, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.char.><0>(wybe.char,wybe.char,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 14, column 29): Type error in call to >, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 14, column 29): Type error in call to >, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.int.><0>(wybe.int,wybe.int,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Valid types = [Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @c_string:14:46
Types:   Type = wybe.c_string
Types: Finding type of expr y @c_string:14:48
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#1:int @c_string:14:29
Types:   Type = wybe.int
Types: Type checking foreign c call strcmp(address, address, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @c_string:14:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc >
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign c strcmp(x @c_string:14:46, y @c_string:14:48, ?tmp#1:int @c_string:14:29)
Types: Mode checking foreign call {foreign c strcmp(x @c_string:14:46, y @c_string:14:48, ?tmp#1:int @c_string:14:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#1:int
Types: Mode check exp resulted in ?tmp#1:int
Types: Finding type of expr x @c_string:14:46
Types:   Type = wybe.c_string
Types: Finding type of expr y @c_string:14:48
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#1:int @c_string:14:29
Types:   Type = wybe.int
Types:     types and modes = [wybe.c_string,wybe.c_string,?wybe.int]
Types: New instr = {foreign c strcmp(x:wybe.c_string @c_string:14:46, y:wybe.c_string @c_string:14:48, ?tmp#1:wybe.int @c_string:14:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt >(tmp#1:int, 0 @c_string:14:57, ?tmp#0 @c_string:14:29)
Types: Mode checking call   : {>(tmp#1:int, 0 @c_string:14:57, ?tmp#0 @c_string:14:29)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#1:int
Types: Mode check exp resulted in tmp#1:int
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:14:57
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:14:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     actual types     : [wybe.int,wybe.int,wybe.bool]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.c_string.><0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 14, column 29): Type error in call to >, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 14, column 29): Type error in call to >, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.char.><0>(wybe.char,wybe.char,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 14, column 29): Type error in call to >, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 14, column 29): Type error in call to >, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.int.><0>(wybe.int,wybe.int,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Type-correct modes   : [(wybe.int.><0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Possible mode matches: [(wybe.int.><0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Exact mode matches: [(wybe.int.><0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:14:57
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:14:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finalising call    :  {wybe.int.<0>>(tmp#1:wybe.int, 0:wybe.int @c_string:14:57, ?tmp#0:wybe.bool @c_string:14:29)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"tmp#1", "x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>>(tmp#1:wybe.int, 0:wybe.int @c_string:14:57, ?tmp#0:wybe.bool @c_string:14:29)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '>'
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @c_string:14:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @c_string:14:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @c_string:14:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:14:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '>'
Types: Mode checked body   : [{foreign c strcmp(x:wybe.c_string @c_string:14:46, y:wybe.c_string @c_string:14:48, ?tmp#1:wybe.int @c_string:14:29)} @c_string:14:29,{wybe.int.<0>>(tmp#1:wybe.int, 0:wybe.int @c_string:14:57, ?tmp#0:wybe.bool @c_string:14:29)} @c_string:14:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:14:5)} @c_string:14:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of >:
Types: 
Types: > > public (0 calls)
Types: 4: >(x:wybe.c_string @c_string:14:10, y:wybe.c_string @c_string:14:17, ?#result:wybe.bool @c_string:14:5):
Types:     foreign c strcmp(x:wybe.c_string @c_string:14:46, y:wybe.c_string @c_string:14:48, ?tmp#1:wybe.int @c_string:14:29)
Types:     wybe.int.<0>>(tmp#1:wybe.int, 0:wybe.int @c_string:14:57, ?tmp#0:wybe.bool @c_string:14:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:14:5)
Types: **** Completed checking of wybe.c_string.> with 0 errors
Types: **** Type checking recursive procs wybe.c_string.<=
Types: ** Type checking decl of proc <=
Types: found 1 definition(s)
Types: Type checking <=
Types: ** Type checking <=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c strcmp(x @c_string:13:47, y @c_string:13:49, ?tmp#1:int @c_string:13:30)
Types:         <=(tmp#1:int, 0 @c_string:13:60, ?tmp#0 @c_string:13:30)
Types:         foreign llvm move(tmp#0, ?#result @c_string:13:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","tmp#1","x","y"]
Types: Recording parameter types: x:wybe.c_string, y:wybe.c_string, ?#result:wybe.bool
Types:     type of 'x' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable x type constrained to wybe.c_string
Types:     type of 'y' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable y type constrained to wybe.c_string
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign c strcmp(x @c_string:13:47, y @c_string:13:49, ?tmp#1:int @c_string:13:30)}
Types: Unifying types int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable tmp#1 type constrained to wybe.int
Types: Recording casts in {<=(tmp#1:int, 0 @c_string:13:60, ?tmp#0 @c_string:13:30)}
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable tmp#1 type constrained to wybe.int
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @c_string:13:5)}
Types: Unifying move argument types tmp#0 and ?#result @c_string:13:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @c_string:13:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {<=(tmp#1:int, 0 @c_string:13:60, ?tmp#0 @c_string:13:30)} @c_string:13:30, typingInfos = [wybe.c_string.<=<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.<=<0>(wybe.char,wybe.char,?wybe.bool),wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types: Type checking call {<=(tmp#1:int, 0 @c_string:13:60, ?tmp#0 @c_string:13:30)} @c_string:13:30
Types: Candidate types:
Types:     wybe.c_string.<=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types:     wybe.char.<=<0>(wybe.char,wybe.char,?wybe.bool)
Types:     wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:13:60
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:13:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Actual types: [wybe.int,wybe.int,wybe.bool]
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.c_string.<=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 13, column 30): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 13, column 30): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.char.<=<0>(wybe.char,wybe.char,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 13, column 30): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 13, column 30): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Valid types = [Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @c_string:13:47
Types:   Type = wybe.c_string
Types: Finding type of expr y @c_string:13:49
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#1:int @c_string:13:30
Types:   Type = wybe.int
Types: Type checking foreign c call strcmp(address, address, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @c_string:13:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc <=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign c strcmp(x @c_string:13:47, y @c_string:13:49, ?tmp#1:int @c_string:13:30)
Types: Mode checking foreign call {foreign c strcmp(x @c_string:13:47, y @c_string:13:49, ?tmp#1:int @c_string:13:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#1:int
Types: Mode check exp resulted in ?tmp#1:int
Types: Finding type of expr x @c_string:13:47
Types:   Type = wybe.c_string
Types: Finding type of expr y @c_string:13:49
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#1:int @c_string:13:30
Types:   Type = wybe.int
Types:     types and modes = [wybe.c_string,wybe.c_string,?wybe.int]
Types: New instr = {foreign c strcmp(x:wybe.c_string @c_string:13:47, y:wybe.c_string @c_string:13:49, ?tmp#1:wybe.int @c_string:13:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt <=(tmp#1:int, 0 @c_string:13:60, ?tmp#0 @c_string:13:30)
Types: Mode checking call   : {<=(tmp#1:int, 0 @c_string:13:60, ?tmp#0 @c_string:13:30)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#1:int
Types: Mode check exp resulted in tmp#1:int
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:13:60
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:13:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     actual types     : [wybe.int,wybe.int,wybe.bool]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.c_string.<=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 13, column 30): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 13, column 30): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.char.<=<0>(wybe.char,wybe.char,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 13, column 30): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 13, column 30): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Type-correct modes   : [(wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Possible mode matches: [(wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Exact mode matches: [(wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:13:60
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:13:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finalising call    :  {wybe.int.<0><=(tmp#1:wybe.int, 0:wybe.int @c_string:13:60, ?tmp#0:wybe.bool @c_string:13:30)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"tmp#1", "x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0><=(tmp#1:wybe.int, 0:wybe.int @c_string:13:60, ?tmp#0:wybe.bool @c_string:13:30)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<='
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @c_string:13:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @c_string:13:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @c_string:13:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:13:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<='
Types: Mode checked body   : [{foreign c strcmp(x:wybe.c_string @c_string:13:47, y:wybe.c_string @c_string:13:49, ?tmp#1:wybe.int @c_string:13:30)} @c_string:13:30,{wybe.int.<0><=(tmp#1:wybe.int, 0:wybe.int @c_string:13:60, ?tmp#0:wybe.bool @c_string:13:30)} @c_string:13:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:13:5)} @c_string:13:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <=:
Types: 
Types: <= > public (0 calls)
Types: 4: <=(x:wybe.c_string @c_string:13:10, y:wybe.c_string @c_string:13:18, ?#result:wybe.bool @c_string:13:5):
Types:     foreign c strcmp(x:wybe.c_string @c_string:13:47, y:wybe.c_string @c_string:13:49, ?tmp#1:wybe.int @c_string:13:30)
Types:     wybe.int.<0><=(tmp#1:wybe.int, 0:wybe.int @c_string:13:60, ?tmp#0:wybe.bool @c_string:13:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:13:5)
Types: **** Completed checking of wybe.c_string.<= with 0 errors
Types: **** Type checking recursive procs wybe.c_string.<
Types: ** Type checking decl of proc <
Types: found 1 definition(s)
Types: Type checking <
Types: ** Type checking <: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c strcmp(x @c_string:12:46, y @c_string:12:48, ?tmp#1:int @c_string:12:29)
Types:         <(tmp#1:int, 0 @c_string:12:57, ?tmp#0 @c_string:12:29)
Types:         foreign llvm move(tmp#0, ?#result @c_string:12:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","tmp#1","x","y"]
Types: Recording parameter types: x:wybe.c_string, y:wybe.c_string, ?#result:wybe.bool
Types:     type of 'x' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable x type constrained to wybe.c_string
Types:     type of 'y' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable y type constrained to wybe.c_string
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign c strcmp(x @c_string:12:46, y @c_string:12:48, ?tmp#1:int @c_string:12:29)}
Types: Unifying types int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable tmp#1 type constrained to wybe.int
Types: Recording casts in {<(tmp#1:int, 0 @c_string:12:57, ?tmp#0 @c_string:12:29)}
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable tmp#1 type constrained to wybe.int
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @c_string:12:5)}
Types: Unifying move argument types tmp#0 and ?#result @c_string:12:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @c_string:12:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {<(tmp#1:int, 0 @c_string:12:57, ?tmp#0 @c_string:12:29)} @c_string:12:29, typingInfos = [wybe.c_string.<<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.<<0>(wybe.char,wybe.char,?wybe.bool),wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types: Type checking call {<(tmp#1:int, 0 @c_string:12:57, ?tmp#0 @c_string:12:29)} @c_string:12:29
Types: Candidate types:
Types:     wybe.c_string.<<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types:     wybe.char.<<0>(wybe.char,wybe.char,?wybe.bool)
Types:     wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:12:57
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:12:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Actual types: [wybe.int,wybe.int,wybe.bool]
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.c_string.<<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 12, column 29): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 12, column 29): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.char.<<0>(wybe.char,wybe.char,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 12, column 29): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 12, column 29): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Valid types = [Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @c_string:12:46
Types:   Type = wybe.c_string
Types: Finding type of expr y @c_string:12:48
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#1:int @c_string:12:29
Types:   Type = wybe.int
Types: Type checking foreign c call strcmp(address, address, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @c_string:12:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc <
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign c strcmp(x @c_string:12:46, y @c_string:12:48, ?tmp#1:int @c_string:12:29)
Types: Mode checking foreign call {foreign c strcmp(x @c_string:12:46, y @c_string:12:48, ?tmp#1:int @c_string:12:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#1:int
Types: Mode check exp resulted in ?tmp#1:int
Types: Finding type of expr x @c_string:12:46
Types:   Type = wybe.c_string
Types: Finding type of expr y @c_string:12:48
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#1:int @c_string:12:29
Types:   Type = wybe.int
Types:     types and modes = [wybe.c_string,wybe.c_string,?wybe.int]
Types: New instr = {foreign c strcmp(x:wybe.c_string @c_string:12:46, y:wybe.c_string @c_string:12:48, ?tmp#1:wybe.int @c_string:12:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt <(tmp#1:int, 0 @c_string:12:57, ?tmp#0 @c_string:12:29)
Types: Mode checking call   : {<(tmp#1:int, 0 @c_string:12:57, ?tmp#0 @c_string:12:29)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#1:int
Types: Mode check exp resulted in tmp#1:int
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:12:57
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:12:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     actual types     : [wybe.int,wybe.int,wybe.bool]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.c_string.<<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 12, column 29): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 12, column 29): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.char.<<0>(wybe.char,wybe.char,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 12, column 29): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 12, column 29): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Type-correct modes   : [(wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Possible mode matches: [(wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Exact mode matches: [(wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:12:57
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:12:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finalising call    :  {wybe.int.<0><(tmp#1:wybe.int, 0:wybe.int @c_string:12:57, ?tmp#0:wybe.bool @c_string:12:29)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"tmp#1", "x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0><(tmp#1:wybe.int, 0:wybe.int @c_string:12:57, ?tmp#0:wybe.bool @c_string:12:29)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<'
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @c_string:12:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @c_string:12:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @c_string:12:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:12:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<'
Types: Mode checked body   : [{foreign c strcmp(x:wybe.c_string @c_string:12:46, y:wybe.c_string @c_string:12:48, ?tmp#1:wybe.int @c_string:12:29)} @c_string:12:29,{wybe.int.<0><(tmp#1:wybe.int, 0:wybe.int @c_string:12:57, ?tmp#0:wybe.bool @c_string:12:29)} @c_string:12:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:12:5)} @c_string:12:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <:
Types: 
Types: < > public (0 calls)
Types: 4: <(x:wybe.c_string @c_string:12:10, y:wybe.c_string @c_string:12:17, ?#result:wybe.bool @c_string:12:5):
Types:     foreign c strcmp(x:wybe.c_string @c_string:12:46, y:wybe.c_string @c_string:12:48, ?tmp#1:wybe.int @c_string:12:29)
Types:     wybe.int.<0><(tmp#1:wybe.int, 0:wybe.int @c_string:12:57, ?tmp#0:wybe.bool @c_string:12:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:12:5)
Types: **** Completed checking of wybe.c_string.< with 0 errors
Types: Type checking non-recursive proc wybe.bool.~=
Types: ** Type checking decl of proc ~=
Types: found 1 definition(s)
Types: Type checking ~=
Types: ** Type checking ~=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_ne(x @bool:38:48, y @bool:38:51, ?tmp#0 @bool:38:27)
Types:         foreign llvm move(tmp#0, ?#result @bool:38:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.bool, y:wybe.bool, ?#result:wybe.bool
Types:     type of 'x' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable x type constrained to wybe.bool
Types:     type of 'y' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable y type constrained to wybe.bool
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_ne(x @bool:38:48, y @bool:38:51, ?tmp#0 @bool:38:27)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @bool:38:5)}
Types: Unifying move argument types tmp#0 and ?#result @bool:38:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @bool:38:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.bool, y::wybe.bool}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.bool, y::wybe.bool}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @bool:38:48
Types:   Type = wybe.bool
Types: Finding type of expr y @bool:38:51
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:38:27
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_ne(1 bit unsigned, 1 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @bool:38:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc ~=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_ne(x @bool:38:48, y @bool:38:51, ?tmp#0 @bool:38:27)
Types: Mode checking foreign call {foreign llvm icmp_ne(x @bool:38:48, y @bool:38:51, ?tmp#0 @bool:38:27)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @bool:38:48
Types:   Type = wybe.bool
Types: Finding type of expr y @bool:38:51
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:38:27
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm icmp_ne(x:wybe.bool @bool:38:48, y:wybe.bool @bool:38:51, ?tmp#0:wybe.bool @bool:38:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @bool:38:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @bool:38:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @bool:38:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:38:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '~='
Types: Mode checked body   : [{foreign llvm icmp_ne(x:wybe.bool @bool:38:48, y:wybe.bool @bool:38:51, ?tmp#0:wybe.bool @bool:38:27)} @bool:38:27,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:38:5)} @bool:38:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of ~=:
Types: 
Types: ~= > public (0 calls)
Types: 4: ~=(x:wybe.bool @bool:38:10, y:wybe.bool @bool:38:18, ?#result:wybe.bool @bool:38:5):
Types:     foreign llvm icmp_ne(x:wybe.bool @bool:38:48, y:wybe.bool @bool:38:51, ?tmp#0:wybe.bool @bool:38:27)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:38:5)
Types: **** Type checking recursive procs wybe.c_string.~=
Types: ** Type checking decl of proc ~=
Types: found 1 definition(s)
Types: Type checking ~=
Types: ** Type checking ~=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c strcmp(x @c_string:11:47, y @c_string:11:49, ?tmp#1:int @c_string:11:30)
Types:         ~=(tmp#1:int, 0 @c_string:11:60, ?tmp#0 @c_string:11:30)
Types:         foreign llvm move(tmp#0, ?#result @c_string:11:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","tmp#1","x","y"]
Types: Recording parameter types: x:wybe.c_string, y:wybe.c_string, ?#result:wybe.bool
Types:     type of 'x' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable x type constrained to wybe.c_string
Types:     type of 'y' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable y type constrained to wybe.c_string
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign c strcmp(x @c_string:11:47, y @c_string:11:49, ?tmp#1:int @c_string:11:30)}
Types: Unifying types int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable tmp#1 type constrained to wybe.int
Types: Recording casts in {~=(tmp#1:int, 0 @c_string:11:60, ?tmp#0 @c_string:11:30)}
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable tmp#1 type constrained to wybe.int
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @c_string:11:5)}
Types: Unifying move argument types tmp#0 and ?#result @c_string:11:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @c_string:11:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {~=(tmp#1:int, 0 @c_string:11:60, ?tmp#0 @c_string:11:30)} @c_string:11:30, typingInfos = [wybe.bool.~=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.c_string.~=<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.~=<0>(wybe.char,wybe.char,?wybe.bool),wybe.int.~=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types: Type checking call {~=(tmp#1:int, 0 @c_string:11:60, ?tmp#0 @c_string:11:30)} @c_string:11:30
Types: Candidate types:
Types:     wybe.bool.~=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.c_string.~=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types:     wybe.char.~=<0>(wybe.char,wybe.char,?wybe.bool)
Types:     wybe.int.~=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:11:60
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:11:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Actual types: [wybe.int,wybe.int,wybe.bool]
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.bool.~=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 11, column 30): Type error in call to ~=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 11, column 30): Type error in call to ~=, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.c_string.~=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 11, column 30): Type error in call to ~=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 11, column 30): Type error in call to ~=, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.char.~=<0>(wybe.char,wybe.char,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 11, column 30): Type error in call to ~=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 11, column 30): Type error in call to ~=, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.int.~=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Valid types = [Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @c_string:11:47
Types:   Type = wybe.c_string
Types: Finding type of expr y @c_string:11:49
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#1:int @c_string:11:30
Types:   Type = wybe.int
Types: Type checking foreign c call strcmp(address, address, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @c_string:11:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc ~=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign c strcmp(x @c_string:11:47, y @c_string:11:49, ?tmp#1:int @c_string:11:30)
Types: Mode checking foreign call {foreign c strcmp(x @c_string:11:47, y @c_string:11:49, ?tmp#1:int @c_string:11:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#1:int
Types: Mode check exp resulted in ?tmp#1:int
Types: Finding type of expr x @c_string:11:47
Types:   Type = wybe.c_string
Types: Finding type of expr y @c_string:11:49
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#1:int @c_string:11:30
Types:   Type = wybe.int
Types:     types and modes = [wybe.c_string,wybe.c_string,?wybe.int]
Types: New instr = {foreign c strcmp(x:wybe.c_string @c_string:11:47, y:wybe.c_string @c_string:11:49, ?tmp#1:wybe.int @c_string:11:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt ~=(tmp#1:int, 0 @c_string:11:60, ?tmp#0 @c_string:11:30)
Types: Mode checking call   : {~=(tmp#1:int, 0 @c_string:11:60, ?tmp#0 @c_string:11:30)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#1:int
Types: Mode check exp resulted in tmp#1:int
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:11:60
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:11:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     actual types     : [wybe.int,wybe.int,wybe.bool]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.bool.~=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 11, column 30): Type error in call to ~=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 11, column 30): Type error in call to ~=, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.c_string.~=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 11, column 30): Type error in call to ~=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 11, column 30): Type error in call to ~=, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.char.~=<0>(wybe.char,wybe.char,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 11, column 30): Type error in call to ~=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 11, column 30): Type error in call to ~=, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.int.~=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Type-correct modes   : [(wybe.int.~=<0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Possible mode matches: [(wybe.int.~=<0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Exact mode matches: [(wybe.int.~=<0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:11:60
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:11:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finalising call    :  {wybe.int.<0>~=(tmp#1:wybe.int, 0:wybe.int @c_string:11:60, ?tmp#0:wybe.bool @c_string:11:30)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"tmp#1", "x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>~=(tmp#1:wybe.int, 0:wybe.int @c_string:11:60, ?tmp#0:wybe.bool @c_string:11:30)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '~='
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @c_string:11:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @c_string:11:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @c_string:11:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:11:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '~='
Types: Mode checked body   : [{foreign c strcmp(x:wybe.c_string @c_string:11:47, y:wybe.c_string @c_string:11:49, ?tmp#1:wybe.int @c_string:11:30)} @c_string:11:30,{wybe.int.<0>~=(tmp#1:wybe.int, 0:wybe.int @c_string:11:60, ?tmp#0:wybe.bool @c_string:11:30)} @c_string:11:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:11:5)} @c_string:11:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of ~=:
Types: 
Types: ~= > public (0 calls)
Types: 4: ~=(x:wybe.c_string @c_string:11:10, y:wybe.c_string @c_string:11:18, ?#result:wybe.bool @c_string:11:5):
Types:     foreign c strcmp(x:wybe.c_string @c_string:11:47, y:wybe.c_string @c_string:11:49, ?tmp#1:wybe.int @c_string:11:30)
Types:     wybe.int.<0>~=(tmp#1:wybe.int, 0:wybe.int @c_string:11:60, ?tmp#0:wybe.bool @c_string:11:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:11:5)
Types: **** Completed checking of wybe.c_string.~= with 0 errors
Types: Type checking non-recursive proc wybe.bool.||
Types: ** Type checking decl of proc ||
Types: found 1 definition(s)
Types: Type checking ||
Types: ** Type checking ||: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm or(p @bool:19:43, q @bool:19:46, ?tmp#0 @bool:19:27)
Types:         foreign llvm move(tmp#0, ?#result @bool:19:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","p","q","tmp#0"]
Types: Recording parameter types: p:wybe.bool, q:wybe.bool, ?#result:wybe.bool
Types:     type of 'p' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable p type constrained to wybe.bool
Types:     type of 'q' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable q type constrained to wybe.bool
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm or(p @bool:19:43, q @bool:19:46, ?tmp#0 @bool:19:27)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @bool:19:5)}
Types: Unifying move argument types tmp#0 and ?#result @bool:19:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @bool:19:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)
Types: Finding type of expr p @bool:19:43
Types:   Type = wybe.bool
Types: Finding type of expr q @bool:19:46
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:19:27
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call or(1 bit unsigned, 1 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @bool:19:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc ||
Types: bound vars: semipure normal (total) computation binding {p, q}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm or(p @bool:19:43, q @bool:19:46, ?tmp#0 @bool:19:27)
Types: Mode checking foreign call {foreign llvm or(p @bool:19:43, q @bool:19:46, ?tmp#0 @bool:19:27)}
Types:     with assigned semipure normal (total) computation binding {p, q}, break set = Everything, with resources {}
Types: Mode check exp p
Types: Mode check exp resulted in p
Types: Mode check exp q
Types: Mode check exp resulted in q
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr p @bool:19:43
Types:   Type = wybe.bool
Types: Finding type of expr q @bool:19:46
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:19:27
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm or(p:wybe.bool @bool:19:43, q:wybe.bool @bool:19:46, ?tmp#0:wybe.bool @bool:19:27)}
Types: Now assigned = semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @bool:19:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @bool:19:5)}
Types:     with assigned semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @bool:19:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:19:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of Det proc '||'
Types: Mode checked body   : [{foreign llvm or(p:wybe.bool @bool:19:43, q:wybe.bool @bool:19:46, ?tmp#0:wybe.bool @bool:19:27)} @bool:19:27,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:19:5)} @bool:19:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, p, q, tmp#0}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of ||:
Types: 
Types: || > public (0 calls)
Types: 4: ||(p:wybe.bool @bool:19:10, q:wybe.bool @bool:19:18, ?#result:wybe.bool @bool:19:5):
Types:     foreign llvm or(p:wybe.bool @bool:19:43, q:wybe.bool @bool:19:46, ?tmp#0:wybe.bool @bool:19:27)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:19:5)
Types: Type checking non-recursive proc wybe.bool.true
Types: ** Type checking decl of proc true
Types: found 1 definition(s)
Types: Type checking true
Types: ** Type checking true: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm cast(1:!_, ?#result)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result"]
Types: Recording parameter types: ?#result:wybe.bool
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm cast(1:!_, ?#result)}
Types: *** Before calls Typing {#result::wybe.bool}; {} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool}; {} (with no errors)
Types: Finding type of expr 1:!_
Types:   Type = wybe.bool
Types: Finding type of expr ?#result
Types:   Type = wybe.bool
Types: Type checking foreign lpvm call cast(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc true
Types: bound vars: semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm cast(1:!_, ?#result)
Types: Mode checking foreign call {foreign lpvm cast(1:!_, ?#result)}
Types:     with assigned semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check exp 1:!_
Types: Mode check exp resulted in 1:!_
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr 1:!_
Types:   Type = wybe.bool
Types: Finding type of expr ?#result
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign lpvm cast(1:!wybe.bool, ?#result:wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'true'
Types: Mode checked body   : [{foreign lpvm cast(1:!wybe.bool, ?#result:wybe.bool)}]
Types: Vars defined by body: semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of true:
Types: 
Types: true > public {inline} (0 calls)
Types: 4: true(?#result:wybe.bool @bool:8:26):
Types:     foreign lpvm cast(1:!wybe.bool, ?#result:wybe.bool)
Types: Type checking non-recursive proc wybe.bool.~
Types: ** Type checking decl of proc ~
Types: found 1 definition(s)
Types: Type checking ~
Types: ** Type checking ~: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         true(?tmp#1 @bool:31:40)
Types:         foreign llvm xor(p @bool:31:37, tmp#1, ?tmp#0 @bool:31:20)
Types:         foreign llvm move(tmp#0, ?#result @bool:31:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","p","tmp#0","tmp#1"]
Types: Recording parameter types: p:wybe.bool, ?#result:wybe.bool
Types:     type of 'p' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable p type constrained to wybe.bool
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {true(?tmp#1 @bool:31:40)}
Types: Recording casts in {foreign llvm xor(p @bool:31:37, tmp#1, ?tmp#0 @bool:31:20)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @bool:31:5)}
Types: Unifying move argument types tmp#0 and ?#result @bool:31:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @bool:31:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, p::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {true(?tmp#1 @bool:31:40)} @bool:31:40, typingInfos = [wybe.bool.true<0>(?wybe.bool)]}Typing {#result::wybe.bool, p::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)
Types: Type checking call {true(?tmp#1 @bool:31:40)} @bool:31:40
Types: Candidate types:
Types:     wybe.bool.true<0>(?wybe.bool)
Types: Finding type of expr ?tmp#1 @bool:31:40
Types:   Type = 1
Types: Actual types: [1]
Types: Matching types [1] with wybe.bool.true<0>(?wybe.bool)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Valid types = [Typing {#result::wybe.bool, p::wybe.bool, tmp#0::0, tmp#1::1}; {0::wybe.bool, 1::wybe.bool} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.bool, p::wybe.bool, tmp#0::0, tmp#1::1}; {0::wybe.bool, 1::wybe.bool} (with no errors)
Types: Finding type of expr p @bool:31:37
Types:   Type = wybe.bool
Types: Finding type of expr tmp#1
Types: Type variable 1 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:31:20
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call xor(1 bit unsigned, 1 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @bool:31:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc ~
Types: bound vars: semipure normal (total) computation binding {p}, break set = Everything, with resources {}
Types: Mode check stmt true(?tmp#1 @bool:31:40)
Types: Mode checking call   : {true(?tmp#1 @bool:31:40)}
Types:     with assigned    : semipure normal (total) computation binding {p}, break set = Everything, with resources {}
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr ?tmp#1 @bool:31:40
Types: Type variable 1 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     actual types     : [wybe.bool]
Types:     actual modes     : [(ParamOut,False,Nothing)]
Types: Matching types [wybe.bool] with wybe.bool.true<0>(?wybe.bool)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Type-correct modes   : [(wybe.bool.true<0>(?wybe.bool),Typing {#result::wybe.bool, p::wybe.bool, tmp#0::0, tmp#1::1}; {0::wybe.bool, 1::wybe.bool} (with no errors))]
Types: Possible mode matches: [(wybe.bool.true<0>(?wybe.bool),Typing {#result::wybe.bool, p::wybe.bool, tmp#0::0, tmp#1::1}; {0::wybe.bool, 1::wybe.bool} (with no errors))]
Types: Exact mode matches: [(wybe.bool.true<0>(?wybe.bool),Typing {#result::wybe.bool, p::wybe.bool, tmp#0::0, tmp#1::1}; {0::wybe.bool, 1::wybe.bool} (with no errors))]
Types: Finding type of expr ?tmp#1 @bool:31:40
Types: Type variable 1 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finalising call    :  {wybe.bool.<0>true(?tmp#1:wybe.bool @bool:31:40)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"p"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.bool.<0>true(?tmp#1:wybe.bool @bool:31:40)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '~'
Types: Now assigned = semipure normal (total) computation binding {p, tmp#1}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm xor(p @bool:31:37, tmp#1, ?tmp#0 @bool:31:20)
Types: Mode checking foreign call {foreign llvm xor(p @bool:31:37, tmp#1, ?tmp#0 @bool:31:20)}
Types:     with assigned semipure normal (total) computation binding {p, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp p
Types: Mode check exp resulted in p
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr p @bool:31:37
Types:   Type = wybe.bool
Types: Finding type of expr tmp#1
Types: Type variable 1 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:31:20
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm xor(p:wybe.bool @bool:31:37, tmp#1:wybe.bool, ?tmp#0:wybe.bool @bool:31:20)}
Types: Now assigned = semipure normal (total) computation binding {p, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @bool:31:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @bool:31:5)}
Types:     with assigned semipure normal (total) computation binding {p, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @bool:31:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:31:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, p, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check end of Det proc '~'
Types: Mode checked body   : [{wybe.bool.<0>true(?tmp#1:wybe.bool @bool:31:40)} @bool:31:40,{foreign llvm xor(p:wybe.bool @bool:31:37, tmp#1:wybe.bool, ?tmp#0:wybe.bool @bool:31:20)} @bool:31:20,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:31:5)} @bool:31:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, p, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of ~:
Types: 
Types: ~ > public (0 calls)
Types: 4: ~(p:wybe.bool @bool:31:11, ?#result:wybe.bool @bool:31:5):
Types:     wybe.bool.<0>true(?tmp#1:wybe.bool @bool:31:40)
Types:     foreign llvm xor(p:wybe.bool @bool:31:37, tmp#1:wybe.bool, ?tmp#0:wybe.bool @bool:31:20)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:31:5)
Types: Type checking non-recursive proc wybe.bool.succeed
Types: ** Type checking decl of proc succeed
Types: found 1 definition(s)
Types: Type checking succeed
Types: ** Type checking succeed: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:    and defaults: 
Types:    with assigned vars: fromList []
Types: Recording parameter types: 
Types: Recording resource types: 
Types: *** Before calls Typing {}; {} (with no errors)
Types:   With calls:
Types:   Typing {}; {} (with no errors)
Types: Now mode checking proc succeed
Types: bound vars: semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check stmt pass
Types: Mode checking Nop
Types: Now assigned = semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'succeed'
Types: Mode checked body   : [{pass} @bool:43:19]
Types: Vars defined by body: semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Output parameters   : 
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of succeed:
Types: 
Types: succeed > public (0 calls)
Types: 4: succeed():
Types:     pass
Types: **** Type checking recursive procs wybe.bool.print
Types: ** Type checking decl of proc print
Types: found 1 definition(s)
Types: Type checking print
Types: ** Type checking print: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         x
Types:         foreign llvm move(c"true" @bool:47:45, ?tmp#0)
Types:         foreign llvm move(c"false" @bool:47:60, ?tmp#0)
Types:         !print(tmp#0 @bool:47:41)
Types:    and defaults: 
Types:    with assigned vars: fromList ["io","tmp#0","x"]
Types: Recording parameter types: x:wybe.bool
Types:     type of 'x' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable x type constrained to wybe.bool
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {x}
Types: Recording casts in {foreign llvm move(c"true" @bool:47:45, ?tmp#0)}
Types: Unifying move argument types c"true" @bool:47:45 and ?tmp#0
Types: Finding type of expr c"true" @bool:47:45
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#0
Types:   Type = 0
Types: Type variable 0 is bound to Nothing
Types: Unifying types wybe.c_string (-> wybe.c_string) and 0 (-> 0)
Types:   Unification yields wybe.c_string
Types: Recording casts in {foreign llvm move(c"false" @bool:47:60, ?tmp#0)}
Types: Unifying move argument types c"false" @bool:47:60 and ?tmp#0
Types: Finding type of expr c"false" @bool:47:60
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.c_string
Types:   Type = wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and wybe.c_string (-> wybe.c_string)
Types:   Unification yields wybe.c_string
Types: Recording casts in {!print(tmp#0 @bool:47:41)}
Types: *** Before calls Typing {io::wybe.phantom, tmp#0::0, x::wybe.bool}; {0::wybe.c_string} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {x} @bool:47:41, typingInfos = [test x]}
Types:     StmtTypings {typingStmt = {!print(tmp#0 @bool:47:41)} @bool:47:31, typingInfos = [wybe.bool.print<0>(wybe.bool) use io, ?io,wybe.c_string.print<0>(wybe.c_string) use io, ?io]}Typing {io::wybe.phantom, tmp#0::0, x::wybe.bool}; {0::wybe.c_string} (with no errors)
Types: Type checking call {x} @bool:47:41
Types: Candidate types:
Types:     test x
Types: Actual types: []
Types: Finding type of expr x
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Valid types = [Typing {io::wybe.phantom, tmp#0::0, x::wybe.bool}; {0::wybe.c_string} (with no errors)]
Types: Resulting typing = Typing {io::wybe.phantom, tmp#0::0, x::wybe.bool}; {0::wybe.c_string} (with no errors)
Types: Type checking call {!print(tmp#0 @bool:47:41)} @bool:47:31
Types: Candidate types:
Types:     wybe.bool.print<0>(wybe.bool) use io, ?io
Types:     wybe.c_string.print<0>(wybe.c_string) use io, ?io
Types: Finding type of expr tmp#0 @bool:47:41
Types: Type variable 0 is bound to Just wybe.c_string
Types:   Type = wybe.c_string
Types: Actual types: [wybe.c_string]
Types: Matching types [wybe.c_string] with wybe.bool.print<0>(wybe.bool) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.c_string (-> wybe.c_string) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/bool.wybe" (line 47, column 31): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Matching types [wybe.c_string] with wybe.c_string.print<0>(wybe.c_string) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.c_string (-> wybe.c_string) and wybe.c_string (-> wybe.c_string)
Types:   Unification yields wybe.c_string
Types: Valid types = [Typing {io::wybe.phantom, tmp#0::0, x::wybe.bool}; {0::wybe.c_string} (with no errors)]
Types: Resulting typing = Typing {io::wybe.phantom, tmp#0::0, x::wybe.bool}; {0::wybe.c_string} (with no errors)
Types: Finding type of expr c"true" @bool:47:45
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.c_string
Types:   Type = wybe.c_string
Types: Type checking foreign llvm call move(address, address)
Types: Finding type of expr c"false" @bool:47:60
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.c_string
Types:   Type = wybe.c_string
Types: Type checking foreign llvm call move(address, address)
Types: Now mode checking proc print
Types: bound vars: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt if {x::
Types: 
Types:                     foreign llvm move(c"true" @bool:47:45, ?tmp#0)
Types:                 else::
Types:                     foreign llvm move(c"false" @bool:47:60, ?tmp#0)
Types: 
Types:                 }
Types: Mode checking conditional {if {x::
Types: 
Types:         foreign llvm move(c"true" @bool:47:45, ?tmp#0)
Types:     else::
Types:         foreign llvm move(c"false" @bool:47:60, ?tmp#0)
Types: 
Types:     }}
Types: Mode checking call   : {x}
Types:     with assigned    : semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types:     actual types     : []
Types:     actual modes     : []
Types: Finding type of expr x
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Type-correct modes   : [(test x,Typing {io::wybe.phantom, tmp#0::0, x::wybe.bool}; {0::wybe.c_string} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: [(test x,Typing {io::wybe.phantom, tmp#0::0, x::wybe.bool}; {0::wybe.c_string} (with no errors))]
Types: Mode checking test x
Types: Assigned by test: semipure test computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt foreign llvm move(c"true" @bool:47:45, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(c"true" @bool:47:45, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp c"true"
Types: Mode check exp resulted in c"true"
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr c"true" @bool:47:45
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.c_string
Types:   Type = wybe.c_string
Types:     types and modes = [wybe.c_string,?wybe.c_string]
Types: New instr = {foreign llvm move(c"true":wybe.c_string @bool:47:45, ?tmp#0:wybe.c_string)}
Types: Now assigned = semipure normal (total) computation binding {io, tmp#0, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'print'
Types: Assigned by then branch: semipure normal (total) computation binding {io, tmp#0, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt foreign llvm move(c"false" @bool:47:60, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(c"false" @bool:47:60, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp c"false"
Types: Mode check exp resulted in c"false"
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr c"false" @bool:47:60
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.c_string
Types:   Type = wybe.c_string
Types:     types and modes = [wybe.c_string,?wybe.c_string]
Types: New instr = {foreign llvm move(c"false":wybe.c_string @bool:47:60, ?tmp#0:wybe.c_string)}
Types: Now assigned = semipure normal (total) computation binding {io, tmp#0, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'print'
Types: Assigned by else branch: semipure normal (total) computation binding {io, tmp#0, x}, break set = Everything, with resources {wybe.io.io}
Types: Assigned by conditional: semipure normal (total) computation binding {io, tmp#0, x}, break set = Everything, with resources {wybe.io.io}
Types: Type variable 0 is bound to Just wybe.c_string
Types: Now assigned = semipure normal (total) computation binding {io, tmp#0, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt !print(tmp#0 @bool:47:41)
Types: Mode checking call   : {!print(tmp#0 @bool:47:41)}
Types:     with assigned    : semipure normal (total) computation binding {io, tmp#0, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr tmp#0 @bool:47:41
Types: Type variable 0 is bound to Just wybe.c_string
Types:   Type = wybe.c_string
Types:     actual types     : [wybe.c_string]
Types:     actual modes     : [(ParamIn,True,Nothing)]
Types: Matching types [wybe.c_string] with wybe.bool.print<0>(wybe.bool) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.c_string (-> wybe.c_string) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/bool.wybe" (line 47, column 31): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Matching types [wybe.c_string] with wybe.c_string.print<0>(wybe.c_string) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.c_string (-> wybe.c_string) and wybe.c_string (-> wybe.c_string)
Types:   Unification yields wybe.c_string
Types: Type-correct modes   : [(wybe.c_string.print<0>(wybe.c_string) use io, ?io,Typing {io::wybe.phantom, tmp#0::0, x::wybe.bool}; {0::wybe.c_string} (with no errors))]
Types: Possible mode matches: [(wybe.c_string.print<0>(wybe.c_string) use io, ?io,Typing {io::wybe.phantom, tmp#0::0, x::wybe.bool}; {0::wybe.c_string} (with no errors))]
Types: Exact mode matches: [(wybe.c_string.print<0>(wybe.c_string) use io, ?io,Typing {io::wybe.phantom, tmp#0::0, x::wybe.bool}; {0::wybe.c_string} (with no errors))]
Types: Finding type of expr tmp#0 @bool:47:41
Types: Type variable 0 is bound to Just wybe.c_string
Types:   Type = wybe.c_string
Types: Finalising call    :  {!wybe.c_string.<0>print(tmp#0:wybe.c_string @bool:47:41)}
Types: Input resources    :  {wybe.io.io}
Types: Output resources   :  {wybe.io.io}
Types: Specials in call   :  {}
Types: Available vars     :  {"io", "tmp#0", "x"}
Types: Available resources:  {wybe.io.io}
Types: Generated special stmts = []
Types: New instr = {!wybe.c_string.<0>print(tmp#0:wybe.c_string @bool:47:41)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'print'
Types: Now assigned = semipure normal (total) computation binding {io, tmp#0, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'print'
Types: Mode checked body   : [{if {testbool x:wybe.bool::
Types: 
Types:         foreign llvm move(c"true":wybe.c_string @bool:47:45, ?tmp#0:wybe.c_string)
Types:     else::
Types:         foreign llvm move(c"false":wybe.c_string @bool:47:60, ?tmp#0:wybe.c_string)
Types: 
Types:     }
Types:    condition -> {io::wybe.phantom, x::wybe.bool}
Types:    then&else -> {io::wybe.phantom, tmp#0::wybe.c_string, x::wybe.bool}} @bool:47:41,{!wybe.c_string.<0>print(tmp#0:wybe.c_string @bool:47:41)} @bool:47:31]
Types: Vars defined by body: semipure normal (total) computation binding {io, tmp#0, x}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : 
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of print:
Types: 
Types: print > public (0 calls)
Types: 4: print(x:wybe.bool @bool:47:15) use !wybe.io.io:
Types:     if {testbool x:wybe.bool::
Types: 
Types:         foreign llvm move(c"true":wybe.c_string @bool:47:45, ?tmp#0:wybe.c_string)
Types:     else::
Types:         foreign llvm move(c"false":wybe.c_string @bool:47:60, ?tmp#0:wybe.c_string)
Types: 
Types:     }
Types:    condition -> {io::wybe.phantom, x::wybe.bool}
Types:    then&else -> {io::wybe.phantom, tmp#0::wybe.c_string, x::wybe.bool}
Types:     !wybe.c_string.<0>print(tmp#0:wybe.c_string @bool:47:41)
Types: **** Completed checking of wybe.bool.print with 0 errors
Types: Type checking non-recursive proc wybe.bool.println
Types: ** Type checking decl of proc println
Types: found 1 definition(s)
Types: Type checking println
Types: ** Type checking println: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         !print(x @bool:49:39)
Types:         !nl
Types:    and defaults: 
Types:    with assigned vars: fromList ["io","x"]
Types: Recording parameter types: x:wybe.bool
Types:     type of 'x' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable x type constrained to wybe.bool
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {!print(x @bool:49:39)}
Types: Recording casts in {!nl}
Types: *** Before calls Typing {io::wybe.phantom, x::wybe.bool}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {!print(x @bool:49:39)} @bool:49:33, typingInfos = [wybe.bool.print<0>(wybe.bool) use io, ?io,wybe.c_string.print<0>(wybe.c_string) use io, ?io]}
Types:     StmtTypings {typingStmt = {!nl} @bool:49:44, typingInfos = [wybe.io.nl<0>() use io, ?io]}Typing {io::wybe.phantom, x::wybe.bool}; {} (with no errors)
Types: Type checking call {!print(x @bool:49:39)} @bool:49:33
Types: Candidate types:
Types:     wybe.bool.print<0>(wybe.bool) use io, ?io
Types:     wybe.c_string.print<0>(wybe.c_string) use io, ?io
Types: Finding type of expr x @bool:49:39
Types:   Type = wybe.bool
Types: Actual types: [wybe.bool]
Types: Matching types [wybe.bool] with wybe.bool.print<0>(wybe.bool) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.bool] with wybe.c_string.print<0>(wybe.c_string) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/bool.wybe" (line 49, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Valid types = [Typing {io::wybe.phantom, x::wybe.bool}; {} (with no errors)]
Types: Resulting typing = Typing {io::wybe.phantom, x::wybe.bool}; {} (with no errors)
Types: Type checking call {!nl} @bool:49:44
Types: Candidate types:
Types:     wybe.io.nl<0>() use io, ?io
Types: Actual types: []
Types: Matching types [] with wybe.io.nl<0>() use io, ?io
Types: Call arity 0; proc arity 0 - 0
Types: Filling  0 optional arguments
Types: Valid types = [Typing {io::wybe.phantom, x::wybe.bool}; {} (with no errors)]
Types: Resulting typing = Typing {io::wybe.phantom, x::wybe.bool}; {} (with no errors)
Types: Now mode checking proc println
Types: bound vars: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt !print(x @bool:49:39)
Types: Mode checking call   : {!print(x @bool:49:39)}
Types:     with assigned    : semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Finding type of expr x @bool:49:39
Types:   Type = wybe.bool
Types:     actual types     : [wybe.bool]
Types:     actual modes     : [(ParamIn,True,Nothing)]
Types: Matching types [wybe.bool] with wybe.bool.print<0>(wybe.bool) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.bool] with wybe.c_string.print<0>(wybe.c_string) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/bool.wybe" (line 49, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Type-correct modes   : [(wybe.bool.print<0>(wybe.bool) use io, ?io,Typing {io::wybe.phantom, x::wybe.bool}; {} (with no errors))]
Types: Possible mode matches: [(wybe.bool.print<0>(wybe.bool) use io, ?io,Typing {io::wybe.phantom, x::wybe.bool}; {} (with no errors))]
Types: Exact mode matches: [(wybe.bool.print<0>(wybe.bool) use io, ?io,Typing {io::wybe.phantom, x::wybe.bool}; {} (with no errors))]
Types: Finding type of expr x @bool:49:39
Types:   Type = wybe.bool
Types: Finalising call    :  {!wybe.bool.<0>print(x:wybe.bool @bool:49:39)}
Types: Input resources    :  {wybe.io.io}
Types: Output resources   :  {wybe.io.io}
Types: Specials in call   :  {}
Types: Available vars     :  {"io", "x"}
Types: Available resources:  {wybe.io.io}
Types: Generated special stmts = []
Types: New instr = {!wybe.bool.<0>print(x:wybe.bool @bool:49:39)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'println'
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt !nl
Types: Mode checking call   : {!nl}
Types:     with assigned    : semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types:     actual types     : []
Types:     actual modes     : []
Types: Matching types [] with wybe.io.nl<0>() use io, ?io
Types: Call arity 0; proc arity 0 - 0
Types: Filling  0 optional arguments
Types: Type-correct modes   : [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.bool}; {} (with no errors))]
Types: Possible mode matches: [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.bool}; {} (with no errors))]
Types: Exact mode matches: [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.bool}; {} (with no errors))]
Types: Finalising call    :  {!wybe.io.<0>nl}
Types: Input resources    :  {wybe.io.io}
Types: Output resources   :  {wybe.io.io}
Types: Specials in call   :  {}
Types: Available vars     :  {"io", "x"}
Types: Available resources:  {wybe.io.io}
Types: Generated special stmts = []
Types: New instr = {!wybe.io.<0>nl}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'println'
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'println'
Types: Mode checked body   : [{!wybe.bool.<0>print(x:wybe.bool @bool:49:39)} @bool:49:33,{!wybe.io.<0>nl} @bool:49:44]
Types: Vars defined by body: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : 
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of println:
Types: 
Types: println > public (0 calls)
Types: 4: println(x:wybe.bool @bool:49:17) use !wybe.io.io:
Types:     !wybe.bool.<0>print(x:wybe.bool @bool:49:39)
Types:     !wybe.io.<0>nl
Types: Type checking non-recursive proc wybe.c_string.println
Types: ** Type checking decl of proc println
Types: found 1 definition(s)
Types: Type checking println
Types: ** Type checking println: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         !print(x @c_string:37:39)
Types:         !nl
Types:    and defaults: 
Types:    with assigned vars: fromList ["io","x"]
Types: Recording parameter types: x:wybe.c_string
Types:     type of 'x' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable x type constrained to wybe.c_string
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {!print(x @c_string:37:39)}
Types: Recording casts in {!nl}
Types: *** Before calls Typing {io::wybe.phantom, x::wybe.c_string}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {!print(x @c_string:37:39)} @c_string:37:33, typingInfos = [wybe.bool.print<0>(wybe.bool) use io, ?io,wybe.c_string.print<0>(wybe.c_string) use io, ?io,wybe.char.print<0>(wybe.char) use io, ?io,wybe.int.print<0>(wybe.int) use io, ?io]}
Types:     StmtTypings {typingStmt = {!nl} @c_string:37:44, typingInfos = [wybe.io.nl<0>() use io, ?io]}Typing {io::wybe.phantom, x::wybe.c_string}; {} (with no errors)
Types: Type checking call {!print(x @c_string:37:39)} @c_string:37:33
Types: Candidate types:
Types:     wybe.bool.print<0>(wybe.bool) use io, ?io
Types:     wybe.c_string.print<0>(wybe.c_string) use io, ?io
Types:     wybe.char.print<0>(wybe.char) use io, ?io
Types:     wybe.int.print<0>(wybe.int) use io, ?io
Types: Finding type of expr x @c_string:37:39
Types:   Type = wybe.c_string
Types: Actual types: [wybe.c_string]
Types: Matching types [wybe.c_string] with wybe.bool.print<0>(wybe.bool) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.c_string (-> wybe.c_string) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 37, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Matching types [wybe.c_string] with wybe.c_string.print<0>(wybe.c_string) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.c_string (-> wybe.c_string) and wybe.c_string (-> wybe.c_string)
Types:   Unification yields wybe.c_string
Types: Matching types [wybe.c_string] with wybe.char.print<0>(wybe.char) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.c_string (-> wybe.c_string) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 37, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Matching types [wybe.c_string] with wybe.int.print<0>(wybe.int) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.c_string (-> wybe.c_string) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 37, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Valid types = [Typing {io::wybe.phantom, x::wybe.c_string}; {} (with no errors)]
Types: Resulting typing = Typing {io::wybe.phantom, x::wybe.c_string}; {} (with no errors)
Types: Type checking call {!nl} @c_string:37:44
Types: Candidate types:
Types:     wybe.io.nl<0>() use io, ?io
Types: Actual types: []
Types: Matching types [] with wybe.io.nl<0>() use io, ?io
Types: Call arity 0; proc arity 0 - 0
Types: Filling  0 optional arguments
Types: Valid types = [Typing {io::wybe.phantom, x::wybe.c_string}; {} (with no errors)]
Types: Resulting typing = Typing {io::wybe.phantom, x::wybe.c_string}; {} (with no errors)
Types: Now mode checking proc println
Types: bound vars: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt !print(x @c_string:37:39)
Types: Mode checking call   : {!print(x @c_string:37:39)}
Types:     with assigned    : semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Finding type of expr x @c_string:37:39
Types:   Type = wybe.c_string
Types:     actual types     : [wybe.c_string]
Types:     actual modes     : [(ParamIn,True,Nothing)]
Types: Matching types [wybe.c_string] with wybe.bool.print<0>(wybe.bool) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.c_string (-> wybe.c_string) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 37, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Matching types [wybe.c_string] with wybe.c_string.print<0>(wybe.c_string) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.c_string (-> wybe.c_string) and wybe.c_string (-> wybe.c_string)
Types:   Unification yields wybe.c_string
Types: Matching types [wybe.c_string] with wybe.char.print<0>(wybe.char) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.c_string (-> wybe.c_string) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 37, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Matching types [wybe.c_string] with wybe.int.print<0>(wybe.int) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.c_string (-> wybe.c_string) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 37, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Type-correct modes   : [(wybe.c_string.print<0>(wybe.c_string) use io, ?io,Typing {io::wybe.phantom, x::wybe.c_string}; {} (with no errors))]
Types: Possible mode matches: [(wybe.c_string.print<0>(wybe.c_string) use io, ?io,Typing {io::wybe.phantom, x::wybe.c_string}; {} (with no errors))]
Types: Exact mode matches: [(wybe.c_string.print<0>(wybe.c_string) use io, ?io,Typing {io::wybe.phantom, x::wybe.c_string}; {} (with no errors))]
Types: Finding type of expr x @c_string:37:39
Types:   Type = wybe.c_string
Types: Finalising call    :  {!wybe.c_string.<0>print(x:wybe.c_string @c_string:37:39)}
Types: Input resources    :  {wybe.io.io}
Types: Output resources   :  {wybe.io.io}
Types: Specials in call   :  {}
Types: Available vars     :  {"io", "x"}
Types: Available resources:  {wybe.io.io}
Types: Generated special stmts = []
Types: New instr = {!wybe.c_string.<0>print(x:wybe.c_string @c_string:37:39)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'println'
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt !nl
Types: Mode checking call   : {!nl}
Types:     with assigned    : semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types:     actual types     : []
Types:     actual modes     : []
Types: Matching types [] with wybe.io.nl<0>() use io, ?io
Types: Call arity 0; proc arity 0 - 0
Types: Filling  0 optional arguments
Types: Type-correct modes   : [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.c_string}; {} (with no errors))]
Types: Possible mode matches: [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.c_string}; {} (with no errors))]
Types: Exact mode matches: [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.c_string}; {} (with no errors))]
Types: Finalising call    :  {!wybe.io.<0>nl}
Types: Input resources    :  {wybe.io.io}
Types: Output resources   :  {wybe.io.io}
Types: Specials in call   :  {}
Types: Available vars     :  {"io", "x"}
Types: Available resources:  {wybe.io.io}
Types: Generated special stmts = []
Types: New instr = {!wybe.io.<0>nl}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'println'
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'println'
Types: Mode checked body   : [{!wybe.c_string.<0>print(x:wybe.c_string @c_string:37:39)} @c_string:37:33,{!wybe.io.<0>nl} @c_string:37:44]
Types: Vars defined by body: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : 
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of println:
Types: 
Types: println > public (0 calls)
Types: 4: println(x:wybe.c_string @c_string:37:17) use !wybe.io.io:
Types:     !wybe.c_string.<0>print(x:wybe.c_string @c_string:37:39)
Types:     !wybe.io.<0>nl
Types: Type checking non-recursive proc wybe.char.println
Types: ** Type checking decl of proc println
Types: found 1 definition(s)
Types: Type checking println
Types: ** Type checking println: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         !print(x @char:39:39)
Types:         !nl
Types:    and defaults: 
Types:    with assigned vars: fromList ["io","x"]
Types: Recording parameter types: x:wybe.char
Types:     type of 'x' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable x type constrained to wybe.char
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {!print(x @char:39:39)}
Types: Recording casts in {!nl}
Types: *** Before calls Typing {io::wybe.phantom, x::wybe.char}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {!print(x @char:39:39)} @char:39:33, typingInfos = [wybe.bool.print<0>(wybe.bool) use io, ?io,wybe.char.print<0>(wybe.char) use io, ?io,wybe.int.print<0>(wybe.int) use io, ?io]}
Types:     StmtTypings {typingStmt = {!nl} @char:39:44, typingInfos = [wybe.io.nl<0>() use io, ?io]}Typing {io::wybe.phantom, x::wybe.char}; {} (with no errors)
Types: Type checking call {!print(x @char:39:39)} @char:39:33
Types: Candidate types:
Types:     wybe.bool.print<0>(wybe.bool) use io, ?io
Types:     wybe.char.print<0>(wybe.char) use io, ?io
Types:     wybe.int.print<0>(wybe.int) use io, ?io
Types: Finding type of expr x @char:39:39
Types:   Type = wybe.char
Types: Actual types: [wybe.char]
Types: Matching types [wybe.char] with wybe.bool.print<0>(wybe.bool) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 39, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Matching types [wybe.char] with wybe.char.print<0>(wybe.char) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Matching types [wybe.char] with wybe.int.print<0>(wybe.int) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 39, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Valid types = [Typing {io::wybe.phantom, x::wybe.char}; {} (with no errors)]
Types: Resulting typing = Typing {io::wybe.phantom, x::wybe.char}; {} (with no errors)
Types: Type checking call {!nl} @char:39:44
Types: Candidate types:
Types:     wybe.io.nl<0>() use io, ?io
Types: Actual types: []
Types: Matching types [] with wybe.io.nl<0>() use io, ?io
Types: Call arity 0; proc arity 0 - 0
Types: Filling  0 optional arguments
Types: Valid types = [Typing {io::wybe.phantom, x::wybe.char}; {} (with no errors)]
Types: Resulting typing = Typing {io::wybe.phantom, x::wybe.char}; {} (with no errors)
Types: Now mode checking proc println
Types: bound vars: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt !print(x @char:39:39)
Types: Mode checking call   : {!print(x @char:39:39)}
Types:     with assigned    : semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Finding type of expr x @char:39:39
Types:   Type = wybe.char
Types:     actual types     : [wybe.char]
Types:     actual modes     : [(ParamIn,True,Nothing)]
Types: Matching types [wybe.char] with wybe.bool.print<0>(wybe.bool) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 39, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Matching types [wybe.char] with wybe.char.print<0>(wybe.char) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Matching types [wybe.char] with wybe.int.print<0>(wybe.int) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 39, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Type-correct modes   : [(wybe.char.print<0>(wybe.char) use io, ?io,Typing {io::wybe.phantom, x::wybe.char}; {} (with no errors))]
Types: Possible mode matches: [(wybe.char.print<0>(wybe.char) use io, ?io,Typing {io::wybe.phantom, x::wybe.char}; {} (with no errors))]
Types: Exact mode matches: [(wybe.char.print<0>(wybe.char) use io, ?io,Typing {io::wybe.phantom, x::wybe.char}; {} (with no errors))]
Types: Finding type of expr x @char:39:39
Types:   Type = wybe.char
Types: Finalising call    :  {!wybe.char.<0>print(x:wybe.char @char:39:39)}
Types: Input resources    :  {wybe.io.io}
Types: Output resources   :  {wybe.io.io}
Types: Specials in call   :  {}
Types: Available vars     :  {"io", "x"}
Types: Available resources:  {wybe.io.io}
Types: Generated special stmts = []
Types: New instr = {!wybe.char.<0>print(x:wybe.char @char:39:39)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'println'
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt !nl
Types: Mode checking call   : {!nl}
Types:     with assigned    : semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types:     actual types     : []
Types:     actual modes     : []
Types: Matching types [] with wybe.io.nl<0>() use io, ?io
Types: Call arity 0; proc arity 0 - 0
Types: Filling  0 optional arguments
Types: Type-correct modes   : [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.char}; {} (with no errors))]
Types: Possible mode matches: [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.char}; {} (with no errors))]
Types: Exact mode matches: [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.char}; {} (with no errors))]
Types: Finalising call    :  {!wybe.io.<0>nl}
Types: Input resources    :  {wybe.io.io}
Types: Output resources   :  {wybe.io.io}
Types: Specials in call   :  {}
Types: Available vars     :  {"io", "x"}
Types: Available resources:  {wybe.io.io}
Types: Generated special stmts = []
Types: New instr = {!wybe.io.<0>nl}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'println'
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'println'
Types: Mode checked body   : [{!wybe.char.<0>print(x:wybe.char @char:39:39)} @char:39:33,{!wybe.io.<0>nl} @char:39:44]
Types: Vars defined by body: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : 
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of println:
Types: 
Types: println > public (0 calls)
Types: 4: println(x:wybe.char @char:39:17) use !wybe.io.io:
Types:     !wybe.char.<0>print(x:wybe.char @char:39:39)
Types:     !wybe.io.<0>nl
Types: Type checking non-recursive proc wybe.int.println
Types: ** Type checking decl of proc println
Types: found 1 definition(s)
Types: Type checking println
Types: ** Type checking println: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         !print(x @int:121:39)
Types:         !nl
Types:    and defaults: 
Types:    with assigned vars: fromList ["io","x"]
Types: Recording parameter types: x:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {!print(x @int:121:39)}
Types: Recording casts in {!nl}
Types: *** Before calls Typing {io::wybe.phantom, x::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {!print(x @int:121:39)} @int:121:33, typingInfos = [wybe.bool.print<0>(wybe.bool) use io, ?io,wybe.int.print<0>(wybe.int) use io, ?io]}
Types:     StmtTypings {typingStmt = {!nl} @int:121:44, typingInfos = [wybe.io.nl<0>() use io, ?io]}Typing {io::wybe.phantom, x::wybe.int}; {} (with no errors)
Types: Type checking call {!print(x @int:121:39)} @int:121:33
Types: Candidate types:
Types:     wybe.bool.print<0>(wybe.bool) use io, ?io
Types:     wybe.int.print<0>(wybe.int) use io, ?io
Types: Finding type of expr x @int:121:39
Types:   Type = wybe.int
Types: Actual types: [wybe.int]
Types: Matching types [wybe.int] with wybe.bool.print<0>(wybe.bool) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 121, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Matching types [wybe.int] with wybe.int.print<0>(wybe.int) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {io::wybe.phantom, x::wybe.int}; {} (with no errors)]
Types: Resulting typing = Typing {io::wybe.phantom, x::wybe.int}; {} (with no errors)
Types: Type checking call {!nl} @int:121:44
Types: Candidate types:
Types:     wybe.io.nl<0>() use io, ?io
Types: Actual types: []
Types: Matching types [] with wybe.io.nl<0>() use io, ?io
Types: Call arity 0; proc arity 0 - 0
Types: Filling  0 optional arguments
Types: Valid types = [Typing {io::wybe.phantom, x::wybe.int}; {} (with no errors)]
Types: Resulting typing = Typing {io::wybe.phantom, x::wybe.int}; {} (with no errors)
Types: Now mode checking proc println
Types: bound vars: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt !print(x @int:121:39)
Types: Mode checking call   : {!print(x @int:121:39)}
Types:     with assigned    : semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Finding type of expr x @int:121:39
Types:   Type = wybe.int
Types:     actual types     : [wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing)]
Types: Matching types [wybe.int] with wybe.bool.print<0>(wybe.bool) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 121, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Matching types [wybe.int] with wybe.int.print<0>(wybe.int) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.print<0>(wybe.int) use io, ?io,Typing {io::wybe.phantom, x::wybe.int}; {} (with no errors))]
Types: Possible mode matches: [(wybe.int.print<0>(wybe.int) use io, ?io,Typing {io::wybe.phantom, x::wybe.int}; {} (with no errors))]
Types: Exact mode matches: [(wybe.int.print<0>(wybe.int) use io, ?io,Typing {io::wybe.phantom, x::wybe.int}; {} (with no errors))]
Types: Finding type of expr x @int:121:39
Types:   Type = wybe.int
Types: Finalising call    :  {!wybe.int.<0>print(x:wybe.int @int:121:39)}
Types: Input resources    :  {wybe.io.io}
Types: Output resources   :  {wybe.io.io}
Types: Specials in call   :  {}
Types: Available vars     :  {"io", "x"}
Types: Available resources:  {wybe.io.io}
Types: Generated special stmts = []
Types: New instr = {!wybe.int.<0>print(x:wybe.int @int:121:39)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'println'
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt !nl
Types: Mode checking call   : {!nl}
Types:     with assigned    : semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types:     actual types     : []
Types:     actual modes     : []
Types: Matching types [] with wybe.io.nl<0>() use io, ?io
Types: Call arity 0; proc arity 0 - 0
Types: Filling  0 optional arguments
Types: Type-correct modes   : [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.int}; {} (with no errors))]
Types: Possible mode matches: [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.int}; {} (with no errors))]
Types: Exact mode matches: [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.int}; {} (with no errors))]
Types: Finalising call    :  {!wybe.io.<0>nl}
Types: Input resources    :  {wybe.io.io}
Types: Output resources   :  {wybe.io.io}
Types: Specials in call   :  {}
Types: Available vars     :  {"io", "x"}
Types: Available resources:  {wybe.io.io}
Types: Generated special stmts = []
Types: New instr = {!wybe.io.<0>nl}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'println'
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'println'
Types: Mode checked body   : [{!wybe.int.<0>print(x:wybe.int @int:121:39)} @int:121:33,{!wybe.io.<0>nl} @int:121:44]
Types: Vars defined by body: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : 
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of println:
Types: 
Types: println > public (0 calls)
Types: 4: println(x:wybe.int @int:121:17) use !wybe.io.io:
Types:     !wybe.int.<0>print(x:wybe.int @int:121:39)
Types:     !wybe.io.<0>nl
Types: Type checking non-recursive proc wybe.bool.false
Types: ** Type checking decl of proc false
Types: found 1 definition(s)
Types: Type checking false
Types: ** Type checking false: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm cast(0:!_, ?#result)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result"]
Types: Recording parameter types: ?#result:wybe.bool
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm cast(0:!_, ?#result)}
Types: *** Before calls Typing {#result::wybe.bool}; {} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool}; {} (with no errors)
Types: Finding type of expr 0:!_
Types:   Type = wybe.bool
Types: Finding type of expr ?#result
Types:   Type = wybe.bool
Types: Type checking foreign lpvm call cast(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc false
Types: bound vars: semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm cast(0:!_, ?#result)
Types: Mode checking foreign call {foreign lpvm cast(0:!_, ?#result)}
Types:     with assigned semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check exp 0:!_
Types: Mode check exp resulted in 0:!_
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr 0:!_
Types:   Type = wybe.bool
Types: Finding type of expr ?#result
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign lpvm cast(0:!wybe.bool, ?#result:wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'false'
Types: Mode checked body   : [{foreign lpvm cast(0:!wybe.bool, ?#result:wybe.bool)}]
Types: Vars defined by body: semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of false:
Types: 
Types: false > public {inline} (0 calls)
Types: 4: false(?#result:wybe.bool @bool:8:18):
Types:     foreign lpvm cast(0:!wybe.bool, ?#result:wybe.bool)
Types: Type checking non-recursive proc wybe.bool.^^
Types: ** Type checking decl of proc ^^
Types: found 1 definition(s)
Types: Type checking ^^
Types: ** Type checking ^^: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm xor(p @bool:25:44, q @bool:25:47, ?tmp#0 @bool:25:27)
Types:         foreign llvm move(tmp#0, ?#result @bool:25:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","p","q","tmp#0"]
Types: Recording parameter types: p:wybe.bool, q:wybe.bool, ?#result:wybe.bool
Types:     type of 'p' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable p type constrained to wybe.bool
Types:     type of 'q' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable q type constrained to wybe.bool
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm xor(p @bool:25:44, q @bool:25:47, ?tmp#0 @bool:25:27)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @bool:25:5)}
Types: Unifying move argument types tmp#0 and ?#result @bool:25:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @bool:25:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)
Types: Finding type of expr p @bool:25:44
Types:   Type = wybe.bool
Types: Finding type of expr q @bool:25:47
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:25:27
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call xor(1 bit unsigned, 1 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @bool:25:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc ^^
Types: bound vars: semipure normal (total) computation binding {p, q}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm xor(p @bool:25:44, q @bool:25:47, ?tmp#0 @bool:25:27)
Types: Mode checking foreign call {foreign llvm xor(p @bool:25:44, q @bool:25:47, ?tmp#0 @bool:25:27)}
Types:     with assigned semipure normal (total) computation binding {p, q}, break set = Everything, with resources {}
Types: Mode check exp p
Types: Mode check exp resulted in p
Types: Mode check exp q
Types: Mode check exp resulted in q
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr p @bool:25:44
Types:   Type = wybe.bool
Types: Finding type of expr q @bool:25:47
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:25:27
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm xor(p:wybe.bool @bool:25:44, q:wybe.bool @bool:25:47, ?tmp#0:wybe.bool @bool:25:27)}
Types: Now assigned = semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @bool:25:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @bool:25:5)}
Types:     with assigned semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @bool:25:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:25:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of Det proc '^^'
Types: Mode checked body   : [{foreign llvm xor(p:wybe.bool @bool:25:44, q:wybe.bool @bool:25:47, ?tmp#0:wybe.bool @bool:25:27)} @bool:25:27,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:25:5)} @bool:25:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, p, q, tmp#0}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of ^^:
Types: 
Types: ^^ > public (0 calls)
Types: 4: ^^(p:wybe.bool @bool:25:10, q:wybe.bool @bool:25:18, ?#result:wybe.bool @bool:25:5):
Types:     foreign llvm xor(p:wybe.bool @bool:25:44, q:wybe.bool @bool:25:47, ?tmp#0:wybe.bool @bool:25:27)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:25:5)
Types: Type checking non-recursive proc wybe.bool.=
Types: ** Type checking decl of proc =
Types: found 1 definition(s)
Types: Type checking =
Types: ** Type checking =: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_eq(x @bool:37:47, y @bool:37:50, ?tmp#0 @bool:37:26)
Types:         foreign llvm move(tmp#0, ?#result @bool:37:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.bool, y:wybe.bool, ?#result:wybe.bool
Types:     type of 'x' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable x type constrained to wybe.bool
Types:     type of 'y' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable y type constrained to wybe.bool
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_eq(x @bool:37:47, y @bool:37:50, ?tmp#0 @bool:37:26)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @bool:37:5)}
Types: Unifying move argument types tmp#0 and ?#result @bool:37:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @bool:37:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.bool, y::wybe.bool}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.bool, y::wybe.bool}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @bool:37:47
Types:   Type = wybe.bool
Types: Finding type of expr y @bool:37:50
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:37:26
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(1 bit unsigned, 1 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @bool:37:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc =
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(x @bool:37:47, y @bool:37:50, ?tmp#0 @bool:37:26)
Types: Mode checking foreign call {foreign llvm icmp_eq(x @bool:37:47, y @bool:37:50, ?tmp#0 @bool:37:26)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @bool:37:47
Types:   Type = wybe.bool
Types: Finding type of expr y @bool:37:50
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:37:26
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(x:wybe.bool @bool:37:47, y:wybe.bool @bool:37:50, ?tmp#0:wybe.bool @bool:37:26)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @bool:37:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @bool:37:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @bool:37:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:37:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '='
Types: Mode checked body   : [{foreign llvm icmp_eq(x:wybe.bool @bool:37:47, y:wybe.bool @bool:37:50, ?tmp#0:wybe.bool @bool:37:26)} @bool:37:26,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:37:5)} @bool:37:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of =:
Types: 
Types: = > public (0 calls)
Types: 4: =(x:wybe.bool @bool:37:10, y:wybe.bool @bool:37:17, ?#result:wybe.bool @bool:37:5):
Types:     foreign llvm icmp_eq(x:wybe.bool @bool:37:47, y:wybe.bool @bool:37:50, ?tmp#0:wybe.bool @bool:37:26)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:37:5)
Types: **** Type checking recursive procs wybe.c_string.=
Types: ** Type checking decl of proc =
Types: found 1 definition(s)
Types: Type checking =
Types: ** Type checking =: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c strcmp(x @c_string:10:46, y @c_string:10:48, ?tmp#1:int @c_string:10:29)
Types:         =(tmp#1:int, 0 @c_string:10:57, ?tmp#0 @c_string:10:29)
Types:         foreign llvm move(tmp#0, ?#result @c_string:10:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","tmp#1","x","y"]
Types: Recording parameter types: x:wybe.c_string, y:wybe.c_string, ?#result:wybe.bool
Types:     type of 'x' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable x type constrained to wybe.c_string
Types:     type of 'y' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable y type constrained to wybe.c_string
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign c strcmp(x @c_string:10:46, y @c_string:10:48, ?tmp#1:int @c_string:10:29)}
Types: Unifying types int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable tmp#1 type constrained to wybe.int
Types: Recording casts in {=(tmp#1:int, 0 @c_string:10:57, ?tmp#0 @c_string:10:29)}
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable tmp#1 type constrained to wybe.int
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @c_string:10:5)}
Types: Unifying move argument types tmp#0 and ?#result @c_string:10:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @c_string:10:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {=(tmp#1:int, 0 @c_string:10:57, ?tmp#0 @c_string:10:29)} @c_string:10:29, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types: Type checking call {=(tmp#1:int, 0 @c_string:10:57, ?tmp#0 @c_string:10:29)} @c_string:10:29
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types:     wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:10:57
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:10:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Actual types: [wybe.int,wybe.int,wybe.bool]
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 10, column 29): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 10, column 29): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 10, column 29): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 10, column 29): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 10, column 29): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 10, column 29): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Valid types = [Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @c_string:10:46
Types:   Type = wybe.c_string
Types: Finding type of expr y @c_string:10:48
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#1:int @c_string:10:29
Types:   Type = wybe.int
Types: Type checking foreign c call strcmp(address, address, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @c_string:10:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc =
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign c strcmp(x @c_string:10:46, y @c_string:10:48, ?tmp#1:int @c_string:10:29)
Types: Mode checking foreign call {foreign c strcmp(x @c_string:10:46, y @c_string:10:48, ?tmp#1:int @c_string:10:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#1:int
Types: Mode check exp resulted in ?tmp#1:int
Types: Finding type of expr x @c_string:10:46
Types:   Type = wybe.c_string
Types: Finding type of expr y @c_string:10:48
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#1:int @c_string:10:29
Types:   Type = wybe.int
Types:     types and modes = [wybe.c_string,wybe.c_string,?wybe.int]
Types: New instr = {foreign c strcmp(x:wybe.c_string @c_string:10:46, y:wybe.c_string @c_string:10:48, ?tmp#1:wybe.int @c_string:10:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt =(tmp#1:int, 0 @c_string:10:57, ?tmp#0 @c_string:10:29)
Types: Mode checking call   : {=(tmp#1:int, 0 @c_string:10:57, ?tmp#0 @c_string:10:29)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#1:int
Types: Mode check exp resulted in tmp#1:int
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:10:57
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:10:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     actual types     : [wybe.int,wybe.int,wybe.bool]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 10, column 29): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 10, column 29): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 10, column 29): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 10, column 29): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 10, column 29): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 10, column 29): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,wybe.int,wybe.bool] with wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Type-correct modes   : [(wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Possible mode matches: [(wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Exact mode matches: [(wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::wybe.int, x::wybe.c_string, y::wybe.c_string}; {0::wybe.bool} (with no errors))]
Types: Finding type of expr tmp#1:int
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:10:57
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @c_string:10:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finalising call    :  {wybe.int.<0>=(tmp#1:wybe.int, 0:wybe.int @c_string:10:57, ?tmp#0:wybe.bool @c_string:10:29)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"tmp#1", "x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>=(tmp#1:wybe.int, 0:wybe.int @c_string:10:57, ?tmp#0:wybe.bool @c_string:10:29)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '='
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @c_string:10:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @c_string:10:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @c_string:10:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:10:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '='
Types: Mode checked body   : [{foreign c strcmp(x:wybe.c_string @c_string:10:46, y:wybe.c_string @c_string:10:48, ?tmp#1:wybe.int @c_string:10:29)} @c_string:10:29,{wybe.int.<0>=(tmp#1:wybe.int, 0:wybe.int @c_string:10:57, ?tmp#0:wybe.bool @c_string:10:29)} @c_string:10:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:10:5)} @c_string:10:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of =:
Types: 
Types: = > public (0 calls)
Types: 4: =(x:wybe.c_string @c_string:10:10, y:wybe.c_string @c_string:10:17, ?#result:wybe.bool @c_string:10:5):
Types:     foreign c strcmp(x:wybe.c_string @c_string:10:46, y:wybe.c_string @c_string:10:48, ?tmp#1:wybe.int @c_string:10:29)
Types:     wybe.int.<0>=(tmp#1:wybe.int, 0:wybe.int @c_string:10:57, ?tmp#0:wybe.bool @c_string:10:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:10:5)
Types: **** Completed checking of wybe.c_string.= with 0 errors
Types: Type checking non-recursive proc wybe.bool.^=
Types: ** Type checking decl of proc ^=
Types: found 1 definition(s)
Types: Type checking ^=
Types: ** Type checking ^=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         ^^(q @bool:28:31, p @bool:28:37, ?tmp#0 @bool:28:31)
Types:         =(?p @bool:28:27, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["p","q","tmp#0"]
Types: Recording parameter types: !p:wybe.bool, q:wybe.bool
Types:     type of 'p' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable p type constrained to wybe.bool
Types:     type of 'q' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable q type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {^^(q @bool:28:31, p @bool:28:37, ?tmp#0 @bool:28:31)}
Types: Recording casts in {=(?p @bool:28:27, tmp#0)}
Types: *** Before calls Typing {p::wybe.bool, q::wybe.bool}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {^^(q @bool:28:31, p @bool:28:37, ?tmp#0 @bool:28:31)} @bool:28:31, typingInfos = [wybe.bool.^^<0>(wybe.bool,wybe.bool,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {=(?p @bool:28:27, tmp#0)} @bool:28:27, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool)]}Typing {p::wybe.bool, q::wybe.bool}; {} (with no errors)
Types: Type checking call {^^(q @bool:28:31, p @bool:28:37, ?tmp#0 @bool:28:31)} @bool:28:31
Types: Candidate types:
Types:     wybe.bool.^^<0>(wybe.bool,wybe.bool,?wybe.bool)
Types: Finding type of expr q @bool:28:31
Types:   Type = wybe.bool
Types: Finding type of expr p @bool:28:37
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:28:31
Types:   Type = 0
Types: Actual types: [wybe.bool,wybe.bool,0]
Types: Matching types [wybe.bool,wybe.bool,0] with wybe.bool.^^<0>(wybe.bool,wybe.bool,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Valid types = [Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)]
Types: Resulting typing = Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)
Types: Type checking call {=(?p @bool:28:27, tmp#0)} @bool:28:27
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types: Finding type of expr ?p @bool:28:27
Types:   Type = wybe.bool
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Actual types: [wybe.bool,wybe.bool]
Types: Matching types [wybe.bool,wybe.bool] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.bool,wybe.bool] with {test} wybe.c_string.=<0>(wybe.c_string,wybe.c_string)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/bool.wybe" (line 28, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/bool.wybe" (line 28, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)]
Types: Resulting typing = Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)
Types: Now mode checking proc ^=
Types: bound vars: semipure normal (total) computation binding {p, q}, break set = Everything, with resources {}
Types: Mode check stmt ^^(q @bool:28:31, p @bool:28:37, ?tmp#0 @bool:28:31)
Types: Mode checking call   : {^^(q @bool:28:31, p @bool:28:37, ?tmp#0 @bool:28:31)}
Types:     with assigned    : semipure normal (total) computation binding {p, q}, break set = Everything, with resources {}
Types: Mode check exp q
Types: Mode check exp resulted in q
Types: Mode check exp p
Types: Mode check exp resulted in p
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr q @bool:28:31
Types:   Type = wybe.bool
Types: Finding type of expr p @bool:28:37
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:28:31
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     actual types     : [wybe.bool,wybe.bool,wybe.bool]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.bool,wybe.bool,wybe.bool] with wybe.bool.^^<0>(wybe.bool,wybe.bool,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Type-correct modes   : [(wybe.bool.^^<0>(wybe.bool,wybe.bool,?wybe.bool),Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors))]
Types: Possible mode matches: [(wybe.bool.^^<0>(wybe.bool,wybe.bool,?wybe.bool),Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors))]
Types: Exact mode matches: [(wybe.bool.^^<0>(wybe.bool,wybe.bool,?wybe.bool),Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors))]
Types: Finding type of expr q @bool:28:31
Types:   Type = wybe.bool
Types: Finding type of expr p @bool:28:37
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:28:31
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finalising call    :  {wybe.bool.<0>^^(q:wybe.bool @bool:28:31, p:wybe.bool @bool:28:37, ?tmp#0:wybe.bool @bool:28:31)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"p", "q"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.bool.<0>^^(q:wybe.bool @bool:28:31, p:wybe.bool @bool:28:37, ?tmp#0:wybe.bool @bool:28:31)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '^='
Types: Now assigned = semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt =(?p @bool:28:27, tmp#0)
Types: Mode checking call   : {=(?p @bool:28:27, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp ?p
Types: Mode check exp resulted in ?p
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?p @bool:28:27
Types:   Type = wybe.bool
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     actual types     : [wybe.bool,wybe.bool]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.bool,wybe.bool] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.bool,wybe.bool] with {test} wybe.c_string.=<0>(wybe.c_string,wybe.c_string)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/bool.wybe" (line 28, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/bool.wybe" (line 28, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.bool.=<0>(wybe.bool,wybe.bool),Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?p @bool:28:27)}
Types:     with assigned semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?p
Types: Mode check exp resulted in ?p
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?p @bool:28:27
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?p:wybe.bool @bool:28:27)}
Types: Now assigned = semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of Det proc '^='
Types: Mode checked body   : [{wybe.bool.<0>^^(q:wybe.bool @bool:28:31, p:wybe.bool @bool:28:37, ?tmp#0:wybe.bool @bool:28:31)} @bool:28:31,{foreign llvm move(tmp#0:wybe.bool, ?p:wybe.bool @bool:28:27)} @bool:28:27]
Types: Vars defined by body: semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Output parameters   : p
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of ^=:
Types: 
Types: ^= > public (0 calls)
Types: 4: ^=(!p:wybe.bool @bool:28:11, q:wybe.bool @bool:28:19):
Types:     wybe.bool.<0>^^(q:wybe.bool @bool:28:31, p:wybe.bool @bool:28:37, ?tmp#0:wybe.bool @bool:28:31)
Types:     foreign llvm move(tmp#0:wybe.bool, ?p:wybe.bool @bool:28:27)
Types: Type checking non-recursive proc wybe.bool.|=
Types: ** Type checking decl of proc |=
Types: found 1 definition(s)
Types: Type checking |=
Types: ** Type checking |=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         ||(p @bool:22:32, q @bool:22:38, ?tmp#0 @bool:22:32)
Types:         =(?p @bool:22:27, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["p","q","tmp#0"]
Types: Recording parameter types: !p:wybe.bool, q:wybe.bool
Types:     type of 'p' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable p type constrained to wybe.bool
Types:     type of 'q' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable q type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {||(p @bool:22:32, q @bool:22:38, ?tmp#0 @bool:22:32)}
Types: Recording casts in {=(?p @bool:22:27, tmp#0)}
Types: *** Before calls Typing {p::wybe.bool, q::wybe.bool}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {||(p @bool:22:32, q @bool:22:38, ?tmp#0 @bool:22:32)} @bool:22:32, typingInfos = [wybe.bool.||<0>(wybe.bool,wybe.bool,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {=(?p @bool:22:27, tmp#0)} @bool:22:27, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool)]}Typing {p::wybe.bool, q::wybe.bool}; {} (with no errors)
Types: Type checking call {||(p @bool:22:32, q @bool:22:38, ?tmp#0 @bool:22:32)} @bool:22:32
Types: Candidate types:
Types:     wybe.bool.||<0>(wybe.bool,wybe.bool,?wybe.bool)
Types: Finding type of expr p @bool:22:32
Types:   Type = wybe.bool
Types: Finding type of expr q @bool:22:38
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:22:32
Types:   Type = 0
Types: Actual types: [wybe.bool,wybe.bool,0]
Types: Matching types [wybe.bool,wybe.bool,0] with wybe.bool.||<0>(wybe.bool,wybe.bool,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Valid types = [Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)]
Types: Resulting typing = Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)
Types: Type checking call {=(?p @bool:22:27, tmp#0)} @bool:22:27
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types: Finding type of expr ?p @bool:22:27
Types:   Type = wybe.bool
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Actual types: [wybe.bool,wybe.bool]
Types: Matching types [wybe.bool,wybe.bool] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.bool,wybe.bool] with {test} wybe.c_string.=<0>(wybe.c_string,wybe.c_string)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/bool.wybe" (line 22, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/bool.wybe" (line 22, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)]
Types: Resulting typing = Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)
Types: Now mode checking proc |=
Types: bound vars: semipure normal (total) computation binding {p, q}, break set = Everything, with resources {}
Types: Mode check stmt ||(p @bool:22:32, q @bool:22:38, ?tmp#0 @bool:22:32)
Types: Mode checking call   : {||(p @bool:22:32, q @bool:22:38, ?tmp#0 @bool:22:32)}
Types:     with assigned    : semipure normal (total) computation binding {p, q}, break set = Everything, with resources {}
Types: Mode check exp p
Types: Mode check exp resulted in p
Types: Mode check exp q
Types: Mode check exp resulted in q
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr p @bool:22:32
Types:   Type = wybe.bool
Types: Finding type of expr q @bool:22:38
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:22:32
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     actual types     : [wybe.bool,wybe.bool,wybe.bool]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.bool,wybe.bool,wybe.bool] with wybe.bool.||<0>(wybe.bool,wybe.bool,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Type-correct modes   : [(wybe.bool.||<0>(wybe.bool,wybe.bool,?wybe.bool),Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors))]
Types: Possible mode matches: [(wybe.bool.||<0>(wybe.bool,wybe.bool,?wybe.bool),Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors))]
Types: Exact mode matches: [(wybe.bool.||<0>(wybe.bool,wybe.bool,?wybe.bool),Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors))]
Types: Finding type of expr p @bool:22:32
Types:   Type = wybe.bool
Types: Finding type of expr q @bool:22:38
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:22:32
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finalising call    :  {wybe.bool.<0>||(p:wybe.bool @bool:22:32, q:wybe.bool @bool:22:38, ?tmp#0:wybe.bool @bool:22:32)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"p", "q"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.bool.<0>||(p:wybe.bool @bool:22:32, q:wybe.bool @bool:22:38, ?tmp#0:wybe.bool @bool:22:32)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '|='
Types: Now assigned = semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt =(?p @bool:22:27, tmp#0)
Types: Mode checking call   : {=(?p @bool:22:27, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp ?p
Types: Mode check exp resulted in ?p
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?p @bool:22:27
Types:   Type = wybe.bool
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     actual types     : [wybe.bool,wybe.bool]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.bool,wybe.bool] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.bool,wybe.bool] with {test} wybe.c_string.=<0>(wybe.c_string,wybe.c_string)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/bool.wybe" (line 22, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/bool.wybe" (line 22, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.bool.=<0>(wybe.bool,wybe.bool),Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?p @bool:22:27)}
Types:     with assigned semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?p
Types: Mode check exp resulted in ?p
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?p @bool:22:27
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?p:wybe.bool @bool:22:27)}
Types: Now assigned = semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of Det proc '|='
Types: Mode checked body   : [{wybe.bool.<0>||(p:wybe.bool @bool:22:32, q:wybe.bool @bool:22:38, ?tmp#0:wybe.bool @bool:22:32)} @bool:22:32,{foreign llvm move(tmp#0:wybe.bool, ?p:wybe.bool @bool:22:27)} @bool:22:27]
Types: Vars defined by body: semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Output parameters   : p
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of |=:
Types: 
Types: |= > public (0 calls)
Types: 4: |=(!p:wybe.bool @bool:22:11, q:wybe.bool @bool:22:19):
Types:     wybe.bool.<0>||(p:wybe.bool @bool:22:32, q:wybe.bool @bool:22:38, ?tmp#0:wybe.bool @bool:22:32)
Types:     foreign llvm move(tmp#0:wybe.bool, ?p:wybe.bool @bool:22:27)
Types: Type checking non-recursive proc wybe.c_string.[]
Types: ** Type checking decl of proc []
Types: found 1 definition(s)
Types: Type checking []
Types: ** Type checking []: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         <=(0 @c_string:27:6, idx @c_string:27:12)
Types:         length(str @c_string:28:19, ?tmp#0 @c_string:28:12)
Types:         <(idx @c_string:28:6, tmp#0)
Types:         unsafe_c_string_index(str @c_string:29:32, idx @c_string:29:37, ?tmp#1 @c_string:29:10)
Types:         =(?c @c_string:29:6, tmp#1)
Types:         foreign llvm move(c @c_string:26:42, ?#result @c_string:26:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","c","idx","str","tmp#0","tmp#1"]
Types: Recording parameter types: str:wybe.c_string, idx:wybe.int, ?#result:wybe.char
Types:     type of 'str' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable str type constrained to wybe.c_string
Types:     type of 'idx' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable idx type constrained to wybe.int
Types:     type of '#result' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable #result type constrained to wybe.char
Types: Recording resource types: 
Types: Recording casts in {<=(0 @c_string:27:6, idx @c_string:27:12)}
Types: Recording casts in {length(str @c_string:28:19, ?tmp#0 @c_string:28:12)}
Types: Recording casts in {<(idx @c_string:28:6, tmp#0)}
Types: Recording casts in {unsafe_c_string_index(str @c_string:29:32, idx @c_string:29:37, ?tmp#1 @c_string:29:10)}
Types: Recording casts in {=(?c @c_string:29:6, tmp#1)}
Types: Recording casts in {foreign llvm move(c @c_string:26:42, ?#result @c_string:26:5)}
Types: Unifying move argument types c @c_string:26:42 and ?#result @c_string:26:5
Types: Finding type of expr c @c_string:26:42
Types:   Type = 0
Types: Finding type of expr ?#result @c_string:26:5
Types:   Type = wybe.char
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: *** Before calls Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string}; {0::wybe.char} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {<=(0 @c_string:27:6, idx @c_string:27:12)} @c_string:27:6, typingInfos = [wybe.c_string.<=<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.<=<0>(wybe.char,wybe.char,?wybe.bool),wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {length(str @c_string:28:19, ?tmp#0 @c_string:28:12)} @c_string:28:12, typingInfos = [wybe.c_string.length<0>(wybe.c_string,?wybe.int)]}
Types:     StmtTypings {typingStmt = {<(idx @c_string:28:6, tmp#0)} @c_string:28:6, typingInfos = [wybe.c_string.<<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.<<0>(wybe.char,wybe.char,?wybe.bool),wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {unsafe_c_string_index(str @c_string:29:32, idx @c_string:29:37, ?tmp#1 @c_string:29:10)} @c_string:29:10, typingInfos = [wybe.c_string.unsafe_c_string_index<0>(wybe.c_string,wybe.int,?wybe.char)]}
Types:     StmtTypings {typingStmt = {=(?c @c_string:29:6, tmp#1)} @c_string:29:6, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string}; {0::wybe.char} (with no errors)
Types: Type checking call {<=(0 @c_string:27:6, idx @c_string:27:12)} @c_string:27:6
Types: Candidate types:
Types:     wybe.c_string.<=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types:     wybe.char.<=<0>(wybe.char,wybe.char,?wybe.bool)
Types:     wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr 0 @c_string:27:6
Types:   Type = wybe.int
Types: Finding type of expr idx @c_string:27:12
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.c_string.<=<0>(wybe.c_string,wybe.c_string)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 27, column 6): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 27, column 6): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.char.<=<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 27, column 6): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 27, column 6): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string}; {0::wybe.char} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string}; {0::wybe.char} (with no errors)
Types: Type checking call {length(str @c_string:28:19, ?tmp#0 @c_string:28:12)} @c_string:28:12
Types: Candidate types:
Types:     wybe.c_string.length<0>(wybe.c_string,?wybe.int)
Types: Finding type of expr str @c_string:28:19
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#0 @c_string:28:12
Types:   Type = 1
Types: Actual types: [wybe.c_string,1]
Types: Matching types [wybe.c_string,1] with wybe.c_string.length<0>(wybe.c_string,?wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.c_string (-> wybe.c_string) and wybe.c_string (-> wybe.c_string)
Types:   Unification yields wybe.c_string
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1}; {0::wybe.char, 1::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1}; {0::wybe.char, 1::wybe.int} (with no errors)
Types: Type checking call {<(idx @c_string:28:6, tmp#0)} @c_string:28:6
Types: Candidate types:
Types:     wybe.c_string.<<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types:     wybe.char.<<0>(wybe.char,wybe.char,?wybe.bool)
Types:     wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr idx @c_string:28:6
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.c_string.<<0>(wybe.c_string,wybe.c_string)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 28, column 6): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 28, column 6): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.char.<<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 28, column 6): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 28, column 6): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1}; {0::wybe.char, 1::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1}; {0::wybe.char, 1::wybe.int} (with no errors)
Types: Type checking call {unsafe_c_string_index(str @c_string:29:32, idx @c_string:29:37, ?tmp#1 @c_string:29:10)} @c_string:29:10
Types: Candidate types:
Types:     wybe.c_string.unsafe_c_string_index<0>(wybe.c_string,wybe.int,?wybe.char)
Types: Finding type of expr str @c_string:29:32
Types:   Type = wybe.c_string
Types: Finding type of expr idx @c_string:29:37
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @c_string:29:10
Types:   Type = 2
Types: Actual types: [wybe.c_string,wybe.int,2]
Types: Matching types [wybe.c_string,wybe.int,2] with wybe.c_string.unsafe_c_string_index<0>(wybe.c_string,wybe.int,?wybe.char)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.c_string (-> wybe.c_string) and wybe.c_string (-> wybe.c_string)
Types:   Unification yields wybe.c_string
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 2 is bound to Nothing
Types: Unifying types 2 (-> 2) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Valid types = [Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1, tmp#1::2}; {0::wybe.char, 1::wybe.int, 2::wybe.char} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1, tmp#1::2}; {0::wybe.char, 1::wybe.int, 2::wybe.char} (with no errors)
Types: Type checking call {=(?c @c_string:29:6, tmp#1)} @c_string:29:6
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types:     wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?c @c_string:29:6
Types: Type variable 0 is bound to Just wybe.char
Types:   Type = wybe.char
Types: Finding type of expr tmp#1
Types: Type variable 2 is bound to Just wybe.char
Types:   Type = wybe.char
Types: Actual types: [wybe.char,wybe.char]
Types: Matching types [wybe.char,wybe.char] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 29, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.char (-> wybe.char) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 29, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.char,wybe.char] with {test} wybe.c_string.=<0>(wybe.c_string,wybe.c_string)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 29, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.char (-> wybe.char) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 29, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.char,wybe.char] with {test} wybe.char.=<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Unifying types wybe.char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Matching types [wybe.char,wybe.char] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 29, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.char (-> wybe.char) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 29, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1, tmp#1::2}; {0::wybe.char, 1::wybe.int, 2::wybe.char} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1, tmp#1::2}; {0::wybe.char, 1::wybe.int, 2::wybe.char} (with no errors)
Types: Finding type of expr c @c_string:26:42
Types: Type variable 0 is bound to Just wybe.char
Types:   Type = wybe.char
Types: Finding type of expr ?#result @c_string:26:5
Types:   Type = wybe.char
Types: Type checking foreign llvm call move(8 bit unsigned, 8 bit unsigned)
Types: Now mode checking proc []
Types: bound vars: semipure normal (total) computation binding {idx, str}, break set = Everything, with resources {}
Types: Mode check stmt <=(0 @c_string:27:6, idx @c_string:27:12)
Types: Mode checking call   : {<=(0 @c_string:27:6, idx @c_string:27:12)}
Types:     with assigned    : semipure normal (total) computation binding {idx, str}, break set = Everything, with resources {}
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp idx
Types: Mode check exp resulted in idx
Types: Finding type of expr 0 @c_string:27:6
Types:   Type = wybe.int
Types: Finding type of expr idx @c_string:27:12
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.c_string.<=<0>(wybe.c_string,wybe.c_string)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 27, column 6): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 27, column 6): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.char.<=<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 27, column 6): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 27, column 6): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1, tmp#1::2}; {0::wybe.char, 1::wybe.int, 2::wybe.char} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1, tmp#1::2}; {0::wybe.char, 1::wybe.int, 2::wybe.char} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1, tmp#1::2}; {0::wybe.char, 1::wybe.int, 2::wybe.char} (with no errors))]
Types: Finding type of expr 0 @c_string:27:6
Types:   Type = wybe.int
Types: Finding type of expr idx @c_string:27:12
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0><=(0:wybe.int @c_string:27:6, idx:wybe.int @c_string:27:12)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"idx", "str"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0><=(0:wybe.int @c_string:27:6, idx:wybe.int @c_string:27:12)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '[]'
Types: Now assigned = semipure test computation binding {idx, str}, break set = Everything, with resources {}
Types: Mode check stmt length(str @c_string:28:19, ?tmp#0 @c_string:28:12)
Types: Mode checking call   : {length(str @c_string:28:19, ?tmp#0 @c_string:28:12)}
Types:     with assigned    : semipure test computation binding {idx, str}, break set = Everything, with resources {}
Types: Mode check exp str
Types: Mode check exp resulted in str
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr str @c_string:28:19
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#0 @c_string:28:12
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.c_string,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.c_string,wybe.int] with wybe.c_string.length<0>(wybe.c_string,?wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.c_string (-> wybe.c_string) and wybe.c_string (-> wybe.c_string)
Types:   Unification yields wybe.c_string
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.c_string.length<0>(wybe.c_string,?wybe.int),Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1, tmp#1::2}; {0::wybe.char, 1::wybe.int, 2::wybe.char} (with no errors))]
Types: Possible mode matches: [(wybe.c_string.length<0>(wybe.c_string,?wybe.int),Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1, tmp#1::2}; {0::wybe.char, 1::wybe.int, 2::wybe.char} (with no errors))]
Types: Exact mode matches: [(wybe.c_string.length<0>(wybe.c_string,?wybe.int),Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1, tmp#1::2}; {0::wybe.char, 1::wybe.int, 2::wybe.char} (with no errors))]
Types: Finding type of expr str @c_string:28:19
Types:   Type = wybe.c_string
Types: Finding type of expr ?tmp#0 @c_string:28:12
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.c_string.<0>length(str:wybe.c_string @c_string:28:19, ?tmp#0:wybe.int @c_string:28:12)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"idx", "str"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.c_string.<0>length(str:wybe.c_string @c_string:28:19, ?tmp#0:wybe.int @c_string:28:12)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '[]'
Types: Now assigned = semipure test computation binding {idx, str, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt <(idx @c_string:28:6, tmp#0)
Types: Mode checking call   : {<(idx @c_string:28:6, tmp#0)}
Types:     with assigned    : semipure test computation binding {idx, str, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp idx
Types: Mode check exp resulted in idx
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr idx @c_string:28:6
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.c_string.<<0>(wybe.c_string,wybe.c_string)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 28, column 6): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 28, column 6): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.char.<<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 28, column 6): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 28, column 6): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.<<0>(wybe.int,wybe.int),Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1, tmp#1::2}; {0::wybe.char, 1::wybe.int, 2::wybe.char} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.<<0>(wybe.int,wybe.int),Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1, tmp#1::2}; {0::wybe.char, 1::wybe.int, 2::wybe.char} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.<<0>(wybe.int,wybe.int),Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1, tmp#1::2}; {0::wybe.char, 1::wybe.int, 2::wybe.char} (with no errors))]
Types: Finding type of expr idx @c_string:28:6
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0><(idx:wybe.int @c_string:28:6, tmp#0:wybe.int)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"idx", "str", "tmp#0"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0><(idx:wybe.int @c_string:28:6, tmp#0:wybe.int)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '[]'
Types: Now assigned = semipure test computation binding {idx, str, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt unsafe_c_string_index(str @c_string:29:32, idx @c_string:29:37, ?tmp#1 @c_string:29:10)
Types: Mode checking call   : {unsafe_c_string_index(str @c_string:29:32, idx @c_string:29:37, ?tmp#1 @c_string:29:10)}
Types:     with assigned    : semipure test computation binding {idx, str, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp str
Types: Mode check exp resulted in str
Types: Mode check exp idx
Types: Mode check exp resulted in idx
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr str @c_string:29:32
Types:   Type = wybe.c_string
Types: Finding type of expr idx @c_string:29:37
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @c_string:29:10
Types: Type variable 2 is bound to Just wybe.char
Types:   Type = wybe.char
Types:     actual types     : [wybe.c_string,wybe.int,wybe.char]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.c_string,wybe.int,wybe.char] with wybe.c_string.unsafe_c_string_index<0>(wybe.c_string,wybe.int,?wybe.char)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.c_string (-> wybe.c_string) and wybe.c_string (-> wybe.c_string)
Types:   Unification yields wybe.c_string
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Type-correct modes   : [(wybe.c_string.unsafe_c_string_index<0>(wybe.c_string,wybe.int,?wybe.char),Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1, tmp#1::2}; {0::wybe.char, 1::wybe.int, 2::wybe.char} (with no errors))]
Types: Possible mode matches: [(wybe.c_string.unsafe_c_string_index<0>(wybe.c_string,wybe.int,?wybe.char),Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1, tmp#1::2}; {0::wybe.char, 1::wybe.int, 2::wybe.char} (with no errors))]
Types: Exact mode matches: [(wybe.c_string.unsafe_c_string_index<0>(wybe.c_string,wybe.int,?wybe.char),Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1, tmp#1::2}; {0::wybe.char, 1::wybe.int, 2::wybe.char} (with no errors))]
Types: Finding type of expr str @c_string:29:32
Types:   Type = wybe.c_string
Types: Finding type of expr idx @c_string:29:37
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @c_string:29:10
Types: Type variable 2 is bound to Just wybe.char
Types:   Type = wybe.char
Types: Finalising call    :  {wybe.c_string.<0>unsafe_c_string_index(str:wybe.c_string @c_string:29:32, idx:wybe.int @c_string:29:37, ?tmp#1:wybe.char @c_string:29:10)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"idx", "str", "tmp#0"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.c_string.<0>unsafe_c_string_index(str:wybe.c_string @c_string:29:32, idx:wybe.int @c_string:29:37, ?tmp#1:wybe.char @c_string:29:10)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '[]'
Types: Now assigned = semipure test computation binding {idx, str, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check stmt =(?c @c_string:29:6, tmp#1)
Types: Mode checking call   : {=(?c @c_string:29:6, tmp#1)}
Types:     with assigned    : semipure test computation binding {idx, str, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp ?c
Types: Mode check exp resulted in ?c
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Finding type of expr ?c @c_string:29:6
Types: Type variable 0 is bound to Just wybe.char
Types:   Type = wybe.char
Types: Finding type of expr tmp#1
Types: Type variable 2 is bound to Just wybe.char
Types:   Type = wybe.char
Types:     actual types     : [wybe.char,wybe.char]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.char,wybe.char] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 29, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.char (-> wybe.char) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 29, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.char,wybe.char] with {test} wybe.c_string.=<0>(wybe.c_string,wybe.c_string)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 29, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.char (-> wybe.char) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 29, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.char,wybe.char] with {test} wybe.char.=<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Unifying types wybe.char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Matching types [wybe.char,wybe.char] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 29, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.char (-> wybe.char) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 29, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.char.=<0>(wybe.char,wybe.char),Typing {#result::wybe.char, c::0, idx::wybe.int, str::wybe.c_string, tmp#0::1, tmp#1::2}; {0::wybe.char, 1::wybe.int, 2::wybe.char} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#1, ?c @c_string:29:6)}
Types:     with assigned semipure test computation binding {idx, str, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp ?c
Types: Mode check exp resulted in ?c
Types: Finding type of expr tmp#1
Types: Type variable 2 is bound to Just wybe.char
Types:   Type = wybe.char
Types: Finding type of expr ?c @c_string:29:6
Types: Type variable 0 is bound to Just wybe.char
Types:   Type = wybe.char
Types:     types and modes = [wybe.char,?wybe.char]
Types: New instr = {foreign llvm move(tmp#1:wybe.char, ?c:wybe.char @c_string:29:6)}
Types: Now assigned = semipure test computation binding {c, idx, str, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(c @c_string:26:42, ?#result @c_string:26:5)
Types: Mode checking foreign call {foreign llvm move(c @c_string:26:42, ?#result @c_string:26:5)}
Types:     with assigned semipure test computation binding {c, idx, str, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp c
Types: Mode check exp resulted in c
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr c @c_string:26:42
Types: Type variable 0 is bound to Just wybe.char
Types:   Type = wybe.char
Types: Finding type of expr ?#result @c_string:26:5
Types:   Type = wybe.char
Types:     types and modes = [wybe.char,?wybe.char]
Types: New instr = {foreign llvm move(c:wybe.char @c_string:26:42, ?#result:wybe.char @c_string:26:5)}
Types: Now assigned = semipure test computation binding {#result, c, idx, str, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc '[]'
Types: Mode checked body   : [{wybe.int.<0><=(0:wybe.int @c_string:27:6, idx:wybe.int @c_string:27:12)} @c_string:27:6,{wybe.c_string.<0>length(str:wybe.c_string @c_string:28:19, ?tmp#0:wybe.int @c_string:28:12)} @c_string:28:12,{wybe.int.<0><(idx:wybe.int @c_string:28:6, tmp#0:wybe.int)} @c_string:28:6,{wybe.c_string.<0>unsafe_c_string_index(str:wybe.c_string @c_string:29:32, idx:wybe.int @c_string:29:37, ?tmp#1:wybe.char @c_string:29:10)} @c_string:29:10,{foreign llvm move(tmp#1:wybe.char, ?c:wybe.char @c_string:29:6)} @c_string:29:6,{foreign llvm move(c:wybe.char @c_string:26:42, ?#result:wybe.char @c_string:26:5)} @c_string:26:5]
Types: Vars defined by body: semipure test computation binding {#result, c, idx, str, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of []:
Types: 
Types: [] > public {test} (0 calls)
Types: 4: [](str:wybe.c_string @c_string:26:19, idx:wybe.int @c_string:26:26, ?#result:wybe.char @c_string:26:5):
Types:     wybe.int.<0><=(0:wybe.int @c_string:27:6, idx:wybe.int @c_string:27:12)
Types:     wybe.c_string.<0>length(str:wybe.c_string @c_string:28:19, ?tmp#0:wybe.int @c_string:28:12)
Types:     wybe.int.<0><(idx:wybe.int @c_string:28:6, tmp#0:wybe.int)
Types:     wybe.c_string.<0>unsafe_c_string_index(str:wybe.c_string @c_string:29:32, idx:wybe.int @c_string:29:37, ?tmp#1:wybe.char @c_string:29:10)
Types:     foreign llvm move(tmp#1:wybe.char, ?c:wybe.char @c_string:29:6)
Types:     foreign llvm move(c:wybe.char @c_string:26:42, ?#result:wybe.char @c_string:26:5)
Types: Type checking non-recursive proc wybe.c_string.[|]
Types: ** Type checking decl of proc [|]
Types: found 1 definition(s)
Types: Type checking [|]
Types: ** Type checking [|]: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm access(str @c_string:20:25, 0 @c_string:20:30, 0 @c_string:20:33, 0 @c_string:20:36, ?head @c_string:20:40)
Types:         foreign llvm icmp_ne(head @c_string:21:26, '\NUL' @c_string:21:32, ?not_done @c_string:21:37)
Types:         true(?tmp#0 @c_string:22:17)
Types:         =(not_done @c_string:22:6, tmp#0)
Types:         foreign llvm add(str @c_string:23:22, 1 @c_string:23:27, ?tail @c_string:23:31)
Types:    and defaults: 
Types:    with assigned vars: fromList ["head","not_done","str","tail","tmp#0"]
Types: Recording parameter types: ?head:wybe.char, ?tail:wybe.c_string, str:wybe.c_string
Types:     type of 'head' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable head type constrained to wybe.char
Types:     type of 'tail' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable tail type constrained to wybe.c_string
Types:     type of 'str' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable str type constrained to wybe.c_string
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm access(str @c_string:20:25, 0 @c_string:20:30, 0 @c_string:20:33, 0 @c_string:20:36, ?head @c_string:20:40)}
Types: Recording casts in {foreign llvm icmp_ne(head @c_string:21:26, '\NUL' @c_string:21:32, ?not_done @c_string:21:37)}
Types: Recording casts in {true(?tmp#0 @c_string:22:17)}
Types: Recording casts in {=(not_done @c_string:22:6, tmp#0)}
Types: Recording casts in {foreign llvm add(str @c_string:23:22, 1 @c_string:23:27, ?tail @c_string:23:31)}
Types: *** Before calls Typing {head::wybe.char, str::wybe.c_string, tail::wybe.c_string}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {true(?tmp#0 @c_string:22:17)} @c_string:22:17, typingInfos = [wybe.bool.true<0>(?wybe.bool)]}
Types:     StmtTypings {typingStmt = {=(not_done @c_string:22:6, tmp#0)} @c_string:22:6, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {head::wybe.char, str::wybe.c_string, tail::wybe.c_string}; {} (with no errors)
Types: Type checking call {true(?tmp#0 @c_string:22:17)} @c_string:22:17
Types: Candidate types:
Types:     wybe.bool.true<0>(?wybe.bool)
Types: Finding type of expr ?tmp#0 @c_string:22:17
Types:   Type = 0
Types: Actual types: [0]
Types: Matching types [0] with wybe.bool.true<0>(?wybe.bool)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Valid types = [Typing {head::wybe.char, str::wybe.c_string, tail::wybe.c_string, tmp#0::0}; {0::wybe.bool} (with no errors)]
Types: Resulting typing = Typing {head::wybe.char, str::wybe.c_string, tail::wybe.c_string, tmp#0::0}; {0::wybe.bool} (with no errors)
Types: Type checking call {=(not_done @c_string:22:6, tmp#0)} @c_string:22:6
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types:     wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr not_done @c_string:22:6
Types:   Type = 1
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Actual types: [1,wybe.bool]
Types: Matching types [1,wybe.bool] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [1,wybe.bool] with {test} wybe.c_string.=<0>(wybe.c_string,wybe.c_string)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.c_string (-> wybe.c_string)
Types:   Unification yields wybe.c_string
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 22, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [1,wybe.bool] with {test} wybe.char.=<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 22, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [1,wybe.bool] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 22, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {head::wybe.char, not_done::1, str::wybe.c_string, tail::wybe.c_string, tmp#0::0}; {0::wybe.bool, 1::wybe.bool} (with no errors)]
Types: Resulting typing = Typing {head::wybe.char, not_done::1, str::wybe.c_string, tail::wybe.c_string, tmp#0::0}; {0::wybe.bool, 1::wybe.bool} (with no errors)
Types: Finding type of expr str @c_string:20:25
Types:   Type = wybe.c_string
Types: Finding type of expr 0 @c_string:20:30
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:20:33
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:20:36
Types:   Type = wybe.int
Types: Finding type of expr ?head @c_string:20:40
Types:   Type = wybe.char
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, 8 bit unsigned)
Types: Finding type of expr head @c_string:21:26
Types:   Type = wybe.char
Types: Finding type of expr '\NUL' @c_string:21:32
Types:   Type = wybe.char
Types: Finding type of expr ?not_done @c_string:21:37
Types: Type variable 1 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_ne(8 bit unsigned, 8 bit unsigned, 1 bit unsigned)
Types: Finding type of expr str @c_string:23:22
Types:   Type = wybe.c_string
Types: Finding type of expr 1 @c_string:23:27
Types:   Type = wybe.int
Types: Finding type of expr ?tail @c_string:23:31
Types:   Type = wybe.c_string
Types: Type checking foreign llvm call add(address, 64 bit signed, address)
Types: Now mode checking proc [|]
Types: bound vars: semipure normal (total) computation binding {str}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(str @c_string:20:25, 0 @c_string:20:30, 0 @c_string:20:33, 0 @c_string:20:36, ?head @c_string:20:40)
Types: Mode checking foreign call {foreign lpvm access(str @c_string:20:25, 0 @c_string:20:30, 0 @c_string:20:33, 0 @c_string:20:36, ?head @c_string:20:40)}
Types:     with assigned semipure normal (total) computation binding {str}, break set = Everything, with resources {}
Types: Mode check exp str
Types: Mode check exp resulted in str
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?head
Types: Mode check exp resulted in ?head
Types: Finding type of expr str @c_string:20:25
Types:   Type = wybe.c_string
Types: Finding type of expr 0 @c_string:20:30
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:20:33
Types:   Type = wybe.int
Types: Finding type of expr 0 @c_string:20:36
Types:   Type = wybe.int
Types: Finding type of expr ?head @c_string:20:40
Types:   Type = wybe.char
Types:     types and modes = [wybe.c_string,wybe.int,wybe.int,wybe.int,?wybe.char]
Types: New instr = {foreign lpvm access(str:wybe.c_string @c_string:20:25, 0:wybe.int @c_string:20:30, 0:wybe.int @c_string:20:33, 0:wybe.int @c_string:20:36, ?head:wybe.char @c_string:20:40)}
Types: Now assigned = semipure normal (total) computation binding {head, str}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_ne(head @c_string:21:26, '\NUL' @c_string:21:32, ?not_done @c_string:21:37)
Types: Mode checking foreign call {foreign llvm icmp_ne(head @c_string:21:26, '\NUL' @c_string:21:32, ?not_done @c_string:21:37)}
Types:     with assigned semipure normal (total) computation binding {head, str}, break set = Everything, with resources {}
Types: Mode check exp head
Types: Mode check exp resulted in head
Types: Mode check exp '\NUL'
Types: Mode check exp resulted in '\NUL'
Types: Mode check exp ?not_done
Types: Mode check exp resulted in ?not_done
Types: Finding type of expr head @c_string:21:26
Types:   Type = wybe.char
Types: Finding type of expr '\NUL' @c_string:21:32
Types:   Type = wybe.char
Types: Finding type of expr ?not_done @c_string:21:37
Types: Type variable 1 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.char,wybe.char,?wybe.bool]
Types: New instr = {foreign llvm icmp_ne(head:wybe.char @c_string:21:26, '\NUL':wybe.char @c_string:21:32, ?not_done:wybe.bool @c_string:21:37)}
Types: Now assigned = semipure normal (total) computation binding {head, not_done, str}, break set = Everything, with resources {}
Types: Mode check stmt true(?tmp#0 @c_string:22:17)
Types: Mode checking call   : {true(?tmp#0 @c_string:22:17)}
Types:     with assigned    : semipure normal (total) computation binding {head, not_done, str}, break set = Everything, with resources {}
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr ?tmp#0 @c_string:22:17
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     actual types     : [wybe.bool]
Types:     actual modes     : [(ParamOut,False,Nothing)]
Types: Matching types [wybe.bool] with wybe.bool.true<0>(?wybe.bool)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Type-correct modes   : [(wybe.bool.true<0>(?wybe.bool),Typing {head::wybe.char, not_done::1, str::wybe.c_string, tail::wybe.c_string, tmp#0::0}; {0::wybe.bool, 1::wybe.bool} (with no errors))]
Types: Possible mode matches: [(wybe.bool.true<0>(?wybe.bool),Typing {head::wybe.char, not_done::1, str::wybe.c_string, tail::wybe.c_string, tmp#0::0}; {0::wybe.bool, 1::wybe.bool} (with no errors))]
Types: Exact mode matches: [(wybe.bool.true<0>(?wybe.bool),Typing {head::wybe.char, not_done::1, str::wybe.c_string, tail::wybe.c_string, tmp#0::0}; {0::wybe.bool, 1::wybe.bool} (with no errors))]
Types: Finding type of expr ?tmp#0 @c_string:22:17
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finalising call    :  {wybe.bool.<0>true(?tmp#0:wybe.bool @c_string:22:17)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"head", "not_done", "str"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.bool.<0>true(?tmp#0:wybe.bool @c_string:22:17)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '[|]'
Types: Now assigned = semipure normal (total) computation binding {head, not_done, str, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt =(not_done @c_string:22:6, tmp#0)
Types: Mode checking call   : {=(not_done @c_string:22:6, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {head, not_done, str, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp not_done
Types: Mode check exp resulted in not_done
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr not_done @c_string:22:6
Types: Type variable 1 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     actual types     : [wybe.bool,wybe.bool]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.bool,wybe.bool] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.bool,wybe.bool] with {test} wybe.c_string.=<0>(wybe.c_string,wybe.c_string)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 22, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 22, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.bool,wybe.bool] with {test} wybe.char.=<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 22, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 22, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.bool,wybe.bool] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 22, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/c_string.wybe" (line 22, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.bool.=<0>(wybe.bool,wybe.bool),Typing {head::wybe.char, not_done::1, str::wybe.c_string, tail::wybe.c_string, tmp#0::0}; {0::wybe.bool, 1::wybe.bool} (with no errors))]
Types: Possible mode matches: [({test} wybe.bool.=<0>(wybe.bool,wybe.bool),Typing {head::wybe.char, not_done::1, str::wybe.c_string, tail::wybe.c_string, tmp#0::0}; {0::wybe.bool, 1::wybe.bool} (with no errors))]
Types: Exact mode matches: [({test} wybe.bool.=<0>(wybe.bool,wybe.bool),Typing {head::wybe.char, not_done::1, str::wybe.c_string, tail::wybe.c_string, tmp#0::0}; {0::wybe.bool, 1::wybe.bool} (with no errors))]
Types: Finding type of expr not_done @c_string:22:6
Types: Type variable 1 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finalising call    :  {wybe.bool.<0>=(not_done:wybe.bool @c_string:22:6, tmp#0:wybe.bool)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"head", "not_done", "str", "tmp#0"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.bool.<0>=(not_done:wybe.bool @c_string:22:6, tmp#0:wybe.bool)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '[|]'
Types: Now assigned = semipure test computation binding {head, not_done, str, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm add(str @c_string:23:22, 1 @c_string:23:27, ?tail @c_string:23:31)
Types: Mode checking foreign call {foreign llvm add(str @c_string:23:22, 1 @c_string:23:27, ?tail @c_string:23:31)}
Types:     with assigned semipure test computation binding {head, not_done, str, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp str
Types: Mode check exp resulted in str
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp ?tail
Types: Mode check exp resulted in ?tail
Types: Finding type of expr str @c_string:23:22
Types:   Type = wybe.c_string
Types: Finding type of expr 1 @c_string:23:27
Types:   Type = wybe.int
Types: Finding type of expr ?tail @c_string:23:31
Types:   Type = wybe.c_string
Types:     types and modes = [wybe.c_string,wybe.int,?wybe.c_string]
Types: New instr = {foreign llvm add(str:wybe.c_string @c_string:23:22, 1:wybe.int @c_string:23:27, ?tail:wybe.c_string @c_string:23:31)}
Types: Now assigned = semipure test computation binding {head, not_done, str, tail, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc '[|]'
Types: Mode checked body   : [{foreign lpvm access(str:wybe.c_string @c_string:20:25, 0:wybe.int @c_string:20:30, 0:wybe.int @c_string:20:33, 0:wybe.int @c_string:20:36, ?head:wybe.char @c_string:20:40)} @c_string:20:5,{foreign llvm icmp_ne(head:wybe.char @c_string:21:26, '\NUL':wybe.char @c_string:21:32, ?not_done:wybe.bool @c_string:21:37)} @c_string:21:5,{wybe.bool.<0>true(?tmp#0:wybe.bool @c_string:22:17)} @c_string:22:17,{wybe.bool.<0>=(not_done:wybe.bool @c_string:22:6, tmp#0:wybe.bool)} @c_string:22:6,{foreign llvm add(str:wybe.c_string @c_string:23:22, 1:wybe.int @c_string:23:27, ?tail:wybe.c_string @c_string:23:31)} @c_string:23:5]
Types: Vars defined by body: semipure test computation binding {head, not_done, str, tail, tmp#0}, break set = Everything, with resources {}
Types: Output parameters   : head, tail
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of [|]:
Types: 
Types: [|] > public {test} (0 calls)
Types: 4: [|](?head:wybe.char @c_string:19:23, ?tail:wybe.c_string @c_string:19:35, str:wybe.c_string @c_string:19:43):
Types:     foreign lpvm access(str:wybe.c_string @c_string:20:25, 0:wybe.int @c_string:20:30, 0:wybe.int @c_string:20:33, 0:wybe.int @c_string:20:36, ?head:wybe.char @c_string:20:40)
Types:     foreign llvm icmp_ne(head:wybe.char @c_string:21:26, '\NUL':wybe.char @c_string:21:32, ?not_done:wybe.bool @c_string:21:37)
Types:     wybe.bool.<0>true(?tmp#0:wybe.bool @c_string:22:17)
Types:     wybe.bool.<0>=(not_done:wybe.bool @c_string:22:6, tmp#0:wybe.bool)
Types:     foreign llvm add(str:wybe.c_string @c_string:23:22, 1:wybe.int @c_string:23:27, ?tail:wybe.c_string @c_string:23:31)
Types: Type checking non-recursive proc wybe.char.<=>
Types: ** Type checking decl of proc <=>
Types: found 1 definition(s)
Types: Type checking <=>
Types: ** Type checking <=>: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         <(x @char:24:10, y @char:24:14)
Types:         lesser(?tmp#1 @char:24:19)
Types:         foreign llvm move(tmp#1, ?tmp#0)
Types:         =(x @char:24:28, y @char:24:32)
Types:         equal(?tmp#3 @char:24:37)
Types:         foreign llvm move(tmp#3, ?tmp#2)
Types:         greater(?tmp#4 @char:24:53)
Types:         foreign llvm move(tmp#4, ?tmp#2)
Types:         foreign llvm move(tmp#2 @char:24:28, ?tmp#0)
Types:         foreign llvm move(tmp#0 @char:24:10, ?#result @char:23:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","tmp#1","tmp#2","tmp#3","tmp#4","x","y"]
Types: Recording parameter types: x:wybe.char, y:wybe.char, ?#result:wybe.comparison
Types:     type of 'x' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable x type constrained to wybe.char
Types:     type of 'y' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable y type constrained to wybe.char
Types:     type of '#result' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable #result type constrained to wybe.comparison
Types: Recording resource types: 
Types: Recording casts in {<(x @char:24:10, y @char:24:14)}
Types: Recording casts in {lesser(?tmp#1 @char:24:19)}
Types: Recording casts in {foreign llvm move(tmp#1, ?tmp#0)}
Types: Unifying move argument types tmp#1 and ?tmp#0
Types: Finding type of expr tmp#1
Types:   Type = 0
Types: Finding type of expr ?tmp#0
Types:   Type = 1
Types: Type variable 0 is bound to Nothing
Types: Type variable 1 is bound to Nothing
Types: Unifying types 0 (-> 0) and 1 (-> 1)
Types:   Unification yields 0
Types: Recording casts in {=(x @char:24:28, y @char:24:32)}
Types: Recording casts in {equal(?tmp#3 @char:24:37)}
Types: Recording casts in {foreign llvm move(tmp#3, ?tmp#2)}
Types: Unifying move argument types tmp#3 and ?tmp#2
Types: Finding type of expr tmp#3
Types:   Type = 2
Types: Finding type of expr ?tmp#2
Types:   Type = 3
Types: Type variable 2 is bound to Nothing
Types: Type variable 3 is bound to Nothing
Types: Unifying types 2 (-> 2) and 3 (-> 3)
Types:   Unification yields 2
Types: Recording casts in {greater(?tmp#4 @char:24:53)}
Types: Recording casts in {foreign llvm move(tmp#4, ?tmp#2)}
Types: Unifying move argument types tmp#4 and ?tmp#2
Types: Finding type of expr tmp#4
Types:   Type = 4
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Nothing
Types:   Type = 2
Types: Type variable 4 is bound to Nothing
Types: Type variable 2 is bound to Nothing
Types: Unifying types 4 (-> 4) and 2 (-> 2)
Types:   Unification yields 2
Types: Recording casts in {foreign llvm move(tmp#2 @char:24:28, ?tmp#0)}
Types: Unifying move argument types tmp#2 @char:24:28 and ?tmp#0
Types: Finding type of expr tmp#2 @char:24:28
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Nothing
Types:   Type = 2
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Nothing
Types:   Type = 0
Types: Type variable 2 is bound to Nothing
Types: Type variable 0 is bound to Nothing
Types: Unifying types 2 (-> 2) and 0 (-> 0)
Types:   Unification yields 0
Types: Recording casts in {foreign llvm move(tmp#0 @char:24:10, ?#result @char:23:5)}
Types: Unifying move argument types tmp#0 @char:24:10 and ?#result @char:23:5
Types: Finding type of expr tmp#0 @char:24:10
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Nothing
Types:   Type = 0
Types: Finding type of expr ?#result @char:23:5
Types:   Type = wybe.comparison
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: *** Before calls Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {<(x @char:24:10, y @char:24:14)} @char:24:10, typingInfos = [wybe.char.<<0>(wybe.char,wybe.char,?wybe.bool),wybe.comparison.<<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {lesser(?tmp#1 @char:24:19)} @char:24:19, typingInfos = [wybe.comparison.lesser<0>(?wybe.comparison)]}
Types:     StmtTypings {typingStmt = {=(x @char:24:28, y @char:24:32)} @char:24:28, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {equal(?tmp#3 @char:24:37)} @char:24:37, typingInfos = [wybe.comparison.equal<0>(?wybe.comparison)]}
Types:     StmtTypings {typingStmt = {greater(?tmp#4 @char:24:53)} @char:24:53, typingInfos = [wybe.comparison.greater<0>(?wybe.comparison)]}Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {<(x @char:24:10, y @char:24:14)} @char:24:10
Types: Candidate types:
Types:     wybe.char.<<0>(wybe.char,wybe.char,?wybe.bool)
Types:     wybe.comparison.<<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr x @char:24:10
Types:   Type = wybe.char
Types: Finding type of expr y @char:24:14
Types:   Type = wybe.char
Types: Actual types: [wybe.char,wybe.char]
Types: Matching types [wybe.char,wybe.char] with {test} wybe.char.<<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Unifying types wybe.char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Matching types [wybe.char,wybe.char] with {test} wybe.comparison.<<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 10): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.char (-> wybe.char) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 10): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.char,wybe.char] with {test} wybe.int.<<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 10): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.char (-> wybe.char) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 10): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {lesser(?tmp#1 @char:24:19)} @char:24:19
Types: Candidate types:
Types:     wybe.comparison.lesser<0>(?wybe.comparison)
Types: Finding type of expr ?tmp#1 @char:24:19
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Actual types: [wybe.comparison]
Types: Matching types [wybe.comparison] with wybe.comparison.lesser<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {=(x @char:24:28, y @char:24:32)} @char:24:28
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr x @char:24:28
Types:   Type = wybe.char
Types: Finding type of expr y @char:24:32
Types:   Type = wybe.char
Types: Actual types: [wybe.char,wybe.char]
Types: Matching types [wybe.char,wybe.char] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.char (-> wybe.char) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.char,wybe.char] with {test} wybe.char.=<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Unifying types wybe.char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Matching types [wybe.char,wybe.char] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.char (-> wybe.char) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.char,wybe.char] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.char (-> wybe.char) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {equal(?tmp#3 @char:24:37)} @char:24:37
Types: Candidate types:
Types:     wybe.comparison.equal<0>(?wybe.comparison)
Types: Finding type of expr ?tmp#3 @char:24:37
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Actual types: [wybe.comparison]
Types: Matching types [wybe.comparison] with wybe.comparison.equal<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {greater(?tmp#4 @char:24:53)} @char:24:53
Types: Candidate types:
Types:     wybe.comparison.greater<0>(?wybe.comparison)
Types: Finding type of expr ?tmp#4 @char:24:53
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Actual types: [wybe.comparison]
Types: Matching types [wybe.comparison] with wybe.comparison.greater<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Finding type of expr tmp#1
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Finding type of expr tmp#3
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Finding type of expr tmp#4
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Finding type of expr tmp#2 @char:24:28
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Finding type of expr tmp#0 @char:24:10
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?#result @char:23:5
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Now mode checking proc <=>
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt if {<(x @char:24:10, y @char:24:14)::
Types: 
Types:                     lesser(?tmp#1 @char:24:19)
Types:                     foreign llvm move(tmp#1, ?tmp#0)
Types:                 else::
Types:                     if {=(x @char:24:28, y @char:24:32)::
Types: 
Types:                         equal(?tmp#3 @char:24:37)
Types:                         foreign llvm move(tmp#3, ?tmp#2)
Types:                     else::
Types:                         greater(?tmp#4 @char:24:53)
Types:                         foreign llvm move(tmp#4, ?tmp#2)
Types: 
Types:                     }
Types:                     foreign llvm move(tmp#2 @char:24:28, ?tmp#0)
Types: 
Types:                 }
Types: Mode checking conditional {if {<(x @char:24:10, y @char:24:14)::
Types: 
Types:         lesser(?tmp#1 @char:24:19)
Types:         foreign llvm move(tmp#1, ?tmp#0)
Types:     else::
Types:         if {=(x @char:24:28, y @char:24:32)::
Types: 
Types:             equal(?tmp#3 @char:24:37)
Types:             foreign llvm move(tmp#3, ?tmp#2)
Types:         else::
Types:             greater(?tmp#4 @char:24:53)
Types:             foreign llvm move(tmp#4, ?tmp#2)
Types: 
Types:         }
Types:         foreign llvm move(tmp#2 @char:24:28, ?tmp#0)
Types: 
Types:     }}
Types: Mode checking call   : {<(x @char:24:10, y @char:24:14)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Finding type of expr x @char:24:10
Types:   Type = wybe.char
Types: Finding type of expr y @char:24:14
Types:   Type = wybe.char
Types:     actual types     : [wybe.char,wybe.char]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.char,wybe.char] with {test} wybe.char.<<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Unifying types wybe.char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Matching types [wybe.char,wybe.char] with {test} wybe.comparison.<<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 10): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.char (-> wybe.char) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 10): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.char,wybe.char] with {test} wybe.int.<<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 10): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.char (-> wybe.char) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 10): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.char.<<0>(wybe.char,wybe.char),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [({test} wybe.char.<<0>(wybe.char,wybe.char),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [({test} wybe.char.<<0>(wybe.char,wybe.char),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr x @char:24:10
Types:   Type = wybe.char
Types: Finding type of expr y @char:24:14
Types:   Type = wybe.char
Types: Finalising call    :  {wybe.char.<0><(x:wybe.char @char:24:10, y:wybe.char @char:24:14)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.char.<0><(x:wybe.char @char:24:10, y:wybe.char @char:24:14)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '<=>'
Types: Assigned by test: semipure test computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt lesser(?tmp#1 @char:24:19)
Types: Mode checking call   : {lesser(?tmp#1 @char:24:19)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr ?tmp#1 @char:24:19
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     actual types     : [wybe.comparison]
Types:     actual modes     : [(ParamOut,False,Nothing)]
Types: Matching types [wybe.comparison] with wybe.comparison.lesser<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Type-correct modes   : [(wybe.comparison.lesser<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [(wybe.comparison.lesser<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [(wybe.comparison.lesser<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr ?tmp#1 @char:24:19
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finalising call    :  {wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @char:24:19)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @char:24:19)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<=>'
Types: Now assigned = semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#1, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(tmp#1, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#1
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#1:wybe.comparison, ?tmp#0:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Assigned by then branch: semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt if {=(x @char:24:28, y @char:24:32)::
Types: 
Types:                     equal(?tmp#3 @char:24:37)
Types:                     foreign llvm move(tmp#3, ?tmp#2)
Types:                 else::
Types:                     greater(?tmp#4 @char:24:53)
Types:                     foreign llvm move(tmp#4, ?tmp#2)
Types: 
Types:                 }
Types: Mode checking conditional {if {=(x @char:24:28, y @char:24:32)::
Types: 
Types:         equal(?tmp#3 @char:24:37)
Types:         foreign llvm move(tmp#3, ?tmp#2)
Types:     else::
Types:         greater(?tmp#4 @char:24:53)
Types:         foreign llvm move(tmp#4, ?tmp#2)
Types: 
Types:     }}
Types: Mode checking call   : {=(x @char:24:28, y @char:24:32)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Finding type of expr x @char:24:28
Types:   Type = wybe.char
Types: Finding type of expr y @char:24:32
Types:   Type = wybe.char
Types:     actual types     : [wybe.char,wybe.char]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.char,wybe.char] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.char (-> wybe.char) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.char,wybe.char] with {test} wybe.char.=<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Unifying types wybe.char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Matching types [wybe.char,wybe.char] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.char (-> wybe.char) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.char,wybe.char] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.char (-> wybe.char) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.char (-> wybe.char) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/char.wybe" (line 24, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.char.=<0>(wybe.char,wybe.char),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [({test} wybe.char.=<0>(wybe.char,wybe.char),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [({test} wybe.char.=<0>(wybe.char,wybe.char),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr x @char:24:28
Types:   Type = wybe.char
Types: Finding type of expr y @char:24:32
Types:   Type = wybe.char
Types: Finalising call    :  {wybe.char.<0>=(x:wybe.char @char:24:28, y:wybe.char @char:24:32)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.char.<0>=(x:wybe.char @char:24:28, y:wybe.char @char:24:32)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '<=>'
Types: Assigned by test: semipure test computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt equal(?tmp#3 @char:24:37)
Types: Mode checking call   : {equal(?tmp#3 @char:24:37)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp ?tmp#3
Types: Mode check exp resulted in ?tmp#3
Types: Finding type of expr ?tmp#3 @char:24:37
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     actual types     : [wybe.comparison]
Types:     actual modes     : [(ParamOut,False,Nothing)]
Types: Matching types [wybe.comparison] with wybe.comparison.equal<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Type-correct modes   : [(wybe.comparison.equal<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [(wybe.comparison.equal<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [(wybe.comparison.equal<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr ?tmp#3 @char:24:37
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finalising call    :  {wybe.comparison.<0>equal(?tmp#3:wybe.comparison @char:24:37)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.comparison.<0>equal(?tmp#3:wybe.comparison @char:24:37)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<=>'
Types: Now assigned = semipure normal (total) computation binding {tmp#3, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#3, ?tmp#2)
Types: Mode checking foreign call {foreign llvm move(tmp#3, ?tmp#2)}
Types:     with assigned semipure normal (total) computation binding {tmp#3, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#3
Types: Mode check exp resulted in tmp#3
Types: Mode check exp ?tmp#2
Types: Mode check exp resulted in ?tmp#2
Types: Finding type of expr tmp#3
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#3:wybe.comparison, ?tmp#2:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {tmp#2, tmp#3, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Assigned by then branch: semipure normal (total) computation binding {tmp#2, tmp#3, x, y}, break set = Everything, with resources {}
Types: Mode check stmt greater(?tmp#4 @char:24:53)
Types: Mode checking call   : {greater(?tmp#4 @char:24:53)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp ?tmp#4
Types: Mode check exp resulted in ?tmp#4
Types: Finding type of expr ?tmp#4 @char:24:53
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     actual types     : [wybe.comparison]
Types:     actual modes     : [(ParamOut,False,Nothing)]
Types: Matching types [wybe.comparison] with wybe.comparison.greater<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Type-correct modes   : [(wybe.comparison.greater<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [(wybe.comparison.greater<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [(wybe.comparison.greater<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.char, y::wybe.char}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr ?tmp#4 @char:24:53
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finalising call    :  {wybe.comparison.<0>greater(?tmp#4:wybe.comparison @char:24:53)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.comparison.<0>greater(?tmp#4:wybe.comparison @char:24:53)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<=>'
Types: Now assigned = semipure normal (total) computation binding {tmp#4, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#4, ?tmp#2)
Types: Mode checking foreign call {foreign llvm move(tmp#4, ?tmp#2)}
Types:     with assigned semipure normal (total) computation binding {tmp#4, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#4
Types: Mode check exp resulted in tmp#4
Types: Mode check exp ?tmp#2
Types: Mode check exp resulted in ?tmp#2
Types: Finding type of expr tmp#4
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#4:wybe.comparison, ?tmp#2:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {tmp#2, tmp#4, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Assigned by else branch: semipure normal (total) computation binding {tmp#2, tmp#4, x, y}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {tmp#2, x, y}, break set = Everything, with resources {}
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types: Now assigned = semipure normal (total) computation binding {tmp#2, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#2 @char:24:28, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(tmp#2 @char:24:28, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {tmp#2, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#2
Types: Mode check exp resulted in tmp#2
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#2 @char:24:28
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#2:wybe.comparison @char:24:28, ?tmp#0:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#2, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Assigned by else branch: semipure normal (total) computation binding {tmp#0, tmp#2, x, y}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0 @char:24:10, ?#result @char:23:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0 @char:24:10, ?#result @char:23:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0 @char:24:10
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?#result @char:23:5
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#0:wybe.comparison @char:24:10, ?#result:wybe.comparison @char:23:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Mode checked body   : [{if {wybe.char.<0><(x:wybe.char @char:24:10, y:wybe.char @char:24:14)::
Types: 
Types:         wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @char:24:19)
Types:         foreign llvm move(tmp#1:wybe.comparison, ?tmp#0:wybe.comparison)
Types:     else::
Types:         if {wybe.char.<0>=(x:wybe.char @char:24:28, y:wybe.char @char:24:32)::
Types: 
Types:             wybe.comparison.<0>equal(?tmp#3:wybe.comparison @char:24:37)
Types:             foreign llvm move(tmp#3:wybe.comparison, ?tmp#2:wybe.comparison)
Types:         else::
Types:             wybe.comparison.<0>greater(?tmp#4:wybe.comparison @char:24:53)
Types:             foreign llvm move(tmp#4:wybe.comparison, ?tmp#2:wybe.comparison)
Types: 
Types:         }
Types:    condition -> {x::wybe.char, y::wybe.char}
Types:    then&else -> {tmp#2::wybe.comparison, x::wybe.char, y::wybe.char}
Types:         foreign llvm move(tmp#2:wybe.comparison @char:24:28, ?tmp#0:wybe.comparison)
Types: 
Types:     }
Types:    condition -> {x::wybe.char, y::wybe.char}
Types:    then&else -> {tmp#0::wybe.comparison, x::wybe.char, y::wybe.char}} @char:24:10,{foreign llvm move(tmp#0:wybe.comparison @char:24:10, ?#result:wybe.comparison @char:23:5)} @char:23:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <=>:
Types: 
Types: <=> > public (0 calls)
Types: 4: <=>(x:wybe.char @char:23:10, y:wybe.char @char:23:20, ?#result:wybe.comparison @char:23:5):
Types:     if {wybe.char.<0><(x:wybe.char @char:24:10, y:wybe.char @char:24:14)::
Types: 
Types:         wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @char:24:19)
Types:         foreign llvm move(tmp#1:wybe.comparison, ?tmp#0:wybe.comparison)
Types:     else::
Types:         if {wybe.char.<0>=(x:wybe.char @char:24:28, y:wybe.char @char:24:32)::
Types: 
Types:             wybe.comparison.<0>equal(?tmp#3:wybe.comparison @char:24:37)
Types:             foreign llvm move(tmp#3:wybe.comparison, ?tmp#2:wybe.comparison)
Types:         else::
Types:             wybe.comparison.<0>greater(?tmp#4:wybe.comparison @char:24:53)
Types:             foreign llvm move(tmp#4:wybe.comparison, ?tmp#2:wybe.comparison)
Types: 
Types:         }
Types:    condition -> {x::wybe.char, y::wybe.char}
Types:    then&else -> {tmp#2::wybe.comparison, x::wybe.char, y::wybe.char}
Types:         foreign llvm move(tmp#2:wybe.comparison @char:24:28, ?tmp#0:wybe.comparison)
Types: 
Types:     }
Types:    condition -> {x::wybe.char, y::wybe.char}
Types:    then&else -> {tmp#0::wybe.comparison, x::wybe.char, y::wybe.char}
Types:     foreign llvm move(tmp#0:wybe.comparison @char:24:10, ?#result:wybe.comparison @char:23:5)
Types: Type checking non-recursive proc wybe.int.%=
Types: ** Type checking decl of proc %=
Types: found 1 definition(s)
Types: Type checking %=
Types: ** Type checking %=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         %(x @int:53:31, y @int:53:35, ?tmp#0 @int:53:31)
Types:         =(?x @int:53:27, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y"]
Types: Recording parameter types: !x:wybe.int, y:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {%(x @int:53:31, y @int:53:35, ?tmp#0 @int:53:31)}
Types: Recording casts in {=(?x @int:53:27, tmp#0)}
Types: *** Before calls Typing {x::wybe.int, y::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {%(x @int:53:31, y @int:53:35, ?tmp#0 @int:53:31)} @int:53:31, typingInfos = [wybe.int.%<0>(wybe.int,wybe.int,?wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?x @int:53:27, tmp#0)} @int:53:27, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.int, y::wybe.int}; {} (with no errors)
Types: Type checking call {%(x @int:53:31, y @int:53:35, ?tmp#0 @int:53:31)} @int:53:31
Types: Candidate types:
Types:     wybe.int.%<0>(wybe.int,wybe.int,?wybe.int)
Types: Finding type of expr x @int:53:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:53:35
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:53:31
Types:   Type = 0
Types: Actual types: [wybe.int,wybe.int,0]
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.%<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Type checking call {=(?x @int:53:27, tmp#0)} @int:53:27
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @int:53:27
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 53, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 53, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 53, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 53, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Now mode checking proc %=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt %(x @int:53:31, y @int:53:35, ?tmp#0 @int:53:31)
Types: Mode checking call   : {%(x @int:53:31, y @int:53:35, ?tmp#0 @int:53:31)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:53:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:53:35
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:53:31
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.%<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.%<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.%<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.%<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Finding type of expr x @int:53:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:53:35
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:53:31
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>%(x:wybe.int @int:53:31, y:wybe.int @int:53:35, ?tmp#0:wybe.int @int:53:31)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>%(x:wybe.int @int:53:31, y:wybe.int @int:53:35, ?tmp#0:wybe.int @int:53:31)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '%='
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @int:53:27, tmp#0)
Types: Mode checking call   : {=(?x @int:53:27, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @int:53:27
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 53, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 53, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 53, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 53, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @int:53:27)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?x @int:53:27
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:53:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '%='
Types: Mode checked body   : [{wybe.int.<0>%(x:wybe.int @int:53:31, y:wybe.int @int:53:35, ?tmp#0:wybe.int @int:53:31)} @int:53:31,{foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:53:27)} @int:53:27]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of %=:
Types: 
Types: %= > public (0 calls)
Types: 4: %=(!x:wybe.int @int:53:11, y:wybe.int @int:53:19):
Types:     wybe.int.<0>%(x:wybe.int @int:53:31, y:wybe.int @int:53:35, ?tmp#0:wybe.int @int:53:31)
Types:     foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:53:27)
Types: Type checking non-recursive proc wybe.int.*=
Types: ** Type checking decl of proc *=
Types: found 1 definition(s)
Types: Type checking *=
Types: ** Type checking *=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         *(x @int:41:31, y @int:41:35, ?tmp#0 @int:41:31)
Types:         =(?x @int:41:27, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y"]
Types: Recording parameter types: !x:wybe.int, y:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {*(x @int:41:31, y @int:41:35, ?tmp#0 @int:41:31)}
Types: Recording casts in {=(?x @int:41:27, tmp#0)}
Types: *** Before calls Typing {x::wybe.int, y::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {*(x @int:41:31, y @int:41:35, ?tmp#0 @int:41:31)} @int:41:31, typingInfos = [wybe.int.*<0>(wybe.int,wybe.int,?wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?x @int:41:27, tmp#0)} @int:41:27, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.int, y::wybe.int}; {} (with no errors)
Types: Type checking call {*(x @int:41:31, y @int:41:35, ?tmp#0 @int:41:31)} @int:41:31
Types: Candidate types:
Types:     wybe.int.*<0>(wybe.int,wybe.int,?wybe.int)
Types: Finding type of expr x @int:41:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:41:35
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:41:31
Types:   Type = 0
Types: Actual types: [wybe.int,wybe.int,0]
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.*<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Type checking call {=(?x @int:41:27, tmp#0)} @int:41:27
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @int:41:27
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 41, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 41, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 41, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 41, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Now mode checking proc *=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt *(x @int:41:31, y @int:41:35, ?tmp#0 @int:41:31)
Types: Mode checking call   : {*(x @int:41:31, y @int:41:35, ?tmp#0 @int:41:31)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:41:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:41:35
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:41:31
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.*<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.*<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.*<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.*<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Finding type of expr x @int:41:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:41:35
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:41:31
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>*(x:wybe.int @int:41:31, y:wybe.int @int:41:35, ?tmp#0:wybe.int @int:41:31)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>*(x:wybe.int @int:41:31, y:wybe.int @int:41:35, ?tmp#0:wybe.int @int:41:31)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '*='
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @int:41:27, tmp#0)
Types: Mode checking call   : {=(?x @int:41:27, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @int:41:27
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 41, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 41, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 41, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 41, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @int:41:27)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?x @int:41:27
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:41:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '*='
Types: Mode checked body   : [{wybe.int.<0>*(x:wybe.int @int:41:31, y:wybe.int @int:41:35, ?tmp#0:wybe.int @int:41:31)} @int:41:31,{foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:41:27)} @int:41:27]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of *=:
Types: 
Types: *= > public (0 calls)
Types: 4: *=(!x:wybe.int @int:41:11, y:wybe.int @int:41:19):
Types:     wybe.int.<0>*(x:wybe.int @int:41:31, y:wybe.int @int:41:35, ?tmp#0:wybe.int @int:41:31)
Types:     foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:41:27)
Types: Type checking non-recursive proc wybe.int.+
Types: ** Type checking decl of proc +
Types: found 3 definition(s)
Types: Type checking +
Types: ** Type checking +: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm add(x @int:16:44, y @int:16:46, ?tmp#0 @int:16:27)
Types:         foreign llvm move(tmp#0, ?#result @int:16:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.int, y:wybe.int, ?#result:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign llvm add(x @int:16:44, y @int:16:46, ?tmp#0 @int:16:27)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:16:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:16:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:16:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr x @int:16:44
Types:   Type = wybe.int
Types: Finding type of expr y @int:16:46
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:16:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call add(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:16:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc +
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm add(x @int:16:44, y @int:16:46, ?tmp#0 @int:16:27)
Types: Mode checking foreign call {foreign llvm add(x @int:16:44, y @int:16:46, ?tmp#0 @int:16:27)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:16:44
Types:   Type = wybe.int
Types: Finding type of expr y @int:16:46
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:16:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm add(x:wybe.int @int:16:44, y:wybe.int @int:16:46, ?tmp#0:wybe.int @int:16:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:16:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:16:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:16:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:16:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '+'
Types: Mode checked body   : [{foreign llvm add(x:wybe.int @int:16:44, y:wybe.int @int:16:46, ?tmp#0:wybe.int @int:16:27)} @int:16:27,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:16:5)} @int:16:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking +
Types: ** Type checking +: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm sub(z @int:17:60, y @int:17:62, ?tmp#0 @int:17:43)
Types:         =(?x @int:17:39, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y","z"]
Types: Recording parameter types: ?x:wybe.int, y:wybe.int, z:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of 'z' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable z type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign llvm sub(z @int:17:60, y @int:17:62, ?tmp#0 @int:17:43)}
Types: Recording casts in {=(?x @int:17:39, tmp#0)}
Types: *** Before calls Typing {x::wybe.int, y::wybe.int, z::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {=(?x @int:17:39, tmp#0)} @int:17:39, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.int, y::wybe.int, z::wybe.int}; {} (with no errors)
Types: Type checking call {=(?x @int:17:39, tmp#0)} @int:17:39
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @int:17:39
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Actual types: [wybe.int,0]
Types: Matching types [wybe.int,0] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 17, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,0] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 17, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.int,0] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int, y::wybe.int, z::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int, y::wybe.int, z::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr z @int:17:60
Types:   Type = wybe.int
Types: Finding type of expr y @int:17:62
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:17:43
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call sub(64 bit signed, 64 bit signed, 64 bit signed)
Types: Now mode checking proc +
Types: bound vars: semipure normal (total) computation binding {y, z}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm sub(z @int:17:60, y @int:17:62, ?tmp#0 @int:17:43)
Types: Mode checking foreign call {foreign llvm sub(z @int:17:60, y @int:17:62, ?tmp#0 @int:17:43)}
Types:     with assigned semipure normal (total) computation binding {y, z}, break set = Everything, with resources {}
Types: Mode check exp z
Types: Mode check exp resulted in z
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr z @int:17:60
Types:   Type = wybe.int
Types: Finding type of expr y @int:17:62
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:17:43
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm sub(z:wybe.int @int:17:60, y:wybe.int @int:17:62, ?tmp#0:wybe.int @int:17:43)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @int:17:39, tmp#0)
Types: Mode checking call   : {=(?x @int:17:39, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @int:17:39
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 17, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 17, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 17, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 17, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int, z::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @int:17:39)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?x @int:17:39
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:17:39)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Mode check end of Det proc '+'
Types: Mode checked body   : [{foreign llvm sub(z:wybe.int @int:17:60, y:wybe.int @int:17:62, ?tmp#0:wybe.int @int:17:43)} @int:17:43,{foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:17:39)} @int:17:39]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking +
Types: ** Type checking +: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm sub(z @int:18:60, x @int:18:62, ?tmp#0 @int:18:43)
Types:         =(?y @int:18:39, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y","z"]
Types: Recording parameter types: x:wybe.int, ?y:wybe.int, z:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of 'z' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable z type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign llvm sub(z @int:18:60, x @int:18:62, ?tmp#0 @int:18:43)}
Types: Recording casts in {=(?y @int:18:39, tmp#0)}
Types: *** Before calls Typing {x::wybe.int, y::wybe.int, z::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {=(?y @int:18:39, tmp#0)} @int:18:39, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.int, y::wybe.int, z::wybe.int}; {} (with no errors)
Types: Type checking call {=(?y @int:18:39, tmp#0)} @int:18:39
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?y @int:18:39
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Actual types: [wybe.int,0]
Types: Matching types [wybe.int,0] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 18, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,0] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 18, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.int,0] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int, y::wybe.int, z::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int, y::wybe.int, z::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr z @int:18:60
Types:   Type = wybe.int
Types: Finding type of expr x @int:18:62
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:18:43
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call sub(64 bit signed, 64 bit signed, 64 bit signed)
Types: Now mode checking proc +
Types: bound vars: semipure normal (total) computation binding {x, z}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm sub(z @int:18:60, x @int:18:62, ?tmp#0 @int:18:43)
Types: Mode checking foreign call {foreign llvm sub(z @int:18:60, x @int:18:62, ?tmp#0 @int:18:43)}
Types:     with assigned semipure normal (total) computation binding {x, z}, break set = Everything, with resources {}
Types: Mode check exp z
Types: Mode check exp resulted in z
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr z @int:18:60
Types:   Type = wybe.int
Types: Finding type of expr x @int:18:62
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:18:43
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm sub(z:wybe.int @int:18:60, x:wybe.int @int:18:62, ?tmp#0:wybe.int @int:18:43)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check stmt =(?y @int:18:39, tmp#0)
Types: Mode checking call   : {=(?y @int:18:39, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check exp ?y
Types: Mode check exp resulted in ?y
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?y @int:18:39
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 18, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 18, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 18, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 18, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int, z::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?y @int:18:39)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?y
Types: Mode check exp resulted in ?y
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?y @int:18:39
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?y:wybe.int @int:18:39)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Mode check end of Det proc '+'
Types: Mode checked body   : [{foreign llvm sub(z:wybe.int @int:18:60, x:wybe.int @int:18:62, ?tmp#0:wybe.int @int:18:43)} @int:18:43,{foreign llvm move(tmp#0:wybe.int, ?y:wybe.int @int:18:39)} @int:18:39]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Output parameters   : y
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of +:
Types: 
Types: + > public (0 calls)
Types: 4: +(x:wybe.int @int:16:10, y:wybe.int @int:16:17, ?#result:wybe.int @int:16:5):
Types:     foreign llvm add(x:wybe.int @int:16:44, y:wybe.int @int:16:46, ?tmp#0:wybe.int @int:16:27)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:16:5)
Types: 
Types: + > public (0 calls)
Types: 4: +(?x:wybe.int @int:17:11, y:wybe.int @int:17:17, z:wybe.int @int:17:5):
Types:     foreign llvm sub(z:wybe.int @int:17:60, y:wybe.int @int:17:62, ?tmp#0:wybe.int @int:17:43)
Types:     foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:17:39)
Types: 
Types: + > public (0 calls)
Types: 4: +(x:wybe.int @int:18:10, ?y:wybe.int @int:18:18, z:wybe.int @int:18:5):
Types:     foreign llvm sub(z:wybe.int @int:18:60, x:wybe.int @int:18:62, ?tmp#0:wybe.int @int:18:43)
Types:     foreign llvm move(tmp#0:wybe.int, ?y:wybe.int @int:18:39)
Types: Type checking non-recursive proc wybe.int.+=
Types: ** Type checking decl of proc +=
Types: found 1 definition(s)
Types: Type checking +=
Types: ** Type checking +=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         +(x @int:21:31, y @int:21:35, ?tmp#0 @int:21:31)
Types:         =(?x @int:21:27, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y"]
Types: Recording parameter types: !x:wybe.int, y:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {+(x @int:21:31, y @int:21:35, ?tmp#0 @int:21:31)}
Types: Recording casts in {=(?x @int:21:27, tmp#0)}
Types: *** Before calls Typing {x::wybe.int, y::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {+(x @int:21:31, y @int:21:35, ?tmp#0 @int:21:31)} @int:21:31, typingInfos = [wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?x @int:21:27, tmp#0)} @int:21:27, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.int, y::wybe.int}; {} (with no errors)
Types: Type checking call {+(x @int:21:31, y @int:21:35, ?tmp#0 @int:21:31)} @int:21:31
Types: Candidate types:
Types:     wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Finding type of expr x @int:21:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:21:35
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:21:31
Types:   Type = 0
Types: Actual types: [wybe.int,wybe.int,0]
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Type checking call {=(?x @int:21:27, tmp#0)} @int:21:27
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @int:21:27
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 21, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 21, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 21, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 21, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Now mode checking proc +=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt +(x @int:21:31, y @int:21:35, ?tmp#0 @int:21:31)
Types: Mode checking call   : {+(x @int:21:31, y @int:21:35, ?tmp#0 @int:21:31)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:21:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:21:35
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:21:31
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)),(wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)),(wybe.int.+<2>(wybe.int,?wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Finding type of expr x @int:21:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:21:35
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:21:31
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>+(x:wybe.int @int:21:31, y:wybe.int @int:21:35, ?tmp#0:wybe.int @int:21:31)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>+(x:wybe.int @int:21:31, y:wybe.int @int:21:35, ?tmp#0:wybe.int @int:21:31)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '+='
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @int:21:27, tmp#0)
Types: Mode checking call   : {=(?x @int:21:27, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @int:21:27
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 21, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 21, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 21, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 21, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @int:21:27)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?x @int:21:27
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:21:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '+='
Types: Mode checked body   : [{wybe.int.<0>+(x:wybe.int @int:21:31, y:wybe.int @int:21:35, ?tmp#0:wybe.int @int:21:31)} @int:21:31,{foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:21:27)} @int:21:27]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of +=:
Types: 
Types: += > public (0 calls)
Types: 4: +=(!x:wybe.int @int:21:11, y:wybe.int @int:21:19):
Types:     wybe.int.<0>+(x:wybe.int @int:21:31, y:wybe.int @int:21:35, ?tmp#0:wybe.int @int:21:31)
Types:     foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:21:27)
Types: Type checking non-recursive proc wybe.int.-
Types: ** Type checking decl of proc -
Types: found 5 definition(s)
Types: Type checking -
Types: ** Type checking -: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm sub(x @int:25:44, y @int:25:46, ?tmp#0 @int:25:27)
Types:         foreign llvm move(tmp#0, ?#result @int:25:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.int, y:wybe.int, ?#result:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign llvm sub(x @int:25:44, y @int:25:46, ?tmp#0 @int:25:27)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:25:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:25:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:25:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.int, tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr x @int:25:44
Types:   Type = wybe.int
Types: Finding type of expr y @int:25:46
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:25:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call sub(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:25:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc -
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm sub(x @int:25:44, y @int:25:46, ?tmp#0 @int:25:27)
Types: Mode checking foreign call {foreign llvm sub(x @int:25:44, y @int:25:46, ?tmp#0 @int:25:27)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:25:44
Types:   Type = wybe.int
Types: Finding type of expr y @int:25:46
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:25:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm sub(x:wybe.int @int:25:44, y:wybe.int @int:25:46, ?tmp#0:wybe.int @int:25:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:25:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:25:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:25:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:25:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '-'
Types: Mode checked body   : [{foreign llvm sub(x:wybe.int @int:25:44, y:wybe.int @int:25:46, ?tmp#0:wybe.int @int:25:27)} @int:25:27,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:25:5)} @int:25:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking -
Types: ** Type checking -: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm add(z @int:26:60, y @int:26:62, ?tmp#0 @int:26:43)
Types:         =(?x @int:26:39, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y","z"]
Types: Recording parameter types: ?x:wybe.int, y:wybe.int, z:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of 'z' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable z type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign llvm add(z @int:26:60, y @int:26:62, ?tmp#0 @int:26:43)}
Types: Recording casts in {=(?x @int:26:39, tmp#0)}
Types: *** Before calls Typing {x::wybe.int, y::wybe.int, z::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {=(?x @int:26:39, tmp#0)} @int:26:39, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.int, y::wybe.int, z::wybe.int}; {} (with no errors)
Types: Type checking call {=(?x @int:26:39, tmp#0)} @int:26:39
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @int:26:39
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Actual types: [wybe.int,0]
Types: Matching types [wybe.int,0] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 26, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,0] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 26, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.int,0] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int, y::wybe.int, z::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int, y::wybe.int, z::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr z @int:26:60
Types:   Type = wybe.int
Types: Finding type of expr y @int:26:62
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:26:43
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call add(64 bit signed, 64 bit signed, 64 bit signed)
Types: Now mode checking proc -
Types: bound vars: semipure normal (total) computation binding {y, z}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm add(z @int:26:60, y @int:26:62, ?tmp#0 @int:26:43)
Types: Mode checking foreign call {foreign llvm add(z @int:26:60, y @int:26:62, ?tmp#0 @int:26:43)}
Types:     with assigned semipure normal (total) computation binding {y, z}, break set = Everything, with resources {}
Types: Mode check exp z
Types: Mode check exp resulted in z
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr z @int:26:60
Types:   Type = wybe.int
Types: Finding type of expr y @int:26:62
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:26:43
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm add(z:wybe.int @int:26:60, y:wybe.int @int:26:62, ?tmp#0:wybe.int @int:26:43)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @int:26:39, tmp#0)
Types: Mode checking call   : {=(?x @int:26:39, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @int:26:39
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 26, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 26, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 26, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 26, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int, z::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @int:26:39)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?x @int:26:39
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:26:39)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Mode check end of Det proc '-'
Types: Mode checked body   : [{foreign llvm add(z:wybe.int @int:26:60, y:wybe.int @int:26:62, ?tmp#0:wybe.int @int:26:43)} @int:26:43,{foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:26:39)} @int:26:39]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking -
Types: ** Type checking -: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm sub(z @int:27:60, x @int:27:62, ?tmp#0 @int:27:43)
Types:         =(?y @int:27:39, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y","z"]
Types: Recording parameter types: x:wybe.int, ?y:wybe.int, z:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of 'z' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable z type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign llvm sub(z @int:27:60, x @int:27:62, ?tmp#0 @int:27:43)}
Types: Recording casts in {=(?y @int:27:39, tmp#0)}
Types: *** Before calls Typing {x::wybe.int, y::wybe.int, z::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {=(?y @int:27:39, tmp#0)} @int:27:39, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.int, y::wybe.int, z::wybe.int}; {} (with no errors)
Types: Type checking call {=(?y @int:27:39, tmp#0)} @int:27:39
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?y @int:27:39
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Actual types: [wybe.int,0]
Types: Matching types [wybe.int,0] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 27, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,0] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 27, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.int,0] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int, y::wybe.int, z::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int, y::wybe.int, z::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr z @int:27:60
Types:   Type = wybe.int
Types: Finding type of expr x @int:27:62
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:27:43
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call sub(64 bit signed, 64 bit signed, 64 bit signed)
Types: Now mode checking proc -
Types: bound vars: semipure normal (total) computation binding {x, z}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm sub(z @int:27:60, x @int:27:62, ?tmp#0 @int:27:43)
Types: Mode checking foreign call {foreign llvm sub(z @int:27:60, x @int:27:62, ?tmp#0 @int:27:43)}
Types:     with assigned semipure normal (total) computation binding {x, z}, break set = Everything, with resources {}
Types: Mode check exp z
Types: Mode check exp resulted in z
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr z @int:27:60
Types:   Type = wybe.int
Types: Finding type of expr x @int:27:62
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:27:43
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm sub(z:wybe.int @int:27:60, x:wybe.int @int:27:62, ?tmp#0:wybe.int @int:27:43)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check stmt =(?y @int:27:39, tmp#0)
Types: Mode checking call   : {=(?y @int:27:39, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check exp ?y
Types: Mode check exp resulted in ?y
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?y @int:27:39
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 27, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 27, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 27, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 27, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int, z::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?y @int:27:39)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?y
Types: Mode check exp resulted in ?y
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?y @int:27:39
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?y:wybe.int @int:27:39)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Mode check end of Det proc '-'
Types: Mode checked body   : [{foreign llvm sub(z:wybe.int @int:27:60, x:wybe.int @int:27:62, ?tmp#0:wybe.int @int:27:43)} @int:27:43,{foreign llvm move(tmp#0:wybe.int, ?y:wybe.int @int:27:39)} @int:27:39]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Output parameters   : y
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking -
Types: ** Type checking -: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm sub(0 @int:31:38, x @int:31:40, ?tmp#0 @int:31:21)
Types:         foreign llvm move(tmp#0, ?#result @int:31:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x"]
Types: Recording parameter types: x:wybe.int, ?#result:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign llvm sub(0 @int:31:38, x @int:31:40, ?tmp#0 @int:31:21)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:31:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:31:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:31:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr 0 @int:31:38
Types:   Type = wybe.int
Types: Finding type of expr x @int:31:40
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:31:21
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call sub(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:31:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc -
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm sub(0 @int:31:38, x @int:31:40, ?tmp#0 @int:31:21)
Types: Mode checking foreign call {foreign llvm sub(0 @int:31:38, x @int:31:40, ?tmp#0 @int:31:21)}
Types:     with assigned semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr 0 @int:31:38
Types:   Type = wybe.int
Types: Finding type of expr x @int:31:40
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:31:21
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm sub(0:wybe.int @int:31:38, x:wybe.int @int:31:40, ?tmp#0:wybe.int @int:31:21)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:31:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:31:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:31:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:31:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc '-'
Types: Mode checked body   : [{foreign llvm sub(0:wybe.int @int:31:38, x:wybe.int @int:31:40, ?tmp#0:wybe.int @int:31:21)} @int:31:21,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:31:5)} @int:31:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking -
Types: ** Type checking -: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm sub(0 @int:32:54, y @int:32:56, ?tmp#0 @int:32:37)
Types:         =(?x @int:32:33, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y"]
Types: Recording parameter types: ?x:wybe.int, y:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign llvm sub(0 @int:32:54, y @int:32:56, ?tmp#0 @int:32:37)}
Types: Recording casts in {=(?x @int:32:33, tmp#0)}
Types: *** Before calls Typing {x::wybe.int, y::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {=(?x @int:32:33, tmp#0)} @int:32:33, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.int, y::wybe.int}; {} (with no errors)
Types: Type checking call {=(?x @int:32:33, tmp#0)} @int:32:33
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @int:32:33
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Actual types: [wybe.int,0]
Types: Matching types [wybe.int,0] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 32, column 33): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.int,0] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 32, column 33): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.int,0] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr 0 @int:32:54
Types:   Type = wybe.int
Types: Finding type of expr y @int:32:56
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:32:37
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call sub(64 bit signed, 64 bit signed, 64 bit signed)
Types: Now mode checking proc -
Types: bound vars: semipure normal (total) computation binding {y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm sub(0 @int:32:54, y @int:32:56, ?tmp#0 @int:32:37)
Types: Mode checking foreign call {foreign llvm sub(0 @int:32:54, y @int:32:56, ?tmp#0 @int:32:37)}
Types:     with assigned semipure normal (total) computation binding {y}, break set = Everything, with resources {}
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr 0 @int:32:54
Types:   Type = wybe.int
Types: Finding type of expr y @int:32:56
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:32:37
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm sub(0:wybe.int @int:32:54, y:wybe.int @int:32:56, ?tmp#0:wybe.int @int:32:37)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, y}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @int:32:33, tmp#0)
Types: Mode checking call   : {=(?x @int:32:33, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, y}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @int:32:33
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 32, column 33): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 32, column 33): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 32, column 33): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 32, column 33): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @int:32:33)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?x @int:32:33
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:32:33)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '-'
Types: Mode checked body   : [{foreign llvm sub(0:wybe.int @int:32:54, y:wybe.int @int:32:56, ?tmp#0:wybe.int @int:32:37)} @int:32:37,{foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:32:33)} @int:32:33]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of -:
Types: 
Types: - > public (0 calls)
Types: 4: -(x:wybe.int @int:25:10, y:wybe.int @int:25:17, ?#result:wybe.int @int:25:5):
Types:     foreign llvm sub(x:wybe.int @int:25:44, y:wybe.int @int:25:46, ?tmp#0:wybe.int @int:25:27)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:25:5)
Types: 
Types: - > public (0 calls)
Types: 4: -(?x:wybe.int @int:26:11, y:wybe.int @int:26:17, z:wybe.int @int:26:5):
Types:     foreign llvm add(z:wybe.int @int:26:60, y:wybe.int @int:26:62, ?tmp#0:wybe.int @int:26:43)
Types:     foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:26:39)
Types: 
Types: - > public (0 calls)
Types: 4: -(x:wybe.int @int:27:10, ?y:wybe.int @int:27:18, z:wybe.int @int:27:5):
Types:     foreign llvm sub(z:wybe.int @int:27:60, x:wybe.int @int:27:62, ?tmp#0:wybe.int @int:27:43)
Types:     foreign llvm move(tmp#0:wybe.int, ?y:wybe.int @int:27:39)
Types: 
Types: - > public (0 calls)
Types: 4: -(x:wybe.int @int:31:11, ?#result:wybe.int @int:31:5):
Types:     foreign llvm sub(0:wybe.int @int:31:38, x:wybe.int @int:31:40, ?tmp#0:wybe.int @int:31:21)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:31:5)
Types: 
Types: - > public (0 calls)
Types: 4: -(?x:wybe.int @int:32:12, y:wybe.int @int:32:5):
Types:     foreign llvm sub(0:wybe.int @int:32:54, y:wybe.int @int:32:56, ?tmp#0:wybe.int @int:32:37)
Types:     foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:32:33)
Types: Type checking non-recursive proc wybe.int.-=
Types: ** Type checking decl of proc -=
Types: found 1 definition(s)
Types: Type checking -=
Types: ** Type checking -=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         -(x @int:35:31, y @int:35:35, ?tmp#0 @int:35:31)
Types:         =(?x @int:35:27, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y"]
Types: Recording parameter types: !x:wybe.int, y:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {-(x @int:35:31, y @int:35:35, ?tmp#0 @int:35:31)}
Types: Recording casts in {=(?x @int:35:27, tmp#0)}
Types: *** Before calls Typing {x::wybe.int, y::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {-(x @int:35:31, y @int:35:35, ?tmp#0 @int:35:31)} @int:35:31, typingInfos = [wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),wybe.int.-<3>(wybe.int,?wybe.int),wybe.int.-<4>(?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?x @int:35:27, tmp#0)} @int:35:27, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.int, y::wybe.int}; {} (with no errors)
Types: Type checking call {-(x @int:35:31, y @int:35:35, ?tmp#0 @int:35:31)} @int:35:31
Types: Candidate types:
Types:     wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types:     wybe.int.-<3>(wybe.int,?wybe.int)
Types:     wybe.int.-<4>(?wybe.int,wybe.int)
Types: Finding type of expr x @int:35:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:35:35
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:35:31
Types:   Type = 0
Types: Actual types: [wybe.int,wybe.int,0]
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Type checking call {=(?x @int:35:27, tmp#0)} @int:35:27
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @int:35:27
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 35, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 35, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 35, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 35, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Now mode checking proc -=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt -(x @int:35:31, y @int:35:35, ?tmp#0 @int:35:31)
Types: Mode checking call   : {-(x @int:35:31, y @int:35:35, ?tmp#0 @int:35:31)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:35:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:35:35
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:35:31
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)),(wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)),(wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Finding type of expr x @int:35:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:35:35
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:35:31
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>-(x:wybe.int @int:35:31, y:wybe.int @int:35:35, ?tmp#0:wybe.int @int:35:31)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>-(x:wybe.int @int:35:31, y:wybe.int @int:35:35, ?tmp#0:wybe.int @int:35:31)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '-='
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @int:35:27, tmp#0)
Types: Mode checking call   : {=(?x @int:35:27, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @int:35:27
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 35, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 35, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 35, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 35, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @int:35:27)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?x @int:35:27
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:35:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '-='
Types: Mode checked body   : [{wybe.int.<0>-(x:wybe.int @int:35:31, y:wybe.int @int:35:35, ?tmp#0:wybe.int @int:35:31)} @int:35:31,{foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:35:27)} @int:35:27]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of -=:
Types: 
Types: -= > public (0 calls)
Types: 4: -=(!x:wybe.int @int:35:11, y:wybe.int @int:35:19):
Types:     wybe.int.<0>-(x:wybe.int @int:35:31, y:wybe.int @int:35:35, ?tmp#0:wybe.int @int:35:31)
Types:     foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:35:27)
Types: Type checking non-recursive proc wybe.int./=
Types: ** Type checking decl of proc /=
Types: found 1 definition(s)
Types: Type checking /=
Types: ** Type checking /=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         /(x @int:47:31, y @int:47:35, ?tmp#0 @int:47:31)
Types:         =(?x @int:47:27, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y"]
Types: Recording parameter types: !x:wybe.int, y:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {/(x @int:47:31, y @int:47:35, ?tmp#0 @int:47:31)}
Types: Recording casts in {=(?x @int:47:27, tmp#0)}
Types: *** Before calls Typing {x::wybe.int, y::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {/(x @int:47:31, y @int:47:35, ?tmp#0 @int:47:31)} @int:47:31, typingInfos = [wybe.int./<0>(wybe.int,wybe.int,?wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?x @int:47:27, tmp#0)} @int:47:27, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.int, y::wybe.int}; {} (with no errors)
Types: Type checking call {/(x @int:47:31, y @int:47:35, ?tmp#0 @int:47:31)} @int:47:31
Types: Candidate types:
Types:     wybe.int./<0>(wybe.int,wybe.int,?wybe.int)
Types: Finding type of expr x @int:47:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:47:35
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:47:31
Types:   Type = 0
Types: Actual types: [wybe.int,wybe.int,0]
Types: Matching types [wybe.int,wybe.int,0] with wybe.int./<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Type checking call {=(?x @int:47:27, tmp#0)} @int:47:27
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @int:47:27
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 47, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 47, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 47, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 47, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors)
Types: Now mode checking proc /=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt /(x @int:47:31, y @int:47:35, ?tmp#0 @int:47:31)
Types: Mode checking call   : {/(x @int:47:31, y @int:47:35, ?tmp#0 @int:47:31)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:47:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:47:35
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:47:31
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int./<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int./<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int./<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int./<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Finding type of expr x @int:47:31
Types:   Type = wybe.int
Types: Finding type of expr y @int:47:35
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:47:31
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>/(x:wybe.int @int:47:31, y:wybe.int @int:47:35, ?tmp#0:wybe.int @int:47:31)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>/(x:wybe.int @int:47:31, y:wybe.int @int:47:35, ?tmp#0:wybe.int @int:47:31)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '/='
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @int:47:27, tmp#0)
Types: Mode checking call   : {=(?x @int:47:27, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @int:47:27
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 47, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 47, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 47, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 47, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int, y::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @int:47:27)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?x @int:47:27
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:47:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '/='
Types: Mode checked body   : [{wybe.int.<0>/(x:wybe.int @int:47:31, y:wybe.int @int:47:35, ?tmp#0:wybe.int @int:47:31)} @int:47:31,{foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:47:27)} @int:47:27]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of /=:
Types: 
Types: /= > public (0 calls)
Types: 4: /=(!x:wybe.int @int:47:11, y:wybe.int @int:47:19):
Types:     wybe.int.<0>/(x:wybe.int @int:47:31, y:wybe.int @int:47:35, ?tmp#0:wybe.int @int:47:31)
Types:     foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:47:27)
Types: Type checking non-recursive proc wybe.int.<<=
Types: ** Type checking decl of proc <<=
Types: found 1 definition(s)
Types: Type checking <<=
Types: ** Type checking <<=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         <<(x @int:59:33, s @int:59:39, ?tmp#0 @int:59:33)
Types:         =(?x @int:59:29, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["s","tmp#0","x"]
Types: Recording parameter types: !x:wybe.int, s:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 's' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable s type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {<<(x @int:59:33, s @int:59:39, ?tmp#0 @int:59:33)}
Types: Recording casts in {=(?x @int:59:29, tmp#0)}
Types: *** Before calls Typing {s::wybe.int, x::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {<<(x @int:59:33, s @int:59:39, ?tmp#0 @int:59:33)} @int:59:33, typingInfos = [wybe.int.<<<0>(wybe.int,wybe.int,?wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?x @int:59:29, tmp#0)} @int:59:29, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {s::wybe.int, x::wybe.int}; {} (with no errors)
Types: Type checking call {<<(x @int:59:33, s @int:59:39, ?tmp#0 @int:59:33)} @int:59:33
Types: Candidate types:
Types:     wybe.int.<<<0>(wybe.int,wybe.int,?wybe.int)
Types: Finding type of expr x @int:59:33
Types:   Type = wybe.int
Types: Finding type of expr s @int:59:39
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:59:33
Types:   Type = 0
Types: Actual types: [wybe.int,wybe.int,0]
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.<<<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types: Type checking call {=(?x @int:59:29, tmp#0)} @int:59:29
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @int:59:29
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 59, column 29): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 59, column 29): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 59, column 29): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 59, column 29): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types: Now mode checking proc <<=
Types: bound vars: semipure normal (total) computation binding {s, x}, break set = Everything, with resources {}
Types: Mode check stmt <<(x @int:59:33, s @int:59:39, ?tmp#0 @int:59:33)
Types: Mode checking call   : {<<(x @int:59:33, s @int:59:39, ?tmp#0 @int:59:33)}
Types:     with assigned    : semipure normal (total) computation binding {s, x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp s
Types: Mode check exp resulted in s
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:59:33
Types:   Type = wybe.int
Types: Finding type of expr s @int:59:39
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:59:33
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.<<<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.<<<0>(wybe.int,wybe.int,?wybe.int),Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.<<<0>(wybe.int,wybe.int,?wybe.int),Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.<<<0>(wybe.int,wybe.int,?wybe.int),Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Finding type of expr x @int:59:33
Types:   Type = wybe.int
Types: Finding type of expr s @int:59:39
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:59:33
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0><<(x:wybe.int @int:59:33, s:wybe.int @int:59:39, ?tmp#0:wybe.int @int:59:33)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"s", "x"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0><<(x:wybe.int @int:59:33, s:wybe.int @int:59:39, ?tmp#0:wybe.int @int:59:33)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<<='
Types: Now assigned = semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @int:59:29, tmp#0)
Types: Mode checking call   : {=(?x @int:59:29, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @int:59:29
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 59, column 29): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 59, column 29): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 59, column 29): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 59, column 29): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @int:59:29)}
Types:     with assigned semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?x @int:59:29
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:59:29)}
Types: Now assigned = semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<<='
Types: Mode checked body   : [{wybe.int.<0><<(x:wybe.int @int:59:33, s:wybe.int @int:59:39, ?tmp#0:wybe.int @int:59:33)} @int:59:33,{foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:59:29)} @int:59:29]
Types: Vars defined by body: semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <<=:
Types: 
Types: <<= > public (0 calls)
Types: 4: <<=(!x:wybe.int @int:59:11, s:wybe.int @int:59:21):
Types:     wybe.int.<0><<(x:wybe.int @int:59:33, s:wybe.int @int:59:39, ?tmp#0:wybe.int @int:59:33)
Types:     foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:59:29)
Types: Type checking non-recursive proc wybe.int.<=>
Types: ** Type checking decl of proc <=>
Types: found 1 definition(s)
Types: Type checking <=>
Types: ** Type checking <=>: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         <(x @int:94:10, y @int:94:14)
Types:         lesser(?tmp#1 @int:94:19)
Types:         foreign llvm move(tmp#1, ?tmp#0)
Types:         =(x @int:94:28, y @int:94:32)
Types:         equal(?tmp#3 @int:94:37)
Types:         foreign llvm move(tmp#3, ?tmp#2)
Types:         greater(?tmp#4 @int:94:53)
Types:         foreign llvm move(tmp#4, ?tmp#2)
Types:         foreign llvm move(tmp#2 @int:94:28, ?tmp#0)
Types:         foreign llvm move(tmp#0 @int:94:10, ?#result @int:93:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","tmp#1","tmp#2","tmp#3","tmp#4","x","y"]
Types: Recording parameter types: x:wybe.int, y:wybe.int, ?#result:wybe.comparison
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 'y' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable y type constrained to wybe.int
Types:     type of '#result' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable #result type constrained to wybe.comparison
Types: Recording resource types: 
Types: Recording casts in {<(x @int:94:10, y @int:94:14)}
Types: Recording casts in {lesser(?tmp#1 @int:94:19)}
Types: Recording casts in {foreign llvm move(tmp#1, ?tmp#0)}
Types: Unifying move argument types tmp#1 and ?tmp#0
Types: Finding type of expr tmp#1
Types:   Type = 0
Types: Finding type of expr ?tmp#0
Types:   Type = 1
Types: Type variable 0 is bound to Nothing
Types: Type variable 1 is bound to Nothing
Types: Unifying types 0 (-> 0) and 1 (-> 1)
Types:   Unification yields 0
Types: Recording casts in {=(x @int:94:28, y @int:94:32)}
Types: Recording casts in {equal(?tmp#3 @int:94:37)}
Types: Recording casts in {foreign llvm move(tmp#3, ?tmp#2)}
Types: Unifying move argument types tmp#3 and ?tmp#2
Types: Finding type of expr tmp#3
Types:   Type = 2
Types: Finding type of expr ?tmp#2
Types:   Type = 3
Types: Type variable 2 is bound to Nothing
Types: Type variable 3 is bound to Nothing
Types: Unifying types 2 (-> 2) and 3 (-> 3)
Types:   Unification yields 2
Types: Recording casts in {greater(?tmp#4 @int:94:53)}
Types: Recording casts in {foreign llvm move(tmp#4, ?tmp#2)}
Types: Unifying move argument types tmp#4 and ?tmp#2
Types: Finding type of expr tmp#4
Types:   Type = 4
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Nothing
Types:   Type = 2
Types: Type variable 4 is bound to Nothing
Types: Type variable 2 is bound to Nothing
Types: Unifying types 4 (-> 4) and 2 (-> 2)
Types:   Unification yields 2
Types: Recording casts in {foreign llvm move(tmp#2 @int:94:28, ?tmp#0)}
Types: Unifying move argument types tmp#2 @int:94:28 and ?tmp#0
Types: Finding type of expr tmp#2 @int:94:28
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Nothing
Types:   Type = 2
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Nothing
Types:   Type = 0
Types: Type variable 2 is bound to Nothing
Types: Type variable 0 is bound to Nothing
Types: Unifying types 2 (-> 2) and 0 (-> 0)
Types:   Unification yields 0
Types: Recording casts in {foreign llvm move(tmp#0 @int:94:10, ?#result @int:93:5)}
Types: Unifying move argument types tmp#0 @int:94:10 and ?#result @int:93:5
Types: Finding type of expr tmp#0 @int:94:10
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Nothing
Types:   Type = 0
Types: Finding type of expr ?#result @int:93:5
Types:   Type = wybe.comparison
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: *** Before calls Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {<(x @int:94:10, y @int:94:14)} @int:94:10, typingInfos = [wybe.comparison.<<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {lesser(?tmp#1 @int:94:19)} @int:94:19, typingInfos = [wybe.comparison.lesser<0>(?wybe.comparison)]}
Types:     StmtTypings {typingStmt = {=(x @int:94:28, y @int:94:32)} @int:94:28, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {equal(?tmp#3 @int:94:37)} @int:94:37, typingInfos = [wybe.comparison.equal<0>(?wybe.comparison)]}
Types:     StmtTypings {typingStmt = {greater(?tmp#4 @int:94:53)} @int:94:53, typingInfos = [wybe.comparison.greater<0>(?wybe.comparison)]}Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {<(x @int:94:10, y @int:94:14)} @int:94:10
Types: Candidate types:
Types:     wybe.comparison.<<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr x @int:94:10
Types:   Type = wybe.int
Types: Finding type of expr y @int:94:14
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.<<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 94, column 10): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 94, column 10): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {lesser(?tmp#1 @int:94:19)} @int:94:19
Types: Candidate types:
Types:     wybe.comparison.lesser<0>(?wybe.comparison)
Types: Finding type of expr ?tmp#1 @int:94:19
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Actual types: [wybe.comparison]
Types: Matching types [wybe.comparison] with wybe.comparison.lesser<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {=(x @int:94:28, y @int:94:32)} @int:94:28
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr x @int:94:28
Types:   Type = wybe.int
Types: Finding type of expr y @int:94:32
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 94, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 94, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 94, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 94, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {equal(?tmp#3 @int:94:37)} @int:94:37
Types: Candidate types:
Types:     wybe.comparison.equal<0>(?wybe.comparison)
Types: Finding type of expr ?tmp#3 @int:94:37
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Actual types: [wybe.comparison]
Types: Matching types [wybe.comparison] with wybe.comparison.equal<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {greater(?tmp#4 @int:94:53)} @int:94:53
Types: Candidate types:
Types:     wybe.comparison.greater<0>(?wybe.comparison)
Types: Finding type of expr ?tmp#4 @int:94:53
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Actual types: [wybe.comparison]
Types: Matching types [wybe.comparison] with wybe.comparison.greater<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Finding type of expr tmp#1
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Finding type of expr tmp#3
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Finding type of expr tmp#4
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Finding type of expr tmp#2 @int:94:28
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Finding type of expr tmp#0 @int:94:10
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?#result @int:93:5
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Now mode checking proc <=>
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt if {<(x @int:94:10, y @int:94:14)::
Types: 
Types:                     lesser(?tmp#1 @int:94:19)
Types:                     foreign llvm move(tmp#1, ?tmp#0)
Types:                 else::
Types:                     if {=(x @int:94:28, y @int:94:32)::
Types: 
Types:                         equal(?tmp#3 @int:94:37)
Types:                         foreign llvm move(tmp#3, ?tmp#2)
Types:                     else::
Types:                         greater(?tmp#4 @int:94:53)
Types:                         foreign llvm move(tmp#4, ?tmp#2)
Types: 
Types:                     }
Types:                     foreign llvm move(tmp#2 @int:94:28, ?tmp#0)
Types: 
Types:                 }
Types: Mode checking conditional {if {<(x @int:94:10, y @int:94:14)::
Types: 
Types:         lesser(?tmp#1 @int:94:19)
Types:         foreign llvm move(tmp#1, ?tmp#0)
Types:     else::
Types:         if {=(x @int:94:28, y @int:94:32)::
Types: 
Types:             equal(?tmp#3 @int:94:37)
Types:             foreign llvm move(tmp#3, ?tmp#2)
Types:         else::
Types:             greater(?tmp#4 @int:94:53)
Types:             foreign llvm move(tmp#4, ?tmp#2)
Types: 
Types:         }
Types:         foreign llvm move(tmp#2 @int:94:28, ?tmp#0)
Types: 
Types:     }}
Types: Mode checking call   : {<(x @int:94:10, y @int:94:14)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Finding type of expr x @int:94:10
Types:   Type = wybe.int
Types: Finding type of expr y @int:94:14
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.<<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 94, column 10): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 94, column 10): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.<<0>(wybe.int,wybe.int),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.<<0>(wybe.int,wybe.int),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.<<0>(wybe.int,wybe.int),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr x @int:94:10
Types:   Type = wybe.int
Types: Finding type of expr y @int:94:14
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0><(x:wybe.int @int:94:10, y:wybe.int @int:94:14)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0><(x:wybe.int @int:94:10, y:wybe.int @int:94:14)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '<=>'
Types: Assigned by test: semipure test computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt lesser(?tmp#1 @int:94:19)
Types: Mode checking call   : {lesser(?tmp#1 @int:94:19)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr ?tmp#1 @int:94:19
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     actual types     : [wybe.comparison]
Types:     actual modes     : [(ParamOut,False,Nothing)]
Types: Matching types [wybe.comparison] with wybe.comparison.lesser<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Type-correct modes   : [(wybe.comparison.lesser<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [(wybe.comparison.lesser<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [(wybe.comparison.lesser<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr ?tmp#1 @int:94:19
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finalising call    :  {wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @int:94:19)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @int:94:19)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<=>'
Types: Now assigned = semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#1, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(tmp#1, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#1
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#1:wybe.comparison, ?tmp#0:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Assigned by then branch: semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt if {=(x @int:94:28, y @int:94:32)::
Types: 
Types:                     equal(?tmp#3 @int:94:37)
Types:                     foreign llvm move(tmp#3, ?tmp#2)
Types:                 else::
Types:                     greater(?tmp#4 @int:94:53)
Types:                     foreign llvm move(tmp#4, ?tmp#2)
Types: 
Types:                 }
Types: Mode checking conditional {if {=(x @int:94:28, y @int:94:32)::
Types: 
Types:         equal(?tmp#3 @int:94:37)
Types:         foreign llvm move(tmp#3, ?tmp#2)
Types:     else::
Types:         greater(?tmp#4 @int:94:53)
Types:         foreign llvm move(tmp#4, ?tmp#2)
Types: 
Types:     }}
Types: Mode checking call   : {=(x @int:94:28, y @int:94:32)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Finding type of expr x @int:94:28
Types:   Type = wybe.int
Types: Finding type of expr y @int:94:32
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 94, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 94, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 94, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 94, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr x @int:94:28
Types:   Type = wybe.int
Types: Finding type of expr y @int:94:32
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>=(x:wybe.int @int:94:28, y:wybe.int @int:94:32)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>=(x:wybe.int @int:94:28, y:wybe.int @int:94:32)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '<=>'
Types: Assigned by test: semipure test computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt equal(?tmp#3 @int:94:37)
Types: Mode checking call   : {equal(?tmp#3 @int:94:37)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp ?tmp#3
Types: Mode check exp resulted in ?tmp#3
Types: Finding type of expr ?tmp#3 @int:94:37
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     actual types     : [wybe.comparison]
Types:     actual modes     : [(ParamOut,False,Nothing)]
Types: Matching types [wybe.comparison] with wybe.comparison.equal<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Type-correct modes   : [(wybe.comparison.equal<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [(wybe.comparison.equal<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [(wybe.comparison.equal<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr ?tmp#3 @int:94:37
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finalising call    :  {wybe.comparison.<0>equal(?tmp#3:wybe.comparison @int:94:37)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.comparison.<0>equal(?tmp#3:wybe.comparison @int:94:37)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<=>'
Types: Now assigned = semipure normal (total) computation binding {tmp#3, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#3, ?tmp#2)
Types: Mode checking foreign call {foreign llvm move(tmp#3, ?tmp#2)}
Types:     with assigned semipure normal (total) computation binding {tmp#3, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#3
Types: Mode check exp resulted in tmp#3
Types: Mode check exp ?tmp#2
Types: Mode check exp resulted in ?tmp#2
Types: Finding type of expr tmp#3
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#3:wybe.comparison, ?tmp#2:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {tmp#2, tmp#3, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Assigned by then branch: semipure normal (total) computation binding {tmp#2, tmp#3, x, y}, break set = Everything, with resources {}
Types: Mode check stmt greater(?tmp#4 @int:94:53)
Types: Mode checking call   : {greater(?tmp#4 @int:94:53)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp ?tmp#4
Types: Mode check exp resulted in ?tmp#4
Types: Finding type of expr ?tmp#4 @int:94:53
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     actual types     : [wybe.comparison]
Types:     actual modes     : [(ParamOut,False,Nothing)]
Types: Matching types [wybe.comparison] with wybe.comparison.greater<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Type-correct modes   : [(wybe.comparison.greater<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [(wybe.comparison.greater<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [(wybe.comparison.greater<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.int, y::wybe.int}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr ?tmp#4 @int:94:53
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finalising call    :  {wybe.comparison.<0>greater(?tmp#4:wybe.comparison @int:94:53)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.comparison.<0>greater(?tmp#4:wybe.comparison @int:94:53)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<=>'
Types: Now assigned = semipure normal (total) computation binding {tmp#4, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#4, ?tmp#2)
Types: Mode checking foreign call {foreign llvm move(tmp#4, ?tmp#2)}
Types:     with assigned semipure normal (total) computation binding {tmp#4, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#4
Types: Mode check exp resulted in tmp#4
Types: Mode check exp ?tmp#2
Types: Mode check exp resulted in ?tmp#2
Types: Finding type of expr tmp#4
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#4:wybe.comparison, ?tmp#2:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {tmp#2, tmp#4, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Assigned by else branch: semipure normal (total) computation binding {tmp#2, tmp#4, x, y}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {tmp#2, x, y}, break set = Everything, with resources {}
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types: Now assigned = semipure normal (total) computation binding {tmp#2, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#2 @int:94:28, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(tmp#2 @int:94:28, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {tmp#2, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#2
Types: Mode check exp resulted in tmp#2
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#2 @int:94:28
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#2:wybe.comparison @int:94:28, ?tmp#0:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#2, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Assigned by else branch: semipure normal (total) computation binding {tmp#0, tmp#2, x, y}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0 @int:94:10, ?#result @int:93:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0 @int:94:10, ?#result @int:93:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0 @int:94:10
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?#result @int:93:5
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#0:wybe.comparison @int:94:10, ?#result:wybe.comparison @int:93:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Mode checked body   : [{if {wybe.int.<0><(x:wybe.int @int:94:10, y:wybe.int @int:94:14)::
Types: 
Types:         wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @int:94:19)
Types:         foreign llvm move(tmp#1:wybe.comparison, ?tmp#0:wybe.comparison)
Types:     else::
Types:         if {wybe.int.<0>=(x:wybe.int @int:94:28, y:wybe.int @int:94:32)::
Types: 
Types:             wybe.comparison.<0>equal(?tmp#3:wybe.comparison @int:94:37)
Types:             foreign llvm move(tmp#3:wybe.comparison, ?tmp#2:wybe.comparison)
Types:         else::
Types:             wybe.comparison.<0>greater(?tmp#4:wybe.comparison @int:94:53)
Types:             foreign llvm move(tmp#4:wybe.comparison, ?tmp#2:wybe.comparison)
Types: 
Types:         }
Types:    condition -> {x::wybe.int, y::wybe.int}
Types:    then&else -> {tmp#2::wybe.comparison, x::wybe.int, y::wybe.int}
Types:         foreign llvm move(tmp#2:wybe.comparison @int:94:28, ?tmp#0:wybe.comparison)
Types: 
Types:     }
Types:    condition -> {x::wybe.int, y::wybe.int}
Types:    then&else -> {tmp#0::wybe.comparison, x::wybe.int, y::wybe.int}} @int:94:10,{foreign llvm move(tmp#0:wybe.comparison @int:94:10, ?#result:wybe.comparison @int:93:5)} @int:93:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <=>:
Types: 
Types: <=> > public (0 calls)
Types: 4: <=>(x:wybe.int @int:93:10, y:wybe.int @int:93:20, ?#result:wybe.comparison @int:93:5):
Types:     if {wybe.int.<0><(x:wybe.int @int:94:10, y:wybe.int @int:94:14)::
Types: 
Types:         wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @int:94:19)
Types:         foreign llvm move(tmp#1:wybe.comparison, ?tmp#0:wybe.comparison)
Types:     else::
Types:         if {wybe.int.<0>=(x:wybe.int @int:94:28, y:wybe.int @int:94:32)::
Types: 
Types:             wybe.comparison.<0>equal(?tmp#3:wybe.comparison @int:94:37)
Types:             foreign llvm move(tmp#3:wybe.comparison, ?tmp#2:wybe.comparison)
Types:         else::
Types:             wybe.comparison.<0>greater(?tmp#4:wybe.comparison @int:94:53)
Types:             foreign llvm move(tmp#4:wybe.comparison, ?tmp#2:wybe.comparison)
Types: 
Types:         }
Types:    condition -> {x::wybe.int, y::wybe.int}
Types:    then&else -> {tmp#2::wybe.comparison, x::wybe.int, y::wybe.int}
Types:         foreign llvm move(tmp#2:wybe.comparison @int:94:28, ?tmp#0:wybe.comparison)
Types: 
Types:     }
Types:    condition -> {x::wybe.int, y::wybe.int}
Types:    then&else -> {tmp#0::wybe.comparison, x::wybe.int, y::wybe.int}
Types:     foreign llvm move(tmp#0:wybe.comparison @int:94:10, ?#result:wybe.comparison @int:93:5)
Types: Type checking non-recursive proc wybe.int.>>=
Types: ** Type checking decl of proc >>=
Types: found 1 definition(s)
Types: Type checking >>=
Types: ** Type checking >>=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         >>(x @int:68:33, s @int:68:39, ?tmp#0 @int:68:33)
Types:         =(?x @int:68:29, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["s","tmp#0","x"]
Types: Recording parameter types: !x:wybe.int, s:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 's' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable s type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {>>(x @int:68:33, s @int:68:39, ?tmp#0 @int:68:33)}
Types: Recording casts in {=(?x @int:68:29, tmp#0)}
Types: *** Before calls Typing {s::wybe.int, x::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {>>(x @int:68:33, s @int:68:39, ?tmp#0 @int:68:33)} @int:68:33, typingInfos = [wybe.int.>><0>(wybe.int,wybe.int,?wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?x @int:68:29, tmp#0)} @int:68:29, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {s::wybe.int, x::wybe.int}; {} (with no errors)
Types: Type checking call {>>(x @int:68:33, s @int:68:39, ?tmp#0 @int:68:33)} @int:68:33
Types: Candidate types:
Types:     wybe.int.>><0>(wybe.int,wybe.int,?wybe.int)
Types: Finding type of expr x @int:68:33
Types:   Type = wybe.int
Types: Finding type of expr s @int:68:39
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:68:33
Types:   Type = 0
Types: Actual types: [wybe.int,wybe.int,0]
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.>><0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types: Type checking call {=(?x @int:68:29, tmp#0)} @int:68:29
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @int:68:29
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 68, column 29): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 68, column 29): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 68, column 29): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 68, column 29): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types: Now mode checking proc >>=
Types: bound vars: semipure normal (total) computation binding {s, x}, break set = Everything, with resources {}
Types: Mode check stmt >>(x @int:68:33, s @int:68:39, ?tmp#0 @int:68:33)
Types: Mode checking call   : {>>(x @int:68:33, s @int:68:39, ?tmp#0 @int:68:33)}
Types:     with assigned    : semipure normal (total) computation binding {s, x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp s
Types: Mode check exp resulted in s
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:68:33
Types:   Type = wybe.int
Types: Finding type of expr s @int:68:39
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:68:33
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.>><0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.>><0>(wybe.int,wybe.int,?wybe.int),Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.>><0>(wybe.int,wybe.int,?wybe.int),Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.>><0>(wybe.int,wybe.int,?wybe.int),Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Finding type of expr x @int:68:33
Types:   Type = wybe.int
Types: Finding type of expr s @int:68:39
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:68:33
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>>>(x:wybe.int @int:68:33, s:wybe.int @int:68:39, ?tmp#0:wybe.int @int:68:33)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"s", "x"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>>>(x:wybe.int @int:68:33, s:wybe.int @int:68:39, ?tmp#0:wybe.int @int:68:33)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '>>='
Types: Now assigned = semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @int:68:29, tmp#0)
Types: Mode checking call   : {=(?x @int:68:29, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @int:68:29
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 68, column 29): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 68, column 29): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 68, column 29): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 68, column 29): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @int:68:29)}
Types:     with assigned semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?x @int:68:29
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:68:29)}
Types: Now assigned = semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc '>>='
Types: Mode checked body   : [{wybe.int.<0>>>(x:wybe.int @int:68:33, s:wybe.int @int:68:39, ?tmp#0:wybe.int @int:68:33)} @int:68:33,{foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:68:29)} @int:68:29]
Types: Vars defined by body: semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of >>=:
Types: 
Types: >>= > public (0 calls)
Types: 4: >>=(!x:wybe.int @int:68:11, s:wybe.int @int:68:21):
Types:     wybe.int.<0>>>(x:wybe.int @int:68:33, s:wybe.int @int:68:39, ?tmp#0:wybe.int @int:68:33)
Types:     foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:68:29)
Types: Type checking non-recursive proc wybe.int.decr
Types: ** Type checking decl of proc decr
Types: found 1 definition(s)
Types: Type checking decr
Types: ** Type checking decr: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         -(x @int:111:27, 1 @int:111:31, ?tmp#0 @int:111:27)
Types:         =(?x @int:111:23, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x"]
Types: Recording parameter types: !x:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {-(x @int:111:27, 1 @int:111:31, ?tmp#0 @int:111:27)}
Types: Recording casts in {=(?x @int:111:23, tmp#0)}
Types: *** Before calls Typing {x::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {-(x @int:111:27, 1 @int:111:31, ?tmp#0 @int:111:27)} @int:111:27, typingInfos = [wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),wybe.int.-<3>(wybe.int,?wybe.int),wybe.int.-<4>(?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?x @int:111:23, tmp#0)} @int:111:23, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.int}; {} (with no errors)
Types: Type checking call {-(x @int:111:27, 1 @int:111:31, ?tmp#0 @int:111:27)} @int:111:27
Types: Candidate types:
Types:     wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types:     wybe.int.-<3>(wybe.int,?wybe.int)
Types:     wybe.int.-<4>(?wybe.int,wybe.int)
Types: Finding type of expr x @int:111:27
Types:   Type = wybe.int
Types: Finding type of expr 1 @int:111:31
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:111:27
Types:   Type = 0
Types: Actual types: [wybe.int,wybe.int,0]
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types: Type checking call {=(?x @int:111:23, tmp#0)} @int:111:23
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @int:111:23
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 111, column 23): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 111, column 23): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 111, column 23): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 111, column 23): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types: Now mode checking proc decr
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt -(x @int:111:27, 1 @int:111:31, ?tmp#0 @int:111:27)
Types: Mode checking call   : {-(x @int:111:27, 1 @int:111:31, ?tmp#0 @int:111:27)}
Types:     with assigned    : semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:111:27
Types:   Type = wybe.int
Types: Finding type of expr 1 @int:111:31
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:111:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)),(wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)),(wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Finding type of expr x @int:111:27
Types:   Type = wybe.int
Types: Finding type of expr 1 @int:111:31
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:111:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>-(x:wybe.int @int:111:27, 1:wybe.int @int:111:31, ?tmp#0:wybe.int @int:111:27)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>-(x:wybe.int @int:111:27, 1:wybe.int @int:111:31, ?tmp#0:wybe.int @int:111:27)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'decr'
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @int:111:23, tmp#0)
Types: Mode checking call   : {=(?x @int:111:23, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @int:111:23
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 111, column 23): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 111, column 23): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 111, column 23): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 111, column 23): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @int:111:23)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?x @int:111:23
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:111:23)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'decr'
Types: Mode checked body   : [{wybe.int.<0>-(x:wybe.int @int:111:27, 1:wybe.int @int:111:31, ?tmp#0:wybe.int @int:111:27)} @int:111:27,{foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:111:23)} @int:111:23]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of decr:
Types: 
Types: decr > public (0 calls)
Types: 4: decr(!x:wybe.int @int:111:15):
Types:     wybe.int.<0>-(x:wybe.int @int:111:27, 1:wybe.int @int:111:31, ?tmp#0:wybe.int @int:111:27)
Types:     foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:111:23)
Types: Type checking non-recursive proc wybe.int.incr
Types: ** Type checking decl of proc incr
Types: found 1 definition(s)
Types: Type checking incr
Types: ** Type checking incr: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         +(x @int:110:27, 1 @int:110:31, ?tmp#0 @int:110:27)
Types:         =(?x @int:110:23, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x"]
Types: Recording parameter types: !x:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {+(x @int:110:27, 1 @int:110:31, ?tmp#0 @int:110:27)}
Types: Recording casts in {=(?x @int:110:23, tmp#0)}
Types: *** Before calls Typing {x::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {+(x @int:110:27, 1 @int:110:31, ?tmp#0 @int:110:27)} @int:110:27, typingInfos = [wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?x @int:110:23, tmp#0)} @int:110:23, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.int}; {} (with no errors)
Types: Type checking call {+(x @int:110:27, 1 @int:110:31, ?tmp#0 @int:110:27)} @int:110:27
Types: Candidate types:
Types:     wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Finding type of expr x @int:110:27
Types:   Type = wybe.int
Types: Finding type of expr 1 @int:110:31
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:110:27
Types:   Type = 0
Types: Actual types: [wybe.int,wybe.int,0]
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types: Type checking call {=(?x @int:110:23, tmp#0)} @int:110:23
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @int:110:23
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 110, column 23): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 110, column 23): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 110, column 23): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 110, column 23): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types: Now mode checking proc incr
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt +(x @int:110:27, 1 @int:110:31, ?tmp#0 @int:110:27)
Types: Mode checking call   : {+(x @int:110:27, 1 @int:110:31, ?tmp#0 @int:110:27)}
Types:     with assigned    : semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:110:27
Types:   Type = wybe.int
Types: Finding type of expr 1 @int:110:31
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:110:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)),(wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)),(wybe.int.+<2>(wybe.int,?wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Finding type of expr x @int:110:27
Types:   Type = wybe.int
Types: Finding type of expr 1 @int:110:31
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:110:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>+(x:wybe.int @int:110:27, 1:wybe.int @int:110:31, ?tmp#0:wybe.int @int:110:27)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>+(x:wybe.int @int:110:27, 1:wybe.int @int:110:31, ?tmp#0:wybe.int @int:110:27)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'incr'
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @int:110:23, tmp#0)
Types: Mode checking call   : {=(?x @int:110:23, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @int:110:23
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 110, column 23): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 110, column 23): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 110, column 23): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 110, column 23): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @int:110:23)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?x @int:110:23
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:110:23)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'incr'
Types: Mode checked body   : [{wybe.int.<0>+(x:wybe.int @int:110:27, 1:wybe.int @int:110:31, ?tmp#0:wybe.int @int:110:27)} @int:110:27,{foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:110:23)} @int:110:23]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of incr:
Types: 
Types: incr > public (0 calls)
Types: 4: incr(!x:wybe.int @int:110:15):
Types:     wybe.int.<0>+(x:wybe.int @int:110:27, 1:wybe.int @int:110:31, ?tmp#0:wybe.int @int:110:27)
Types:     foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:110:23)
Types: **** Type checking recursive procs wybe.int.logical_bitshift
Types: ** Type checking decl of proc logical_bitshift
Types: found 2 definition(s)
Types: Type checking logical_bitshift
Types: ** Type checking logical_bitshift: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm lshr(x @int:74:58, s @int:74:61, ?tmp#0 @int:74:40)
Types:         foreign llvm move(tmp#0, ?#result @int:74:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","s","tmp#0","x"]
Types: Recording parameter types: x:wybe.int, s:wybe.int, ?#result:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 's' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable s type constrained to wybe.int
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign llvm lshr(x @int:74:58, s @int:74:61, ?tmp#0 @int:74:40)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @int:74:5)}
Types: Unifying move argument types tmp#0 and ?#result @int:74:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @int:74:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.int, s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types: Finding type of expr x @int:74:58
Types:   Type = wybe.int
Types: Finding type of expr s @int:74:61
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:74:40
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call lshr(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:74:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc logical_bitshift
Types: bound vars: semipure normal (total) computation binding {s, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm lshr(x @int:74:58, s @int:74:61, ?tmp#0 @int:74:40)
Types: Mode checking foreign call {foreign llvm lshr(x @int:74:58, s @int:74:61, ?tmp#0 @int:74:40)}
Types:     with assigned semipure normal (total) computation binding {s, x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp s
Types: Mode check exp resulted in s
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:74:58
Types:   Type = wybe.int
Types: Finding type of expr s @int:74:61
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:74:40
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm lshr(x:wybe.int @int:74:58, s:wybe.int @int:74:61, ?tmp#0:wybe.int @int:74:40)}
Types: Now assigned = semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @int:74:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @int:74:5)}
Types:     with assigned semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @int:74:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:74:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'logical_bitshift'
Types: Mode checked body   : [{foreign llvm lshr(x:wybe.int @int:74:58, s:wybe.int @int:74:61, ?tmp#0:wybe.int @int:74:40)} @int:74:40,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:74:5)} @int:74:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, s, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking logical_bitshift
Types: ** Type checking logical_bitshift: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         logical_bitshift(x @int:77:61, s @int:77:64, ?tmp#0 @int:77:44)
Types:         =(?x @int:77:40, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["s","tmp#0","x"]
Types: Recording parameter types: !x:wybe.int, s:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types:     type of 's' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable s type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {logical_bitshift(x @int:77:61, s @int:77:64, ?tmp#0 @int:77:44)}
Types: Recording casts in {=(?x @int:77:40, tmp#0)}
Types: *** Before calls Typing {s::wybe.int, x::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {logical_bitshift(x @int:77:61, s @int:77:64, ?tmp#0 @int:77:44)} @int:77:44, typingInfos = [wybe.int.logical_bitshift<0>(wybe.int,wybe.int,?wybe.int),wybe.int.logical_bitshift<1>(!wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?x @int:77:40, tmp#0)} @int:77:40, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {s::wybe.int, x::wybe.int}; {} (with no errors)
Types: Type checking call {logical_bitshift(x @int:77:61, s @int:77:64, ?tmp#0 @int:77:44)} @int:77:44
Types: Candidate types:
Types:     wybe.int.logical_bitshift<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.logical_bitshift<1>(!wybe.int,wybe.int)
Types: Finding type of expr x @int:77:61
Types:   Type = wybe.int
Types: Finding type of expr s @int:77:64
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:77:44
Types:   Type = 0
Types: Actual types: [wybe.int,wybe.int,0]
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.logical_bitshift<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types: Type checking call {=(?x @int:77:40, tmp#0)} @int:77:40
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @int:77:40
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 77, column 40): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 77, column 40): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 77, column 40): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 77, column 40): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)]
Types: Resulting typing = Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors)
Types: Now mode checking proc logical_bitshift
Types: bound vars: semipure normal (total) computation binding {s, x}, break set = Everything, with resources {}
Types: Mode check stmt logical_bitshift(x @int:77:61, s @int:77:64, ?tmp#0 @int:77:44)
Types: Mode checking call   : {logical_bitshift(x @int:77:61, s @int:77:64, ?tmp#0 @int:77:44)}
Types:     with assigned    : semipure normal (total) computation binding {s, x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp s
Types: Mode check exp resulted in s
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @int:77:61
Types:   Type = wybe.int
Types: Finding type of expr s @int:77:64
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:77:44
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.logical_bitshift<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.logical_bitshift<0>(wybe.int,wybe.int,?wybe.int),Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.logical_bitshift<0>(wybe.int,wybe.int,?wybe.int),Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.logical_bitshift<0>(wybe.int,wybe.int,?wybe.int),Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Finding type of expr x @int:77:61
Types:   Type = wybe.int
Types: Finding type of expr s @int:77:64
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @int:77:44
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>logical_bitshift(x:wybe.int @int:77:61, s:wybe.int @int:77:64, ?tmp#0:wybe.int @int:77:44)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"s", "x"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>logical_bitshift(x:wybe.int @int:77:61, s:wybe.int @int:77:64, ?tmp#0:wybe.int @int:77:44)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'logical_bitshift'
Types: Now assigned = semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @int:77:40, tmp#0)
Types: Mode checking call   : {=(?x @int:77:40, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @int:77:40
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 77, column 40): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 77, column 40): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 77, column 40): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/int.wybe" (line 77, column 40): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {s::wybe.int, tmp#0::0, x::wybe.int}; {0::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @int:77:40)}
Types:     with assigned semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?x @int:77:40
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:77:40)}
Types: Now assigned = semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'logical_bitshift'
Types: Mode checked body   : [{wybe.int.<0>logical_bitshift(x:wybe.int @int:77:61, s:wybe.int @int:77:64, ?tmp#0:wybe.int @int:77:44)} @int:77:44,{foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:77:40)} @int:77:40]
Types: Vars defined by body: semipure normal (total) computation binding {s, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of logical_bitshift:
Types: 
Types: logical_bitshift > public (0 calls)
Types: 4: logical_bitshift(x:wybe.int @int:74:26, s:wybe.int @int:74:31, ?#result:wybe.int @int:74:5):
Types:     foreign llvm lshr(x:wybe.int @int:74:58, s:wybe.int @int:74:61, ?tmp#0:wybe.int @int:74:40)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:74:5)
Types: 
Types: logical_bitshift > public (0 calls)
Types: 4: logical_bitshift(!x:wybe.int @int:77:27, s:wybe.int @int:77:32):
Types:     wybe.int.<0>logical_bitshift(x:wybe.int @int:77:61, s:wybe.int @int:77:64, ?tmp#0:wybe.int @int:77:44)
Types:     foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:77:40)
Types: **** Completed checking of wybe.int.logical_bitshift with 0 errors
Types: Type checking non-recursive proc wybe.bool.&&
Types: ** Type checking decl of proc &&
Types: found 1 definition(s)
Types: Type checking &&
Types: ** Type checking &&: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm and(p @bool:13:44, q @bool:13:47, ?tmp#0 @bool:13:27)
Types:         foreign llvm move(tmp#0, ?#result @bool:13:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","p","q","tmp#0"]
Types: Recording parameter types: p:wybe.bool, q:wybe.bool, ?#result:wybe.bool
Types:     type of 'p' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable p type constrained to wybe.bool
Types:     type of 'q' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable q type constrained to wybe.bool
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm and(p @bool:13:44, q @bool:13:47, ?tmp#0 @bool:13:27)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @bool:13:5)}
Types: Unifying move argument types tmp#0 and ?#result @bool:13:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @bool:13:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)
Types: Finding type of expr p @bool:13:44
Types:   Type = wybe.bool
Types: Finding type of expr q @bool:13:47
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:13:27
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call and(1 bit unsigned, 1 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @bool:13:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc &&
Types: bound vars: semipure normal (total) computation binding {p, q}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(p @bool:13:44, q @bool:13:47, ?tmp#0 @bool:13:27)
Types: Mode checking foreign call {foreign llvm and(p @bool:13:44, q @bool:13:47, ?tmp#0 @bool:13:27)}
Types:     with assigned semipure normal (total) computation binding {p, q}, break set = Everything, with resources {}
Types: Mode check exp p
Types: Mode check exp resulted in p
Types: Mode check exp q
Types: Mode check exp resulted in q
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr p @bool:13:44
Types:   Type = wybe.bool
Types: Finding type of expr q @bool:13:47
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:13:27
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm and(p:wybe.bool @bool:13:44, q:wybe.bool @bool:13:47, ?tmp#0:wybe.bool @bool:13:27)}
Types: Now assigned = semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @bool:13:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @bool:13:5)}
Types:     with assigned semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @bool:13:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:13:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of Det proc '&&'
Types: Mode checked body   : [{foreign llvm and(p:wybe.bool @bool:13:44, q:wybe.bool @bool:13:47, ?tmp#0:wybe.bool @bool:13:27)} @bool:13:27,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:13:5)} @bool:13:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, p, q, tmp#0}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of &&:
Types: 
Types: && > public (0 calls)
Types: 4: &&(p:wybe.bool @bool:13:10, q:wybe.bool @bool:13:18, ?#result:wybe.bool @bool:13:5):
Types:     foreign llvm and(p:wybe.bool @bool:13:44, q:wybe.bool @bool:13:47, ?tmp#0:wybe.bool @bool:13:27)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:13:5)
Types: Type checking non-recursive proc wybe.bool.&=
Types: ** Type checking decl of proc &=
Types: found 1 definition(s)
Types: Type checking &=
Types: ** Type checking &=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         &&(p @bool:16:32, q @bool:16:38, ?tmp#0 @bool:16:32)
Types:         =(?p @bool:16:27, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["p","q","tmp#0"]
Types: Recording parameter types: !p:wybe.bool, q:wybe.bool
Types:     type of 'p' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable p type constrained to wybe.bool
Types:     type of 'q' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable q type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {&&(p @bool:16:32, q @bool:16:38, ?tmp#0 @bool:16:32)}
Types: Recording casts in {=(?p @bool:16:27, tmp#0)}
Types: *** Before calls Typing {p::wybe.bool, q::wybe.bool}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {&&(p @bool:16:32, q @bool:16:38, ?tmp#0 @bool:16:32)} @bool:16:32, typingInfos = [wybe.bool.&&<0>(wybe.bool,wybe.bool,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {=(?p @bool:16:27, tmp#0)} @bool:16:27, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool)]}Typing {p::wybe.bool, q::wybe.bool}; {} (with no errors)
Types: Type checking call {&&(p @bool:16:32, q @bool:16:38, ?tmp#0 @bool:16:32)} @bool:16:32
Types: Candidate types:
Types:     wybe.bool.&&<0>(wybe.bool,wybe.bool,?wybe.bool)
Types: Finding type of expr p @bool:16:32
Types:   Type = wybe.bool
Types: Finding type of expr q @bool:16:38
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:16:32
Types:   Type = 0
Types: Actual types: [wybe.bool,wybe.bool,0]
Types: Matching types [wybe.bool,wybe.bool,0] with wybe.bool.&&<0>(wybe.bool,wybe.bool,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Valid types = [Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)]
Types: Resulting typing = Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)
Types: Type checking call {=(?p @bool:16:27, tmp#0)} @bool:16:27
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types: Finding type of expr ?p @bool:16:27
Types:   Type = wybe.bool
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Actual types: [wybe.bool,wybe.bool]
Types: Matching types [wybe.bool,wybe.bool] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.bool,wybe.bool] with {test} wybe.c_string.=<0>(wybe.c_string,wybe.c_string)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/bool.wybe" (line 16, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/bool.wybe" (line 16, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)]
Types: Resulting typing = Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors)
Types: Now mode checking proc &=
Types: bound vars: semipure normal (total) computation binding {p, q}, break set = Everything, with resources {}
Types: Mode check stmt &&(p @bool:16:32, q @bool:16:38, ?tmp#0 @bool:16:32)
Types: Mode checking call   : {&&(p @bool:16:32, q @bool:16:38, ?tmp#0 @bool:16:32)}
Types:     with assigned    : semipure normal (total) computation binding {p, q}, break set = Everything, with resources {}
Types: Mode check exp p
Types: Mode check exp resulted in p
Types: Mode check exp q
Types: Mode check exp resulted in q
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr p @bool:16:32
Types:   Type = wybe.bool
Types: Finding type of expr q @bool:16:38
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:16:32
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     actual types     : [wybe.bool,wybe.bool,wybe.bool]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.bool,wybe.bool,wybe.bool] with wybe.bool.&&<0>(wybe.bool,wybe.bool,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Type-correct modes   : [(wybe.bool.&&<0>(wybe.bool,wybe.bool,?wybe.bool),Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors))]
Types: Possible mode matches: [(wybe.bool.&&<0>(wybe.bool,wybe.bool,?wybe.bool),Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors))]
Types: Exact mode matches: [(wybe.bool.&&<0>(wybe.bool,wybe.bool,?wybe.bool),Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors))]
Types: Finding type of expr p @bool:16:32
Types:   Type = wybe.bool
Types: Finding type of expr q @bool:16:38
Types:   Type = wybe.bool
Types: Finding type of expr ?tmp#0 @bool:16:32
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finalising call    :  {wybe.bool.<0>&&(p:wybe.bool @bool:16:32, q:wybe.bool @bool:16:38, ?tmp#0:wybe.bool @bool:16:32)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"p", "q"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.bool.<0>&&(p:wybe.bool @bool:16:32, q:wybe.bool @bool:16:38, ?tmp#0:wybe.bool @bool:16:32)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '&='
Types: Now assigned = semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt =(?p @bool:16:27, tmp#0)
Types: Mode checking call   : {=(?p @bool:16:27, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp ?p
Types: Mode check exp resulted in ?p
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?p @bool:16:27
Types:   Type = wybe.bool
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     actual types     : [wybe.bool,wybe.bool]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.bool,wybe.bool] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.bool,wybe.bool] with {test} wybe.c_string.=<0>(wybe.c_string,wybe.c_string)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/bool.wybe" (line 16, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/bool.wybe" (line 16, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.bool.=<0>(wybe.bool,wybe.bool),Typing {p::wybe.bool, q::wybe.bool, tmp#0::0}; {0::wybe.bool} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?p @bool:16:27)}
Types:     with assigned semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?p
Types: Mode check exp resulted in ?p
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?p @bool:16:27
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?p:wybe.bool @bool:16:27)}
Types: Now assigned = semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of Det proc '&='
Types: Mode checked body   : [{wybe.bool.<0>&&(p:wybe.bool @bool:16:32, q:wybe.bool @bool:16:38, ?tmp#0:wybe.bool @bool:16:32)} @bool:16:32,{foreign llvm move(tmp#0:wybe.bool, ?p:wybe.bool @bool:16:27)} @bool:16:27]
Types: Vars defined by body: semipure normal (total) computation binding {p, q, tmp#0}, break set = Everything, with resources {}
Types: Output parameters   : p
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of &=:
Types: 
Types: &= > public (0 calls)
Types: 4: &=(!p:wybe.bool @bool:16:11, q:wybe.bool @bool:16:19):
Types:     wybe.bool.<0>&&(p:wybe.bool @bool:16:32, q:wybe.bool @bool:16:38, ?tmp#0:wybe.bool @bool:16:32)
Types:     foreign llvm move(tmp#0:wybe.bool, ?p:wybe.bool @bool:16:27)
======================================================================
AFTER TYPE CHECK:
 Module wybe
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : 
  imports         : public use wybe.array
                    public use wybe.bool
                    public use wybe.c_string
                    public use wybe.char
                    public use wybe.comparison
                    public use wybe.control
                    public use wybe.count
                    public use wybe.float
                    public use wybe.int
                    public use wybe.io
                    public use wybe.list
                    public use wybe.machine_word
                    public use wybe.memory_management
                    public use wybe.phantom
                    public use wybe.predicate
                    public use wybe.range
                    public use wybe.string
  resources       : 
  submodules      : wybe.array, wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.control, wybe.count, wybe.float, wybe.int, wybe.io, wybe.list, wybe.machine_word, wybe.memory_management, wybe.phantom, wybe.predicate, wybe.range, wybe.string
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.array(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.array.[]<0>
                    wybe.array.[]<1>
                    wybe.array.[|]<0>
                    wybe.array.array<0>
                    wybe.array.array<1>
                    wybe.array.inbounds<0>
                    wybe.array.unsafe_get<0>
                    wybe.array.unsafe_update<0>
  imports         : public use wybe.array.raw_array
                    use wybe.bool
                    use wybe.int
                    use wybe.list
                    use wybe.machine_word
  resources       : 
  submodules      : wybe.array.raw_array
  procs           : 

[] > public {test} (0 calls)
0: [](a:_(T) @array:67:21, idx:int @array:67:29, ?#result:T @array:67:5):
    inbounds(a @array:68:14, idx @array:68:17)
    unsafe_get(a @array:69:10, idx @array:69:23, ?tmp#0 @array:69:10)
    =(?x @array:69:6, tmp#0)
    foreign llvm move(x @array:67:42, ?#result @array:67:5)
[] > public {test} (0 calls)
1: [](!a:_(T) @array:81:22, idx:int @array:81:30, x:T @array:81:39):
    inbounds(a @array:82:14, idx @array:82:17)
    unsafe_update(!a @array:83:20, idx @array:83:23, x @array:83:28)


[|] > public {test} (0 calls)
0: [|](?head:T @array:51:23, ?tail:_(T) @array:51:32, a:_(T) @array:51:43):
    array(?length @array:52:12, ?data @array:52:21, a @array:52:29)
    >(length @array:53:6, 0 @array:53:15)
    word_size_bytes(?tmp#0 @array:54:34)
    foreign lpvm access(data @array:54:25, 0 @array:54:31, tmp#0, 0 @array:54:51, ?head @array:54:55)
    word_size_bytes(?tmp#1 @array:55:28)
    foreign llvm add(data @array:55:22, tmp#1, ?data @array:55:46)
    -(length @array:56:19, 1 @array:56:28, ?tmp#3 @array:56:19)
    array(tmp#3, data @array:56:31, ?tmp#2 @array:56:13)
    =(?tail @array:56:6, tmp#2)


array > public (0 calls)
0: array(x:T @array:18:15, len:int @array:18:20, ?#result:_(T) @array:18:5):
    word_size_bytes(?tmp#1 @array:19:19)
    *(len @array:19:13, tmp#1, ?tmp#0 @array:19:13)
    =(?size @array:19:6, tmp#0)
    foreign lpvm alloc(size @array:20:24, ?data @array:20:31)
    =(?offset @array:21:6, 0 @array:21:15)
    do {
        if {<(offset @array:23:15, size @array:23:24)::

            pass
        else::
            break

        }
        foreign lpvm mutate(data @array:24:29, ?data @array:24:36, offset @array:24:42, 1 @array:24:50, size @array:24:53, 0 @array:24:59, x @array:24:62)
        word_size_bytes(?tmp#2 @array:25:21)
        +=(!offset @array:25:10, tmp#2)
    }
    array(len @array:27:17, data @array:27:22, ?tmp#3 @array:27:11)
    =(?ar @array:27:6, tmp#3)
    foreign llvm move(ar @array:18:36, ?#result @array:18:5)
array > public (0 calls)
1: array(ls:list(T) @array:34:15, ?#result:_(T) @array:34:5):
    length(ls @array:35:19, ?tmp#0 @array:35:12)
    =(?len @array:35:6, tmp#0)
    word_size_bytes(?tmp#2 @array:36:19)
    *(len @array:36:13, tmp#2, ?tmp#1 @array:36:13)
    =(?size @array:36:6, tmp#1)
    foreign lpvm alloc(size @array:37:24, ?data @array:37:31)
    =(?offset @array:38:6, 0 @array:38:15)
    foreign llvm move(ls @array:39:15, ?tmp#3)
    do {
        if {[|](?x @array:39:10, ?tmp#3, tmp#3)::

            foreign lpvm mutate(data @array:40:29, ?data @array:40:36, offset @array:40:42, 1 @array:40:50, size @array:40:53, 0 @array:40:59, x @array:40:62)
            word_size_bytes(?tmp#4 @array:41:21)
            +=(!offset @array:41:10, tmp#4)
        else::
            break

        }
    }
    array(len @array:43:17, data @array:43:22, ?tmp#5 @array:43:11)
    =(?ar @array:43:6, tmp#5)
    foreign llvm move(ar @array:34:34, ?#result @array:34:5)


inbounds > public {test,inline} (0 calls)
0: inbounds(a:_(T) @array:60:33, idx:int @array:60:41):
    <=(0 @array:61:6, idx @array:61:12)
    length(a @array:62:12, ?tmp#0 @array:62:12)
    <(idx @array:62:6, tmp#0)


unsafe_get > public {inline} (0 calls)
0: unsafe_get(a:_(T) @array:75:29, idx:int @array:75:37, ?#result:T @array:75:5):
    raw_data(a @array:76:25, ?tmp#0 @array:76:25)
    word_size_bytes(?tmp#2 @array:76:43)
    *(idx @array:76:37, tmp#2, ?tmp#1 @array:76:37)
    word_size_bytes(?tmp#3 @array:76:60)
    foreign lpvm access(tmp#0, tmp#1, tmp#3, 0 @array:76:77, ?x @array:76:81)
    foreign llvm move(x @array:75:50, ?#result @array:75:5)


unsafe_update > public {inline} (0 calls)
0: unsafe_update(!a:_(T) @array:89:33, idx:int @array:89:41, x:T @array:89:50):
    raw_data(a @array:90:25, ?tmp#0 @array:90:25)
    word_size_bytes(?tmp#2 @array:90:50)
    *(idx @array:90:44, tmp#2, ?tmp#1 @array:90:44)
    length(a @array:91:44, ?tmp#4 @array:91:44)
    word_size_bytes(?tmp#5 @array:91:55)
    *(tmp#4, tmp#5, ?tmp#3 @array:91:44)
    foreign lpvm mutate(tmp#0, ?data @array:90:38, tmp#1, 0 @array:90:67, tmp#3, 0 @array:91:72, x @array:91:75)
    raw_data(!a @array:92:6, data @array:92:19)

LLVM code       : None

--------------------------------------------------
 Module wybe.array.raw_array(T)
  representation  : address
  public submods  : 
  public resources: 
  public procs    : 
  imports         : use wybe
                    use wybe.array
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.bool
  representation  : 1 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.bool.&&<0>
                    wybe.bool.&=<0>
                    wybe.bool.=<0>
                    wybe.bool.^=<0>
                    wybe.bool.^^<0>
                    wybe.bool.false<0>
                    wybe.bool.print<0>
                    wybe.bool.println<0>
                    wybe.bool.succeed<0>
                    wybe.bool.true<0>
                    wybe.bool.|=<0>
                    wybe.bool.||<0>
                    wybe.bool.~<0>
                    wybe.bool.~=<0>
  imports         : use wybe.c_string
                    use wybe.io
  resources       : 
  procs           : 

&& > public (0 calls)
0: &&(p:wybe.bool @bool:13:10, q:wybe.bool @bool:13:18, ?#result:wybe.bool @bool:13:5):
    foreign llvm and(p:wybe.bool @bool:13:44, q:wybe.bool @bool:13:47, ?tmp#0:wybe.bool @bool:13:27)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:13:5)


&= > public (0 calls)
0: &=(!p:wybe.bool @bool:16:11, q:wybe.bool @bool:16:19):
    wybe.bool.<0>&&(p:wybe.bool @bool:16:32, q:wybe.bool @bool:16:38, ?tmp#0:wybe.bool @bool:16:32)
    foreign llvm move(tmp#0:wybe.bool, ?p:wybe.bool @bool:16:27)


= > public (0 calls)
0: =(x:wybe.bool @bool:37:10, y:wybe.bool @bool:37:17, ?#result:wybe.bool @bool:37:5):
    foreign llvm icmp_eq(x:wybe.bool @bool:37:47, y:wybe.bool @bool:37:50, ?tmp#0:wybe.bool @bool:37:26)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:37:5)


^= > public (0 calls)
0: ^=(!p:wybe.bool @bool:28:11, q:wybe.bool @bool:28:19):
    wybe.bool.<0>^^(q:wybe.bool @bool:28:31, p:wybe.bool @bool:28:37, ?tmp#0:wybe.bool @bool:28:31)
    foreign llvm move(tmp#0:wybe.bool, ?p:wybe.bool @bool:28:27)


^^ > public (0 calls)
0: ^^(p:wybe.bool @bool:25:10, q:wybe.bool @bool:25:18, ?#result:wybe.bool @bool:25:5):
    foreign llvm xor(p:wybe.bool @bool:25:44, q:wybe.bool @bool:25:47, ?tmp#0:wybe.bool @bool:25:27)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:25:5)


false > public {inline} (0 calls)
0: false(?#result:wybe.bool @bool:8:18):
    foreign lpvm cast(0:!wybe.bool, ?#result:wybe.bool)


print > public (0 calls)
0: print(x:wybe.bool @bool:47:15) use !wybe.io.io:
    if {testbool x:wybe.bool::

        foreign llvm move(c"true":wybe.c_string @bool:47:45, ?tmp#0:wybe.c_string)
    else::
        foreign llvm move(c"false":wybe.c_string @bool:47:60, ?tmp#0:wybe.c_string)

    }
   condition -> {io::wybe.phantom, x::wybe.bool}
   then&else -> {io::wybe.phantom, tmp#0::wybe.c_string, x::wybe.bool}
    !wybe.c_string.<0>print(tmp#0:wybe.c_string @bool:47:41)


println > public (0 calls)
0: println(x:wybe.bool @bool:49:17) use !wybe.io.io:
    !wybe.bool.<0>print(x:wybe.bool @bool:49:39)
    !wybe.io.<0>nl


succeed > public (0 calls)
0: succeed():
    pass


true > public {inline} (0 calls)
0: true(?#result:wybe.bool @bool:8:26):
    foreign lpvm cast(1:!wybe.bool, ?#result:wybe.bool)


|= > public (0 calls)
0: |=(!p:wybe.bool @bool:22:11, q:wybe.bool @bool:22:19):
    wybe.bool.<0>||(p:wybe.bool @bool:22:32, q:wybe.bool @bool:22:38, ?tmp#0:wybe.bool @bool:22:32)
    foreign llvm move(tmp#0:wybe.bool, ?p:wybe.bool @bool:22:27)


|| > public (0 calls)
0: ||(p:wybe.bool @bool:19:10, q:wybe.bool @bool:19:18, ?#result:wybe.bool @bool:19:5):
    foreign llvm or(p:wybe.bool @bool:19:43, q:wybe.bool @bool:19:46, ?tmp#0:wybe.bool @bool:19:27)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:19:5)


~ > public (0 calls)
0: ~(p:wybe.bool @bool:31:11, ?#result:wybe.bool @bool:31:5):
    wybe.bool.<0>true(?tmp#1:wybe.bool @bool:31:40)
    foreign llvm xor(p:wybe.bool @bool:31:37, tmp#1:wybe.bool, ?tmp#0:wybe.bool @bool:31:20)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:31:5)


~= > public (0 calls)
0: ~=(x:wybe.bool @bool:38:10, y:wybe.bool @bool:38:18, ?#result:wybe.bool @bool:38:5):
    foreign llvm icmp_ne(x:wybe.bool @bool:38:48, y:wybe.bool @bool:38:51, ?tmp#0:wybe.bool @bool:38:27)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @bool:38:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.c_string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.c_string.<<0>
                    wybe.c_string.<=<0>
                    wybe.c_string.=<0>
                    wybe.c_string.><0>
                    wybe.c_string.>=<0>
                    wybe.c_string.[]<0>
                    wybe.c_string.[|]<0>
                    wybe.c_string.length<0>
                    wybe.c_string.print<0>
                    wybe.c_string.println<0>
                    wybe.c_string.read<0>
                    wybe.c_string.unsafe_c_string_index<0>
                    wybe.c_string.~=<0>
  imports         : use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:wybe.c_string @c_string:12:10, y:wybe.c_string @c_string:12:17, ?#result:wybe.bool @c_string:12:5):
    foreign c strcmp(x:wybe.c_string @c_string:12:46, y:wybe.c_string @c_string:12:48, ?tmp#1:wybe.int @c_string:12:29)
    wybe.int.<0><(tmp#1:wybe.int, 0:wybe.int @c_string:12:57, ?tmp#0:wybe.bool @c_string:12:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:12:5)


<= > public (0 calls)
0: <=(x:wybe.c_string @c_string:13:10, y:wybe.c_string @c_string:13:18, ?#result:wybe.bool @c_string:13:5):
    foreign c strcmp(x:wybe.c_string @c_string:13:47, y:wybe.c_string @c_string:13:49, ?tmp#1:wybe.int @c_string:13:30)
    wybe.int.<0><=(tmp#1:wybe.int, 0:wybe.int @c_string:13:60, ?tmp#0:wybe.bool @c_string:13:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:13:5)


= > public (0 calls)
0: =(x:wybe.c_string @c_string:10:10, y:wybe.c_string @c_string:10:17, ?#result:wybe.bool @c_string:10:5):
    foreign c strcmp(x:wybe.c_string @c_string:10:46, y:wybe.c_string @c_string:10:48, ?tmp#1:wybe.int @c_string:10:29)
    wybe.int.<0>=(tmp#1:wybe.int, 0:wybe.int @c_string:10:57, ?tmp#0:wybe.bool @c_string:10:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:10:5)


> > public (0 calls)
0: >(x:wybe.c_string @c_string:14:10, y:wybe.c_string @c_string:14:17, ?#result:wybe.bool @c_string:14:5):
    foreign c strcmp(x:wybe.c_string @c_string:14:46, y:wybe.c_string @c_string:14:48, ?tmp#1:wybe.int @c_string:14:29)
    wybe.int.<0>>(tmp#1:wybe.int, 0:wybe.int @c_string:14:57, ?tmp#0:wybe.bool @c_string:14:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:14:5)


>= > public (0 calls)
0: >=(x:wybe.c_string @c_string:15:10, y:wybe.c_string @c_string:15:18, ?#result:wybe.bool @c_string:15:5):
    foreign c strcmp(x:wybe.c_string @c_string:15:47, y:wybe.c_string @c_string:15:49, ?tmp#1:wybe.int @c_string:15:30)
    wybe.int.<0>>=(tmp#1:wybe.int, 0:wybe.int @c_string:15:60, ?tmp#0:wybe.bool @c_string:15:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:15:5)


[] > public {test} (0 calls)
0: [](str:wybe.c_string @c_string:26:19, idx:wybe.int @c_string:26:26, ?#result:wybe.char @c_string:26:5):
    wybe.int.<0><=(0:wybe.int @c_string:27:6, idx:wybe.int @c_string:27:12)
    wybe.c_string.<0>length(str:wybe.c_string @c_string:28:19, ?tmp#0:wybe.int @c_string:28:12)
    wybe.int.<0><(idx:wybe.int @c_string:28:6, tmp#0:wybe.int)
    wybe.c_string.<0>unsafe_c_string_index(str:wybe.c_string @c_string:29:32, idx:wybe.int @c_string:29:37, ?tmp#1:wybe.char @c_string:29:10)
    foreign llvm move(tmp#1:wybe.char, ?c:wybe.char @c_string:29:6)
    foreign llvm move(c:wybe.char @c_string:26:42, ?#result:wybe.char @c_string:26:5)


[|] > public {test} (0 calls)
0: [|](?head:wybe.char @c_string:19:23, ?tail:wybe.c_string @c_string:19:35, str:wybe.c_string @c_string:19:43):
    foreign lpvm access(str:wybe.c_string @c_string:20:25, 0:wybe.int @c_string:20:30, 0:wybe.int @c_string:20:33, 0:wybe.int @c_string:20:36, ?head:wybe.char @c_string:20:40)
    foreign llvm icmp_ne(head:wybe.char @c_string:21:26, '\NUL':wybe.char @c_string:21:32, ?not_done:wybe.bool @c_string:21:37)
    wybe.bool.<0>true(?tmp#0:wybe.bool @c_string:22:17)
    wybe.bool.<0>=(not_done:wybe.bool @c_string:22:6, tmp#0:wybe.bool)
    foreign llvm add(str:wybe.c_string @c_string:23:22, 1:wybe.int @c_string:23:27, ?tail:wybe.c_string @c_string:23:31)


length > public (0 calls)
0: length(str:wybe.c_string @c_string:17:16, ?#result:wybe.int @c_string:17:5):
    foreign c strlen(str:wybe.c_string @c_string:17:46, ?tmp#0:wybe.int @c_string:17:29)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @c_string:17:5)


print > public (0 calls)
0: print(x:wybe.c_string @c_string:35:15) use !wybe.io.io:
    foreign c print_string(x:wybe.c_string @c_string:35:53, !io:wybe.phantom @c_string:35:57)


println > public (0 calls)
0: println(x:wybe.c_string @c_string:37:17) use !wybe.io.io:
    !wybe.c_string.<0>print(x:wybe.c_string @c_string:37:39)
    !wybe.io.<0>nl


read > public (0 calls)
0: read(?x:wybe.c_string @c_string:39:15) use !wybe.io.io:
    foreign c read_line(?x:wybe.c_string @c_string:39:51, !io:wybe.phantom @c_string:39:55)


unsafe_c_string_index > public (0 calls)
0: unsafe_c_string_index(str:wybe.c_string @c_string:32:31, idx:wybe.int @c_string:32:38, ?#result:wybe.char @c_string:32:5):
    foreign lpvm access(str:wybe.c_string @c_string:33:27, idx:wybe.int @c_string:33:32, 1:wybe.int @c_string:33:37, 0:wybe.int @c_string:33:40, ?tmp#0:wybe.char @c_string:33:7)
    foreign llvm move(tmp#0:wybe.char, ?#result:wybe.char @c_string:32:5)


~= > public (0 calls)
0: ~=(x:wybe.c_string @c_string:11:10, y:wybe.c_string @c_string:11:18, ?#result:wybe.bool @c_string:11:5):
    foreign c strcmp(x:wybe.c_string @c_string:11:47, y:wybe.c_string @c_string:11:49, ?tmp#1:wybe.int @c_string:11:30)
    wybe.int.<0>~=(tmp#1:wybe.int, 0:wybe.int @c_string:11:60, ?tmp#0:wybe.bool @c_string:11:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @c_string:11:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.char
  representation  : 8 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.char.<<0>
                    wybe.char.<=<0>
                    wybe.char.<=><0>
                    wybe.char.=<0>
                    wybe.char.><0>
                    wybe.char.>=<0>
                    wybe.char.chr<0>
                    wybe.char.ord<0>
                    wybe.char.print<0>
                    wybe.char.println<0>
                    wybe.char.read<0>
                    wybe.char.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:wybe.char @char:17:10, y:wybe.char @char:17:17, ?#result:wybe.bool @char:17:5):
    foreign llvm icmp_ult(x:wybe.char @char:17:51, y:wybe.char @char:17:54, ?tmp#0:wybe.bool @char:17:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:17:5)


<= > public (0 calls)
0: <=(x:wybe.char @char:18:10, y:wybe.char @char:18:18, ?#result:wybe.bool @char:18:5):
    foreign llvm icmp_ule(x:wybe.char @char:18:52, y:wybe.char @char:18:55, ?tmp#0:wybe.bool @char:18:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:18:5)


<=> > public (0 calls)
0: <=>(x:wybe.char @char:23:10, y:wybe.char @char:23:20, ?#result:wybe.comparison @char:23:5):
    if {wybe.char.<0><(x:wybe.char @char:24:10, y:wybe.char @char:24:14)::

        wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @char:24:19)
        foreign llvm move(tmp#1:wybe.comparison, ?tmp#0:wybe.comparison)
    else::
        if {wybe.char.<0>=(x:wybe.char @char:24:28, y:wybe.char @char:24:32)::

            wybe.comparison.<0>equal(?tmp#3:wybe.comparison @char:24:37)
            foreign llvm move(tmp#3:wybe.comparison, ?tmp#2:wybe.comparison)
        else::
            wybe.comparison.<0>greater(?tmp#4:wybe.comparison @char:24:53)
            foreign llvm move(tmp#4:wybe.comparison, ?tmp#2:wybe.comparison)

        }
   condition -> {x::wybe.char, y::wybe.char}
   then&else -> {tmp#2::wybe.comparison, x::wybe.char, y::wybe.char}
        foreign llvm move(tmp#2:wybe.comparison @char:24:28, ?tmp#0:wybe.comparison)

    }
   condition -> {x::wybe.char, y::wybe.char}
   then&else -> {tmp#0::wybe.comparison, x::wybe.char, y::wybe.char}
    foreign llvm move(tmp#0:wybe.comparison @char:24:10, ?#result:wybe.comparison @char:23:5)


= > public (0 calls)
0: =(x:wybe.char @char:13:10, y:wybe.char @char:13:17, ?#result:wybe.bool @char:13:5):
    foreign llvm icmp_eq(x:wybe.char @char:13:50, y:wybe.char @char:13:53, ?tmp#0:wybe.bool @char:13:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:13:5)


> > public (0 calls)
0: >(x:wybe.char @char:19:10, y:wybe.char @char:19:17, ?#result:wybe.bool @char:19:5):
    foreign llvm icmp_ugt(x:wybe.char @char:19:51, y:wybe.char @char:19:54, ?tmp#0:wybe.bool @char:19:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:19:5)


>= > public (0 calls)
0: >=(x:wybe.char @char:20:10, y:wybe.char @char:20:18, ?#result:wybe.bool @char:20:5):
    foreign llvm icmp_uge(x:wybe.char @char:20:52, y:wybe.char @char:20:55, ?tmp#0:wybe.bool @char:20:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:20:5)


chr > public {test} (0 calls)
0: chr(i:wybe.int @char:33:20, ?#result:wybe.char @char:33:5):
    wybe.int.<0><=(0:wybe.int @char:33:60, i:wybe.int @char:33:66)
    wybe.int.<0><=(i:wybe.int @char:33:70, 255:wybe.int @char:33:76)
    foreign lpvm cast(i:wybe.int @char:33:49, ?tmp#0:wybe.char @char:33:31)
    foreign llvm move(tmp#0:wybe.char, ?#result:wybe.char @char:33:5)


ord > public (0 calls)
0: ord(c:wybe.char @char:30:13, ?#result:wybe.int @char:30:5):
    foreign lpvm cast(c:wybe.char @char:30:42, ?tmp#0:wybe.int @char:30:24)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @char:30:5)


print > public (0 calls)
0: print(x:wybe.char @char:37:15) use !wybe.io.io:
    foreign c putchar(x:wybe.char @char:37:48, !io:wybe.phantom @char:37:52)


println > public (0 calls)
0: println(x:wybe.char @char:39:17) use !wybe.io.io:
    !wybe.char.<0>print(x:wybe.char @char:39:39)
    !wybe.io.<0>nl


read > public (0 calls)
0: read(?x:wybe.char @char:41:15) use !wybe.io.io:
    foreign c read_char(?x:wybe.char @char:41:51, !io:wybe.phantom @char:41:55)


~= > public (0 calls)
0: ~=(x:wybe.char @char:14:10, y:wybe.char @char:14:18, ?#result:wybe.bool @char:14:5):
    foreign llvm icmp_ne(x:wybe.char @char:14:51, y:wybe.char @char:14:54, ?tmp#0:wybe.bool @char:14:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @char:14:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.comparison
  representation  : 2 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.comparison.<<0>
                    wybe.comparison.<=<0>
                    wybe.comparison.=<0>
                    wybe.comparison.><0>
                    wybe.comparison.>=<0>
                    wybe.comparison.equal<0>
                    wybe.comparison.greater<0>
                    wybe.comparison.lesser<0>
                    wybe.comparison.~=<0>
  imports         : use wybe.bool
  resources       : 
  procs           : 

< > public (0 calls)
0: <(x:wybe.comparison @comparison:12:10, y:wybe.comparison @comparison:12:17, ?#result:wybe.bool @comparison:12:5):
    foreign llvm icmp_ult(x:wybe.comparison @comparison:12:51, y:wybe.comparison @comparison:12:54, ?tmp#0:wybe.bool @comparison:12:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:12:5)


<= > public (0 calls)
0: <=(x:wybe.comparison @comparison:13:10, y:wybe.comparison @comparison:13:18, ?#result:wybe.bool @comparison:13:5):
    foreign llvm icmp_ule(x:wybe.comparison @comparison:13:52, y:wybe.comparison @comparison:13:55, ?tmp#0:wybe.bool @comparison:13:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:13:5)


= > public (0 calls)
0: =(x:wybe.comparison @comparison:10:10, y:wybe.comparison @comparison:10:17, ?#result:wybe.bool @comparison:10:5):
    foreign llvm icmp_eq(x:wybe.comparison @comparison:10:50, y:wybe.comparison @comparison:10:53, ?tmp#0:wybe.bool @comparison:10:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:10:5)


> > public (0 calls)
0: >(x:wybe.comparison @comparison:14:10, y:wybe.comparison @comparison:14:17, ?#result:wybe.bool @comparison:14:5):
    foreign llvm icmp_ugt(x:wybe.comparison @comparison:14:51, y:wybe.comparison @comparison:14:54, ?tmp#0:wybe.bool @comparison:14:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:14:5)


>= > public (0 calls)
0: >=(x:wybe.comparison @comparison:15:10, y:wybe.comparison @comparison:15:18, ?#result:wybe.bool @comparison:15:5):
    foreign llvm icmp_uge(x:wybe.comparison @comparison:15:52, y:wybe.comparison @comparison:15:55, ?tmp#0:wybe.bool @comparison:15:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:15:5)


equal > public {inline} (0 calls)
0: equal(?#result:wybe.comparison @comparison:8:27):
    foreign lpvm cast(1:!wybe.comparison, ?#result:wybe.comparison)


greater > public {inline} (0 calls)
0: greater(?#result:wybe.comparison @comparison:8:35):
    foreign lpvm cast(2:!wybe.comparison, ?#result:wybe.comparison)


lesser > public {inline} (0 calls)
0: lesser(?#result:wybe.comparison @comparison:8:18):
    foreign lpvm cast(0:!wybe.comparison, ?#result:wybe.comparison)


~= > public (0 calls)
0: ~=(x:wybe.comparison @comparison:11:10, y:wybe.comparison @comparison:11:18, ?#result:wybe.bool @comparison:11:5):
    foreign llvm icmp_ne(x:wybe.comparison @comparison:11:51, y:wybe.comparison @comparison:11:54, ?tmp#0:wybe.bool @comparison:11:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @comparison:11:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.control
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.control.assert<0>
                    wybe.control.error<0>
                    wybe.control.error<1>
                    wybe.control.exit<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.int
                    use wybe.string
  resources       : 
  procs           : 

assert > public {semipure} (0 calls)
0: assert(condition:bool @control:26:27) use call_source_location:
    if {~(condition @control:27:11)::

        !error(c"assertion failed" @control:27:31)
    else::
        pass

    }


error > public {terminal,semipure} (0 calls)
0: error(message:string @control:17:35) use call_source_location:
    c_string(message @control:18:77, ?tmp#0 @control:18:68)
    foreign c {terminal,semipure} error_exit(call_source_location @control:18:46, tmp#0)
error > public {terminal,semipure} (0 calls)
1: error(message:c_string @control:21:35) use call_source_location:
    foreign c {terminal,semipure} error_exit(call_source_location @control:22:46, message @control:22:68)


exit > public {terminal,semipure} (0 calls)
0: exit(code:int @control:10:34):
    foreign c {terminal,semipure} exit(code @control:11:40)

LLVM code       : None

--------------------------------------------------
 Module wybe.count
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.count.%<0>
                    wybe.count.%=<0>
                    wybe.count.*<0>
                    wybe.count.*=<0>
                    wybe.count.+<0>
                    wybe.count.+<1>
                    wybe.count.+<2>
                    wybe.count.+=<0>
                    wybe.count.-<0>
                    wybe.count.-<1>
                    wybe.count.-<2>
                    wybe.count.-=<0>
                    wybe.count./<0>
                    wybe.count./=<0>
                    wybe.count.<<0>
                    wybe.count.<=<0>
                    wybe.count.<=><0>
                    wybe.count.=<0>
                    wybe.count.><0>
                    wybe.count.>=<0>
                    wybe.count.decr<0>
                    wybe.count.incr<0>
                    wybe.count.max<0>
                    wybe.count.min<0>
                    wybe.count.print<0>
                    wybe.count.println<0>
                    wybe.count.read<0>
                    wybe.count.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public (0 calls)
0: %(x:_ @count:51:10, y:_ @count:51:16, ?#result:_ @count:51:5):
    foreign llvm urem(x @count:51:43, y @count:51:45, ?tmp#0 @count:51:25)
    foreign llvm move(tmp#0, ?#result @count:51:5)


%= > public (0 calls)
0: %=(!x:_ @count:54:11, y:_ @count:54:19):
    %(x @count:54:31, y @count:54:35, ?tmp#0 @count:54:31)
    =(?x @count:54:27, tmp#0)


* > public (0 calls)
0: *(x:_ @count:39:10, y:_ @count:39:16, ?#result:_ @count:39:5):
    foreign llvm mul(x @count:39:42, y @count:39:44, ?tmp#0 @count:39:25)
    foreign llvm move(tmp#0, ?#result @count:39:5)


*= > public (0 calls)
0: *=(!x:_ @count:42:11, y:_ @count:42:19):
    *(x @count:42:31, y @count:42:35, ?tmp#0 @count:42:31)
    =(?x @count:42:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @count:15:10, y:_ @count:15:16, ?#result:_ @count:15:5):
    foreign llvm add(x @count:15:42, y @count:15:44, ?tmp#0 @count:15:25)
    foreign llvm move(tmp#0, ?#result @count:15:5)
+ > public {test} (0 calls)
1: +(?x:_ @count:16:21, y:_ @count:16:27, z:_ @count:16:5):
    >=(z @count:17:5, y @count:17:11)
    foreign llvm sub(z @count:18:27, y @count:18:29, ?tmp#0 @count:18:10)
    =(?x @count:18:6, tmp#0)
+ > public {test} (0 calls)
2: +(x:_ @count:20:20, ?y:_ @count:20:27, z:_ @count:20:5):
    >=(z @count:21:5, x @count:21:11)
    foreign llvm sub(z @count:22:27, x @count:22:29, ?tmp#0 @count:22:10)
    =(?y @count:22:6, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @count:26:11, y:_ @count:26:19):
    +(x @count:26:31, y @count:26:35, ?tmp#0 @count:26:31)
    =(?x @count:26:27, tmp#0)


- > public {test} (0 calls)
0: -(x:_ @count:31:20, y:_ @count:31:26, ?#result:_ @count:31:5):
    >=(y @count:31:65, x @count:31:71)
    foreign llvm sub(x @count:31:52, y @count:31:54, ?tmp#0 @count:31:35)
    foreign llvm move(tmp#0, ?#result @count:31:5)
- > public (0 calls)
1: -(?x:_ @count:32:11, y:_ @count:32:17, z:_ @count:32:5):
    foreign llvm add(z @count:32:59, y @count:32:61, ?tmp#0 @count:32:42)
    =(?x @count:32:38, tmp#0)
- > public (0 calls)
2: -(x:_ @count:33:10, ?y:_ @count:33:17, z:_ @count:33:5):
    foreign llvm sub(z @count:33:59, x @count:33:61, ?tmp#0 @count:33:42)
    =(?y @count:33:38, tmp#0)


-= > public {test} (0 calls)
0: -=(!x:_ @count:36:21, y:_ @count:36:29):
    -(x @count:36:41, y @count:36:45, ?tmp#0 @count:36:41)
    =(?x @count:36:37, tmp#0)


/ > public (0 calls)
0: /(x:_ @count:45:10, y:_ @count:45:16, ?#result:_ @count:45:5):
    foreign llvm udiv(x @count:45:43, y @count:45:45, ?tmp#0 @count:45:25)
    foreign llvm move(tmp#0, ?#result @count:45:5)


/= > public (0 calls)
0: /=(!x:_ @count:48:11, y:_ @count:48:19):
    /(x @count:48:31, y @count:48:35, ?tmp#0 @count:48:31)
    =(?x @count:48:27, tmp#0)


< > public (0 calls)
0: <(x:_ @count:64:10, y:_ @count:64:17, ?#result:bool @count:64:5):
    foreign llvm icmp_ult(x @count:64:51, y @count:64:53, ?tmp#0 @count:64:29)
    foreign llvm move(tmp#0, ?#result @count:64:5)


<= > public (0 calls)
0: <=(x:_ @count:65:10, y:_ @count:65:18, ?#result:bool @count:65:5):
    foreign llvm icmp_ule(x @count:65:52, y @count:65:54, ?tmp#0 @count:65:30)
    foreign llvm move(tmp#0, ?#result @count:65:5)


<=> > public (0 calls)
0: <=>(x:_ @count:70:10, y:_ @count:70:20, ?#result:comparison @count:70:5):
    if {<(x @count:71:10, y @count:71:14)::

        lesser(?tmp#1 @count:71:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @count:71:28, y @count:71:32)::

            equal(?tmp#3 @count:71:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @count:71:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @count:71:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:71:10, ?#result @count:70:5)


= > public (0 calls)
0: =(x:_ @count:60:10, y:_ @count:60:17, ?#result:bool @count:60:5):
    foreign llvm icmp_eq(x @count:60:50, y @count:60:52, ?tmp#0 @count:60:29)
    foreign llvm move(tmp#0, ?#result @count:60:5)


> > public (0 calls)
0: >(x:_ @count:66:10, y:_ @count:66:17, ?#result:bool @count:66:5):
    foreign llvm icmp_ugt(x @count:66:51, y @count:66:53, ?tmp#0 @count:66:29)
    foreign llvm move(tmp#0, ?#result @count:66:5)


>= > public (0 calls)
0: >=(x:_ @count:67:10, y:_ @count:67:18, ?#result:bool @count:67:5):
    foreign llvm icmp_uge(x @count:67:52, y @count:67:54, ?tmp#0 @count:67:30)
    foreign llvm move(tmp#0, ?#result @count:67:5)


decr > public {test} (0 calls)
0: decr(!x:_ @count:84:25):
    -(x @count:84:37, 1:_ @count:84:41, ?tmp#0 @count:84:37)
    =(?x @count:84:33, tmp#0)


incr > public (0 calls)
0: incr(!x:_ @count:81:15):
    +(x @count:81:27, 1:_ @count:81:31, ?tmp#0 @count:81:27)
    =(?x @count:81:23, tmp#0)


max > public (0 calls)
0: max(x:_ @count:75:13, y:_ @count:75:18, ?#result:_ @count:75:5):
    if {>=(x @count:75:31, y @count:75:35)::

        foreign llvm move(x @count:75:39, ?tmp#0)
    else::
        foreign llvm move(y @count:75:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:75:31, ?#result @count:75:5)


min > public (0 calls)
0: min(x:_ @count:74:13, y:_ @count:74:18, ?#result:_ @count:74:5):
    if {<=(x @count:74:31, y @count:74:35)::

        foreign llvm move(x @count:74:39, ?tmp#0)
    else::
        foreign llvm move(y @count:74:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:74:31, ?#result @count:74:5)


print > public (0 calls)
0: print(x:_ @count:88:15) use !io:
    foreign c print_count(x @count:88:52, !io @count:88:56)


println > public (0 calls)
0: println(x:_ @count:90:17) use !io:
    !print(x @count:90:39)
    !nl


read > public (0 calls)
0: read(?x:_ @count:92:15) use !io:
    foreign c read_count(?x @count:92:52, !io @count:92:56)


~= > public (0 calls)
0: ~=(x:_ @count:61:10, y:_ @count:61:18, ?#result:bool @count:61:5):
    foreign llvm icmp_ne(x @count:61:51, y @count:61:53, ?tmp#0 @count:61:30)
    foreign llvm move(tmp#0, ?#result @count:61:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.float
  representation  : 64 bit float
  public submods  : 
  public resources: 
  public procs    : wybe.float.*<0>
                    wybe.float.**<0>
                    wybe.float.*=<0>
                    wybe.float.+<0>
                    wybe.float.+<1>
                    wybe.float.+<2>
                    wybe.float.+=<0>
                    wybe.float.-<0>
                    wybe.float.-<1>
                    wybe.float.-<2>
                    wybe.float.-<3>
                    wybe.float.-<4>
                    wybe.float.-=<0>
                    wybe.float./<0>
                    wybe.float./=<0>
                    wybe.float.<<0>
                    wybe.float.<=<0>
                    wybe.float.<=><0>
                    wybe.float.=<0>
                    wybe.float.><0>
                    wybe.float.>=<0>
                    wybe.float.abs<0>
                    wybe.float.ceil<0>
                    wybe.float.cos<0>
                    wybe.float.e<0>
                    wybe.float.exp<0>
                    wybe.float.floor<0>
                    wybe.float.iceil<0>
                    wybe.float.ifloor<0>
                    wybe.float.iround<0>
                    wybe.float.log<0>
                    wybe.float.log10<0>
                    wybe.float.log2<0>
                    wybe.float.max<0>
                    wybe.float.min<0>
                    wybe.float.pi<0>
                    wybe.float.power<0>
                    wybe.float.print<0>
                    wybe.float.println<0>
                    wybe.float.read<0>
                    wybe.float.round<0>
                    wybe.float.sin<0>
                    wybe.float.sqrt<0>
                    wybe.float.square<0>
                    wybe.float.tan<0>
                    wybe.float.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

* > public (0 calls)
0: *(x:_ @float:45:10, y:_ @float:45:16, ?#result:_ @float:45:5):
    foreign llvm fmul(x @float:45:43, y @float:45:45, ?tmp#0 @float:45:25)
    foreign llvm move(tmp#0, ?#result @float:45:5)


** > public (0 calls)
0: **(x:_ @float:112:10, n:_ @float:112:18, ?#result:_ @float:112:5):
    foreign c llvm.pow.f64(x @float:112:52, n @float:112:54, ?tmp#0 @float:112:27)
    foreign llvm move(tmp#0, ?#result @float:112:5)


*= > public (0 calls)
0: *=(!x:_ @float:48:11, y:_ @float:48:19):
    *(x @float:48:31, y @float:48:35, ?tmp#0 @float:48:31)
    =(?x @float:48:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @float:23:10, y:_ @float:23:17, ?#result:_ @float:23:5):
    foreign llvm fadd(x @float:23:45, y @float:23:47, ?tmp#0 @float:23:27)
    foreign llvm move(tmp#0, ?#result @float:23:5)
+ > public (0 calls)
1: +(?x:_ @float:24:11, y:_ @float:24:17, z:_ @float:24:5):
    foreign llvm fsub(z @float:24:61, y @float:24:63, ?tmp#0 @float:24:43)
    =(?x @float:24:39, tmp#0)
+ > public (0 calls)
2: +(x:_ @float:25:10, ?y:_ @float:25:18, z:_ @float:25:5):
    foreign llvm fsub(z @float:25:61, x @float:25:63, ?tmp#0 @float:25:43)
    =(?y @float:25:39, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @float:28:11, y:_ @float:28:19):
    +(x @float:28:31, y @float:28:35, ?tmp#0 @float:28:31)
    =(?x @float:28:27, tmp#0)


- > public (0 calls)
0: -(x:_ @float:32:10, y:_ @float:32:17, ?#result:_ @float:32:5):
    foreign llvm fsub(x @float:32:45, y @float:32:47, ?tmp#0 @float:32:27)
    foreign llvm move(tmp#0, ?#result @float:32:5)
- > public (0 calls)
1: -(?x:_ @float:33:11, y:_ @float:33:17, z:_ @float:33:5):
    foreign llvm fadd(z @float:33:61, y @float:33:63, ?tmp#0 @float:33:43)
    =(?x @float:33:39, tmp#0)
- > public (0 calls)
2: -(x:_ @float:34:10, ?y:_ @float:34:18, z:_ @float:34:5):
    foreign llvm fsub(z @float:34:61, x @float:34:63, ?tmp#0 @float:34:43)
    =(?y @float:34:39, tmp#0)
- > public (0 calls)
3: -(x:_ @float:38:11, ?#result:_ @float:38:5):
    foreign llvm fsub(0.0 @float:38:39, x @float:38:43, ?tmp#0 @float:38:21)
    foreign llvm move(tmp#0, ?#result @float:38:5)
- > public (0 calls)
4: -(?x:_ @float:39:12, y:_ @float:39:5):
    foreign llvm fsub(0.0 @float:39:55, y @float:39:59, ?tmp#0 @float:39:37)
    =(?x @float:39:33, tmp#0)


-= > public (0 calls)
0: -=(!x:_ @float:42:11, y:_ @float:42:19):
    -(x @float:42:31, y @float:42:35, ?tmp#0 @float:42:31)
    =(?x @float:42:27, tmp#0)


/ > public (0 calls)
0: /(x:_ @float:51:10, y:_ @float:51:16, ?#result:_ @float:51:5):
    foreign llvm fdiv(x @float:51:43, y @float:51:45, ?tmp#0 @float:51:25)
    foreign llvm move(tmp#0, ?#result @float:51:5)


/= > public (0 calls)
0: /=(!x:_ @float:54:11, y:_ @float:54:19):
    /(x @float:54:31, y @float:54:35, ?tmp#0 @float:54:31)
    =(?x @float:54:27, tmp#0)


< > public (0 calls)
0: <(x:_ @float:70:10, y:_ @float:70:17, ?#result:bool @float:70:5):
    foreign llvm fcmp_slt(x @float:70:51, y @float:70:53, ?tmp#0 @float:70:29)
    foreign llvm move(tmp#0, ?#result @float:70:5)


<= > public (0 calls)
0: <=(x:_ @float:71:10, y:_ @float:71:18, ?#result:bool @float:71:5):
    foreign llvm fcmp_sle(x @float:71:52, y @float:71:54, ?tmp#0 @float:71:30)
    foreign llvm move(tmp#0, ?#result @float:71:5)


<=> > public (0 calls)
0: <=>(x:_ @float:76:10, y:_ @float:76:20, ?#result:comparison @float:76:5):
    if {<(x @float:77:10, y @float:77:14)::

        lesser(?tmp#1 @float:77:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @float:77:28, y @float:77:32)::

            equal(?tmp#3 @float:77:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @float:77:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @float:77:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @float:77:10, ?#result @float:76:5)


= > public (0 calls)
0: =(x:_ @float:66:10, y:_ @float:66:17, ?#result:bool @float:66:5):
    foreign llvm fcmp_eq(x @float:66:50, y @float:66:52, ?tmp#0 @float:66:29)
    foreign llvm move(tmp#0, ?#result @float:66:5)


> > public (0 calls)
0: >(x:_ @float:72:10, y:_ @float:72:17, ?#result:bool @float:72:5):
    foreign llvm fcmp_sgt(x @float:72:51, y @float:72:53, ?tmp#0 @float:72:29)
    foreign llvm move(tmp#0, ?#result @float:72:5)


>= > public (0 calls)
0: >=(x:_ @float:73:10, y:_ @float:73:18, ?#result:bool @float:73:5):
    foreign llvm fcmp_sge(x @float:73:52, y @float:73:54, ?tmp#0 @float:73:30)
    foreign llvm move(tmp#0, ?#result @float:73:5)


abs > public (0 calls)
0: abs(x:_ @float:60:13, ?#result:_ @float:60:5):
    foreign c llvm.fabs.f64(x @float:60:48, ?tmp#0 @float:60:22)
    foreign llvm move(tmp#0, ?#result @float:60:5)


ceil > public (0 calls)
0: ceil(x:_ @float:87:14, ?#result:_ @float:87:5):
    foreign c llvm.ceil.f64(x @float:87:49, ?tmp#0 @float:87:23)
    foreign llvm move(tmp#0, ?#result @float:87:5)


cos > public (0 calls)
0: cos(x:_ @float:116:13, ?#result:_ @float:116:5):
    foreign c llvm.cos.f64(x @float:116:47, ?tmp#0 @float:116:22)
    foreign llvm move(tmp#0, ?#result @float:116:5)


e > public (0 calls)
0: e(?#result:_ @float:16:5):
    foreign llvm move(2.7182818284590455 @float:16:15, ?#result @float:16:5)


exp > public (0 calls)
0: exp(x:_ @float:120:13, ?#result:_ @float:120:5):
    foreign c llvm.exp.f64(x @float:120:47, ?tmp#0 @float:120:22)
    foreign llvm move(tmp#0, ?#result @float:120:5)


floor > public (0 calls)
0: floor(x:_ @float:90:15, ?#result:_ @float:90:5):
    foreign c llvm.floor.f64(x @float:90:51, ?tmp#0 @float:90:24)
    foreign llvm move(tmp#0, ?#result @float:90:5)


iceil > public (0 calls)
0: iceil(x:_ @float:99:15, ?#result:int @float:99:5):
    ceil(x @float:99:51, ?tmp#1 @float:99:46)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:99:26)
    foreign llvm move(tmp#0, ?#result @float:99:5)


ifloor > public (0 calls)
0: ifloor(x:_ @float:102:16, ?#result:int @float:102:5):
    floor(x @float:102:53, ?tmp#1 @float:102:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:102:27)
    foreign llvm move(tmp#0, ?#result @float:102:5)


iround > public (0 calls)
0: iround(x:_ @float:96:16, ?#result:int @float:96:5):
    round(x @float:96:53, ?tmp#1 @float:96:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:96:27)
    foreign llvm move(tmp#0, ?#result @float:96:5)


log > public (0 calls)
0: log(x:_ @float:123:13, ?#result:_ @float:123:5):
    foreign c llvm.log.f64(x @float:123:47, ?tmp#0 @float:123:22)
    foreign llvm move(tmp#0, ?#result @float:123:5)


log10 > public (0 calls)
0: log10(x:_ @float:126:15, ?#result:_ @float:126:5):
    foreign c llvm.log10.f64(x @float:126:51, ?tmp#0 @float:126:24)
    foreign llvm move(tmp#0, ?#result @float:126:5)


log2 > public (0 calls)
0: log2(x:_ @float:129:14, ?#result:_ @float:129:5):
    foreign c llvm.log2.f64(x @float:129:49, ?tmp#0 @float:129:23)
    foreign llvm move(tmp#0, ?#result @float:129:5)


max > public (0 calls)
0: max(x:_ @float:81:13, y:_ @float:81:18, ?#result:_ @float:81:5):
    foreign c llvm.maxnum.f64(x @float:81:55, y @float:81:57, ?tmp#0 @float:81:27)
    foreign llvm move(tmp#0, ?#result @float:81:5)


min > public (0 calls)
0: min(x:_ @float:80:13, y:_ @float:80:18, ?#result:_ @float:80:5):
    foreign c llvm.minnum.f64(x @float:80:55, y @float:80:57, ?tmp#0 @float:80:27)
    foreign llvm move(tmp#0, ?#result @float:80:5)


pi > public (0 calls)
0: pi(?#result:_ @float:13:5):
    foreign llvm move(3.141592653589793 @float:13:16, ?#result @float:13:5)


power > public (0 calls)
0: power(x:_ @float:111:15, n:_ @float:111:19, ?#result:_ @float:111:5):
    foreign c llvm.pow.f64(x @float:111:53, n @float:111:55, ?tmp#0 @float:111:28)
    foreign llvm move(tmp#0, ?#result @float:111:5)


print > public (0 calls)
0: print(x:_ @float:133:15) use !io:
    foreign c print_float(x @float:133:52, !io @float:133:56)


println > public (0 calls)
0: println(x:_ @float:135:17) use !io:
    !print(x @float:135:39)
    !nl


read > public (0 calls)
0: read(?x:_ @float:137:15) use !io:
    foreign c read_float(?x @float:137:52, !io @float:137:56)


round > public (0 calls)
0: round(x:_ @float:93:15, ?#result:_ @float:93:5):
    foreign c llvm.round.f64(x @float:93:51, ?tmp#0 @float:93:24)
    foreign llvm move(tmp#0, ?#result @float:93:5)


sin > public (0 calls)
0: sin(x:_ @float:115:13, ?#result:_ @float:115:5):
    foreign c llvm.sin.f64(x @float:115:47, ?tmp#0 @float:115:22)
    foreign llvm move(tmp#0, ?#result @float:115:5)


sqrt > public (0 calls)
0: sqrt(x:_ @float:108:14, ?#result:_ @float:108:5):
    foreign c llvm.sqrt.f64(x @float:108:49, ?tmp#0 @float:108:23)
    foreign llvm move(tmp#0, ?#result @float:108:5)


square > public (0 calls)
0: square(x:_ @float:57:16, ?#result:_ @float:57:5):
    foreign llvm fmul(x @float:57:43, x @float:57:45, ?tmp#0 @float:57:25)
    foreign llvm move(tmp#0, ?#result @float:57:5)


tan > public (0 calls)
0: tan(x:_ @float:117:13, ?#result:_ @float:117:5):
    foreign c llvm.sin.f64(x @float:117:47, ?tmp#1 @float:117:22)
    foreign c llvm.cos.f64(x @float:117:77, ?tmp#2 @float:117:52)
    /(tmp#1, tmp#2, ?tmp#0 @float:117:22)
    foreign llvm move(tmp#0, ?#result @float:117:5)


~= > public (0 calls)
0: ~=(x:_ @float:67:10, y:_ @float:67:18, ?#result:bool @float:67:5):
    foreign llvm fcmp_ne(x @float:67:51, y @float:67:53, ?tmp#0 @float:67:30)
    foreign llvm move(tmp#0, ?#result @float:67:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.int
  representation  : 64 bit signed
  public submods  : 
  public resources: 
  public procs    : wybe.int.%<0>
                    wybe.int.%=<0>
                    wybe.int.*<0>
                    wybe.int.*=<0>
                    wybe.int.+<0>
                    wybe.int.+<1>
                    wybe.int.+<2>
                    wybe.int.+=<0>
                    wybe.int.-<0>
                    wybe.int.-<1>
                    wybe.int.-<2>
                    wybe.int.-<3>
                    wybe.int.-<4>
                    wybe.int.-=<0>
                    wybe.int./<0>
                    wybe.int./=<0>
                    wybe.int.<<0>
                    wybe.int.<<<0>
                    wybe.int.<<=<0>
                    wybe.int.<=<0>
                    wybe.int.<=><0>
                    wybe.int.=<0>
                    wybe.int.><0>
                    wybe.int.>=<0>
                    wybe.int.>><0>
                    wybe.int.>>=<0>
                    wybe.int.decr<0>
                    wybe.int.incr<0>
                    wybe.int.logical_bitshift<0>
                    wybe.int.logical_bitshift<1>
                    wybe.int.max<0>
                    wybe.int.min<0>
                    wybe.int.power<0>
                    wybe.int.print<0>
                    wybe.int.println<0>
                    wybe.int.read<0>
                    wybe.int.signum<0>
                    wybe.int.sqrt<0>
                    wybe.int.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public (0 calls)
0: %(x:wybe.int @int:50:10, y:wybe.int @int:50:16, ?#result:wybe.int @int:50:5):
    foreign llvm srem(x:wybe.int @int:50:43, y:wybe.int @int:50:45, ?tmp#0:wybe.int @int:50:25)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:50:5)


%= > public (0 calls)
0: %=(!x:wybe.int @int:53:11, y:wybe.int @int:53:19):
    wybe.int.<0>%(x:wybe.int @int:53:31, y:wybe.int @int:53:35, ?tmp#0:wybe.int @int:53:31)
    foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:53:27)


* > public (0 calls)
0: *(x:wybe.int @int:38:10, y:wybe.int @int:38:16, ?#result:wybe.int @int:38:5):
    foreign llvm mul(x:wybe.int @int:38:42, y:wybe.int @int:38:44, ?tmp#0:wybe.int @int:38:25)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:38:5)


*= > public (0 calls)
0: *=(!x:wybe.int @int:41:11, y:wybe.int @int:41:19):
    wybe.int.<0>*(x:wybe.int @int:41:31, y:wybe.int @int:41:35, ?tmp#0:wybe.int @int:41:31)
    foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:41:27)


+ > public (0 calls)
0: +(x:wybe.int @int:16:10, y:wybe.int @int:16:17, ?#result:wybe.int @int:16:5):
    foreign llvm add(x:wybe.int @int:16:44, y:wybe.int @int:16:46, ?tmp#0:wybe.int @int:16:27)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:16:5)
+ > public (0 calls)
1: +(?x:wybe.int @int:17:11, y:wybe.int @int:17:17, z:wybe.int @int:17:5):
    foreign llvm sub(z:wybe.int @int:17:60, y:wybe.int @int:17:62, ?tmp#0:wybe.int @int:17:43)
    foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:17:39)
+ > public (0 calls)
2: +(x:wybe.int @int:18:10, ?y:wybe.int @int:18:18, z:wybe.int @int:18:5):
    foreign llvm sub(z:wybe.int @int:18:60, x:wybe.int @int:18:62, ?tmp#0:wybe.int @int:18:43)
    foreign llvm move(tmp#0:wybe.int, ?y:wybe.int @int:18:39)


+= > public (0 calls)
0: +=(!x:wybe.int @int:21:11, y:wybe.int @int:21:19):
    wybe.int.<0>+(x:wybe.int @int:21:31, y:wybe.int @int:21:35, ?tmp#0:wybe.int @int:21:31)
    foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:21:27)


- > public (0 calls)
0: -(x:wybe.int @int:25:10, y:wybe.int @int:25:17, ?#result:wybe.int @int:25:5):
    foreign llvm sub(x:wybe.int @int:25:44, y:wybe.int @int:25:46, ?tmp#0:wybe.int @int:25:27)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:25:5)
- > public (0 calls)
1: -(?x:wybe.int @int:26:11, y:wybe.int @int:26:17, z:wybe.int @int:26:5):
    foreign llvm add(z:wybe.int @int:26:60, y:wybe.int @int:26:62, ?tmp#0:wybe.int @int:26:43)
    foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:26:39)
- > public (0 calls)
2: -(x:wybe.int @int:27:10, ?y:wybe.int @int:27:18, z:wybe.int @int:27:5):
    foreign llvm sub(z:wybe.int @int:27:60, x:wybe.int @int:27:62, ?tmp#0:wybe.int @int:27:43)
    foreign llvm move(tmp#0:wybe.int, ?y:wybe.int @int:27:39)
- > public (0 calls)
3: -(x:wybe.int @int:31:11, ?#result:wybe.int @int:31:5):
    foreign llvm sub(0:wybe.int @int:31:38, x:wybe.int @int:31:40, ?tmp#0:wybe.int @int:31:21)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:31:5)
- > public (0 calls)
4: -(?x:wybe.int @int:32:12, y:wybe.int @int:32:5):
    foreign llvm sub(0:wybe.int @int:32:54, y:wybe.int @int:32:56, ?tmp#0:wybe.int @int:32:37)
    foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:32:33)


-= > public (0 calls)
0: -=(!x:wybe.int @int:35:11, y:wybe.int @int:35:19):
    wybe.int.<0>-(x:wybe.int @int:35:31, y:wybe.int @int:35:35, ?tmp#0:wybe.int @int:35:31)
    foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:35:27)


/ > public (0 calls)
0: /(x:wybe.int @int:44:10, y:wybe.int @int:44:16, ?#result:wybe.int @int:44:5):
    foreign llvm sdiv(x:wybe.int @int:44:43, y:wybe.int @int:44:45, ?tmp#0:wybe.int @int:44:25)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:44:5)


/= > public (0 calls)
0: /=(!x:wybe.int @int:47:11, y:wybe.int @int:47:19):
    wybe.int.<0>/(x:wybe.int @int:47:31, y:wybe.int @int:47:35, ?tmp#0:wybe.int @int:47:31)
    foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:47:27)


< > public (0 calls)
0: <(x:wybe.int @int:87:10, y:wybe.int @int:87:17, ?#result:wybe.bool @int:87:5):
    foreign llvm icmp_slt(x:wybe.int @int:87:51, y:wybe.int @int:87:53, ?tmp#0:wybe.bool @int:87:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:87:5)


<< > public (0 calls)
0: <<(x:wybe.int @int:56:10, s:wybe.int @int:56:18, ?#result:wybe.int @int:56:5):
    foreign llvm shl(x:wybe.int @int:56:44, s:wybe.int @int:56:47, ?tmp#0:wybe.int @int:56:27)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:56:5)


<<= > public (0 calls)
0: <<=(!x:wybe.int @int:59:11, s:wybe.int @int:59:21):
    wybe.int.<0><<(x:wybe.int @int:59:33, s:wybe.int @int:59:39, ?tmp#0:wybe.int @int:59:33)
    foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:59:29)


<= > public (0 calls)
0: <=(x:wybe.int @int:88:10, y:wybe.int @int:88:18, ?#result:wybe.bool @int:88:5):
    foreign llvm icmp_sle(x:wybe.int @int:88:52, y:wybe.int @int:88:54, ?tmp#0:wybe.bool @int:88:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:88:5)


<=> > public (0 calls)
0: <=>(x:wybe.int @int:93:10, y:wybe.int @int:93:20, ?#result:wybe.comparison @int:93:5):
    if {wybe.int.<0><(x:wybe.int @int:94:10, y:wybe.int @int:94:14)::

        wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @int:94:19)
        foreign llvm move(tmp#1:wybe.comparison, ?tmp#0:wybe.comparison)
    else::
        if {wybe.int.<0>=(x:wybe.int @int:94:28, y:wybe.int @int:94:32)::

            wybe.comparison.<0>equal(?tmp#3:wybe.comparison @int:94:37)
            foreign llvm move(tmp#3:wybe.comparison, ?tmp#2:wybe.comparison)
        else::
            wybe.comparison.<0>greater(?tmp#4:wybe.comparison @int:94:53)
            foreign llvm move(tmp#4:wybe.comparison, ?tmp#2:wybe.comparison)

        }
   condition -> {x::wybe.int, y::wybe.int}
   then&else -> {tmp#2::wybe.comparison, x::wybe.int, y::wybe.int}
        foreign llvm move(tmp#2:wybe.comparison @int:94:28, ?tmp#0:wybe.comparison)

    }
   condition -> {x::wybe.int, y::wybe.int}
   then&else -> {tmp#0::wybe.comparison, x::wybe.int, y::wybe.int}
    foreign llvm move(tmp#0:wybe.comparison @int:94:10, ?#result:wybe.comparison @int:93:5)


= > public (0 calls)
0: =(x:wybe.int @int:83:10, y:wybe.int @int:83:17, ?#result:wybe.bool @int:83:5):
    foreign llvm icmp_eq(x:wybe.int @int:83:50, y:wybe.int @int:83:52, ?tmp#0:wybe.bool @int:83:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:83:5)


> > public (0 calls)
0: >(x:wybe.int @int:89:10, y:wybe.int @int:89:17, ?#result:wybe.bool @int:89:5):
    foreign llvm icmp_sgt(x:wybe.int @int:89:51, y:wybe.int @int:89:53, ?tmp#0:wybe.bool @int:89:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:89:5)


>= > public (0 calls)
0: >=(x:wybe.int @int:90:10, y:wybe.int @int:90:18, ?#result:wybe.bool @int:90:5):
    foreign llvm icmp_sge(x:wybe.int @int:90:52, y:wybe.int @int:90:54, ?tmp#0:wybe.bool @int:90:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:90:5)


>> > public (0 calls)
0: >>(x:wybe.int @int:65:10, s:wybe.int @int:65:18, ?#result:wybe.int @int:65:5):
    foreign llvm ashr(x:wybe.int @int:65:45, s:wybe.int @int:65:48, ?tmp#0:wybe.int @int:65:27)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:65:5)


>>= > public (0 calls)
0: >>=(!x:wybe.int @int:68:11, s:wybe.int @int:68:21):
    wybe.int.<0>>>(x:wybe.int @int:68:33, s:wybe.int @int:68:39, ?tmp#0:wybe.int @int:68:33)
    foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:68:29)


decr > public (0 calls)
0: decr(!x:wybe.int @int:111:15):
    wybe.int.<0>-(x:wybe.int @int:111:27, 1:wybe.int @int:111:31, ?tmp#0:wybe.int @int:111:27)
    foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:111:23)


incr > public (0 calls)
0: incr(!x:wybe.int @int:110:15):
    wybe.int.<0>+(x:wybe.int @int:110:27, 1:wybe.int @int:110:31, ?tmp#0:wybe.int @int:110:27)
    foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:110:23)


logical_bitshift > public (0 calls)
0: logical_bitshift(x:wybe.int @int:74:26, s:wybe.int @int:74:31, ?#result:wybe.int @int:74:5):
    foreign llvm lshr(x:wybe.int @int:74:58, s:wybe.int @int:74:61, ?tmp#0:wybe.int @int:74:40)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:74:5)
logical_bitshift > public (0 calls)
1: logical_bitshift(!x:wybe.int @int:77:27, s:wybe.int @int:77:32):
    wybe.int.<0>logical_bitshift(x:wybe.int @int:77:61, s:wybe.int @int:77:64, ?tmp#0:wybe.int @int:77:44)
    foreign llvm move(tmp#0:wybe.int, ?x:wybe.int @int:77:40)


max > public (0 calls)
0: max(x:wybe.int @int:98:13, y:wybe.int @int:98:18, ?#result:wybe.int @int:98:5):
    if {wybe.int.<0>>=(x:wybe.int @int:98:31, y:wybe.int @int:98:35)::

        foreign llvm move(x:wybe.int @int:98:39, ?tmp#0:wybe.int)
    else::
        foreign llvm move(y:wybe.int @int:98:50, ?tmp#0:wybe.int)

    }
   condition -> {x::wybe.int, y::wybe.int}
   then&else -> {tmp#0::wybe.int, x::wybe.int, y::wybe.int}
    foreign llvm move(tmp#0:wybe.int @int:98:31, ?#result:wybe.int @int:98:5)


min > public (0 calls)
0: min(x:wybe.int @int:97:13, y:wybe.int @int:97:18, ?#result:wybe.int @int:97:5):
    if {wybe.int.<0><=(x:wybe.int @int:97:31, y:wybe.int @int:97:35)::

        foreign llvm move(x:wybe.int @int:97:39, ?tmp#0:wybe.int)
    else::
        foreign llvm move(y:wybe.int @int:97:50, ?tmp#0:wybe.int)

    }
   condition -> {x::wybe.int, y::wybe.int}
   then&else -> {tmp#0::wybe.int, x::wybe.int, y::wybe.int}
    foreign llvm move(tmp#0:wybe.int @int:97:31, ?#result:wybe.int @int:97:5)


power > public (0 calls)
0: power(x:wybe.int @int:107:15, y:wybe.int @int:107:20, ?#result:wybe.int @int:107:5):
    foreign c ipow(x:wybe.int @int:107:44, y:wybe.int @int:107:46, ?tmp#0:wybe.int @int:107:29)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:107:5)


print > public (0 calls)
0: print(x:wybe.int @int:119:15) use !wybe.io.io:
    foreign c print_int(x:wybe.int @int:119:50, !io:wybe.phantom @int:119:54)


println > public (0 calls)
0: println(x:wybe.int @int:121:17) use !wybe.io.io:
    !wybe.int.<0>print(x:wybe.int @int:121:39)
    !wybe.io.<0>nl


read > public (0 calls)
0: read(?x:wybe.int @int:123:15) use !wybe.io.io:
    foreign c read_int(?x:wybe.int @int:123:50, !io:wybe.phantom @int:123:54)


signum > public (0 calls)
0: signum(x:wybe.int @int:114:16, ?#result:wybe.int @int:114:5):
    foreign c signum(x:wybe.int @int:114:42, ?tmp#0:wybe.int @int:114:25)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:114:5)


sqrt > public (0 calls)
0: sqrt(x:wybe.int @int:104:14, ?#result:wybe.int @int:104:5):
    foreign c isqrt(x:wybe.int @int:104:39, ?tmp#0:wybe.int @int:104:23)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @int:104:5)


~= > public (0 calls)
0: ~=(x:wybe.int @int:84:10, y:wybe.int @int:84:18, ?#result:wybe.bool @int:84:5):
    foreign llvm icmp_ne(x:wybe.int @int:84:51, y:wybe.int @int:84:53, ?tmp#0:wybe.bool @int:84:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @int:84:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.io
  representation  : (not a type)
  public submods  : phantom -> wybe.phantom
  public resources: io: wybe.io.io
  public procs    : wybe.io.<0>
                    wybe.io.eof<0>
                    wybe.io.nl<0>
  imports         : use wybe.char
                    public use wybe.phantom
  resources       : io: fromList [(wybe.io.io,wybe.phantom = 0:phantom @io:13:27 @io:13:5)]
  procs           : 

module top-level code > public {semipure} (0 calls)
0: () use ?wybe.io.io:
    foreign llvm move(0:wybe.phantom @io:13:27, ?io:wybe.phantom @io:13:5)


eof > public {inline} (0 calls)
0: eof(?#result:wybe.char @io:20:5):
    foreign lpvm cast(-1:wybe.int @io:20:47, ?tmp#0:wybe.char @io:20:29)
    foreign llvm move(tmp#0:wybe.char, ?#result:wybe.char @io:20:5)


nl > public {inline} (0 calls)
0: nl() use !wybe.io.io:
    foreign c putchar('\n':wybe.char @io:17:49, !io:wybe.phantom @io:17:54)

LLVM code       : None

--------------------------------------------------
 Module wybe.list(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.list.,,<0>
                    wybe.list.[]<0>
                    wybe.list.all<0>
                    wybe.list.any<0>
                    wybe.list.empty<0>
                    wybe.list.filter<0>
                    wybe.list.foldl<0>
                    wybe.list.foldr<0>
                    wybe.list.length<0>
                    wybe.list.list<0>
                    wybe.list.map<0>
                    wybe.list.map<1>
                    wybe.list.map<2>
                    wybe.list.print<0>
                    wybe.list.println<0>
                    wybe.list.reverse<0>
  imports         : use wybe.array
                    use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
                    use wybe.machine_word
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_(T) @list:20:10, y:_(T) @list:20:20, ?#result:_(T) @list:20:5):
    if {[|](?h @list:21:16, ?t @list:21:21, x @list:21:10)::

        ,,(t @list:21:32, y @list:21:37, ?tmp#2 @list:21:32)
        [|](h @list:21:28, tmp#2, ?tmp#1 @list:21:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(y @list:21:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:21:10, ?#result @list:20:5)


[] > public {test} (0 calls)
0: [](xs:_(T) @list:31:21, idx:int @list:31:30, ?#result:T @list:31:5):
    >=(idx @list:32:5, 0 @list:32:13)
    index1(xs @list:33:17, idx @list:33:21, ?tmp#0 @list:33:10)
    =(?x @list:33:6, tmp#0)
    foreign llvm move(x @list:31:43, ?#result @list:31:5)


all > public {test} (0 calls)
0: all(p:{test}(T) @list:61:20, xs:_(T) @list:61:33):
    foreign llvm move(xs @list:62:15, ?tmp#0)
    do {
        if {[|](?x @list:62:10, ?tmp#0, tmp#0)::

            p(x @list:63:11)
        else::
            break

        }
    }


any > public {test} (0 calls)
0: any(p:{test}(T) @list:69:20, xs:_(T) @list:69:33):
    [|](?x @list:70:7, ?xs @list:70:12, xs @list:70:18)
    (   p(x @list:71:8)
    | any(p @list:71:17, xs @list:71:20))


empty > public {test} (0 calls)
0: empty(xs:_(T) @list:15:22):
    if {[|](?tmp#0 @list:16:11, ?tmp#1 @list:16:15, xs @list:16:20)::

        fail
    else::
        pass

    }


filter > public (0 calls)
0: filter(p:{test}(T) @list:95:16, !xs:_(T) @list:95:30):
    [](?tmp#0 @list:96:12)
    =(?out @list:96:6, tmp#0)
    foreign llvm move(xs @list:97:15, ?tmp#1)
    do {
        if {[|](?x @list:97:10, ?tmp#1, tmp#1)::

            if {p(x @list:98:16)::

                [|](x @list:98:30, out @list:98:34, ?tmp#2 @list:98:29)
                =(?out @list:98:23, tmp#2)
            else::
                pass

            }
        else::
            break

        }
    }
    reverse(out @list:100:19, ?tmp#3 @list:100:11)
    =(?as @list:100:6, tmp#3)


foldl > public (0 calls)
0: foldl(f:(A, !B) @list:77:15, as:_(A) @list:77:26, !b:B @list:77:36):
    foreign llvm move(as @list:78:15, ?tmp#0)
    do {
        if {[|](?a @list:78:10, ?tmp#0, tmp#0)::

            f(a @list:79:11, !b @list:79:15)
        else::
            break

        }
    }


foldr > public (0 calls)
0: foldr(f:(A, !B) @list:86:15, as:_(A) @list:86:26, !b:B @list:86:36):
    if {[|](?a @list:87:12, ?as @list:87:17, as @list:87:23)::

        foldr(f @list:88:15, as @list:88:18, !b @list:88:23)
        f(a @list:89:11, !b @list:89:15)
    else::
        pass

    }


index1 > {test} (0 calls)
0: index1(xs:_(T) @list:148:19, idx:int @list:148:28, ?#result:T @list:148:1):
    [|](?x @list:149:7, ?xs @list:149:12, xs @list:149:18)
    (   =(idx @list:150:6, 0 @list:150:12)
    | (   -(idx @list:150:27, 1 @list:150:33, ?tmp#0 @list:150:27)
        & index1(xs @list:150:23, tmp#0, ?x @list:150:37)))
    foreign llvm move(x @list:148:41, ?#result @list:148:1)


length > public (0 calls)
0: length(x:_(T) @list:24:16, ?#result:int @list:24:5):
    length1(x @list:24:38, 0 @list:24:41, ?tmp#0 @list:24:30)
    foreign llvm move(tmp#0, ?#result @list:24:5)


length1 > (0 calls)
0: length1(x:_(T) @list:140:13, acc:int @list:140:21, ?#result:int @list:140:1):
    if {[|](?h @list:141:16, ?t @list:141:21, x @list:141:10)::

        +(acc @list:141:38, 1 @list:141:44, ?tmp#2 @list:141:38)
        length1(t @list:141:35, tmp#2, ?tmp#1 @list:141:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(acc @list:141:57, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:141:10, ?#result @list:140:1)


list > public (0 calls)
0: list(ar:array(T) @list:128:14, ?#result:_(T) @list:128:5):
    [](?tmp#0 @list:129:11)
    =(?ls @list:129:6, tmp#0)
    foreign llvm move(ar @list:130:15, ?tmp#1)
    do {
        if {[|](?x @list:130:10, ?tmp#1, tmp#1)::

            [|](x @list:131:16, ls @list:131:20, ?tmp#2 @list:131:15)
            =(?ls @list:131:10, tmp#2)
        else::
            break

        }
    }
    reverse(ls @list:133:13, ?ls @list:133:18)
    foreign llvm move(ls @list:128:34, ?#result @list:128:5)


map > public (0 calls)
0: map(f:{resource}(T) @list:41:13, xs:_(T) @list:41:30):
    foreign llvm move(xs @list:42:15, ?tmp#0)
    do {
        if {[|](?x @list:42:10, ?tmp#0, tmp#0)::

            !f(x @list:43:12)
        else::
            break

        }
    }
map > public (0 calls)
1: map(f:(A, ?B) @list:49:13, as:_(A) @list:49:24, ?#result:_(B) @list:49:5):
    if {[|](?a @list:50:12, ?as @list:50:17, as @list:50:23)::

        f(a @list:50:33, ?tmp#2 @list:50:31)
        map(f @list:50:42, as @list:50:45, ?tmp#3 @list:50:38)
        [|](tmp#2, tmp#3, ?tmp#1 @list:50:29)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:50:61)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:50:10, ?#result @list:49:5)
map > public (0 calls)
2: map(f:(A, B, ?C) @list:55:13, as:_(A) @list:55:27, bs:_(B) @list:55:36, ?#result:_(C) @list:55:5):
    if {(   [|](?a @list:56:12, ?as @list:56:17, as @list:56:23)
        & [|](?b @list:56:30, ?bs @list:56:35, bs @list:56:41))::

        f(a @list:56:51, b @list:56:54, ?tmp#2 @list:56:49)
        map(f @list:56:63, as @list:56:66, bs @list:56:70, ?tmp#3 @list:56:59)
        [|](tmp#2, tmp#3, ?tmp#1 @list:56:47)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:57:47)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:56:10, ?#result @list:55:5)


print > public (0 calls)
0: print(printer:{resource}(T) @list:108:15, xs:_(T) @list:108:38) use !io:
    !print('[' @list:109:12)
    if {[|](?x @list:110:12, ?xs @list:110:17, xs @list:110:23)::

        !printer(x @list:111:18)
        !print1(printer @list:112:17, xs @list:112:26)
    else::
        pass

    }
    !print(']' @list:114:12)


print1 > (0 calls)
0: print1(printer:{resource}(T) @list:154:12, xs:_(T) @list:154:35) use !io:
    if {[|](?x @list:155:12, ?xs @list:155:17, xs @list:155:23)::

        !print(',' @list:156:16)
        !printer(x @list:157:18)
        !print1(printer @list:158:17, xs @list:158:26)
    else::
        pass

    }


println > public (0 calls)
0: println(printer:{resource}(T) @list:119:17, xs:_(T) @list:119:40) use !io:
    !print(printer @list:120:12, xs @list:120:21)
    !nl


reverse > public (0 calls)
0: reverse(x:_(T) @list:27:17, ?#result:_(T) @list:27:5):
    [](?tmp#1 @list:27:44)
    reverse1(x @list:27:41, tmp#1, ?tmp#0 @list:27:32)
    foreign llvm move(tmp#0, ?#result @list:27:5)


reverse1 > (0 calls)
0: reverse1(x:_(T) @list:144:14, tail:_(T) @list:144:22, ?#result:_(T) @list:144:1):
    if {[|](?h @list:145:16, ?t @list:145:21, x @list:145:10)::

        [|](h @list:145:40, tail @list:145:44, ?tmp#2 @list:145:39)
        reverse1(t @list:145:36, tmp#2, ?tmp#1 @list:145:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(tail @list:145:61, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:145:10, ?#result @list:144:1)

LLVM code       : None

--------------------------------------------------
 Module wybe.machine_word
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.machine_word.word_size_bits<0>
                    wybe.machine_word.word_size_bytes<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

word_size_bits > public (0 calls)
0: word_size_bits(?#result:int @machine_word:12:5):
    word_size_bytes(?tmp#1 @machine_word:12:34)
    *(8 @machine_word:12:30, tmp#1, ?tmp#0 @machine_word:12:30)
    foreign llvm move(tmp#0, ?#result @machine_word:12:5)


word_size_bytes > public (0 calls)
0: word_size_bytes(?#result:int @machine_word:10:5):
    foreign llvm move(8 @machine_word:10:31, ?#result @machine_word:10:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.memory_management
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.memory_management.malloc_count<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

malloc_count > public {semipure} (0 calls)
0: malloc_count(?x:int @memory_management:11:34):
    foreign c {impure} malloc_count(?x @memory_management:12:38)

LLVM code       : None

--------------------------------------------------
 Module wybe.phantom
 modifiers       : {unique} 
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : 
  imports         : 
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.predicate
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.predicate.const<0>
                    wybe.predicate.id<0>
  imports         : 
  resources       : 
  procs           : 

const > public {inline} (0 calls)
0: wybe.predicate.const<0>
const(a##0:A <{}; {}; {0}>, [b##0:B <{}; {}; {1}>], ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:8:5


id > public {inline} (0 calls)
0: wybe.predicate.id<0>
id(a##0:A <{}; {}; {0}>, ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:6:5

LLVM code       : None

--------------------------------------------------
 Module wybe.range
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.range...<0>
                    wybe.range.[]<0>
                    wybe.range.[|]<0>
                    wybe.range.irange<0>
                    wybe.range.size<0>
                    wybe.range.xrange<0>
  imports         : use wybe.bool
                    use wybe.int
  resources       : 
  procs           : 

.. > public (0 calls)
0: ..(start:int @range:38:10, end:int @range:38:23, ?#result:_ @range:38:5):
    if {<=(start @range:39:27, end @range:39:37)::

        foreign llvm move(1 @range:39:44, ?tmp#1)
    else::
        foreign llvm move(-1 @range:39:56, ?tmp#1)

    }
    construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)
    foreign llvm move(tmp#0, ?#result @range:38:5)


[] > public {test} (0 calls)
0: [](r:_ @range:20:19, idx:int @range:20:24, ?value:int @range:20:34):
    <=(0 @range:21:6, idx @range:21:12)
    range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)
    *(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)
    +(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)
    =(?value @range:23:6, tmp#0)
    if {<=(0 @range:24:10, stride @range:24:16)::

        <(value @range:24:27, end @range:24:35)
    else::
        <(end @range:24:51, value @range:24:57)

    }


[|] > public {test} (0 calls)
0: [|](?value:int @range:12:23, ?rest:_ @range:12:35, current:_ @range:12:43):
    range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)
    ~=(value @range:14:6, end @range:14:16)
    +(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)
    range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)
    =(?rest @range:15:6, tmp#0)


construct > (0 calls)
0: construct(start:int @range:49:15, stride:int @range:49:26, end:int @range:49:38, ?#result:_ @range:49:1):
    -(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)
    %(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)
    =(?diff @range:50:6, tmp#0)
    if {<=(0 @range:51:19, stride @range:51:25)::

        if {=(diff @range:52:26, 0 @range:52:33)::

            max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
            -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
            max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
            foreign llvm move(tmp#5, ?tmp#3)

        }
        foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
    else::
        if {=(diff @range:55:26, 0 @range:55:33)::

            min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
            foreign llvm move(tmp#9, ?tmp#8)
        else::
            +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
            min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
            foreign llvm move(tmp#10, ?tmp#8)

        }
        foreign llvm move(tmp#8 @range:55:26, ?tmp#2)

    }
    =(?final @range:51:6, tmp#2 @range:51:19)
    range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)
    =(?r @range:58:6, tmp#12)
    foreign llvm move(r @range:49:51, ?#result @range:49:1)


irange > public (0 calls)
0: irange(start:int @range:32:16, stride:int @range:32:27, end:int @range:32:39, ?#result:_ @range:32:5):
    if {<(stride @range:33:41, 0 @range:33:50)::

        foreign llvm move(-1 @range:33:55, ?tmp#2)
    else::
        foreign llvm move(1 @range:33:68, ?tmp#2)

    }
    +(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)
    construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)
    foreign llvm move(tmp#0, ?#result @range:32:5)


size > public (0 calls)
0: size(r:_ @range:42:14, ?#result:int @range:42:5):
    range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)
    if {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
        & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
        & signum(tmp#3, ?tmp#2 @range:44:29)
        & ~=(tmp#1, tmp#2))::

        foreign llvm move(0 @range:44:52, ?tmp#0)
    else::
        if {<=(0 @range:45:10, stride @range:45:16)::

            -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
            -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
            /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
            +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
            foreign llvm move(tmp#5, ?tmp#4)
        else::
            -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
            -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
            -(stride @range:46:39, ?tmp#13 @range:46:38)
            /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
            +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
            foreign llvm move(tmp#9, ?tmp#4)

        }
        foreign llvm move(tmp#4 @range:45:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)


xrange > public (0 calls)
0: xrange(start:int @range:28:16, stride:int @range:28:27, end:int @range:28:39, ?#result:_ @range:28:5):
    construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)
    foreign llvm move(tmp#0, ?#result @range:28:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.string
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.string.,,<0>
                    wybe.string.<<0>
                    wybe.string.<=<0>
                    wybe.string.<=><0>
                    wybe.string.=<0>
                    wybe.string.><0>
                    wybe.string.>=<0>
                    wybe.string.[]<0>
                    wybe.string.[]<1>
                    wybe.string.[|]<0>
                    wybe.string.c_string<0>
                    wybe.string.length<0>
                    wybe.string.print<0>
                    wybe.string.println<0>
                    wybe.string.read<0>
                    wybe.string.string<0>
                    wybe.string.string<1>
                    wybe.string.~=<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.char
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
                    use wybe.range
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_ @string:64:10, y:_ @string:64:17, ?#result:_ @string:64:5):
    if {(   empty(?tmp#1 @string:65:14)
        & =(x @string:65:10, tmp#1))::

        foreign llvm move(y @string:65:23, ?tmp#0)
    else::
        if {(   empty(?tmp#3 @string:66:14)
            & =(y @string:66:10, tmp#3))::

            foreign llvm move(x @string:66:23, ?tmp#2)
        else::
            concat(x @string:67:25, y @string:67:28, ?tmp#4 @string:67:18)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:66:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:65:10, ?#result @string:64:5)


< > public (0 calls)
0: <(x:_ @string:119:10, y:_ @string:119:17, ?#result:bool @string:119:5):
    <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
    equal(?tmp#2 @string:119:44)
    <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
    foreign llvm move(tmp#0, ?#result @string:119:5)


<= > public (0 calls)
0: <=(x:_ @string:120:10, y:_ @string:120:18, ?#result:bool @string:120:5):
    <=>(x @string:120:31, y @string:120:39, ?tmp#1 @string:120:31)
    equal(?tmp#2 @string:120:46)
    <=(tmp#1, tmp#2, ?tmp#0 @string:120:30)
    foreign llvm move(tmp#0, ?#result @string:120:5)


<=> > public (0 calls)
0: <=>(x:_ @string:125:10, y:_ @string:125:20, ?#result:comparison @string:125:5):
    equal(?tmp#0 @string:126:10)
    =(?c @string:126:6, tmp#0)
    foreign llvm move(x @string:127:16, ?tmp#1)
    foreign llvm move(y @string:127:26, ?tmp#2)
    do {
        if {[|](?cx @string:127:10, ?tmp#1, tmp#1)::

            if {[|](?cy @string:127:20, ?tmp#2, tmp#2)::

                if {<(cx @string:128:14, cy @string:128:19)::

                    lesser(?tmp#3 @string:128:30)
                    =(?c @string:128:26, tmp#3)
                    break
                else::
                    if {>(cx @string:129:14, cy @string:129:19)::

                        greater(?tmp#4 @string:129:30)
                        =(?c @string:129:26, tmp#4)
                        break
                    else::
                        pass

                    }

                }
            else::
                break

            }
        else::
            break

        }
    }
    if {(   equal(?tmp#5 @string:132:14)
        & =(c @string:132:10, tmp#5))::

        length(x @string:133:22, ?tmp#6 @string:133:15)
        =(?lx @string:133:10, tmp#6)
        length(y @string:134:22, ?tmp#7 @string:134:15)
        =(?ly @string:134:10, tmp#7)
        if {<(lx @string:135:14, ly @string:135:19)::

            lesser(?tmp#8 @string:135:30)
            =(?c @string:135:26, tmp#8)
        else::
            if {>(lx @string:135:39, ly @string:135:44)::

                greater(?tmp#9 @string:135:55)
                =(?c @string:135:51, tmp#9)
            else::
                pass

            }

        }
    else::
        pass

    }
    foreign llvm move(c @string:125:38, ?#result @string:125:5)


= > public (0 calls)
0: =(x:_ @string:115:10, y:_ @string:115:17, ?#result:bool @string:115:5):
    <=>(x @string:115:30, y @string:115:38, ?tmp#1 @string:115:30)
    equal(?tmp#2 @string:115:44)
    =(tmp#1, tmp#2, ?tmp#0 @string:115:29)
    foreign llvm move(tmp#0, ?#result @string:115:5)


> > public (0 calls)
0: >(x:_ @string:121:10, y:_ @string:121:17, ?#result:bool @string:121:5):
    <=>(x @string:121:30, y @string:121:38, ?tmp#1 @string:121:30)
    equal(?tmp#2 @string:121:44)
    >(tmp#1, tmp#2, ?tmp#0 @string:121:29)
    foreign llvm move(tmp#0, ?#result @string:121:5)


>= > public (0 calls)
0: >=(x:_ @string:122:10, y:_ @string:122:18, ?#result:bool @string:122:5):
    <=>(x @string:122:31, y @string:122:39, ?tmp#1 @string:122:31)
    equal(?tmp#2 @string:122:46)
    >=(tmp#1, tmp#2, ?tmp#0 @string:122:30)
    foreign llvm move(tmp#0, ?#result @string:122:5)


[] > public {test} (0 calls)
0: [](s:_ @string:91:19, idx:int @string:91:24, ?c:char @string:91:34):
    if {buffer(?len @string:93:17, ?str @string:93:23, s @string:92:10)::

        <=(0 @string:94:14, idx @string:94:20)
        <(idx @string:95:14, len @string:95:20)
        unsafe_c_string_index(str @string:96:35, idx @string:96:40, ?c @string:96:46)
    else::
        if {concat(?left @string:97:17, ?right @string:97:24, s @string:92:10)::

            length(left @string:98:32, ?tmp#0 @string:98:25)
            =(?left_len @string:98:14, tmp#0)
            if {<(idx @string:99:18, left_len @string:99:24)::

                [](left @string:99:41, idx @string:99:46, ?tmp#1 @string:99:41)
                =(?c @string:99:37, tmp#1)
            else::
                -(idx @string:100:37, left_len @string:100:43, ?tmp#3 @string:100:37)
                [](right @string:100:31, tmp#3, ?tmp#2 @string:100:31)
                =(?c @string:100:27, tmp#2)

            }
        else::
            if {slice(?base @string:102:16, ?range @string:102:23, s @string:92:10)::

                [](range @string:102:43, idx @string:102:49, ?tmp#5 @string:102:43)
                [](base @string:102:38, tmp#5, ?tmp#4 @string:102:38)
                =(?c @string:102:34, tmp#4)
            else::
                if {singleton(?c @string:103:20, s @string:92:10)::

                    =(idx @string:103:27, 0 @string:103:33)
                else::
                    fail

                }

            }

        }

    }
[] > public (0 calls)
1: [](s:_ @string:109:12, r:range @string:109:17, ?#result:_ @string:109:5):
    slice(s @string:109:36, r @string:109:39, ?tmp#0 @string:109:30)
    foreign llvm move(tmp#0, ?#result @string:109:5)


[|] > public {test} (0 calls)
0: [|](?head:char @string:71:23, ?tail:_ @string:71:35, s:_ @string:71:43):
    if {buffer(?len @string:73:17, ?str @string:73:23, s @string:72:10)::

        [|](?head @string:74:15, ?str @string:74:23, str @string:74:30)
        if {=(len @string:75:26, 1 @string:75:32)::

            empty(?tmp#1 @string:75:37)
            foreign llvm move(tmp#1, ?tmp#0)
        else::
            -(len @string:75:60, 1 @string:75:66, ?tmp#3 @string:75:60)
            buffer(tmp#3, str @string:75:69, ?tmp#2 @string:75:53)
            foreign llvm move(tmp#2, ?tmp#0)

        }
        =(?tail @string:75:14, tmp#0 @string:75:26)
    else::
        if {concat(?left @string:76:17, ?right @string:76:24, s @string:72:10)::

            if {[|](?head @string:77:20, ?t @string:77:28, left @string:77:33)::

                concat(t @string:77:56, right @string:77:59, ?tmp#4 @string:77:49)
                =(?tail @string:77:42, tmp#4)
            else::
                [|](?head @string:78:28, ?tail @string:78:36, right @string:78:44)

            }
        else::
            if {slice(?base @string:80:16, ?range @string:80:23, s @string:72:10)::

                do {
                    [|](?idx @string:82:19, ?range @string:82:26, range @string:82:35)
                    if {(   [](base @string:83:30, idx @string:83:35, ?tmp#5 @string:83:30)
                        & =(?head @string:83:23, tmp#5))::

                        slice(base @string:83:57, range @string:83:63, ?tmp#6 @string:83:51)
                        =(?tail @string:83:44, tmp#6)
                        break
                    else::
                        pass

                    }
                }
            else::
                if {singleton(?head @string:85:20, s @string:72:10)::

                    empty(?tmp#7 @string:85:37)
                    =(?tail @string:85:30, tmp#7)
                else::
                    fail

                }

            }

        }

    }


c_string > public (0 calls)
0: c_string(s:_ @string:40:18, ?#result:c_string @string:40:5):
    if {buffer(?tmp#0 @string:41:21, ?str @string:41:25, s @string:41:10)::

        pass
    else::
        length(s @string:43:27, ?tmp#2 @string:43:20)
        +(tmp#2, 1 @string:43:32, ?tmp#1 @string:43:20)
        =(?len @string:43:14, tmp#1)
        foreign lpvm alloc(len @string:44:32, ?str @string:44:38)
        true(?tmp#3 @string:45:49)
        foreign lpvm mutate(str @string:45:33, ?str @string:45:39, len @string:45:44, tmp#3, len @string:45:55, 0 @string:45:60, '\NUL' @string:45:63)
        =(?offset @string:46:14, 0 @string:46:23)
        pack(s @string:47:18, !str @string:47:22, len @string:47:27, !offset @string:47:33)

    }
    foreign llvm move(str @string:40:34, ?#result @string:40:5)


fixed_range_size > (0 calls)
0: fixed_range_size(hi:int @string:184:22, r:range @string:184:30, ?sz:int @string:184:40):
    range(?start @string:185:16, ?stride @string:185:24, ?end @string:185:33, r @string:185:5)
    if {<=(0 @string:186:10, stride @string:186:16)::

        -(start @string:187:39, ?tmp#4 @string:187:38)
        /(tmp#4, stride @string:187:47, ?tmp#3 @string:187:38)
        *(tmp#3, stride @string:187:56, ?tmp#2 @string:187:38)
        +(start @string:187:30, tmp#2, ?tmp#1 @string:187:30)
        max(start @string:187:23, tmp#1, ?tmp#0 @string:187:19)
        =(?lo @string:187:14, tmp#0)
        min(hi @string:188:23, end @string:188:27, ?tmp#5 @string:188:19)
        =(?hi @string:188:14, tmp#5)
    else::
        max(-1 @string:190:23, end @string:190:27, ?tmp#6 @string:190:19)
        =(?lo @string:190:14, tmp#6)
        +(hi @string:191:30, stride @string:191:35, ?tmp#10 @string:191:30)
        -(start @string:191:45, hi @string:191:53, ?tmp#13 @string:191:45)
        -(tmp#13, 1 @string:191:58, ?tmp#12 @string:191:45)
        -(stride @string:191:64, ?tmp#14 @string:191:63)
        %(tmp#12, tmp#14, ?tmp#11 @string:191:44)
        +(tmp#10, tmp#11, ?tmp#9 @string:191:30)
        +(tmp#9, 1 @string:191:73, ?tmp#8 @string:191:30)
        min(start @string:191:23, tmp#8, ?tmp#7 @string:191:19)
        =(?hi @string:191:14, tmp#7)
        -(stride @string:192:24, ?tmp#15 @string:192:23)
        =(?stride @string:192:14, tmp#15)

    }
    if {<=(hi @string:194:16, lo @string:194:23)::

        foreign llvm move(0 @string:194:29, ?tmp#16)
    else::
        -(hi @string:194:42, lo @string:194:47, ?tmp#20 @string:194:42)
        -(tmp#20, 1 @string:194:52, ?tmp#19 @string:194:42)
        /(tmp#19, stride @string:194:57, ?tmp#18 @string:194:41)
        +(tmp#18, 1 @string:194:66, ?tmp#17 @string:194:41)
        foreign llvm move(tmp#17, ?tmp#16)

    }
    =(?sz @string:194:6, tmp#16 @string:194:16)


length > public (0 calls)
0: length(s:_ @string:52:16, ?#result:int @string:52:5):
    if {buffer(?len @string:53:22, ?tmp#1 @string:53:27, s @string:53:10)::

        foreign llvm move(len @string:53:33, ?tmp#0)
    else::
        if {concat(?left @string:54:22, ?right @string:54:29, s @string:54:10)::

            length(left @string:54:46, ?tmp#4 @string:54:39)
            length(right @string:54:61, ?tmp#5 @string:54:54)
            +(tmp#4, tmp#5, ?tmp#3 @string:54:39)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            if {slice(?base @string:55:21, ?range @string:55:28, s @string:55:10)::

                length(base @string:55:62, ?tmp#8 @string:55:55)
                fixed_range_size(tmp#8, range @string:55:69, ?tmp#7 @string:55:38)
                foreign llvm move(tmp#7, ?tmp#6)
            else::
                if {singleton(?tmp#10 @string:56:24, s @string:56:10)::

                    foreign llvm move(1 @string:56:30, ?tmp#9)
                else::
                    foreign llvm move(0 @string:57:18, ?tmp#9)

                }
                foreign llvm move(tmp#9 @string:56:10, ?tmp#6)

            }
            foreign llvm move(tmp#6 @string:55:10, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:54:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:53:10, ?#result @string:52:5)


pack > (0 calls)
0: pack(s:_ @string:160:10, !raw:c_string @string:160:16, size:int @string:160:30, !offset:int @string:160:41):
    if {buffer(?tmp#0 @string:162:16, ?str @string:162:20, s @string:161:10)::

        foreign llvm move(str @string:163:23, ?tmp#1)
        do {
            if {[|](?c @string:163:18, ?tmp#1, tmp#1)::

                true(?tmp#2 @string:164:56)
                foreign lpvm mutate(raw @string:164:37, ?raw @string:164:43, offset @string:164:48, tmp#2, size @string:164:62, 0 @string:164:68, c @string:164:71)
                incr(!offset @string:165:23)
            else::
                break

            }
        }
    else::
        if {concat(?left @string:167:17, ?right @string:167:24, s @string:161:10)::

            pack(left @string:168:18, !raw @string:168:25, size @string:168:30, !offset @string:168:37)
            pack(right @string:169:18, !raw @string:169:26, size @string:169:31, !offset @string:169:38)
            incr(!offset @string:170:19)
        else::
            if {slice(?tmp#3 @string:171:15, ?tmp#4 @string:171:18, s @string:161:10)::

                foreign llvm move(s @string:172:23, ?tmp#5)
                do {
                    if {[|](?c @string:172:18, ?tmp#5, tmp#5)::

                        true(?tmp#6 @string:173:56)
                        foreign lpvm mutate(raw @string:173:37, ?raw @string:173:43, offset @string:173:48, tmp#6, size @string:173:62, 0 @string:173:68, c @string:173:71)
                        incr(!offset @string:174:23)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:176:20, s @string:161:10)::

                    true(?tmp#7 @string:177:52)
                    foreign lpvm mutate(raw @string:177:33, ?raw @string:177:39, offset @string:177:44, tmp#7, size @string:177:58, 0 @string:177:64, c @string:177:67)
                    incr(!offset @string:178:19)
                else::
                    fail

                }

            }

        }

    }


print > public (0 calls)
0: print(x:_ @string:142:15) use !io:
    if {buffer(?tmp#0 @string:144:16, ?str @string:144:20, x @string:143:10)::

        !print(str @string:144:35)
    else::
        if {concat(?left @string:145:17, ?right @string:145:24, x @string:143:10)::

            !print(left @string:145:41)
            !print(right @string:145:55)
        else::
            if {slice(?tmp#1 @string:146:15, ?tmp#2 @string:146:18, x @string:143:10)::

                foreign llvm move(x @string:146:34, ?tmp#3)
                do {
                    if {[|](?c @string:146:29, ?tmp#3, tmp#3)::

                        !print(c @string:146:45)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:147:20, x @string:143:10)::

                    !print(c @string:147:33)
                else::
                    fail

                }

            }

        }

    }


println > public (0 calls)
0: println(x:_ @string:151:17) use !io:
    !print(x @string:151:39)
    !nl


read > public (0 calls)
0: read(?x:_ @string:153:15) use !io:
    !read(?str:c_string @string:153:37)
    string(str @string:153:64, ?tmp#0 @string:153:57)
    =(?x @string:153:53, tmp#0)


string > public (0 calls)
0: string(str:c_string @string:28:16, ?#result:_ @string:28:5):
    length(str @string:29:19, ?tmp#0 @string:29:12)
    =(?len @string:29:6, tmp#0)
    if {=(len @string:30:15, 0 @string:30:21)::

        empty(?tmp#2 @string:30:26)
        foreign llvm move(tmp#2, ?tmp#1)
    else::
        if {=(len @string:31:15, 1 @string:31:21)::

            foreign lpvm access(str @string:31:56, 0 @string:31:61, 1 @string:31:64, 0 @string:31:67, ?tmp#5 @string:31:36)
            singleton(tmp#5, ?tmp#4 @string:31:26)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            buffer(len @string:32:33, str @string:32:38, ?tmp#6 @string:32:26)
            foreign llvm move(tmp#6, ?tmp#3)

        }
        foreign llvm move(tmp#3 @string:31:15, ?tmp#1)

    }
    =(?s @string:30:6, tmp#1 @string:30:15)
    foreign llvm move(s @string:28:34, ?#result @string:28:5)
string > public (0 calls)
1: string(c:char @string:37:16, ?#result:_ @string:37:5):
    singleton(c @string:37:38, ?tmp#0 @string:37:28)
    foreign llvm move(tmp#0, ?#result @string:37:5)


~= > public (0 calls)
0: ~=(x:_ @string:116:10, y:_ @string:116:18, ?#result:bool @string:116:5):
    <=>(x @string:116:31, y @string:116:39, ?tmp#1 @string:116:31)
    equal(?tmp#2 @string:116:46)
    ~=(tmp#1, tmp#2, ?tmp#0 @string:116:30)
    foreign llvm move(tmp#0, ?#result @string:116:5)

LLVM code       : None

======================================================================
AFTER FLATTENING:
 Module wybe
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : 
  imports         : public use wybe.array
                    public use wybe.bool
                    public use wybe.c_string
                    public use wybe.char
                    public use wybe.comparison
                    public use wybe.control
                    public use wybe.count
                    public use wybe.float
                    public use wybe.int
                    public use wybe.io
                    public use wybe.list
                    public use wybe.machine_word
                    public use wybe.memory_management
                    public use wybe.phantom
                    public use wybe.predicate
                    public use wybe.range
                    public use wybe.string
  resources       : 
  submodules      : wybe.array, wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.control, wybe.count, wybe.float, wybe.int, wybe.io, wybe.list, wybe.machine_word, wybe.memory_management, wybe.phantom, wybe.predicate, wybe.range, wybe.string
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.array(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.array.[]<0>
                    wybe.array.[]<1>
                    wybe.array.[|]<0>
                    wybe.array.array<0>
                    wybe.array.array<1>
                    wybe.array.inbounds<0>
                    wybe.array.unsafe_get<0>
                    wybe.array.unsafe_update<0>
  imports         : public use wybe.array.raw_array
                    use wybe.bool
                    use wybe.int
                    use wybe.list
                    use wybe.machine_word
  resources       : 
  submodules      : wybe.array.raw_array
  procs           : 

[] > public {test} (0 calls)
0: [](a:_(T) @array:67:21, idx:int @array:67:29, ?#result:T @array:67:5):
    inbounds(a @array:68:14, idx @array:68:17)
    unsafe_get(a @array:69:10, idx @array:69:23, ?tmp#0 @array:69:10)
    =(?x @array:69:6, tmp#0)
    foreign llvm move(x @array:67:42, ?#result @array:67:5)
[] > public {test} (0 calls)
1: [](!a:_(T) @array:81:22, idx:int @array:81:30, x:T @array:81:39):
    inbounds(a @array:82:14, idx @array:82:17)
    unsafe_update(!a @array:83:20, idx @array:83:23, x @array:83:28)


[|] > public {test} (0 calls)
0: [|](?head:T @array:51:23, ?tail:_(T) @array:51:32, a:_(T) @array:51:43):
    array(?length @array:52:12, ?data @array:52:21, a @array:52:29)
    >(length @array:53:6, 0 @array:53:15)
    word_size_bytes(?tmp#0 @array:54:34)
    foreign lpvm access(data @array:54:25, 0 @array:54:31, tmp#0, 0 @array:54:51, ?head @array:54:55)
    word_size_bytes(?tmp#1 @array:55:28)
    foreign llvm add(data @array:55:22, tmp#1, ?data @array:55:46)
    -(length @array:56:19, 1 @array:56:28, ?tmp#3 @array:56:19)
    array(tmp#3, data @array:56:31, ?tmp#2 @array:56:13)
    =(?tail @array:56:6, tmp#2)


array > public (0 calls)
0: array(x:T @array:18:15, len:int @array:18:20, ?#result:_(T) @array:18:5):
    word_size_bytes(?tmp#1 @array:19:19)
    *(len @array:19:13, tmp#1, ?tmp#0 @array:19:13)
    =(?size @array:19:6, tmp#0)
    foreign lpvm alloc(size @array:20:24, ?data @array:20:31)
    =(?offset @array:21:6, 0 @array:21:15)
    do {
        if {<(offset @array:23:15, size @array:23:24)::

            pass
        else::
            break

        }
        foreign lpvm mutate(data @array:24:29, ?data @array:24:36, offset @array:24:42, 1 @array:24:50, size @array:24:53, 0 @array:24:59, x @array:24:62)
        word_size_bytes(?tmp#2 @array:25:21)
        +=(!offset @array:25:10, tmp#2)
    }
    array(len @array:27:17, data @array:27:22, ?tmp#3 @array:27:11)
    =(?ar @array:27:6, tmp#3)
    foreign llvm move(ar @array:18:36, ?#result @array:18:5)
array > public (0 calls)
1: array(ls:list(T) @array:34:15, ?#result:_(T) @array:34:5):
    length(ls @array:35:19, ?tmp#0 @array:35:12)
    =(?len @array:35:6, tmp#0)
    word_size_bytes(?tmp#2 @array:36:19)
    *(len @array:36:13, tmp#2, ?tmp#1 @array:36:13)
    =(?size @array:36:6, tmp#1)
    foreign lpvm alloc(size @array:37:24, ?data @array:37:31)
    =(?offset @array:38:6, 0 @array:38:15)
    foreign llvm move(ls @array:39:15, ?tmp#3)
    do {
        if {[|](?x @array:39:10, ?tmp#3, tmp#3)::

            foreign lpvm mutate(data @array:40:29, ?data @array:40:36, offset @array:40:42, 1 @array:40:50, size @array:40:53, 0 @array:40:59, x @array:40:62)
            word_size_bytes(?tmp#4 @array:41:21)
            +=(!offset @array:41:10, tmp#4)
        else::
            break

        }
    }
    array(len @array:43:17, data @array:43:22, ?tmp#5 @array:43:11)
    =(?ar @array:43:6, tmp#5)
    foreign llvm move(ar @array:34:34, ?#result @array:34:5)


inbounds > public {test,inline} (0 calls)
0: inbounds(a:_(T) @array:60:33, idx:int @array:60:41):
    <=(0 @array:61:6, idx @array:61:12)
    length(a @array:62:12, ?tmp#0 @array:62:12)
    <(idx @array:62:6, tmp#0)


unsafe_get > public {inline} (0 calls)
0: unsafe_get(a:_(T) @array:75:29, idx:int @array:75:37, ?#result:T @array:75:5):
    raw_data(a @array:76:25, ?tmp#0 @array:76:25)
    word_size_bytes(?tmp#2 @array:76:43)
    *(idx @array:76:37, tmp#2, ?tmp#1 @array:76:37)
    word_size_bytes(?tmp#3 @array:76:60)
    foreign lpvm access(tmp#0, tmp#1, tmp#3, 0 @array:76:77, ?x @array:76:81)
    foreign llvm move(x @array:75:50, ?#result @array:75:5)


unsafe_update > public {inline} (0 calls)
0: unsafe_update(!a:_(T) @array:89:33, idx:int @array:89:41, x:T @array:89:50):
    raw_data(a @array:90:25, ?tmp#0 @array:90:25)
    word_size_bytes(?tmp#2 @array:90:50)
    *(idx @array:90:44, tmp#2, ?tmp#1 @array:90:44)
    length(a @array:91:44, ?tmp#4 @array:91:44)
    word_size_bytes(?tmp#5 @array:91:55)
    *(tmp#4, tmp#5, ?tmp#3 @array:91:44)
    foreign lpvm mutate(tmp#0, ?data @array:90:38, tmp#1, 0 @array:90:67, tmp#3, 0 @array:91:72, x @array:91:75)
    raw_data(!a @array:92:6, data @array:92:19)

LLVM code       : None

--------------------------------------------------
 Module wybe.array.raw_array(T)
  representation  : address
  public submods  : 
  public resources: 
  public procs    : 
  imports         : use wybe
                    use wybe.array
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.bool
  representation  : 1 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.bool.&&<0>
                    wybe.bool.&=<0>
                    wybe.bool.=<0>
                    wybe.bool.^=<0>
                    wybe.bool.^^<0>
                    wybe.bool.false<0>
                    wybe.bool.print<0>
                    wybe.bool.println<0>
                    wybe.bool.succeed<0>
                    wybe.bool.true<0>
                    wybe.bool.|=<0>
                    wybe.bool.||<0>
                    wybe.bool.~<0>
                    wybe.bool.~=<0>
  imports         : use wybe.c_string
                    use wybe.io
  resources       : 
  procs           : 

&& > public {inline} (1 calls)
0: wybe.bool.&&<0>
&&(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:13:27


&= > public {inline} (0 calls)
0: wybe.bool.&=<0>
&=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:13:27


= > public {inline} (0 calls)
0: wybe.bool.=<0>
=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:37:26


^= > public {inline} (0 calls)
0: wybe.bool.^=<0>
^=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:25:27


^^ > public {inline} (1 calls)
0: wybe.bool.^^<0>
^^(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:25:27


false > public {inline} (0 calls)
0: wybe.bool.false<0>
false(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.bool, ?#result##0:wybe.bool)


print > public (1 calls)
0: wybe.bool.print<0>
print(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    case ~x##0:wybe.bool of
    0:
        wybe.c_string.print<0>(c"false":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #1 @bool:47:31

    1:
        wybe.c_string.print<0>(c"true":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:47:31



println > public {inline} (0 calls)
0: wybe.bool.println<0>
println(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.bool.print<0>(~x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:49:33
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#0##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~tmp#0##0:wybe.phantom, ?tmp#1##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#1##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


succeed > public {inline} (0 calls)
0: wybe.bool.succeed<0>
succeed()<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []


true > public {inline} (1 calls)
0: wybe.bool.true<0>
true(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.bool, ?#result##0:wybe.bool)


|= > public {inline} (0 calls)
0: wybe.bool.|=<0>
|=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:19:27


|| > public {inline} (1 calls)
0: wybe.bool.||<0>
||(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:19:27


~ > public {inline} (0 calls)
0: wybe.bool.~<0>
~(p##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, 1:wybe.bool, ?#result##0:wybe.bool) @bool:31:20


~= > public {inline} (0 calls)
0: wybe.bool.~=<0>
~=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:38:27

LLVM code       : None

--------------------------------------------------
 Module wybe.c_string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.c_string.<<0>
                    wybe.c_string.<=<0>
                    wybe.c_string.=<0>
                    wybe.c_string.><0>
                    wybe.c_string.>=<0>
                    wybe.c_string.[]<0>
                    wybe.c_string.[|]<0>
                    wybe.c_string.length<0>
                    wybe.c_string.print<0>
                    wybe.c_string.println<0>
                    wybe.c_string.read<0>
                    wybe.c_string.unsafe_c_string_index<0>
                    wybe.c_string.~=<0>
  imports         : use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.c_string.<<0>
<(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:12:29
    wybe.int.<<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:12:29


<= > public {inline} (0 calls)
0: wybe.c_string.<=<0>
<=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:13:30
    wybe.int.<=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:13:30


= > public {inline} (0 calls)
0: wybe.c_string.=<0>
=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:10:29
    wybe.int.=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:10:29


> > public {inline} (0 calls)
0: wybe.c_string.><0>
>(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:14:29
    wybe.int.><0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:14:29


>= > public {inline} (0 calls)
0: wybe.c_string.>=<0>
>=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:15:30
    wybe.int.>=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:15:30


[] > public (0 calls)
0: wybe.c_string.[]<0>
[](str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, idx##0:wybe.int, ?tmp#2##0:wybe.bool) #0 @c_string:27:6
    case ~tmp#2##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        foreign c strlen(str##0:wybe.c_string, ?tmp#0##0:wybe.int) @c_string:17:29
        wybe.int.<<0>(idx##0:wybe.int, ~tmp#0##0:wybe.int, ?tmp#3##0:wybe.bool) #2 @c_string:28:6
        case ~tmp#3##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




[|] > public (0 calls)
0: wybe.c_string.[|]<0>
[|](?head##0:wybe.char, ?tail##0:wybe.c_string, str##0:wybe.c_string, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(str##0:wybe.c_string, 0:wybe.int, 0:wybe.int, 0:wybe.int, ?head##0:wybe.char) @c_string:20:5
    foreign llvm icmp_ne(head##0:wybe.char, '\NUL':wybe.char, ?not_done##0:wybe.bool) @c_string:21:5
    foreign llvm icmp_eq(~not_done##0:wybe.bool, 1:wybe.bool, ?tmp#1##0:wybe.bool) @bool:37:26
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.c_string, ?tail##0:wybe.c_string)

    1:
        foreign llvm add(~str##0:wybe.c_string, 1:wybe.int, ?tail##0:wybe.c_string) @c_string:23:5
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



length > public {inline} (3 calls)
0: wybe.c_string.length<0>
length(str##0:wybe.c_string, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strlen(~str##0:wybe.c_string, ?#result##0:wybe.int) @c_string:17:29


print > public {inline} (1 calls)
0: wybe.c_string.print<0>
print(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:35:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:35:30


println > public {inline} (0 calls)
0: wybe.c_string.println<0>
println(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @c_string:35:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.c_string.read<0>
read(?x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:39:30
    foreign c read_line(?x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:39:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:39:30


unsafe_c_string_index > public {inline} (1 calls)
0: wybe.c_string.unsafe_c_string_index<0>
unsafe_c_string_index(str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7


~= > public {inline} (0 calls)
0: wybe.c_string.~=<0>
~=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:11:30
    wybe.int.~=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.char
  representation  : 8 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.char.<<0>
                    wybe.char.<=<0>
                    wybe.char.<=><0>
                    wybe.char.=<0>
                    wybe.char.><0>
                    wybe.char.>=<0>
                    wybe.char.chr<0>
                    wybe.char.ord<0>
                    wybe.char.print<0>
                    wybe.char.println<0>
                    wybe.char.read<0>
                    wybe.char.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (4 calls)
0: wybe.char.<<0>
<(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:17:29


<= > public {inline} (0 calls)
0: wybe.char.<=<0>
<=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:18:30


<=> > public (0 calls)
0: wybe.char.<=><0>
<=>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.char, y##0:wybe.char, ?tmp#6##0:wybe.bool) @char:17:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?tmp#5##0:wybe.bool) @char:13:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5



= > public {inline} (2 calls)
0: wybe.char.=<0>
=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:13:29


> > public {inline} (0 calls)
0: wybe.char.><0>
>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:19:29


>= > public {inline} (0 calls)
0: wybe.char.>=<0>
>=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:20:30


chr > public (0 calls)
0: wybe.char.chr<0>
chr(i##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, i##0:wybe.int, ?tmp#1##0:wybe.bool) #0 @char:33:60
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        wybe.int.<=<0>(i##0:wybe.int, 255:wybe.int, ?tmp#2##0:wybe.bool) #1 @char:33:70
        case ~tmp#2##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm cast(~i##0:wybe.int, ?#result##0:wybe.char) @char:33:31
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




ord > public {inline} (0 calls)
0: wybe.char.ord<0>
ord(c##0:wybe.char, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(~c##0:wybe.char, ?#result##0:wybe.int) @char:30:24


print > public {inline} (1 calls)
0: wybe.char.print<0>
print(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:37:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:37:30


println > public {inline} (0 calls)
0: wybe.char.println<0>
println(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @char:37:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.char.read<0>
read(?x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:41:30
    foreign c read_char(?x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:41:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:41:30


~= > public {inline} (0 calls)
0: wybe.char.~=<0>
~=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:14:30

LLVM code       : None

--------------------------------------------------
 Module wybe.comparison
  representation  : 2 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.comparison.<<0>
                    wybe.comparison.<=<0>
                    wybe.comparison.=<0>
                    wybe.comparison.><0>
                    wybe.comparison.>=<0>
                    wybe.comparison.equal<0>
                    wybe.comparison.greater<0>
                    wybe.comparison.lesser<0>
                    wybe.comparison.~=<0>
  imports         : use wybe.bool
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.comparison.<<0>
<(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:12:29


<= > public {inline} (0 calls)
0: wybe.comparison.<=<0>
<=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:13:30


= > public {inline} (0 calls)
0: wybe.comparison.=<0>
=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:10:29


> > public {inline} (0 calls)
0: wybe.comparison.><0>
>(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:14:29


>= > public {inline} (0 calls)
0: wybe.comparison.>=<0>
>=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:15:30


equal > public {inline} (0 calls)
0: wybe.comparison.equal<0>
equal(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison)


greater > public {inline} (0 calls)
0: wybe.comparison.greater<0>
greater(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison)


lesser > public {inline} (0 calls)
0: wybe.comparison.lesser<0>
lesser(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison)


~= > public {inline} (0 calls)
0: wybe.comparison.~=<0>
~=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.control
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.control.assert<0>
                    wybe.control.error<0>
                    wybe.control.error<1>
                    wybe.control.exit<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.int
                    use wybe.string
  resources       : 
  procs           : 

assert > public {semipure} (0 calls)
0: assert(condition:bool @control:26:27) use call_source_location:
    if {~(condition @control:27:11)::

        !error(c"assertion failed" @control:27:31)
    else::
        pass

    }


error > public {terminal,semipure} (0 calls)
0: error(message:string @control:17:35) use call_source_location:
    c_string(message @control:18:77, ?tmp#0 @control:18:68)
    foreign c {terminal,semipure} error_exit(call_source_location @control:18:46, tmp#0)
error > public {terminal,semipure} (0 calls)
1: error(message:c_string @control:21:35) use call_source_location:
    foreign c {terminal,semipure} error_exit(call_source_location @control:22:46, message @control:22:68)


exit > public {terminal,semipure} (0 calls)
0: exit(code:int @control:10:34):
    foreign c {terminal,semipure} exit(code @control:11:40)

LLVM code       : None

--------------------------------------------------
 Module wybe.count
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.count.%<0>
                    wybe.count.%=<0>
                    wybe.count.*<0>
                    wybe.count.*=<0>
                    wybe.count.+<0>
                    wybe.count.+<1>
                    wybe.count.+<2>
                    wybe.count.+=<0>
                    wybe.count.-<0>
                    wybe.count.-<1>
                    wybe.count.-<2>
                    wybe.count.-=<0>
                    wybe.count./<0>
                    wybe.count./=<0>
                    wybe.count.<<0>
                    wybe.count.<=<0>
                    wybe.count.<=><0>
                    wybe.count.=<0>
                    wybe.count.><0>
                    wybe.count.>=<0>
                    wybe.count.decr<0>
                    wybe.count.incr<0>
                    wybe.count.max<0>
                    wybe.count.min<0>
                    wybe.count.print<0>
                    wybe.count.println<0>
                    wybe.count.read<0>
                    wybe.count.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public (0 calls)
0: %(x:_ @count:51:10, y:_ @count:51:16, ?#result:_ @count:51:5):
    foreign llvm urem(x @count:51:43, y @count:51:45, ?tmp#0 @count:51:25)
    foreign llvm move(tmp#0, ?#result @count:51:5)


%= > public (0 calls)
0: %=(!x:_ @count:54:11, y:_ @count:54:19):
    %(x @count:54:31, y @count:54:35, ?tmp#0 @count:54:31)
    =(?x @count:54:27, tmp#0)


* > public (0 calls)
0: *(x:_ @count:39:10, y:_ @count:39:16, ?#result:_ @count:39:5):
    foreign llvm mul(x @count:39:42, y @count:39:44, ?tmp#0 @count:39:25)
    foreign llvm move(tmp#0, ?#result @count:39:5)


*= > public (0 calls)
0: *=(!x:_ @count:42:11, y:_ @count:42:19):
    *(x @count:42:31, y @count:42:35, ?tmp#0 @count:42:31)
    =(?x @count:42:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @count:15:10, y:_ @count:15:16, ?#result:_ @count:15:5):
    foreign llvm add(x @count:15:42, y @count:15:44, ?tmp#0 @count:15:25)
    foreign llvm move(tmp#0, ?#result @count:15:5)
+ > public {test} (0 calls)
1: +(?x:_ @count:16:21, y:_ @count:16:27, z:_ @count:16:5):
    >=(z @count:17:5, y @count:17:11)
    foreign llvm sub(z @count:18:27, y @count:18:29, ?tmp#0 @count:18:10)
    =(?x @count:18:6, tmp#0)
+ > public {test} (0 calls)
2: +(x:_ @count:20:20, ?y:_ @count:20:27, z:_ @count:20:5):
    >=(z @count:21:5, x @count:21:11)
    foreign llvm sub(z @count:22:27, x @count:22:29, ?tmp#0 @count:22:10)
    =(?y @count:22:6, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @count:26:11, y:_ @count:26:19):
    +(x @count:26:31, y @count:26:35, ?tmp#0 @count:26:31)
    =(?x @count:26:27, tmp#0)


- > public {test} (0 calls)
0: -(x:_ @count:31:20, y:_ @count:31:26, ?#result:_ @count:31:5):
    >=(y @count:31:65, x @count:31:71)
    foreign llvm sub(x @count:31:52, y @count:31:54, ?tmp#0 @count:31:35)
    foreign llvm move(tmp#0, ?#result @count:31:5)
- > public (0 calls)
1: -(?x:_ @count:32:11, y:_ @count:32:17, z:_ @count:32:5):
    foreign llvm add(z @count:32:59, y @count:32:61, ?tmp#0 @count:32:42)
    =(?x @count:32:38, tmp#0)
- > public (0 calls)
2: -(x:_ @count:33:10, ?y:_ @count:33:17, z:_ @count:33:5):
    foreign llvm sub(z @count:33:59, x @count:33:61, ?tmp#0 @count:33:42)
    =(?y @count:33:38, tmp#0)


-= > public {test} (0 calls)
0: -=(!x:_ @count:36:21, y:_ @count:36:29):
    -(x @count:36:41, y @count:36:45, ?tmp#0 @count:36:41)
    =(?x @count:36:37, tmp#0)


/ > public (0 calls)
0: /(x:_ @count:45:10, y:_ @count:45:16, ?#result:_ @count:45:5):
    foreign llvm udiv(x @count:45:43, y @count:45:45, ?tmp#0 @count:45:25)
    foreign llvm move(tmp#0, ?#result @count:45:5)


/= > public (0 calls)
0: /=(!x:_ @count:48:11, y:_ @count:48:19):
    /(x @count:48:31, y @count:48:35, ?tmp#0 @count:48:31)
    =(?x @count:48:27, tmp#0)


< > public (0 calls)
0: <(x:_ @count:64:10, y:_ @count:64:17, ?#result:bool @count:64:5):
    foreign llvm icmp_ult(x @count:64:51, y @count:64:53, ?tmp#0 @count:64:29)
    foreign llvm move(tmp#0, ?#result @count:64:5)


<= > public (0 calls)
0: <=(x:_ @count:65:10, y:_ @count:65:18, ?#result:bool @count:65:5):
    foreign llvm icmp_ule(x @count:65:52, y @count:65:54, ?tmp#0 @count:65:30)
    foreign llvm move(tmp#0, ?#result @count:65:5)


<=> > public (0 calls)
0: <=>(x:_ @count:70:10, y:_ @count:70:20, ?#result:comparison @count:70:5):
    if {<(x @count:71:10, y @count:71:14)::

        lesser(?tmp#1 @count:71:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @count:71:28, y @count:71:32)::

            equal(?tmp#3 @count:71:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @count:71:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @count:71:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:71:10, ?#result @count:70:5)


= > public (0 calls)
0: =(x:_ @count:60:10, y:_ @count:60:17, ?#result:bool @count:60:5):
    foreign llvm icmp_eq(x @count:60:50, y @count:60:52, ?tmp#0 @count:60:29)
    foreign llvm move(tmp#0, ?#result @count:60:5)


> > public (0 calls)
0: >(x:_ @count:66:10, y:_ @count:66:17, ?#result:bool @count:66:5):
    foreign llvm icmp_ugt(x @count:66:51, y @count:66:53, ?tmp#0 @count:66:29)
    foreign llvm move(tmp#0, ?#result @count:66:5)


>= > public (0 calls)
0: >=(x:_ @count:67:10, y:_ @count:67:18, ?#result:bool @count:67:5):
    foreign llvm icmp_uge(x @count:67:52, y @count:67:54, ?tmp#0 @count:67:30)
    foreign llvm move(tmp#0, ?#result @count:67:5)


decr > public {test} (0 calls)
0: decr(!x:_ @count:84:25):
    -(x @count:84:37, 1:_ @count:84:41, ?tmp#0 @count:84:37)
    =(?x @count:84:33, tmp#0)


incr > public (0 calls)
0: incr(!x:_ @count:81:15):
    +(x @count:81:27, 1:_ @count:81:31, ?tmp#0 @count:81:27)
    =(?x @count:81:23, tmp#0)


max > public (0 calls)
0: max(x:_ @count:75:13, y:_ @count:75:18, ?#result:_ @count:75:5):
    if {>=(x @count:75:31, y @count:75:35)::

        foreign llvm move(x @count:75:39, ?tmp#0)
    else::
        foreign llvm move(y @count:75:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:75:31, ?#result @count:75:5)


min > public (0 calls)
0: min(x:_ @count:74:13, y:_ @count:74:18, ?#result:_ @count:74:5):
    if {<=(x @count:74:31, y @count:74:35)::

        foreign llvm move(x @count:74:39, ?tmp#0)
    else::
        foreign llvm move(y @count:74:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @count:74:31, ?#result @count:74:5)


print > public (0 calls)
0: print(x:_ @count:88:15) use !io:
    foreign c print_count(x @count:88:52, !io @count:88:56)


println > public (0 calls)
0: println(x:_ @count:90:17) use !io:
    !print(x @count:90:39)
    !nl


read > public (0 calls)
0: read(?x:_ @count:92:15) use !io:
    foreign c read_count(?x @count:92:52, !io @count:92:56)


~= > public (0 calls)
0: ~=(x:_ @count:61:10, y:_ @count:61:18, ?#result:bool @count:61:5):
    foreign llvm icmp_ne(x @count:61:51, y @count:61:53, ?tmp#0 @count:61:30)
    foreign llvm move(tmp#0, ?#result @count:61:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.float
  representation  : 64 bit float
  public submods  : 
  public resources: 
  public procs    : wybe.float.*<0>
                    wybe.float.**<0>
                    wybe.float.*=<0>
                    wybe.float.+<0>
                    wybe.float.+<1>
                    wybe.float.+<2>
                    wybe.float.+=<0>
                    wybe.float.-<0>
                    wybe.float.-<1>
                    wybe.float.-<2>
                    wybe.float.-<3>
                    wybe.float.-<4>
                    wybe.float.-=<0>
                    wybe.float./<0>
                    wybe.float./=<0>
                    wybe.float.<<0>
                    wybe.float.<=<0>
                    wybe.float.<=><0>
                    wybe.float.=<0>
                    wybe.float.><0>
                    wybe.float.>=<0>
                    wybe.float.abs<0>
                    wybe.float.ceil<0>
                    wybe.float.cos<0>
                    wybe.float.e<0>
                    wybe.float.exp<0>
                    wybe.float.floor<0>
                    wybe.float.iceil<0>
                    wybe.float.ifloor<0>
                    wybe.float.iround<0>
                    wybe.float.log<0>
                    wybe.float.log10<0>
                    wybe.float.log2<0>
                    wybe.float.max<0>
                    wybe.float.min<0>
                    wybe.float.pi<0>
                    wybe.float.power<0>
                    wybe.float.print<0>
                    wybe.float.println<0>
                    wybe.float.read<0>
                    wybe.float.round<0>
                    wybe.float.sin<0>
                    wybe.float.sqrt<0>
                    wybe.float.square<0>
                    wybe.float.tan<0>
                    wybe.float.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

* > public (0 calls)
0: *(x:_ @float:45:10, y:_ @float:45:16, ?#result:_ @float:45:5):
    foreign llvm fmul(x @float:45:43, y @float:45:45, ?tmp#0 @float:45:25)
    foreign llvm move(tmp#0, ?#result @float:45:5)


** > public (0 calls)
0: **(x:_ @float:112:10, n:_ @float:112:18, ?#result:_ @float:112:5):
    foreign c llvm.pow.f64(x @float:112:52, n @float:112:54, ?tmp#0 @float:112:27)
    foreign llvm move(tmp#0, ?#result @float:112:5)


*= > public (0 calls)
0: *=(!x:_ @float:48:11, y:_ @float:48:19):
    *(x @float:48:31, y @float:48:35, ?tmp#0 @float:48:31)
    =(?x @float:48:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @float:23:10, y:_ @float:23:17, ?#result:_ @float:23:5):
    foreign llvm fadd(x @float:23:45, y @float:23:47, ?tmp#0 @float:23:27)
    foreign llvm move(tmp#0, ?#result @float:23:5)
+ > public (0 calls)
1: +(?x:_ @float:24:11, y:_ @float:24:17, z:_ @float:24:5):
    foreign llvm fsub(z @float:24:61, y @float:24:63, ?tmp#0 @float:24:43)
    =(?x @float:24:39, tmp#0)
+ > public (0 calls)
2: +(x:_ @float:25:10, ?y:_ @float:25:18, z:_ @float:25:5):
    foreign llvm fsub(z @float:25:61, x @float:25:63, ?tmp#0 @float:25:43)
    =(?y @float:25:39, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @float:28:11, y:_ @float:28:19):
    +(x @float:28:31, y @float:28:35, ?tmp#0 @float:28:31)
    =(?x @float:28:27, tmp#0)


- > public (0 calls)
0: -(x:_ @float:32:10, y:_ @float:32:17, ?#result:_ @float:32:5):
    foreign llvm fsub(x @float:32:45, y @float:32:47, ?tmp#0 @float:32:27)
    foreign llvm move(tmp#0, ?#result @float:32:5)
- > public (0 calls)
1: -(?x:_ @float:33:11, y:_ @float:33:17, z:_ @float:33:5):
    foreign llvm fadd(z @float:33:61, y @float:33:63, ?tmp#0 @float:33:43)
    =(?x @float:33:39, tmp#0)
- > public (0 calls)
2: -(x:_ @float:34:10, ?y:_ @float:34:18, z:_ @float:34:5):
    foreign llvm fsub(z @float:34:61, x @float:34:63, ?tmp#0 @float:34:43)
    =(?y @float:34:39, tmp#0)
- > public (0 calls)
3: -(x:_ @float:38:11, ?#result:_ @float:38:5):
    foreign llvm fsub(0.0 @float:38:39, x @float:38:43, ?tmp#0 @float:38:21)
    foreign llvm move(tmp#0, ?#result @float:38:5)
- > public (0 calls)
4: -(?x:_ @float:39:12, y:_ @float:39:5):
    foreign llvm fsub(0.0 @float:39:55, y @float:39:59, ?tmp#0 @float:39:37)
    =(?x @float:39:33, tmp#0)


-= > public (0 calls)
0: -=(!x:_ @float:42:11, y:_ @float:42:19):
    -(x @float:42:31, y @float:42:35, ?tmp#0 @float:42:31)
    =(?x @float:42:27, tmp#0)


/ > public (0 calls)
0: /(x:_ @float:51:10, y:_ @float:51:16, ?#result:_ @float:51:5):
    foreign llvm fdiv(x @float:51:43, y @float:51:45, ?tmp#0 @float:51:25)
    foreign llvm move(tmp#0, ?#result @float:51:5)


/= > public (0 calls)
0: /=(!x:_ @float:54:11, y:_ @float:54:19):
    /(x @float:54:31, y @float:54:35, ?tmp#0 @float:54:31)
    =(?x @float:54:27, tmp#0)


< > public (0 calls)
0: <(x:_ @float:70:10, y:_ @float:70:17, ?#result:bool @float:70:5):
    foreign llvm fcmp_slt(x @float:70:51, y @float:70:53, ?tmp#0 @float:70:29)
    foreign llvm move(tmp#0, ?#result @float:70:5)


<= > public (0 calls)
0: <=(x:_ @float:71:10, y:_ @float:71:18, ?#result:bool @float:71:5):
    foreign llvm fcmp_sle(x @float:71:52, y @float:71:54, ?tmp#0 @float:71:30)
    foreign llvm move(tmp#0, ?#result @float:71:5)


<=> > public (0 calls)
0: <=>(x:_ @float:76:10, y:_ @float:76:20, ?#result:comparison @float:76:5):
    if {<(x @float:77:10, y @float:77:14)::

        lesser(?tmp#1 @float:77:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @float:77:28, y @float:77:32)::

            equal(?tmp#3 @float:77:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @float:77:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @float:77:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @float:77:10, ?#result @float:76:5)


= > public (0 calls)
0: =(x:_ @float:66:10, y:_ @float:66:17, ?#result:bool @float:66:5):
    foreign llvm fcmp_eq(x @float:66:50, y @float:66:52, ?tmp#0 @float:66:29)
    foreign llvm move(tmp#0, ?#result @float:66:5)


> > public (0 calls)
0: >(x:_ @float:72:10, y:_ @float:72:17, ?#result:bool @float:72:5):
    foreign llvm fcmp_sgt(x @float:72:51, y @float:72:53, ?tmp#0 @float:72:29)
    foreign llvm move(tmp#0, ?#result @float:72:5)


>= > public (0 calls)
0: >=(x:_ @float:73:10, y:_ @float:73:18, ?#result:bool @float:73:5):
    foreign llvm fcmp_sge(x @float:73:52, y @float:73:54, ?tmp#0 @float:73:30)
    foreign llvm move(tmp#0, ?#result @float:73:5)


abs > public (0 calls)
0: abs(x:_ @float:60:13, ?#result:_ @float:60:5):
    foreign c llvm.fabs.f64(x @float:60:48, ?tmp#0 @float:60:22)
    foreign llvm move(tmp#0, ?#result @float:60:5)


ceil > public (0 calls)
0: ceil(x:_ @float:87:14, ?#result:_ @float:87:5):
    foreign c llvm.ceil.f64(x @float:87:49, ?tmp#0 @float:87:23)
    foreign llvm move(tmp#0, ?#result @float:87:5)


cos > public (0 calls)
0: cos(x:_ @float:116:13, ?#result:_ @float:116:5):
    foreign c llvm.cos.f64(x @float:116:47, ?tmp#0 @float:116:22)
    foreign llvm move(tmp#0, ?#result @float:116:5)


e > public (0 calls)
0: e(?#result:_ @float:16:5):
    foreign llvm move(2.7182818284590455 @float:16:15, ?#result @float:16:5)


exp > public (0 calls)
0: exp(x:_ @float:120:13, ?#result:_ @float:120:5):
    foreign c llvm.exp.f64(x @float:120:47, ?tmp#0 @float:120:22)
    foreign llvm move(tmp#0, ?#result @float:120:5)


floor > public (0 calls)
0: floor(x:_ @float:90:15, ?#result:_ @float:90:5):
    foreign c llvm.floor.f64(x @float:90:51, ?tmp#0 @float:90:24)
    foreign llvm move(tmp#0, ?#result @float:90:5)


iceil > public (0 calls)
0: iceil(x:_ @float:99:15, ?#result:int @float:99:5):
    ceil(x @float:99:51, ?tmp#1 @float:99:46)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:99:26)
    foreign llvm move(tmp#0, ?#result @float:99:5)


ifloor > public (0 calls)
0: ifloor(x:_ @float:102:16, ?#result:int @float:102:5):
    floor(x @float:102:53, ?tmp#1 @float:102:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:102:27)
    foreign llvm move(tmp#0, ?#result @float:102:5)


iround > public (0 calls)
0: iround(x:_ @float:96:16, ?#result:int @float:96:5):
    round(x @float:96:53, ?tmp#1 @float:96:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:96:27)
    foreign llvm move(tmp#0, ?#result @float:96:5)


log > public (0 calls)
0: log(x:_ @float:123:13, ?#result:_ @float:123:5):
    foreign c llvm.log.f64(x @float:123:47, ?tmp#0 @float:123:22)
    foreign llvm move(tmp#0, ?#result @float:123:5)


log10 > public (0 calls)
0: log10(x:_ @float:126:15, ?#result:_ @float:126:5):
    foreign c llvm.log10.f64(x @float:126:51, ?tmp#0 @float:126:24)
    foreign llvm move(tmp#0, ?#result @float:126:5)


log2 > public (0 calls)
0: log2(x:_ @float:129:14, ?#result:_ @float:129:5):
    foreign c llvm.log2.f64(x @float:129:49, ?tmp#0 @float:129:23)
    foreign llvm move(tmp#0, ?#result @float:129:5)


max > public (0 calls)
0: max(x:_ @float:81:13, y:_ @float:81:18, ?#result:_ @float:81:5):
    foreign c llvm.maxnum.f64(x @float:81:55, y @float:81:57, ?tmp#0 @float:81:27)
    foreign llvm move(tmp#0, ?#result @float:81:5)


min > public (0 calls)
0: min(x:_ @float:80:13, y:_ @float:80:18, ?#result:_ @float:80:5):
    foreign c llvm.minnum.f64(x @float:80:55, y @float:80:57, ?tmp#0 @float:80:27)
    foreign llvm move(tmp#0, ?#result @float:80:5)


pi > public (0 calls)
0: pi(?#result:_ @float:13:5):
    foreign llvm move(3.141592653589793 @float:13:16, ?#result @float:13:5)


power > public (0 calls)
0: power(x:_ @float:111:15, n:_ @float:111:19, ?#result:_ @float:111:5):
    foreign c llvm.pow.f64(x @float:111:53, n @float:111:55, ?tmp#0 @float:111:28)
    foreign llvm move(tmp#0, ?#result @float:111:5)


print > public (0 calls)
0: print(x:_ @float:133:15) use !io:
    foreign c print_float(x @float:133:52, !io @float:133:56)


println > public (0 calls)
0: println(x:_ @float:135:17) use !io:
    !print(x @float:135:39)
    !nl


read > public (0 calls)
0: read(?x:_ @float:137:15) use !io:
    foreign c read_float(?x @float:137:52, !io @float:137:56)


round > public (0 calls)
0: round(x:_ @float:93:15, ?#result:_ @float:93:5):
    foreign c llvm.round.f64(x @float:93:51, ?tmp#0 @float:93:24)
    foreign llvm move(tmp#0, ?#result @float:93:5)


sin > public (0 calls)
0: sin(x:_ @float:115:13, ?#result:_ @float:115:5):
    foreign c llvm.sin.f64(x @float:115:47, ?tmp#0 @float:115:22)
    foreign llvm move(tmp#0, ?#result @float:115:5)


sqrt > public (0 calls)
0: sqrt(x:_ @float:108:14, ?#result:_ @float:108:5):
    foreign c llvm.sqrt.f64(x @float:108:49, ?tmp#0 @float:108:23)
    foreign llvm move(tmp#0, ?#result @float:108:5)


square > public (0 calls)
0: square(x:_ @float:57:16, ?#result:_ @float:57:5):
    foreign llvm fmul(x @float:57:43, x @float:57:45, ?tmp#0 @float:57:25)
    foreign llvm move(tmp#0, ?#result @float:57:5)


tan > public (0 calls)
0: tan(x:_ @float:117:13, ?#result:_ @float:117:5):
    foreign c llvm.sin.f64(x @float:117:47, ?tmp#1 @float:117:22)
    foreign c llvm.cos.f64(x @float:117:77, ?tmp#2 @float:117:52)
    /(tmp#1, tmp#2, ?tmp#0 @float:117:22)
    foreign llvm move(tmp#0, ?#result @float:117:5)


~= > public (0 calls)
0: ~=(x:_ @float:67:10, y:_ @float:67:18, ?#result:bool @float:67:5):
    foreign llvm fcmp_ne(x @float:67:51, y @float:67:53, ?tmp#0 @float:67:30)
    foreign llvm move(tmp#0, ?#result @float:67:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.int
  representation  : 64 bit signed
  public submods  : 
  public resources: 
  public procs    : wybe.int.%<0>
                    wybe.int.%=<0>
                    wybe.int.*<0>
                    wybe.int.*=<0>
                    wybe.int.+<0>
                    wybe.int.+<1>
                    wybe.int.+<2>
                    wybe.int.+=<0>
                    wybe.int.-<0>
                    wybe.int.-<1>
                    wybe.int.-<2>
                    wybe.int.-<3>
                    wybe.int.-<4>
                    wybe.int.-=<0>
                    wybe.int./<0>
                    wybe.int./=<0>
                    wybe.int.<<0>
                    wybe.int.<<<0>
                    wybe.int.<<=<0>
                    wybe.int.<=<0>
                    wybe.int.<=><0>
                    wybe.int.=<0>
                    wybe.int.><0>
                    wybe.int.>=<0>
                    wybe.int.>><0>
                    wybe.int.>>=<0>
                    wybe.int.decr<0>
                    wybe.int.incr<0>
                    wybe.int.logical_bitshift<0>
                    wybe.int.logical_bitshift<1>
                    wybe.int.max<0>
                    wybe.int.min<0>
                    wybe.int.power<0>
                    wybe.int.print<0>
                    wybe.int.println<0>
                    wybe.int.read<0>
                    wybe.int.signum<0>
                    wybe.int.sqrt<0>
                    wybe.int.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.int.%<0>
%(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:50:25


%= > public {inline} (0 calls)
0: wybe.int.%=<0>
%=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:50:25


* > public {inline} (1 calls)
0: wybe.int.*<0>
*(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:38:25


*= > public {inline} (0 calls)
0: wybe.int.*=<0>
*=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:38:25


+ > public {inline} (2 calls)
0: wybe.int.+<0>
+(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:16:27
+ > public {inline} (0 calls)
1: wybe.int.+<1>
+(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:17:43
+ > public {inline} (0 calls)
2: wybe.int.+<2>
+(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:18:43


+= > public {inline} (0 calls)
0: wybe.int.+=<0>
+=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:16:27


- > public {inline} (2 calls)
0: wybe.int.-<0>
-(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:25:27
- > public {inline} (0 calls)
1: wybe.int.-<1>
-(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.int, ~z##0:wybe.int, ?x##0:wybe.int) @int:26:43
- > public {inline} (0 calls)
2: wybe.int.-<2>
-(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:27:43
- > public {inline} (0 calls)
3: wybe.int.-<3>
-(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~x##0:wybe.int, ?#result##0:wybe.int) @int:31:21
- > public {inline} (0 calls)
4: wybe.int.-<4>
-(?x##0:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:32:37


-= > public {inline} (0 calls)
0: wybe.int.-=<0>
-=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:25:27


/ > public {inline} (1 calls)
0: wybe.int./<0>
/(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:44:25


/= > public {inline} (0 calls)
0: wybe.int./=<0>
/=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:44:25


< > public {inline} (4 calls)
0: wybe.int.<<0>
<(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:87:29


<< > public {inline} (1 calls)
0: wybe.int.<<<0>
<<(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:56:27


<<= > public {inline} (0 calls)
0: wybe.int.<<=<0>
<<=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:56:27


<= > public {inline} (3 calls)
0: wybe.int.<=<0>
<=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:88:30


<=> > public (0 calls)
0: wybe.int.<=><0>
<=>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(x##0:wybe.int, y##0:wybe.int, ?tmp#6##0:wybe.bool) @int:87:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?tmp#5##0:wybe.bool) @int:83:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5



= > public {inline} (2 calls)
0: wybe.int.=<0>
=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:83:29


> > public {inline} (0 calls)
0: wybe.int.><0>
>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sgt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:89:29


>= > public {inline} (3 calls)
0: wybe.int.>=<0>
>=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:90:30


>> > public {inline} (1 calls)
0: wybe.int.>><0>
>>(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:65:27


>>= > public {inline} (0 calls)
0: wybe.int.>>=<0>
>>=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:65:27


decr > public {inline} (0 calls)
0: wybe.int.decr<0>
decr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:25:27


incr > public {inline} (0 calls)
0: wybe.int.incr<0>
incr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:16:27


logical_bitshift > public {inline} (1 calls)
0: wybe.int.logical_bitshift<0>
logical_bitshift(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:74:40
logical_bitshift > public {inline} (0 calls)
1: wybe.int.logical_bitshift<1>
logical_bitshift(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:74:40


max > public (0 calls)
0: wybe.int.max<0>
max(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:90:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:98:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:98:5



min > public (0 calls)
0: wybe.int.min<0>
min(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:88:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:97:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:97:5



power > public {inline} (0 calls)
0: wybe.int.power<0>
power(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c ipow(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:107:29


print > public {inline} (1 calls)
0: wybe.int.print<0>
print(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:119:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:119:30


println > public {inline} (0 calls)
0: wybe.int.println<0>
println(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @int:119:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.int.read<0>
read(?x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:123:30
    foreign c read_int(?x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:123:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:123:30


signum > public {inline} (0 calls)
0: wybe.int.signum<0>
signum(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c signum(~x##0:wybe.int, ?#result##0:wybe.int) @int:114:25


sqrt > public {inline} (0 calls)
0: wybe.int.sqrt<0>
sqrt(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c isqrt(~x##0:wybe.int, ?#result##0:wybe.int) @int:104:23


~= > public {inline} (0 calls)
0: wybe.int.~=<0>
~=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:84:30

LLVM code       : None

--------------------------------------------------
 Module wybe.io
  representation  : (not a type)
  public submods  : phantom -> wybe.phantom
  public resources: io: wybe.io.io
  public procs    : wybe.io.<0>
                    wybe.io.eof<0>
                    wybe.io.nl<0>
  imports         : use wybe.char
                    public use wybe.phantom
  resources       : io: fromList [(wybe.io.io,wybe.phantom = 0:phantom @io:13:27 @io:13:5)]
  procs           : 

module top-level code > public {inline,semipure} (0 calls)
0: wybe.io.<0>
()<{}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm store(0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:13:5


eof > public {inline} (0 calls)
0: wybe.io.eof<0>
eof(?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(-1:wybe.int, ?#result##0:wybe.char) @io:20:29


nl > public {inline} (0 calls)
0: wybe.io.nl<0>
nl()<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @io:17:31
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31

LLVM code       : None

--------------------------------------------------
 Module wybe.list(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.list.,,<0>
                    wybe.list.[]<0>
                    wybe.list.all<0>
                    wybe.list.any<0>
                    wybe.list.empty<0>
                    wybe.list.filter<0>
                    wybe.list.foldl<0>
                    wybe.list.foldr<0>
                    wybe.list.length<0>
                    wybe.list.list<0>
                    wybe.list.map<0>
                    wybe.list.map<1>
                    wybe.list.map<2>
                    wybe.list.print<0>
                    wybe.list.println<0>
                    wybe.list.reverse<0>
  imports         : use wybe.array
                    use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
                    use wybe.machine_word
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_(T) @list:20:10, y:_(T) @list:20:20, ?#result:_(T) @list:20:5):
    if {[|](?h @list:21:16, ?t @list:21:21, x @list:21:10)::

        ,,(t @list:21:32, y @list:21:37, ?tmp#2 @list:21:32)
        [|](h @list:21:28, tmp#2, ?tmp#1 @list:21:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(y @list:21:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:21:10, ?#result @list:20:5)


[] > public {test} (0 calls)
0: [](xs:_(T) @list:31:21, idx:int @list:31:30, ?#result:T @list:31:5):
    >=(idx @list:32:5, 0 @list:32:13)
    index1(xs @list:33:17, idx @list:33:21, ?tmp#0 @list:33:10)
    =(?x @list:33:6, tmp#0)
    foreign llvm move(x @list:31:43, ?#result @list:31:5)


all > public {test} (0 calls)
0: all(p:{test}(T) @list:61:20, xs:_(T) @list:61:33):
    foreign llvm move(xs @list:62:15, ?tmp#0)
    do {
        if {[|](?x @list:62:10, ?tmp#0, tmp#0)::

            p(x @list:63:11)
        else::
            break

        }
    }


any > public {test} (0 calls)
0: any(p:{test}(T) @list:69:20, xs:_(T) @list:69:33):
    [|](?x @list:70:7, ?xs @list:70:12, xs @list:70:18)
    (   p(x @list:71:8)
    | any(p @list:71:17, xs @list:71:20))


empty > public {test} (0 calls)
0: empty(xs:_(T) @list:15:22):
    if {[|](?tmp#0 @list:16:11, ?tmp#1 @list:16:15, xs @list:16:20)::

        fail
    else::
        pass

    }


filter > public (0 calls)
0: filter(p:{test}(T) @list:95:16, !xs:_(T) @list:95:30):
    [](?tmp#0 @list:96:12)
    =(?out @list:96:6, tmp#0)
    foreign llvm move(xs @list:97:15, ?tmp#1)
    do {
        if {[|](?x @list:97:10, ?tmp#1, tmp#1)::

            if {p(x @list:98:16)::

                [|](x @list:98:30, out @list:98:34, ?tmp#2 @list:98:29)
                =(?out @list:98:23, tmp#2)
            else::
                pass

            }
        else::
            break

        }
    }
    reverse(out @list:100:19, ?tmp#3 @list:100:11)
    =(?as @list:100:6, tmp#3)


foldl > public (0 calls)
0: foldl(f:(A, !B) @list:77:15, as:_(A) @list:77:26, !b:B @list:77:36):
    foreign llvm move(as @list:78:15, ?tmp#0)
    do {
        if {[|](?a @list:78:10, ?tmp#0, tmp#0)::

            f(a @list:79:11, !b @list:79:15)
        else::
            break

        }
    }


foldr > public (0 calls)
0: foldr(f:(A, !B) @list:86:15, as:_(A) @list:86:26, !b:B @list:86:36):
    if {[|](?a @list:87:12, ?as @list:87:17, as @list:87:23)::

        foldr(f @list:88:15, as @list:88:18, !b @list:88:23)
        f(a @list:89:11, !b @list:89:15)
    else::
        pass

    }


index1 > {test} (0 calls)
0: index1(xs:_(T) @list:148:19, idx:int @list:148:28, ?#result:T @list:148:1):
    [|](?x @list:149:7, ?xs @list:149:12, xs @list:149:18)
    (   =(idx @list:150:6, 0 @list:150:12)
    | (   -(idx @list:150:27, 1 @list:150:33, ?tmp#0 @list:150:27)
        & index1(xs @list:150:23, tmp#0, ?x @list:150:37)))
    foreign llvm move(x @list:148:41, ?#result @list:148:1)


length > public (0 calls)
0: length(x:_(T) @list:24:16, ?#result:int @list:24:5):
    length1(x @list:24:38, 0 @list:24:41, ?tmp#0 @list:24:30)
    foreign llvm move(tmp#0, ?#result @list:24:5)


length1 > (0 calls)
0: length1(x:_(T) @list:140:13, acc:int @list:140:21, ?#result:int @list:140:1):
    if {[|](?h @list:141:16, ?t @list:141:21, x @list:141:10)::

        +(acc @list:141:38, 1 @list:141:44, ?tmp#2 @list:141:38)
        length1(t @list:141:35, tmp#2, ?tmp#1 @list:141:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(acc @list:141:57, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:141:10, ?#result @list:140:1)


list > public (0 calls)
0: list(ar:array(T) @list:128:14, ?#result:_(T) @list:128:5):
    [](?tmp#0 @list:129:11)
    =(?ls @list:129:6, tmp#0)
    foreign llvm move(ar @list:130:15, ?tmp#1)
    do {
        if {[|](?x @list:130:10, ?tmp#1, tmp#1)::

            [|](x @list:131:16, ls @list:131:20, ?tmp#2 @list:131:15)
            =(?ls @list:131:10, tmp#2)
        else::
            break

        }
    }
    reverse(ls @list:133:13, ?ls @list:133:18)
    foreign llvm move(ls @list:128:34, ?#result @list:128:5)


map > public (0 calls)
0: map(f:{resource}(T) @list:41:13, xs:_(T) @list:41:30):
    foreign llvm move(xs @list:42:15, ?tmp#0)
    do {
        if {[|](?x @list:42:10, ?tmp#0, tmp#0)::

            !f(x @list:43:12)
        else::
            break

        }
    }
map > public (0 calls)
1: map(f:(A, ?B) @list:49:13, as:_(A) @list:49:24, ?#result:_(B) @list:49:5):
    if {[|](?a @list:50:12, ?as @list:50:17, as @list:50:23)::

        f(a @list:50:33, ?tmp#2 @list:50:31)
        map(f @list:50:42, as @list:50:45, ?tmp#3 @list:50:38)
        [|](tmp#2, tmp#3, ?tmp#1 @list:50:29)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:50:61)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:50:10, ?#result @list:49:5)
map > public (0 calls)
2: map(f:(A, B, ?C) @list:55:13, as:_(A) @list:55:27, bs:_(B) @list:55:36, ?#result:_(C) @list:55:5):
    if {(   [|](?a @list:56:12, ?as @list:56:17, as @list:56:23)
        & [|](?b @list:56:30, ?bs @list:56:35, bs @list:56:41))::

        f(a @list:56:51, b @list:56:54, ?tmp#2 @list:56:49)
        map(f @list:56:63, as @list:56:66, bs @list:56:70, ?tmp#3 @list:56:59)
        [|](tmp#2, tmp#3, ?tmp#1 @list:56:47)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:57:47)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:56:10, ?#result @list:55:5)


print > public (0 calls)
0: print(printer:{resource}(T) @list:108:15, xs:_(T) @list:108:38) use !io:
    !print('[' @list:109:12)
    if {[|](?x @list:110:12, ?xs @list:110:17, xs @list:110:23)::

        !printer(x @list:111:18)
        !print1(printer @list:112:17, xs @list:112:26)
    else::
        pass

    }
    !print(']' @list:114:12)


print1 > (0 calls)
0: print1(printer:{resource}(T) @list:154:12, xs:_(T) @list:154:35) use !io:
    if {[|](?x @list:155:12, ?xs @list:155:17, xs @list:155:23)::

        !print(',' @list:156:16)
        !printer(x @list:157:18)
        !print1(printer @list:158:17, xs @list:158:26)
    else::
        pass

    }


println > public (0 calls)
0: println(printer:{resource}(T) @list:119:17, xs:_(T) @list:119:40) use !io:
    !print(printer @list:120:12, xs @list:120:21)
    !nl


reverse > public (0 calls)
0: reverse(x:_(T) @list:27:17, ?#result:_(T) @list:27:5):
    [](?tmp#1 @list:27:44)
    reverse1(x @list:27:41, tmp#1, ?tmp#0 @list:27:32)
    foreign llvm move(tmp#0, ?#result @list:27:5)


reverse1 > (0 calls)
0: reverse1(x:_(T) @list:144:14, tail:_(T) @list:144:22, ?#result:_(T) @list:144:1):
    if {[|](?h @list:145:16, ?t @list:145:21, x @list:145:10)::

        [|](h @list:145:40, tail @list:145:44, ?tmp#2 @list:145:39)
        reverse1(t @list:145:36, tmp#2, ?tmp#1 @list:145:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(tail @list:145:61, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:145:10, ?#result @list:144:1)

LLVM code       : None

--------------------------------------------------
 Module wybe.machine_word
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.machine_word.word_size_bits<0>
                    wybe.machine_word.word_size_bytes<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

word_size_bits > public (0 calls)
0: word_size_bits(?#result:int @machine_word:12:5):
    word_size_bytes(?tmp#1 @machine_word:12:34)
    *(8 @machine_word:12:30, tmp#1, ?tmp#0 @machine_word:12:30)
    foreign llvm move(tmp#0, ?#result @machine_word:12:5)


word_size_bytes > public (0 calls)
0: word_size_bytes(?#result:int @machine_word:10:5):
    foreign llvm move(8 @machine_word:10:31, ?#result @machine_word:10:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.memory_management
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.memory_management.malloc_count<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

malloc_count > public {semipure} (0 calls)
0: malloc_count(?x:int @memory_management:11:34):
    foreign c {impure} malloc_count(?x @memory_management:12:38)

LLVM code       : None

--------------------------------------------------
 Module wybe.phantom
 modifiers       : {unique} 
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : 
  imports         : 
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.predicate
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.predicate.const<0>
                    wybe.predicate.id<0>
  imports         : 
  resources       : 
  procs           : 

const > public {inline} (0 calls)
0: wybe.predicate.const<0>
const(a##0:A <{}; {}; {0}>, [b##0:B <{}; {}; {1}>], ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:8:5


id > public {inline} (0 calls)
0: wybe.predicate.id<0>
id(a##0:A <{}; {}; {0}>, ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:6:5

LLVM code       : None

--------------------------------------------------
 Module wybe.range
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.range...<0>
                    wybe.range.[]<0>
                    wybe.range.[|]<0>
                    wybe.range.irange<0>
                    wybe.range.size<0>
                    wybe.range.xrange<0>
  imports         : use wybe.bool
                    use wybe.int
  resources       : 
  procs           : 

.. > public (0 calls)
0: ..(start:int @range:38:10, end:int @range:38:23, ?#result:_ @range:38:5):
    if {<=(start @range:39:27, end @range:39:37)::

        foreign llvm move(1 @range:39:44, ?tmp#1)
    else::
        foreign llvm move(-1 @range:39:56, ?tmp#1)

    }
    construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)
    foreign llvm move(tmp#0, ?#result @range:38:5)


[] > public {test} (0 calls)
0: [](r:_ @range:20:19, idx:int @range:20:24, ?value:int @range:20:34):
    <=(0 @range:21:6, idx @range:21:12)
    range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)
    *(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)
    +(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)
    =(?value @range:23:6, tmp#0)
    if {<=(0 @range:24:10, stride @range:24:16)::

        <(value @range:24:27, end @range:24:35)
    else::
        <(end @range:24:51, value @range:24:57)

    }


[|] > public {test} (0 calls)
0: [|](?value:int @range:12:23, ?rest:_ @range:12:35, current:_ @range:12:43):
    range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)
    ~=(value @range:14:6, end @range:14:16)
    +(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)
    range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)
    =(?rest @range:15:6, tmp#0)


construct > (0 calls)
0: construct(start:int @range:49:15, stride:int @range:49:26, end:int @range:49:38, ?#result:_ @range:49:1):
    -(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)
    %(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)
    =(?diff @range:50:6, tmp#0)
    if {<=(0 @range:51:19, stride @range:51:25)::

        if {=(diff @range:52:26, 0 @range:52:33)::

            max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
            -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
            max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
            foreign llvm move(tmp#5, ?tmp#3)

        }
        foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
    else::
        if {=(diff @range:55:26, 0 @range:55:33)::

            min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
            foreign llvm move(tmp#9, ?tmp#8)
        else::
            +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
            min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
            foreign llvm move(tmp#10, ?tmp#8)

        }
        foreign llvm move(tmp#8 @range:55:26, ?tmp#2)

    }
    =(?final @range:51:6, tmp#2 @range:51:19)
    range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)
    =(?r @range:58:6, tmp#12)
    foreign llvm move(r @range:49:51, ?#result @range:49:1)


irange > public (0 calls)
0: irange(start:int @range:32:16, stride:int @range:32:27, end:int @range:32:39, ?#result:_ @range:32:5):
    if {<(stride @range:33:41, 0 @range:33:50)::

        foreign llvm move(-1 @range:33:55, ?tmp#2)
    else::
        foreign llvm move(1 @range:33:68, ?tmp#2)

    }
    +(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)
    construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)
    foreign llvm move(tmp#0, ?#result @range:32:5)


size > public (0 calls)
0: size(r:_ @range:42:14, ?#result:int @range:42:5):
    range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)
    if {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
        & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
        & signum(tmp#3, ?tmp#2 @range:44:29)
        & ~=(tmp#1, tmp#2))::

        foreign llvm move(0 @range:44:52, ?tmp#0)
    else::
        if {<=(0 @range:45:10, stride @range:45:16)::

            -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
            -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
            /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
            +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
            foreign llvm move(tmp#5, ?tmp#4)
        else::
            -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
            -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
            -(stride @range:46:39, ?tmp#13 @range:46:38)
            /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
            +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
            foreign llvm move(tmp#9, ?tmp#4)

        }
        foreign llvm move(tmp#4 @range:45:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)


xrange > public (0 calls)
0: xrange(start:int @range:28:16, stride:int @range:28:27, end:int @range:28:39, ?#result:_ @range:28:5):
    construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)
    foreign llvm move(tmp#0, ?#result @range:28:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.string
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.string.,,<0>
                    wybe.string.<<0>
                    wybe.string.<=<0>
                    wybe.string.<=><0>
                    wybe.string.=<0>
                    wybe.string.><0>
                    wybe.string.>=<0>
                    wybe.string.[]<0>
                    wybe.string.[]<1>
                    wybe.string.[|]<0>
                    wybe.string.c_string<0>
                    wybe.string.length<0>
                    wybe.string.print<0>
                    wybe.string.println<0>
                    wybe.string.read<0>
                    wybe.string.string<0>
                    wybe.string.string<1>
                    wybe.string.~=<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.char
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
                    use wybe.range
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_ @string:64:10, y:_ @string:64:17, ?#result:_ @string:64:5):
    if {(   empty(?tmp#1 @string:65:14)
        & =(x @string:65:10, tmp#1))::

        foreign llvm move(y @string:65:23, ?tmp#0)
    else::
        if {(   empty(?tmp#3 @string:66:14)
            & =(y @string:66:10, tmp#3))::

            foreign llvm move(x @string:66:23, ?tmp#2)
        else::
            concat(x @string:67:25, y @string:67:28, ?tmp#4 @string:67:18)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:66:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:65:10, ?#result @string:64:5)


< > public (0 calls)
0: <(x:_ @string:119:10, y:_ @string:119:17, ?#result:bool @string:119:5):
    <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
    equal(?tmp#2 @string:119:44)
    <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
    foreign llvm move(tmp#0, ?#result @string:119:5)


<= > public (0 calls)
0: <=(x:_ @string:120:10, y:_ @string:120:18, ?#result:bool @string:120:5):
    <=>(x @string:120:31, y @string:120:39, ?tmp#1 @string:120:31)
    equal(?tmp#2 @string:120:46)
    <=(tmp#1, tmp#2, ?tmp#0 @string:120:30)
    foreign llvm move(tmp#0, ?#result @string:120:5)


<=> > public (0 calls)
0: <=>(x:_ @string:125:10, y:_ @string:125:20, ?#result:comparison @string:125:5):
    equal(?tmp#0 @string:126:10)
    =(?c @string:126:6, tmp#0)
    foreign llvm move(x @string:127:16, ?tmp#1)
    foreign llvm move(y @string:127:26, ?tmp#2)
    do {
        if {[|](?cx @string:127:10, ?tmp#1, tmp#1)::

            if {[|](?cy @string:127:20, ?tmp#2, tmp#2)::

                if {<(cx @string:128:14, cy @string:128:19)::

                    lesser(?tmp#3 @string:128:30)
                    =(?c @string:128:26, tmp#3)
                    break
                else::
                    if {>(cx @string:129:14, cy @string:129:19)::

                        greater(?tmp#4 @string:129:30)
                        =(?c @string:129:26, tmp#4)
                        break
                    else::
                        pass

                    }

                }
            else::
                break

            }
        else::
            break

        }
    }
    if {(   equal(?tmp#5 @string:132:14)
        & =(c @string:132:10, tmp#5))::

        length(x @string:133:22, ?tmp#6 @string:133:15)
        =(?lx @string:133:10, tmp#6)
        length(y @string:134:22, ?tmp#7 @string:134:15)
        =(?ly @string:134:10, tmp#7)
        if {<(lx @string:135:14, ly @string:135:19)::

            lesser(?tmp#8 @string:135:30)
            =(?c @string:135:26, tmp#8)
        else::
            if {>(lx @string:135:39, ly @string:135:44)::

                greater(?tmp#9 @string:135:55)
                =(?c @string:135:51, tmp#9)
            else::
                pass

            }

        }
    else::
        pass

    }
    foreign llvm move(c @string:125:38, ?#result @string:125:5)


= > public (0 calls)
0: =(x:_ @string:115:10, y:_ @string:115:17, ?#result:bool @string:115:5):
    <=>(x @string:115:30, y @string:115:38, ?tmp#1 @string:115:30)
    equal(?tmp#2 @string:115:44)
    =(tmp#1, tmp#2, ?tmp#0 @string:115:29)
    foreign llvm move(tmp#0, ?#result @string:115:5)


> > public (0 calls)
0: >(x:_ @string:121:10, y:_ @string:121:17, ?#result:bool @string:121:5):
    <=>(x @string:121:30, y @string:121:38, ?tmp#1 @string:121:30)
    equal(?tmp#2 @string:121:44)
    >(tmp#1, tmp#2, ?tmp#0 @string:121:29)
    foreign llvm move(tmp#0, ?#result @string:121:5)


>= > public (0 calls)
0: >=(x:_ @string:122:10, y:_ @string:122:18, ?#result:bool @string:122:5):
    <=>(x @string:122:31, y @string:122:39, ?tmp#1 @string:122:31)
    equal(?tmp#2 @string:122:46)
    >=(tmp#1, tmp#2, ?tmp#0 @string:122:30)
    foreign llvm move(tmp#0, ?#result @string:122:5)


[] > public {test} (0 calls)
0: [](s:_ @string:91:19, idx:int @string:91:24, ?c:char @string:91:34):
    if {buffer(?len @string:93:17, ?str @string:93:23, s @string:92:10)::

        <=(0 @string:94:14, idx @string:94:20)
        <(idx @string:95:14, len @string:95:20)
        unsafe_c_string_index(str @string:96:35, idx @string:96:40, ?c @string:96:46)
    else::
        if {concat(?left @string:97:17, ?right @string:97:24, s @string:92:10)::

            length(left @string:98:32, ?tmp#0 @string:98:25)
            =(?left_len @string:98:14, tmp#0)
            if {<(idx @string:99:18, left_len @string:99:24)::

                [](left @string:99:41, idx @string:99:46, ?tmp#1 @string:99:41)
                =(?c @string:99:37, tmp#1)
            else::
                -(idx @string:100:37, left_len @string:100:43, ?tmp#3 @string:100:37)
                [](right @string:100:31, tmp#3, ?tmp#2 @string:100:31)
                =(?c @string:100:27, tmp#2)

            }
        else::
            if {slice(?base @string:102:16, ?range @string:102:23, s @string:92:10)::

                [](range @string:102:43, idx @string:102:49, ?tmp#5 @string:102:43)
                [](base @string:102:38, tmp#5, ?tmp#4 @string:102:38)
                =(?c @string:102:34, tmp#4)
            else::
                if {singleton(?c @string:103:20, s @string:92:10)::

                    =(idx @string:103:27, 0 @string:103:33)
                else::
                    fail

                }

            }

        }

    }
[] > public (0 calls)
1: [](s:_ @string:109:12, r:range @string:109:17, ?#result:_ @string:109:5):
    slice(s @string:109:36, r @string:109:39, ?tmp#0 @string:109:30)
    foreign llvm move(tmp#0, ?#result @string:109:5)


[|] > public {test} (0 calls)
0: [|](?head:char @string:71:23, ?tail:_ @string:71:35, s:_ @string:71:43):
    if {buffer(?len @string:73:17, ?str @string:73:23, s @string:72:10)::

        [|](?head @string:74:15, ?str @string:74:23, str @string:74:30)
        if {=(len @string:75:26, 1 @string:75:32)::

            empty(?tmp#1 @string:75:37)
            foreign llvm move(tmp#1, ?tmp#0)
        else::
            -(len @string:75:60, 1 @string:75:66, ?tmp#3 @string:75:60)
            buffer(tmp#3, str @string:75:69, ?tmp#2 @string:75:53)
            foreign llvm move(tmp#2, ?tmp#0)

        }
        =(?tail @string:75:14, tmp#0 @string:75:26)
    else::
        if {concat(?left @string:76:17, ?right @string:76:24, s @string:72:10)::

            if {[|](?head @string:77:20, ?t @string:77:28, left @string:77:33)::

                concat(t @string:77:56, right @string:77:59, ?tmp#4 @string:77:49)
                =(?tail @string:77:42, tmp#4)
            else::
                [|](?head @string:78:28, ?tail @string:78:36, right @string:78:44)

            }
        else::
            if {slice(?base @string:80:16, ?range @string:80:23, s @string:72:10)::

                do {
                    [|](?idx @string:82:19, ?range @string:82:26, range @string:82:35)
                    if {(   [](base @string:83:30, idx @string:83:35, ?tmp#5 @string:83:30)
                        & =(?head @string:83:23, tmp#5))::

                        slice(base @string:83:57, range @string:83:63, ?tmp#6 @string:83:51)
                        =(?tail @string:83:44, tmp#6)
                        break
                    else::
                        pass

                    }
                }
            else::
                if {singleton(?head @string:85:20, s @string:72:10)::

                    empty(?tmp#7 @string:85:37)
                    =(?tail @string:85:30, tmp#7)
                else::
                    fail

                }

            }

        }

    }


c_string > public (0 calls)
0: c_string(s:_ @string:40:18, ?#result:c_string @string:40:5):
    if {buffer(?tmp#0 @string:41:21, ?str @string:41:25, s @string:41:10)::

        pass
    else::
        length(s @string:43:27, ?tmp#2 @string:43:20)
        +(tmp#2, 1 @string:43:32, ?tmp#1 @string:43:20)
        =(?len @string:43:14, tmp#1)
        foreign lpvm alloc(len @string:44:32, ?str @string:44:38)
        true(?tmp#3 @string:45:49)
        foreign lpvm mutate(str @string:45:33, ?str @string:45:39, len @string:45:44, tmp#3, len @string:45:55, 0 @string:45:60, '\NUL' @string:45:63)
        =(?offset @string:46:14, 0 @string:46:23)
        pack(s @string:47:18, !str @string:47:22, len @string:47:27, !offset @string:47:33)

    }
    foreign llvm move(str @string:40:34, ?#result @string:40:5)


fixed_range_size > (0 calls)
0: fixed_range_size(hi:int @string:184:22, r:range @string:184:30, ?sz:int @string:184:40):
    range(?start @string:185:16, ?stride @string:185:24, ?end @string:185:33, r @string:185:5)
    if {<=(0 @string:186:10, stride @string:186:16)::

        -(start @string:187:39, ?tmp#4 @string:187:38)
        /(tmp#4, stride @string:187:47, ?tmp#3 @string:187:38)
        *(tmp#3, stride @string:187:56, ?tmp#2 @string:187:38)
        +(start @string:187:30, tmp#2, ?tmp#1 @string:187:30)
        max(start @string:187:23, tmp#1, ?tmp#0 @string:187:19)
        =(?lo @string:187:14, tmp#0)
        min(hi @string:188:23, end @string:188:27, ?tmp#5 @string:188:19)
        =(?hi @string:188:14, tmp#5)
    else::
        max(-1 @string:190:23, end @string:190:27, ?tmp#6 @string:190:19)
        =(?lo @string:190:14, tmp#6)
        +(hi @string:191:30, stride @string:191:35, ?tmp#10 @string:191:30)
        -(start @string:191:45, hi @string:191:53, ?tmp#13 @string:191:45)
        -(tmp#13, 1 @string:191:58, ?tmp#12 @string:191:45)
        -(stride @string:191:64, ?tmp#14 @string:191:63)
        %(tmp#12, tmp#14, ?tmp#11 @string:191:44)
        +(tmp#10, tmp#11, ?tmp#9 @string:191:30)
        +(tmp#9, 1 @string:191:73, ?tmp#8 @string:191:30)
        min(start @string:191:23, tmp#8, ?tmp#7 @string:191:19)
        =(?hi @string:191:14, tmp#7)
        -(stride @string:192:24, ?tmp#15 @string:192:23)
        =(?stride @string:192:14, tmp#15)

    }
    if {<=(hi @string:194:16, lo @string:194:23)::

        foreign llvm move(0 @string:194:29, ?tmp#16)
    else::
        -(hi @string:194:42, lo @string:194:47, ?tmp#20 @string:194:42)
        -(tmp#20, 1 @string:194:52, ?tmp#19 @string:194:42)
        /(tmp#19, stride @string:194:57, ?tmp#18 @string:194:41)
        +(tmp#18, 1 @string:194:66, ?tmp#17 @string:194:41)
        foreign llvm move(tmp#17, ?tmp#16)

    }
    =(?sz @string:194:6, tmp#16 @string:194:16)


length > public (0 calls)
0: length(s:_ @string:52:16, ?#result:int @string:52:5):
    if {buffer(?len @string:53:22, ?tmp#1 @string:53:27, s @string:53:10)::

        foreign llvm move(len @string:53:33, ?tmp#0)
    else::
        if {concat(?left @string:54:22, ?right @string:54:29, s @string:54:10)::

            length(left @string:54:46, ?tmp#4 @string:54:39)
            length(right @string:54:61, ?tmp#5 @string:54:54)
            +(tmp#4, tmp#5, ?tmp#3 @string:54:39)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            if {slice(?base @string:55:21, ?range @string:55:28, s @string:55:10)::

                length(base @string:55:62, ?tmp#8 @string:55:55)
                fixed_range_size(tmp#8, range @string:55:69, ?tmp#7 @string:55:38)
                foreign llvm move(tmp#7, ?tmp#6)
            else::
                if {singleton(?tmp#10 @string:56:24, s @string:56:10)::

                    foreign llvm move(1 @string:56:30, ?tmp#9)
                else::
                    foreign llvm move(0 @string:57:18, ?tmp#9)

                }
                foreign llvm move(tmp#9 @string:56:10, ?tmp#6)

            }
            foreign llvm move(tmp#6 @string:55:10, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:54:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:53:10, ?#result @string:52:5)


pack > (0 calls)
0: pack(s:_ @string:160:10, !raw:c_string @string:160:16, size:int @string:160:30, !offset:int @string:160:41):
    if {buffer(?tmp#0 @string:162:16, ?str @string:162:20, s @string:161:10)::

        foreign llvm move(str @string:163:23, ?tmp#1)
        do {
            if {[|](?c @string:163:18, ?tmp#1, tmp#1)::

                true(?tmp#2 @string:164:56)
                foreign lpvm mutate(raw @string:164:37, ?raw @string:164:43, offset @string:164:48, tmp#2, size @string:164:62, 0 @string:164:68, c @string:164:71)
                incr(!offset @string:165:23)
            else::
                break

            }
        }
    else::
        if {concat(?left @string:167:17, ?right @string:167:24, s @string:161:10)::

            pack(left @string:168:18, !raw @string:168:25, size @string:168:30, !offset @string:168:37)
            pack(right @string:169:18, !raw @string:169:26, size @string:169:31, !offset @string:169:38)
            incr(!offset @string:170:19)
        else::
            if {slice(?tmp#3 @string:171:15, ?tmp#4 @string:171:18, s @string:161:10)::

                foreign llvm move(s @string:172:23, ?tmp#5)
                do {
                    if {[|](?c @string:172:18, ?tmp#5, tmp#5)::

                        true(?tmp#6 @string:173:56)
                        foreign lpvm mutate(raw @string:173:37, ?raw @string:173:43, offset @string:173:48, tmp#6, size @string:173:62, 0 @string:173:68, c @string:173:71)
                        incr(!offset @string:174:23)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:176:20, s @string:161:10)::

                    true(?tmp#7 @string:177:52)
                    foreign lpvm mutate(raw @string:177:33, ?raw @string:177:39, offset @string:177:44, tmp#7, size @string:177:58, 0 @string:177:64, c @string:177:67)
                    incr(!offset @string:178:19)
                else::
                    fail

                }

            }

        }

    }


print > public (0 calls)
0: print(x:_ @string:142:15) use !io:
    if {buffer(?tmp#0 @string:144:16, ?str @string:144:20, x @string:143:10)::

        !print(str @string:144:35)
    else::
        if {concat(?left @string:145:17, ?right @string:145:24, x @string:143:10)::

            !print(left @string:145:41)
            !print(right @string:145:55)
        else::
            if {slice(?tmp#1 @string:146:15, ?tmp#2 @string:146:18, x @string:143:10)::

                foreign llvm move(x @string:146:34, ?tmp#3)
                do {
                    if {[|](?c @string:146:29, ?tmp#3, tmp#3)::

                        !print(c @string:146:45)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:147:20, x @string:143:10)::

                    !print(c @string:147:33)
                else::
                    fail

                }

            }

        }

    }


println > public (0 calls)
0: println(x:_ @string:151:17) use !io:
    !print(x @string:151:39)
    !nl


read > public (0 calls)
0: read(?x:_ @string:153:15) use !io:
    !read(?str:c_string @string:153:37)
    string(str @string:153:64, ?tmp#0 @string:153:57)
    =(?x @string:153:53, tmp#0)


string > public (0 calls)
0: string(str:c_string @string:28:16, ?#result:_ @string:28:5):
    length(str @string:29:19, ?tmp#0 @string:29:12)
    =(?len @string:29:6, tmp#0)
    if {=(len @string:30:15, 0 @string:30:21)::

        empty(?tmp#2 @string:30:26)
        foreign llvm move(tmp#2, ?tmp#1)
    else::
        if {=(len @string:31:15, 1 @string:31:21)::

            foreign lpvm access(str @string:31:56, 0 @string:31:61, 1 @string:31:64, 0 @string:31:67, ?tmp#5 @string:31:36)
            singleton(tmp#5, ?tmp#4 @string:31:26)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            buffer(len @string:32:33, str @string:32:38, ?tmp#6 @string:32:26)
            foreign llvm move(tmp#6, ?tmp#3)

        }
        foreign llvm move(tmp#3 @string:31:15, ?tmp#1)

    }
    =(?s @string:30:6, tmp#1 @string:30:15)
    foreign llvm move(s @string:28:34, ?#result @string:28:5)
string > public (0 calls)
1: string(c:char @string:37:16, ?#result:_ @string:37:5):
    singleton(c @string:37:38, ?tmp#0 @string:37:28)
    foreign llvm move(tmp#0, ?#result @string:37:5)


~= > public (0 calls)
0: ~=(x:_ @string:116:10, y:_ @string:116:18, ?#result:bool @string:116:5):
    <=>(x @string:116:31, y @string:116:39, ?tmp#1 @string:116:31)
    equal(?tmp#2 @string:116:46)
    ~=(tmp#1, tmp#2, ?tmp#0 @string:116:30)
    foreign llvm move(tmp#0, ?#result @string:116:5)

LLVM code       : None

Types: **** Validating parameter types in module wybe.count
Types: Validating def of %
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.count
Types: Validating def of %=
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Validating def of *
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.count
Types: Validating def of *=
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Validating def of +
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.count
Types: Validating def of +
Types: Checking type _ of param ?x:_
Types: Param is ?x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Checking type _ of param z:_
Types: Param is z:wybe.count
Types: Validating def of +
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Checking type _ of param ?y:_
Types: Param is ?y:wybe.count
Types: Checking type _ of param z:_
Types: Param is z:wybe.count
Types: Validating def of +=
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Validating def of -
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.count
Types: Validating def of -
Types: Checking type _ of param ?x:_
Types: Param is ?x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Checking type _ of param z:_
Types: Param is z:wybe.count
Types: Validating def of -
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Checking type _ of param ?y:_
Types: Param is ?y:wybe.count
Types: Checking type _ of param z:_
Types: Param is z:wybe.count
Types: Validating def of -=
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Validating def of /
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.count
Types: Validating def of /=
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Validating def of <
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of <=
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of <=>
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Checking type comparison of param ?#result:comparison
Types: Param is ?#result:wybe.comparison
Types: Validating def of =
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of >
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of >=
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of decr
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.count
Types: Validating def of incr
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.count
Types: Validating def of max
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.count
Types: Validating def of min
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.count
Types: Validating def of print
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Validating def of println
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Validating def of read
Types: Checking type _ of param ?x:_
Types: Param is ?x:wybe.count
Types: Validating def of ~=
Types: Checking type _ of param x:_
Types: Param is x:wybe.count
Types: Checking type _ of param y:_
Types: Param is y:wybe.count
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: **** Re-exiting module wybe.count
Types: **** Type checking modules wybe.count
Types: **** Strongly connected components:
Types:     wybe.count.~=
Types:     wybe.count.read
Types:     wybe.count.print
Types:     wybe.count.println
Types:     wybe.count.>=
Types:     wybe.count.max
Types:     wybe.count.>
Types:     wybe.count.=
Types:     wybe.count.<=
Types:     wybe.count.min
Types:     wybe.count.<
Types:     wybe.count.<=>
Types:     wybe.count./
Types:     wybe.count./=
Types:     wybe.count.-
Types:     wybe.count.-=
Types:     wybe.count.decr
Types:     wybe.count.+
Types:     wybe.count.+=
Types:     wybe.count.incr
Types:     wybe.count.*
Types:     wybe.count.*=
Types:     wybe.count.%
Types:     wybe.count.%=
Types: Type checking non-recursive proc wybe.count.~=
Types: ** Type checking decl of proc ~=
Types: found 1 definition(s)
Types: Type checking ~=
Types: ** Type checking ~=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_ne(x @count:61:51, y @count:61:53, ?tmp#0 @count:61:30)
Types:         foreign llvm move(tmp#0, ?#result @count:61:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.count, y:wybe.count, ?#result:wybe.bool
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_ne(x @count:61:51, y @count:61:53, ?tmp#0 @count:61:30)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @count:61:5)}
Types: Unifying move argument types tmp#0 and ?#result @count:61:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @count:61:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @count:61:51
Types:   Type = wybe.count
Types: Finding type of expr y @count:61:53
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:61:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_ne(64 bit unsigned, 64 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @count:61:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc ~=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_ne(x @count:61:51, y @count:61:53, ?tmp#0 @count:61:30)
Types: Mode checking foreign call {foreign llvm icmp_ne(x @count:61:51, y @count:61:53, ?tmp#0 @count:61:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:61:51
Types:   Type = wybe.count
Types: Finding type of expr y @count:61:53
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:61:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.count,wybe.count,?wybe.bool]
Types: New instr = {foreign llvm icmp_ne(x:wybe.count @count:61:51, y:wybe.count @count:61:53, ?tmp#0:wybe.bool @count:61:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @count:61:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @count:61:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @count:61:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:61:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '~='
Types: Mode checked body   : [{foreign llvm icmp_ne(x:wybe.count @count:61:51, y:wybe.count @count:61:53, ?tmp#0:wybe.bool @count:61:30)} @count:61:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:61:5)} @count:61:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of ~=:
Types: 
Types: ~= > public (0 calls)
Types: 4: ~=(x:wybe.count @count:61:10, y:wybe.count @count:61:18, ?#result:wybe.bool @count:61:5):
Types:     foreign llvm icmp_ne(x:wybe.count @count:61:51, y:wybe.count @count:61:53, ?tmp#0:wybe.bool @count:61:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:61:5)
Types: Type checking non-recursive proc wybe.count.read
Types: ** Type checking decl of proc read
Types: found 1 definition(s)
Types: Type checking read
Types: ** Type checking read: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         foreign c read_count(?x @count:92:52, !io @count:92:56)
Types:    and defaults: 
Types:    with assigned vars: fromList ["io","x"]
Types: Recording parameter types: ?x:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {foreign c read_count(?x @count:92:52, !io @count:92:56)}
Types: *** Before calls Typing {io::wybe.phantom, x::wybe.count}; {} (with no errors)
Types:   With calls:
Types:   Typing {io::wybe.phantom, x::wybe.count}; {} (with no errors)
Types: Finding type of expr ?x @count:92:52
Types:   Type = wybe.count
Types: Finding type of expr !io @count:92:56
Types:   Type = wybe.phantom
Types: Type checking foreign c call read_count(64 bit unsigned)
Types: Now mode checking proc read
Types: bound vars: semipure normal (total) computation binding {io}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt foreign c read_count(?x @count:92:52, !io @count:92:56)
Types: Mode checking foreign call {foreign c read_count(?x @count:92:52, !io @count:92:56)}
Types:     with assigned semipure normal (total) computation binding {io}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp !io
Types: Mode check exp resulted in !io
Types: Finding type of expr ?x @count:92:52
Types:   Type = wybe.count
Types: Finding type of expr !io @count:92:56
Types:   Type = wybe.phantom
Types:     types and modes = [?wybe.count,!wybe.phantom]
Types: New instr = {foreign c read_count(?x:wybe.count @count:92:52, !io:wybe.phantom @count:92:56)}
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'read'
Types: Mode checked body   : [{foreign c read_count(?x:wybe.count @count:92:52, !io:wybe.phantom @count:92:56)} @count:92:30]
Types: Vars defined by body: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : x
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of read:
Types: 
Types: read > public (0 calls)
Types: 4: read(?x:wybe.count @count:92:15) use !wybe.io.io:
Types:     foreign c read_count(?x:wybe.count @count:92:52, !io:wybe.phantom @count:92:56)
Types: Type checking non-recursive proc wybe.count.print
Types: ** Type checking decl of proc print
Types: found 1 definition(s)
Types: Type checking print
Types: ** Type checking print: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         foreign c print_count(x @count:88:52, !io @count:88:56)
Types:    and defaults: 
Types:    with assigned vars: fromList ["io","x"]
Types: Recording parameter types: x:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {foreign c print_count(x @count:88:52, !io @count:88:56)}
Types: *** Before calls Typing {io::wybe.phantom, x::wybe.count}; {} (with no errors)
Types:   With calls:
Types:   Typing {io::wybe.phantom, x::wybe.count}; {} (with no errors)
Types: Finding type of expr x @count:88:52
Types:   Type = wybe.count
Types: Finding type of expr !io @count:88:56
Types:   Type = wybe.phantom
Types: Type checking foreign c call print_count(64 bit unsigned)
Types: Now mode checking proc print
Types: bound vars: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt foreign c print_count(x @count:88:52, !io @count:88:56)
Types: Mode checking foreign call {foreign c print_count(x @count:88:52, !io @count:88:56)}
Types:     with assigned semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp !io
Types: Mode check exp resulted in !io
Types: Finding type of expr x @count:88:52
Types:   Type = wybe.count
Types: Finding type of expr !io @count:88:56
Types:   Type = wybe.phantom
Types:     types and modes = [wybe.count,!wybe.phantom]
Types: New instr = {foreign c print_count(x:wybe.count @count:88:52, !io:wybe.phantom @count:88:56)}
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'print'
Types: Mode checked body   : [{foreign c print_count(x:wybe.count @count:88:52, !io:wybe.phantom @count:88:56)} @count:88:30]
Types: Vars defined by body: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : 
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of print:
Types: 
Types: print > public (0 calls)
Types: 4: print(x:wybe.count @count:88:15) use !wybe.io.io:
Types:     foreign c print_count(x:wybe.count @count:88:52, !io:wybe.phantom @count:88:56)
Types: Type checking non-recursive proc wybe.count.println
Types: ** Type checking decl of proc println
Types: found 1 definition(s)
Types: Type checking println
Types: ** Type checking println: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         !print(x @count:90:39)
Types:         !nl
Types:    and defaults: 
Types:    with assigned vars: fromList ["io","x"]
Types: Recording parameter types: x:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {!print(x @count:90:39)}
Types: Recording casts in {!nl}
Types: *** Before calls Typing {io::wybe.phantom, x::wybe.count}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {!print(x @count:90:39)} @count:90:33, typingInfos = [wybe.bool.print<0>(wybe.bool) use io, ?io,wybe.count.print<0>(wybe.count) use io, ?io]}
Types:     StmtTypings {typingStmt = {!nl} @count:90:44, typingInfos = [wybe.io.nl<0>() use io, ?io]}Typing {io::wybe.phantom, x::wybe.count}; {} (with no errors)
Types: Type checking call {!print(x @count:90:39)} @count:90:33
Types: Candidate types:
Types:     wybe.bool.print<0>(wybe.bool) use io, ?io
Types:     wybe.count.print<0>(wybe.count) use io, ?io
Types: Finding type of expr x @count:90:39
Types:   Type = wybe.count
Types: Actual types: [wybe.count]
Types: Matching types [wybe.count] with wybe.bool.print<0>(wybe.bool) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 90, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Matching types [wybe.count] with wybe.count.print<0>(wybe.count) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {io::wybe.phantom, x::wybe.count}; {} (with no errors)]
Types: Resulting typing = Typing {io::wybe.phantom, x::wybe.count}; {} (with no errors)
Types: Type checking call {!nl} @count:90:44
Types: Candidate types:
Types:     wybe.io.nl<0>() use io, ?io
Types: Actual types: []
Types: Matching types [] with wybe.io.nl<0>() use io, ?io
Types: Call arity 0; proc arity 0 - 0
Types: Filling  0 optional arguments
Types: Valid types = [Typing {io::wybe.phantom, x::wybe.count}; {} (with no errors)]
Types: Resulting typing = Typing {io::wybe.phantom, x::wybe.count}; {} (with no errors)
Types: Now mode checking proc println
Types: bound vars: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt !print(x @count:90:39)
Types: Mode checking call   : {!print(x @count:90:39)}
Types:     with assigned    : semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Finding type of expr x @count:90:39
Types:   Type = wybe.count
Types:     actual types     : [wybe.count]
Types:     actual modes     : [(ParamIn,True,Nothing)]
Types: Matching types [wybe.count] with wybe.bool.print<0>(wybe.bool) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 90, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Matching types [wybe.count] with wybe.count.print<0>(wybe.count) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [(wybe.count.print<0>(wybe.count) use io, ?io,Typing {io::wybe.phantom, x::wybe.count}; {} (with no errors))]
Types: Possible mode matches: [(wybe.count.print<0>(wybe.count) use io, ?io,Typing {io::wybe.phantom, x::wybe.count}; {} (with no errors))]
Types: Exact mode matches: [(wybe.count.print<0>(wybe.count) use io, ?io,Typing {io::wybe.phantom, x::wybe.count}; {} (with no errors))]
Types: Finding type of expr x @count:90:39
Types:   Type = wybe.count
Types: Finalising call    :  {!wybe.count.<0>print(x:wybe.count @count:90:39)}
Types: Input resources    :  {wybe.io.io}
Types: Output resources   :  {wybe.io.io}
Types: Specials in call   :  {}
Types: Available vars     :  {"io", "x"}
Types: Available resources:  {wybe.io.io}
Types: Generated special stmts = []
Types: New instr = {!wybe.count.<0>print(x:wybe.count @count:90:39)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'println'
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt !nl
Types: Mode checking call   : {!nl}
Types:     with assigned    : semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types:     actual types     : []
Types:     actual modes     : []
Types: Matching types [] with wybe.io.nl<0>() use io, ?io
Types: Call arity 0; proc arity 0 - 0
Types: Filling  0 optional arguments
Types: Type-correct modes   : [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.count}; {} (with no errors))]
Types: Possible mode matches: [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.count}; {} (with no errors))]
Types: Exact mode matches: [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.count}; {} (with no errors))]
Types: Finalising call    :  {!wybe.io.<0>nl}
Types: Input resources    :  {wybe.io.io}
Types: Output resources   :  {wybe.io.io}
Types: Specials in call   :  {}
Types: Available vars     :  {"io", "x"}
Types: Available resources:  {wybe.io.io}
Types: Generated special stmts = []
Types: New instr = {!wybe.io.<0>nl}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'println'
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'println'
Types: Mode checked body   : [{!wybe.count.<0>print(x:wybe.count @count:90:39)} @count:90:33,{!wybe.io.<0>nl} @count:90:44]
Types: Vars defined by body: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : 
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of println:
Types: 
Types: println > public (0 calls)
Types: 4: println(x:wybe.count @count:90:17) use !wybe.io.io:
Types:     !wybe.count.<0>print(x:wybe.count @count:90:39)
Types:     !wybe.io.<0>nl
Types: Type checking non-recursive proc wybe.count.>=
Types: ** Type checking decl of proc >=
Types: found 1 definition(s)
Types: Type checking >=
Types: ** Type checking >=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_uge(x @count:67:52, y @count:67:54, ?tmp#0 @count:67:30)
Types:         foreign llvm move(tmp#0, ?#result @count:67:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.count, y:wybe.count, ?#result:wybe.bool
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(x @count:67:52, y @count:67:54, ?tmp#0 @count:67:30)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @count:67:5)}
Types: Unifying move argument types tmp#0 and ?#result @count:67:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @count:67:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @count:67:52
Types:   Type = wybe.count
Types: Finding type of expr y @count:67:54
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:67:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit unsigned, 64 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @count:67:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc >=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_uge(x @count:67:52, y @count:67:54, ?tmp#0 @count:67:30)
Types: Mode checking foreign call {foreign llvm icmp_uge(x @count:67:52, y @count:67:54, ?tmp#0 @count:67:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:67:52
Types:   Type = wybe.count
Types: Finding type of expr y @count:67:54
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:67:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.count,wybe.count,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(x:wybe.count @count:67:52, y:wybe.count @count:67:54, ?tmp#0:wybe.bool @count:67:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @count:67:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @count:67:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @count:67:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:67:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '>='
Types: Mode checked body   : [{foreign llvm icmp_uge(x:wybe.count @count:67:52, y:wybe.count @count:67:54, ?tmp#0:wybe.bool @count:67:30)} @count:67:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:67:5)} @count:67:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of >=:
Types: 
Types: >= > public (0 calls)
Types: 4: >=(x:wybe.count @count:67:10, y:wybe.count @count:67:18, ?#result:wybe.bool @count:67:5):
Types:     foreign llvm icmp_uge(x:wybe.count @count:67:52, y:wybe.count @count:67:54, ?tmp#0:wybe.bool @count:67:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:67:5)
Types: Type checking non-recursive proc wybe.count.max
Types: ** Type checking decl of proc max
Types: found 1 definition(s)
Types: Type checking max
Types: ** Type checking max: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         >=(x @count:75:31, y @count:75:35)
Types:         foreign llvm move(x @count:75:39, ?tmp#0)
Types:         foreign llvm move(y @count:75:50, ?tmp#0)
Types:         foreign llvm move(tmp#0 @count:75:31, ?#result @count:75:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.count, y:wybe.count, ?#result:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of '#result' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable #result type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {>=(x @count:75:31, y @count:75:35)}
Types: Recording casts in {foreign llvm move(x @count:75:39, ?tmp#0)}
Types: Unifying move argument types x @count:75:39 and ?tmp#0
Types: Finding type of expr x @count:75:39
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0
Types:   Type = 0
Types: Type variable 0 is bound to Nothing
Types: Unifying types wybe.count (-> wybe.count) and 0 (-> 0)
Types:   Unification yields wybe.count
Types: Recording casts in {foreign llvm move(y @count:75:50, ?tmp#0)}
Types: Unifying move argument types y @count:75:50 and ?tmp#0
Types: Finding type of expr y @count:75:50
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Recording casts in {foreign llvm move(tmp#0 @count:75:31, ?#result @count:75:5)}
Types: Unifying move argument types tmp#0 @count:75:31 and ?#result @count:75:5
Types: Finding type of expr tmp#0 @count:75:31
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?#result @count:75:5
Types:   Type = wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: *** Before calls Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {>=(x @count:75:31, y @count:75:35)} @count:75:31, typingInfos = [wybe.comparison.>=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.>=<0>(wybe.count,wybe.count,?wybe.bool)]}Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Type checking call {>=(x @count:75:31, y @count:75:35)} @count:75:31
Types: Candidate types:
Types:     wybe.comparison.>=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.>=<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr x @count:75:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:75:35
Types:   Type = wybe.count
Types: Actual types: [wybe.count,wybe.count]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.>=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 75, column 31): Type error in call to >=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 75, column 31): Type error in call to >=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.>=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Finding type of expr x @count:75:39
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Type checking foreign llvm call move(64 bit unsigned, 64 bit unsigned)
Types: Finding type of expr y @count:75:50
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Type checking foreign llvm call move(64 bit unsigned, 64 bit unsigned)
Types: Finding type of expr tmp#0 @count:75:31
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?#result @count:75:5
Types:   Type = wybe.count
Types: Type checking foreign llvm call move(64 bit unsigned, 64 bit unsigned)
Types: Now mode checking proc max
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt if {>=(x @count:75:31, y @count:75:35)::
Types: 
Types:                     foreign llvm move(x @count:75:39, ?tmp#0)
Types:                 else::
Types:                     foreign llvm move(y @count:75:50, ?tmp#0)
Types: 
Types:                 }
Types: Mode checking conditional {if {>=(x @count:75:31, y @count:75:35)::
Types: 
Types:         foreign llvm move(x @count:75:39, ?tmp#0)
Types:     else::
Types:         foreign llvm move(y @count:75:50, ?tmp#0)
Types: 
Types:     }}
Types: Mode checking call   : {>=(x @count:75:31, y @count:75:35)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Finding type of expr x @count:75:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:75:35
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.>=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 75, column 31): Type error in call to >=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 75, column 31): Type error in call to >=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.>=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.>=<0>(wybe.count,wybe.count),Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: [({test} wybe.count.>=<0>(wybe.count,wybe.count),Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Exact mode matches: [({test} wybe.count.>=<0>(wybe.count,wybe.count),Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Finding type of expr x @count:75:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:75:35
Types:   Type = wybe.count
Types: Finalising call    :  {wybe.count.<0>>=(x:wybe.count @count:75:31, y:wybe.count @count:75:35)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.count.<0>>=(x:wybe.count @count:75:31, y:wybe.count @count:75:35)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc 'max'
Types: Assigned by test: semipure test computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(x @count:75:39, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(x @count:75:39, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:75:39
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(x:wybe.count @count:75:39, ?tmp#0:wybe.count)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'max'
Types: Assigned by then branch: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(y @count:75:50, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(y @count:75:50, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr y @count:75:50
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(y:wybe.count @count:75:50, ?tmp#0:wybe.count)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'max'
Types: Assigned by else branch: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Type variable 0 is bound to Just wybe.count
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0 @count:75:31, ?#result @count:75:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0 @count:75:31, ?#result @count:75:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0 @count:75:31
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?#result @count:75:5
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count @count:75:31, ?#result:wybe.count @count:75:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'max'
Types: Mode checked body   : [{if {wybe.count.<0>>=(x:wybe.count @count:75:31, y:wybe.count @count:75:35)::
Types: 
Types:         foreign llvm move(x:wybe.count @count:75:39, ?tmp#0:wybe.count)
Types:     else::
Types:         foreign llvm move(y:wybe.count @count:75:50, ?tmp#0:wybe.count)
Types: 
Types:     }
Types:    condition -> {x::wybe.count, y::wybe.count}
Types:    then&else -> {tmp#0::wybe.count, x::wybe.count, y::wybe.count}} @count:75:31,{foreign llvm move(tmp#0:wybe.count @count:75:31, ?#result:wybe.count @count:75:5)} @count:75:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of max:
Types: 
Types: max > public (0 calls)
Types: 4: max(x:wybe.count @count:75:13, y:wybe.count @count:75:18, ?#result:wybe.count @count:75:5):
Types:     if {wybe.count.<0>>=(x:wybe.count @count:75:31, y:wybe.count @count:75:35)::
Types: 
Types:         foreign llvm move(x:wybe.count @count:75:39, ?tmp#0:wybe.count)
Types:     else::
Types:         foreign llvm move(y:wybe.count @count:75:50, ?tmp#0:wybe.count)
Types: 
Types:     }
Types:    condition -> {x::wybe.count, y::wybe.count}
Types:    then&else -> {tmp#0::wybe.count, x::wybe.count, y::wybe.count}
Types:     foreign llvm move(tmp#0:wybe.count @count:75:31, ?#result:wybe.count @count:75:5)
Types: Type checking non-recursive proc wybe.count.>
Types: ** Type checking decl of proc >
Types: found 1 definition(s)
Types: Type checking >
Types: ** Type checking >: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_ugt(x @count:66:51, y @count:66:53, ?tmp#0 @count:66:29)
Types:         foreign llvm move(tmp#0, ?#result @count:66:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.count, y:wybe.count, ?#result:wybe.bool
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_ugt(x @count:66:51, y @count:66:53, ?tmp#0 @count:66:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @count:66:5)}
Types: Unifying move argument types tmp#0 and ?#result @count:66:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @count:66:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @count:66:51
Types:   Type = wybe.count
Types: Finding type of expr y @count:66:53
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:66:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_ugt(64 bit unsigned, 64 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @count:66:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc >
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_ugt(x @count:66:51, y @count:66:53, ?tmp#0 @count:66:29)
Types: Mode checking foreign call {foreign llvm icmp_ugt(x @count:66:51, y @count:66:53, ?tmp#0 @count:66:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:66:51
Types:   Type = wybe.count
Types: Finding type of expr y @count:66:53
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:66:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.count,wybe.count,?wybe.bool]
Types: New instr = {foreign llvm icmp_ugt(x:wybe.count @count:66:51, y:wybe.count @count:66:53, ?tmp#0:wybe.bool @count:66:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @count:66:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @count:66:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @count:66:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:66:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '>'
Types: Mode checked body   : [{foreign llvm icmp_ugt(x:wybe.count @count:66:51, y:wybe.count @count:66:53, ?tmp#0:wybe.bool @count:66:29)} @count:66:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:66:5)} @count:66:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of >:
Types: 
Types: > > public (0 calls)
Types: 4: >(x:wybe.count @count:66:10, y:wybe.count @count:66:17, ?#result:wybe.bool @count:66:5):
Types:     foreign llvm icmp_ugt(x:wybe.count @count:66:51, y:wybe.count @count:66:53, ?tmp#0:wybe.bool @count:66:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:66:5)
Types: Type checking non-recursive proc wybe.count.=
Types: ** Type checking decl of proc =
Types: found 1 definition(s)
Types: Type checking =
Types: ** Type checking =: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_eq(x @count:60:50, y @count:60:52, ?tmp#0 @count:60:29)
Types:         foreign llvm move(tmp#0, ?#result @count:60:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.count, y:wybe.count, ?#result:wybe.bool
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_eq(x @count:60:50, y @count:60:52, ?tmp#0 @count:60:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @count:60:5)}
Types: Unifying move argument types tmp#0 and ?#result @count:60:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @count:60:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @count:60:50
Types:   Type = wybe.count
Types: Finding type of expr y @count:60:52
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:60:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit unsigned, 64 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @count:60:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc =
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(x @count:60:50, y @count:60:52, ?tmp#0 @count:60:29)
Types: Mode checking foreign call {foreign llvm icmp_eq(x @count:60:50, y @count:60:52, ?tmp#0 @count:60:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:60:50
Types:   Type = wybe.count
Types: Finding type of expr y @count:60:52
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:60:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.count,wybe.count,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(x:wybe.count @count:60:50, y:wybe.count @count:60:52, ?tmp#0:wybe.bool @count:60:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @count:60:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @count:60:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @count:60:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:60:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '='
Types: Mode checked body   : [{foreign llvm icmp_eq(x:wybe.count @count:60:50, y:wybe.count @count:60:52, ?tmp#0:wybe.bool @count:60:29)} @count:60:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:60:5)} @count:60:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of =:
Types: 
Types: = > public (0 calls)
Types: 4: =(x:wybe.count @count:60:10, y:wybe.count @count:60:17, ?#result:wybe.bool @count:60:5):
Types:     foreign llvm icmp_eq(x:wybe.count @count:60:50, y:wybe.count @count:60:52, ?tmp#0:wybe.bool @count:60:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:60:5)
Types: Type checking non-recursive proc wybe.count.<=
Types: ** Type checking decl of proc <=
Types: found 1 definition(s)
Types: Type checking <=
Types: ** Type checking <=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_ule(x @count:65:52, y @count:65:54, ?tmp#0 @count:65:30)
Types:         foreign llvm move(tmp#0, ?#result @count:65:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.count, y:wybe.count, ?#result:wybe.bool
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_ule(x @count:65:52, y @count:65:54, ?tmp#0 @count:65:30)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @count:65:5)}
Types: Unifying move argument types tmp#0 and ?#result @count:65:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @count:65:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @count:65:52
Types:   Type = wybe.count
Types: Finding type of expr y @count:65:54
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:65:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_ule(64 bit unsigned, 64 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @count:65:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc <=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_ule(x @count:65:52, y @count:65:54, ?tmp#0 @count:65:30)
Types: Mode checking foreign call {foreign llvm icmp_ule(x @count:65:52, y @count:65:54, ?tmp#0 @count:65:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:65:52
Types:   Type = wybe.count
Types: Finding type of expr y @count:65:54
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:65:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.count,wybe.count,?wybe.bool]
Types: New instr = {foreign llvm icmp_ule(x:wybe.count @count:65:52, y:wybe.count @count:65:54, ?tmp#0:wybe.bool @count:65:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @count:65:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @count:65:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @count:65:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:65:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<='
Types: Mode checked body   : [{foreign llvm icmp_ule(x:wybe.count @count:65:52, y:wybe.count @count:65:54, ?tmp#0:wybe.bool @count:65:30)} @count:65:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:65:5)} @count:65:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <=:
Types: 
Types: <= > public (0 calls)
Types: 4: <=(x:wybe.count @count:65:10, y:wybe.count @count:65:18, ?#result:wybe.bool @count:65:5):
Types:     foreign llvm icmp_ule(x:wybe.count @count:65:52, y:wybe.count @count:65:54, ?tmp#0:wybe.bool @count:65:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:65:5)
Types: Type checking non-recursive proc wybe.count.min
Types: ** Type checking decl of proc min
Types: found 1 definition(s)
Types: Type checking min
Types: ** Type checking min: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         <=(x @count:74:31, y @count:74:35)
Types:         foreign llvm move(x @count:74:39, ?tmp#0)
Types:         foreign llvm move(y @count:74:50, ?tmp#0)
Types:         foreign llvm move(tmp#0 @count:74:31, ?#result @count:74:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.count, y:wybe.count, ?#result:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of '#result' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable #result type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {<=(x @count:74:31, y @count:74:35)}
Types: Recording casts in {foreign llvm move(x @count:74:39, ?tmp#0)}
Types: Unifying move argument types x @count:74:39 and ?tmp#0
Types: Finding type of expr x @count:74:39
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0
Types:   Type = 0
Types: Type variable 0 is bound to Nothing
Types: Unifying types wybe.count (-> wybe.count) and 0 (-> 0)
Types:   Unification yields wybe.count
Types: Recording casts in {foreign llvm move(y @count:74:50, ?tmp#0)}
Types: Unifying move argument types y @count:74:50 and ?tmp#0
Types: Finding type of expr y @count:74:50
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Recording casts in {foreign llvm move(tmp#0 @count:74:31, ?#result @count:74:5)}
Types: Unifying move argument types tmp#0 @count:74:31 and ?#result @count:74:5
Types: Finding type of expr tmp#0 @count:74:31
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?#result @count:74:5
Types:   Type = wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: *** Before calls Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {<=(x @count:74:31, y @count:74:35)} @count:74:31, typingInfos = [wybe.comparison.<=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.<=<0>(wybe.count,wybe.count,?wybe.bool)]}Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Type checking call {<=(x @count:74:31, y @count:74:35)} @count:74:31
Types: Candidate types:
Types:     wybe.comparison.<=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.<=<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr x @count:74:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:74:35
Types:   Type = wybe.count
Types: Actual types: [wybe.count,wybe.count]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.<=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 74, column 31): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 74, column 31): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.<=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Finding type of expr x @count:74:39
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Type checking foreign llvm call move(64 bit unsigned, 64 bit unsigned)
Types: Finding type of expr y @count:74:50
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Type checking foreign llvm call move(64 bit unsigned, 64 bit unsigned)
Types: Finding type of expr tmp#0 @count:74:31
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?#result @count:74:5
Types:   Type = wybe.count
Types: Type checking foreign llvm call move(64 bit unsigned, 64 bit unsigned)
Types: Now mode checking proc min
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt if {<=(x @count:74:31, y @count:74:35)::
Types: 
Types:                     foreign llvm move(x @count:74:39, ?tmp#0)
Types:                 else::
Types:                     foreign llvm move(y @count:74:50, ?tmp#0)
Types: 
Types:                 }
Types: Mode checking conditional {if {<=(x @count:74:31, y @count:74:35)::
Types: 
Types:         foreign llvm move(x @count:74:39, ?tmp#0)
Types:     else::
Types:         foreign llvm move(y @count:74:50, ?tmp#0)
Types: 
Types:     }}
Types: Mode checking call   : {<=(x @count:74:31, y @count:74:35)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Finding type of expr x @count:74:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:74:35
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.<=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 74, column 31): Type error in call to <=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 74, column 31): Type error in call to <=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.<=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.<=<0>(wybe.count,wybe.count),Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: [({test} wybe.count.<=<0>(wybe.count,wybe.count),Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Exact mode matches: [({test} wybe.count.<=<0>(wybe.count,wybe.count),Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Finding type of expr x @count:74:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:74:35
Types:   Type = wybe.count
Types: Finalising call    :  {wybe.count.<0><=(x:wybe.count @count:74:31, y:wybe.count @count:74:35)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.count.<0><=(x:wybe.count @count:74:31, y:wybe.count @count:74:35)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc 'min'
Types: Assigned by test: semipure test computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(x @count:74:39, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(x @count:74:39, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:74:39
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(x:wybe.count @count:74:39, ?tmp#0:wybe.count)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'min'
Types: Assigned by then branch: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(y @count:74:50, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(y @count:74:50, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr y @count:74:50
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(y:wybe.count @count:74:50, ?tmp#0:wybe.count)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'min'
Types: Assigned by else branch: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Type variable 0 is bound to Just wybe.count
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0 @count:74:31, ?#result @count:74:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0 @count:74:31, ?#result @count:74:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0 @count:74:31
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?#result @count:74:5
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count @count:74:31, ?#result:wybe.count @count:74:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'min'
Types: Mode checked body   : [{if {wybe.count.<0><=(x:wybe.count @count:74:31, y:wybe.count @count:74:35)::
Types: 
Types:         foreign llvm move(x:wybe.count @count:74:39, ?tmp#0:wybe.count)
Types:     else::
Types:         foreign llvm move(y:wybe.count @count:74:50, ?tmp#0:wybe.count)
Types: 
Types:     }
Types:    condition -> {x::wybe.count, y::wybe.count}
Types:    then&else -> {tmp#0::wybe.count, x::wybe.count, y::wybe.count}} @count:74:31,{foreign llvm move(tmp#0:wybe.count @count:74:31, ?#result:wybe.count @count:74:5)} @count:74:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of min:
Types: 
Types: min > public (0 calls)
Types: 4: min(x:wybe.count @count:74:13, y:wybe.count @count:74:18, ?#result:wybe.count @count:74:5):
Types:     if {wybe.count.<0><=(x:wybe.count @count:74:31, y:wybe.count @count:74:35)::
Types: 
Types:         foreign llvm move(x:wybe.count @count:74:39, ?tmp#0:wybe.count)
Types:     else::
Types:         foreign llvm move(y:wybe.count @count:74:50, ?tmp#0:wybe.count)
Types: 
Types:     }
Types:    condition -> {x::wybe.count, y::wybe.count}
Types:    then&else -> {tmp#0::wybe.count, x::wybe.count, y::wybe.count}
Types:     foreign llvm move(tmp#0:wybe.count @count:74:31, ?#result:wybe.count @count:74:5)
Types: Type checking non-recursive proc wybe.count.<
Types: ** Type checking decl of proc <
Types: found 1 definition(s)
Types: Type checking <
Types: ** Type checking <: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm icmp_ult(x @count:64:51, y @count:64:53, ?tmp#0 @count:64:29)
Types:         foreign llvm move(tmp#0, ?#result @count:64:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.count, y:wybe.count, ?#result:wybe.bool
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_ult(x @count:64:51, y @count:64:53, ?tmp#0 @count:64:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @count:64:5)}
Types: Unifying move argument types tmp#0 and ?#result @count:64:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @count:64:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @count:64:51
Types:   Type = wybe.count
Types: Finding type of expr y @count:64:53
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:64:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_ult(64 bit unsigned, 64 bit unsigned, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @count:64:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc <
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_ult(x @count:64:51, y @count:64:53, ?tmp#0 @count:64:29)
Types: Mode checking foreign call {foreign llvm icmp_ult(x @count:64:51, y @count:64:53, ?tmp#0 @count:64:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:64:51
Types:   Type = wybe.count
Types: Finding type of expr y @count:64:53
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:64:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.count,wybe.count,?wybe.bool]
Types: New instr = {foreign llvm icmp_ult(x:wybe.count @count:64:51, y:wybe.count @count:64:53, ?tmp#0:wybe.bool @count:64:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @count:64:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @count:64:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @count:64:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:64:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<'
Types: Mode checked body   : [{foreign llvm icmp_ult(x:wybe.count @count:64:51, y:wybe.count @count:64:53, ?tmp#0:wybe.bool @count:64:29)} @count:64:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:64:5)} @count:64:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <:
Types: 
Types: < > public (0 calls)
Types: 4: <(x:wybe.count @count:64:10, y:wybe.count @count:64:17, ?#result:wybe.bool @count:64:5):
Types:     foreign llvm icmp_ult(x:wybe.count @count:64:51, y:wybe.count @count:64:53, ?tmp#0:wybe.bool @count:64:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:64:5)
Types: Type checking non-recursive proc wybe.count.<=>
Types: ** Type checking decl of proc <=>
Types: found 1 definition(s)
Types: Type checking <=>
Types: ** Type checking <=>: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         <(x @count:71:10, y @count:71:14)
Types:         lesser(?tmp#1 @count:71:19)
Types:         foreign llvm move(tmp#1, ?tmp#0)
Types:         =(x @count:71:28, y @count:71:32)
Types:         equal(?tmp#3 @count:71:37)
Types:         foreign llvm move(tmp#3, ?tmp#2)
Types:         greater(?tmp#4 @count:71:53)
Types:         foreign llvm move(tmp#4, ?tmp#2)
Types:         foreign llvm move(tmp#2 @count:71:28, ?tmp#0)
Types:         foreign llvm move(tmp#0 @count:71:10, ?#result @count:70:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","tmp#1","tmp#2","tmp#3","tmp#4","x","y"]
Types: Recording parameter types: x:wybe.count, y:wybe.count, ?#result:wybe.comparison
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of '#result' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable #result type constrained to wybe.comparison
Types: Recording resource types: 
Types: Recording casts in {<(x @count:71:10, y @count:71:14)}
Types: Recording casts in {lesser(?tmp#1 @count:71:19)}
Types: Recording casts in {foreign llvm move(tmp#1, ?tmp#0)}
Types: Unifying move argument types tmp#1 and ?tmp#0
Types: Finding type of expr tmp#1
Types:   Type = 0
Types: Finding type of expr ?tmp#0
Types:   Type = 1
Types: Type variable 0 is bound to Nothing
Types: Type variable 1 is bound to Nothing
Types: Unifying types 0 (-> 0) and 1 (-> 1)
Types:   Unification yields 0
Types: Recording casts in {=(x @count:71:28, y @count:71:32)}
Types: Recording casts in {equal(?tmp#3 @count:71:37)}
Types: Recording casts in {foreign llvm move(tmp#3, ?tmp#2)}
Types: Unifying move argument types tmp#3 and ?tmp#2
Types: Finding type of expr tmp#3
Types:   Type = 2
Types: Finding type of expr ?tmp#2
Types:   Type = 3
Types: Type variable 2 is bound to Nothing
Types: Type variable 3 is bound to Nothing
Types: Unifying types 2 (-> 2) and 3 (-> 3)
Types:   Unification yields 2
Types: Recording casts in {greater(?tmp#4 @count:71:53)}
Types: Recording casts in {foreign llvm move(tmp#4, ?tmp#2)}
Types: Unifying move argument types tmp#4 and ?tmp#2
Types: Finding type of expr tmp#4
Types:   Type = 4
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Nothing
Types:   Type = 2
Types: Type variable 4 is bound to Nothing
Types: Type variable 2 is bound to Nothing
Types: Unifying types 4 (-> 4) and 2 (-> 2)
Types:   Unification yields 2
Types: Recording casts in {foreign llvm move(tmp#2 @count:71:28, ?tmp#0)}
Types: Unifying move argument types tmp#2 @count:71:28 and ?tmp#0
Types: Finding type of expr tmp#2 @count:71:28
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Nothing
Types:   Type = 2
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Nothing
Types:   Type = 0
Types: Type variable 2 is bound to Nothing
Types: Type variable 0 is bound to Nothing
Types: Unifying types 2 (-> 2) and 0 (-> 0)
Types:   Unification yields 0
Types: Recording casts in {foreign llvm move(tmp#0 @count:71:10, ?#result @count:70:5)}
Types: Unifying move argument types tmp#0 @count:71:10 and ?#result @count:70:5
Types: Finding type of expr tmp#0 @count:71:10
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Nothing
Types:   Type = 0
Types: Finding type of expr ?#result @count:70:5
Types:   Type = wybe.comparison
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: *** Before calls Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {<(x @count:71:10, y @count:71:14)} @count:71:10, typingInfos = [wybe.comparison.<<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.<<0>(wybe.count,wybe.count,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {lesser(?tmp#1 @count:71:19)} @count:71:19, typingInfos = [wybe.comparison.lesser<0>(?wybe.comparison)]}
Types:     StmtTypings {typingStmt = {=(x @count:71:28, y @count:71:32)} @count:71:28, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {equal(?tmp#3 @count:71:37)} @count:71:37, typingInfos = [wybe.comparison.equal<0>(?wybe.comparison)]}
Types:     StmtTypings {typingStmt = {greater(?tmp#4 @count:71:53)} @count:71:53, typingInfos = [wybe.comparison.greater<0>(?wybe.comparison)]}Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {<(x @count:71:10, y @count:71:14)} @count:71:10
Types: Candidate types:
Types:     wybe.comparison.<<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.<<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr x @count:71:10
Types:   Type = wybe.count
Types: Finding type of expr y @count:71:14
Types:   Type = wybe.count
Types: Actual types: [wybe.count,wybe.count]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.<<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 71, column 10): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 71, column 10): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.<<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {lesser(?tmp#1 @count:71:19)} @count:71:19
Types: Candidate types:
Types:     wybe.comparison.lesser<0>(?wybe.comparison)
Types: Finding type of expr ?tmp#1 @count:71:19
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Actual types: [wybe.comparison]
Types: Matching types [wybe.comparison] with wybe.comparison.lesser<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {=(x @count:71:28, y @count:71:32)} @count:71:28
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr x @count:71:28
Types:   Type = wybe.count
Types: Finding type of expr y @count:71:32
Types:   Type = wybe.count
Types: Actual types: [wybe.count,wybe.count]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 71, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 71, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 71, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 71, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {equal(?tmp#3 @count:71:37)} @count:71:37
Types: Candidate types:
Types:     wybe.comparison.equal<0>(?wybe.comparison)
Types: Finding type of expr ?tmp#3 @count:71:37
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Actual types: [wybe.comparison]
Types: Matching types [wybe.comparison] with wybe.comparison.equal<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {greater(?tmp#4 @count:71:53)} @count:71:53
Types: Candidate types:
Types:     wybe.comparison.greater<0>(?wybe.comparison)
Types: Finding type of expr ?tmp#4 @count:71:53
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Actual types: [wybe.comparison]
Types: Matching types [wybe.comparison] with wybe.comparison.greater<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Finding type of expr tmp#1
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Finding type of expr tmp#3
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Finding type of expr tmp#4
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Finding type of expr tmp#2 @count:71:28
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Finding type of expr tmp#0 @count:71:10
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?#result @count:70:5
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Now mode checking proc <=>
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt if {<(x @count:71:10, y @count:71:14)::
Types: 
Types:                     lesser(?tmp#1 @count:71:19)
Types:                     foreign llvm move(tmp#1, ?tmp#0)
Types:                 else::
Types:                     if {=(x @count:71:28, y @count:71:32)::
Types: 
Types:                         equal(?tmp#3 @count:71:37)
Types:                         foreign llvm move(tmp#3, ?tmp#2)
Types:                     else::
Types:                         greater(?tmp#4 @count:71:53)
Types:                         foreign llvm move(tmp#4, ?tmp#2)
Types: 
Types:                     }
Types:                     foreign llvm move(tmp#2 @count:71:28, ?tmp#0)
Types: 
Types:                 }
Types: Mode checking conditional {if {<(x @count:71:10, y @count:71:14)::
Types: 
Types:         lesser(?tmp#1 @count:71:19)
Types:         foreign llvm move(tmp#1, ?tmp#0)
Types:     else::
Types:         if {=(x @count:71:28, y @count:71:32)::
Types: 
Types:             equal(?tmp#3 @count:71:37)
Types:             foreign llvm move(tmp#3, ?tmp#2)
Types:         else::
Types:             greater(?tmp#4 @count:71:53)
Types:             foreign llvm move(tmp#4, ?tmp#2)
Types: 
Types:         }
Types:         foreign llvm move(tmp#2 @count:71:28, ?tmp#0)
Types: 
Types:     }}
Types: Mode checking call   : {<(x @count:71:10, y @count:71:14)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Finding type of expr x @count:71:10
Types:   Type = wybe.count
Types: Finding type of expr y @count:71:14
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.<<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 71, column 10): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 71, column 10): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.<<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.<<0>(wybe.count,wybe.count),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [({test} wybe.count.<<0>(wybe.count,wybe.count),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [({test} wybe.count.<<0>(wybe.count,wybe.count),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr x @count:71:10
Types:   Type = wybe.count
Types: Finding type of expr y @count:71:14
Types:   Type = wybe.count
Types: Finalising call    :  {wybe.count.<0><(x:wybe.count @count:71:10, y:wybe.count @count:71:14)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.count.<0><(x:wybe.count @count:71:10, y:wybe.count @count:71:14)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '<=>'
Types: Assigned by test: semipure test computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt lesser(?tmp#1 @count:71:19)
Types: Mode checking call   : {lesser(?tmp#1 @count:71:19)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr ?tmp#1 @count:71:19
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     actual types     : [wybe.comparison]
Types:     actual modes     : [(ParamOut,False,Nothing)]
Types: Matching types [wybe.comparison] with wybe.comparison.lesser<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Type-correct modes   : [(wybe.comparison.lesser<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [(wybe.comparison.lesser<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [(wybe.comparison.lesser<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr ?tmp#1 @count:71:19
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finalising call    :  {wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @count:71:19)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @count:71:19)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<=>'
Types: Now assigned = semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#1, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(tmp#1, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#1
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#1:wybe.comparison, ?tmp#0:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Assigned by then branch: semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt if {=(x @count:71:28, y @count:71:32)::
Types: 
Types:                     equal(?tmp#3 @count:71:37)
Types:                     foreign llvm move(tmp#3, ?tmp#2)
Types:                 else::
Types:                     greater(?tmp#4 @count:71:53)
Types:                     foreign llvm move(tmp#4, ?tmp#2)
Types: 
Types:                 }
Types: Mode checking conditional {if {=(x @count:71:28, y @count:71:32)::
Types: 
Types:         equal(?tmp#3 @count:71:37)
Types:         foreign llvm move(tmp#3, ?tmp#2)
Types:     else::
Types:         greater(?tmp#4 @count:71:53)
Types:         foreign llvm move(tmp#4, ?tmp#2)
Types: 
Types:     }}
Types: Mode checking call   : {=(x @count:71:28, y @count:71:32)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Finding type of expr x @count:71:28
Types:   Type = wybe.count
Types: Finding type of expr y @count:71:32
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 71, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 71, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 71, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 71, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.=<0>(wybe.count,wybe.count),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [({test} wybe.count.=<0>(wybe.count,wybe.count),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [({test} wybe.count.=<0>(wybe.count,wybe.count),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr x @count:71:28
Types:   Type = wybe.count
Types: Finding type of expr y @count:71:32
Types:   Type = wybe.count
Types: Finalising call    :  {wybe.count.<0>=(x:wybe.count @count:71:28, y:wybe.count @count:71:32)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.count.<0>=(x:wybe.count @count:71:28, y:wybe.count @count:71:32)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '<=>'
Types: Assigned by test: semipure test computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt equal(?tmp#3 @count:71:37)
Types: Mode checking call   : {equal(?tmp#3 @count:71:37)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp ?tmp#3
Types: Mode check exp resulted in ?tmp#3
Types: Finding type of expr ?tmp#3 @count:71:37
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     actual types     : [wybe.comparison]
Types:     actual modes     : [(ParamOut,False,Nothing)]
Types: Matching types [wybe.comparison] with wybe.comparison.equal<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Type-correct modes   : [(wybe.comparison.equal<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [(wybe.comparison.equal<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [(wybe.comparison.equal<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr ?tmp#3 @count:71:37
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finalising call    :  {wybe.comparison.<0>equal(?tmp#3:wybe.comparison @count:71:37)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.comparison.<0>equal(?tmp#3:wybe.comparison @count:71:37)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<=>'
Types: Now assigned = semipure normal (total) computation binding {tmp#3, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#3, ?tmp#2)
Types: Mode checking foreign call {foreign llvm move(tmp#3, ?tmp#2)}
Types:     with assigned semipure normal (total) computation binding {tmp#3, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#3
Types: Mode check exp resulted in tmp#3
Types: Mode check exp ?tmp#2
Types: Mode check exp resulted in ?tmp#2
Types: Finding type of expr tmp#3
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#3:wybe.comparison, ?tmp#2:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {tmp#2, tmp#3, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Assigned by then branch: semipure normal (total) computation binding {tmp#2, tmp#3, x, y}, break set = Everything, with resources {}
Types: Mode check stmt greater(?tmp#4 @count:71:53)
Types: Mode checking call   : {greater(?tmp#4 @count:71:53)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp ?tmp#4
Types: Mode check exp resulted in ?tmp#4
Types: Finding type of expr ?tmp#4 @count:71:53
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     actual types     : [wybe.comparison]
Types:     actual modes     : [(ParamOut,False,Nothing)]
Types: Matching types [wybe.comparison] with wybe.comparison.greater<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Type-correct modes   : [(wybe.comparison.greater<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [(wybe.comparison.greater<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [(wybe.comparison.greater<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.count, y::wybe.count}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr ?tmp#4 @count:71:53
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finalising call    :  {wybe.comparison.<0>greater(?tmp#4:wybe.comparison @count:71:53)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.comparison.<0>greater(?tmp#4:wybe.comparison @count:71:53)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<=>'
Types: Now assigned = semipure normal (total) computation binding {tmp#4, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#4, ?tmp#2)
Types: Mode checking foreign call {foreign llvm move(tmp#4, ?tmp#2)}
Types:     with assigned semipure normal (total) computation binding {tmp#4, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#4
Types: Mode check exp resulted in tmp#4
Types: Mode check exp ?tmp#2
Types: Mode check exp resulted in ?tmp#2
Types: Finding type of expr tmp#4
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#4:wybe.comparison, ?tmp#2:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {tmp#2, tmp#4, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Assigned by else branch: semipure normal (total) computation binding {tmp#2, tmp#4, x, y}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {tmp#2, x, y}, break set = Everything, with resources {}
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types: Now assigned = semipure normal (total) computation binding {tmp#2, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#2 @count:71:28, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(tmp#2 @count:71:28, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {tmp#2, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#2
Types: Mode check exp resulted in tmp#2
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#2 @count:71:28
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#2:wybe.comparison @count:71:28, ?tmp#0:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#2, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Assigned by else branch: semipure normal (total) computation binding {tmp#0, tmp#2, x, y}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0 @count:71:10, ?#result @count:70:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0 @count:71:10, ?#result @count:70:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0 @count:71:10
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?#result @count:70:5
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#0:wybe.comparison @count:71:10, ?#result:wybe.comparison @count:70:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Mode checked body   : [{if {wybe.count.<0><(x:wybe.count @count:71:10, y:wybe.count @count:71:14)::
Types: 
Types:         wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @count:71:19)
Types:         foreign llvm move(tmp#1:wybe.comparison, ?tmp#0:wybe.comparison)
Types:     else::
Types:         if {wybe.count.<0>=(x:wybe.count @count:71:28, y:wybe.count @count:71:32)::
Types: 
Types:             wybe.comparison.<0>equal(?tmp#3:wybe.comparison @count:71:37)
Types:             foreign llvm move(tmp#3:wybe.comparison, ?tmp#2:wybe.comparison)
Types:         else::
Types:             wybe.comparison.<0>greater(?tmp#4:wybe.comparison @count:71:53)
Types:             foreign llvm move(tmp#4:wybe.comparison, ?tmp#2:wybe.comparison)
Types: 
Types:         }
Types:    condition -> {x::wybe.count, y::wybe.count}
Types:    then&else -> {tmp#2::wybe.comparison, x::wybe.count, y::wybe.count}
Types:         foreign llvm move(tmp#2:wybe.comparison @count:71:28, ?tmp#0:wybe.comparison)
Types: 
Types:     }
Types:    condition -> {x::wybe.count, y::wybe.count}
Types:    then&else -> {tmp#0::wybe.comparison, x::wybe.count, y::wybe.count}} @count:71:10,{foreign llvm move(tmp#0:wybe.comparison @count:71:10, ?#result:wybe.comparison @count:70:5)} @count:70:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <=>:
Types: 
Types: <=> > public (0 calls)
Types: 4: <=>(x:wybe.count @count:70:10, y:wybe.count @count:70:20, ?#result:wybe.comparison @count:70:5):
Types:     if {wybe.count.<0><(x:wybe.count @count:71:10, y:wybe.count @count:71:14)::
Types: 
Types:         wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @count:71:19)
Types:         foreign llvm move(tmp#1:wybe.comparison, ?tmp#0:wybe.comparison)
Types:     else::
Types:         if {wybe.count.<0>=(x:wybe.count @count:71:28, y:wybe.count @count:71:32)::
Types: 
Types:             wybe.comparison.<0>equal(?tmp#3:wybe.comparison @count:71:37)
Types:             foreign llvm move(tmp#3:wybe.comparison, ?tmp#2:wybe.comparison)
Types:         else::
Types:             wybe.comparison.<0>greater(?tmp#4:wybe.comparison @count:71:53)
Types:             foreign llvm move(tmp#4:wybe.comparison, ?tmp#2:wybe.comparison)
Types: 
Types:         }
Types:    condition -> {x::wybe.count, y::wybe.count}
Types:    then&else -> {tmp#2::wybe.comparison, x::wybe.count, y::wybe.count}
Types:         foreign llvm move(tmp#2:wybe.comparison @count:71:28, ?tmp#0:wybe.comparison)
Types: 
Types:     }
Types:    condition -> {x::wybe.count, y::wybe.count}
Types:    then&else -> {tmp#0::wybe.comparison, x::wybe.count, y::wybe.count}
Types:     foreign llvm move(tmp#0:wybe.comparison @count:71:10, ?#result:wybe.comparison @count:70:5)
Types: Type checking non-recursive proc wybe.count./
Types: ** Type checking decl of proc /
Types: found 1 definition(s)
Types: Type checking /
Types: ** Type checking /: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm udiv(x @count:45:43, y @count:45:45, ?tmp#0 @count:45:25)
Types:         foreign llvm move(tmp#0, ?#result @count:45:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.count, y:wybe.count, ?#result:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of '#result' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable #result type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {foreign llvm udiv(x @count:45:43, y @count:45:45, ?tmp#0 @count:45:25)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @count:45:5)}
Types: Unifying move argument types tmp#0 and ?#result @count:45:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @count:45:5
Types:   Type = wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: *** Before calls Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Finding type of expr x @count:45:43
Types:   Type = wybe.count
Types: Finding type of expr y @count:45:45
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:45:25
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Type checking foreign llvm call udiv(64 bit unsigned, 64 bit unsigned, 64 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?#result @count:45:5
Types:   Type = wybe.count
Types: Type checking foreign llvm call move(64 bit unsigned, 64 bit unsigned)
Types: Now mode checking proc /
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm udiv(x @count:45:43, y @count:45:45, ?tmp#0 @count:45:25)
Types: Mode checking foreign call {foreign llvm udiv(x @count:45:43, y @count:45:45, ?tmp#0 @count:45:25)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:45:43
Types:   Type = wybe.count
Types: Finding type of expr y @count:45:45
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:45:25
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,wybe.count,?wybe.count]
Types: New instr = {foreign llvm udiv(x:wybe.count @count:45:43, y:wybe.count @count:45:45, ?tmp#0:wybe.count @count:45:25)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @count:45:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @count:45:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?#result @count:45:5
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:45:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '/'
Types: Mode checked body   : [{foreign llvm udiv(x:wybe.count @count:45:43, y:wybe.count @count:45:45, ?tmp#0:wybe.count @count:45:25)} @count:45:25,{foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:45:5)} @count:45:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of /:
Types: 
Types: / > public (0 calls)
Types: 4: /(x:wybe.count @count:45:10, y:wybe.count @count:45:16, ?#result:wybe.count @count:45:5):
Types:     foreign llvm udiv(x:wybe.count @count:45:43, y:wybe.count @count:45:45, ?tmp#0:wybe.count @count:45:25)
Types:     foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:45:5)
Types: Type checking non-recursive proc wybe.count./=
Types: ** Type checking decl of proc /=
Types: found 1 definition(s)
Types: Type checking /=
Types: ** Type checking /=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         /(x @count:48:31, y @count:48:35, ?tmp#0 @count:48:31)
Types:         =(?x @count:48:27, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y"]
Types: Recording parameter types: !x:wybe.count, y:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {/(x @count:48:31, y @count:48:35, ?tmp#0 @count:48:31)}
Types: Recording casts in {=(?x @count:48:27, tmp#0)}
Types: *** Before calls Typing {x::wybe.count, y::wybe.count}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {/(x @count:48:31, y @count:48:35, ?tmp#0 @count:48:31)} @count:48:31, typingInfos = [wybe.count./<0>(wybe.count,wybe.count,?wybe.count)]}
Types:     StmtTypings {typingStmt = {=(?x @count:48:27, tmp#0)} @count:48:27, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)]}Typing {x::wybe.count, y::wybe.count}; {} (with no errors)
Types: Type checking call {/(x @count:48:31, y @count:48:35, ?tmp#0 @count:48:31)} @count:48:31
Types: Candidate types:
Types:     wybe.count./<0>(wybe.count,wybe.count,?wybe.count)
Types: Finding type of expr x @count:48:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:48:35
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:48:31
Types:   Type = 0
Types: Actual types: [wybe.count,wybe.count,0]
Types: Matching types [wybe.count,wybe.count,0] with wybe.count./<0>(wybe.count,wybe.count,?wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Type checking call {=(?x @count:48:27, tmp#0)} @count:48:27
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr ?x @count:48:27
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Actual types: [wybe.count,wybe.count]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 48, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 48, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 48, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 48, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Now mode checking proc /=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt /(x @count:48:31, y @count:48:35, ?tmp#0 @count:48:31)
Types: Mode checking call   : {/(x @count:48:31, y @count:48:35, ?tmp#0 @count:48:31)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:48:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:48:35
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:48:31
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count,wybe.count]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.count,wybe.count,wybe.count] with wybe.count./<0>(wybe.count,wybe.count,?wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [(wybe.count./<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: [(wybe.count./<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Exact mode matches: [(wybe.count./<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Finding type of expr x @count:48:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:48:35
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:48:31
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finalising call    :  {wybe.count.<0>/(x:wybe.count @count:48:31, y:wybe.count @count:48:35, ?tmp#0:wybe.count @count:48:31)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.count.<0>/(x:wybe.count @count:48:31, y:wybe.count @count:48:35, ?tmp#0:wybe.count @count:48:31)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '/='
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @count:48:27, tmp#0)
Types: Mode checking call   : {=(?x @count:48:27, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @count:48:27
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 48, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 48, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 48, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 48, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.=<0>(wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @count:48:27)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?x @count:48:27
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:48:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '/='
Types: Mode checked body   : [{wybe.count.<0>/(x:wybe.count @count:48:31, y:wybe.count @count:48:35, ?tmp#0:wybe.count @count:48:31)} @count:48:31,{foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:48:27)} @count:48:27]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of /=:
Types: 
Types: /= > public (0 calls)
Types: 4: /=(!x:wybe.count @count:48:11, y:wybe.count @count:48:19):
Types:     wybe.count.<0>/(x:wybe.count @count:48:31, y:wybe.count @count:48:35, ?tmp#0:wybe.count @count:48:31)
Types:     foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:48:27)
Types: Type checking non-recursive proc wybe.count.-
Types: ** Type checking decl of proc -
Types: found 3 definition(s)
Types: Type checking -
Types: ** Type checking -: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         >=(y @count:31:65, x @count:31:71)
Types:         foreign llvm sub(x @count:31:52, y @count:31:54, ?tmp#0 @count:31:35)
Types:         foreign llvm move(tmp#0, ?#result @count:31:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.count, y:wybe.count, ?#result:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of '#result' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable #result type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {>=(y @count:31:65, x @count:31:71)}
Types: Recording casts in {foreign llvm sub(x @count:31:52, y @count:31:54, ?tmp#0 @count:31:35)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @count:31:5)}
Types: Unifying move argument types tmp#0 and ?#result @count:31:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @count:31:5
Types:   Type = wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: *** Before calls Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {>=(y @count:31:65, x @count:31:71)} @count:31:65, typingInfos = [wybe.comparison.>=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.>=<0>(wybe.count,wybe.count,?wybe.bool)]}Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Type checking call {>=(y @count:31:65, x @count:31:71)} @count:31:65
Types: Candidate types:
Types:     wybe.comparison.>=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.>=<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr y @count:31:65
Types:   Type = wybe.count
Types: Finding type of expr x @count:31:71
Types:   Type = wybe.count
Types: Actual types: [wybe.count,wybe.count]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.>=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 31, column 65): Type error in call to >=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 31, column 65): Type error in call to >=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.>=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Finding type of expr x @count:31:52
Types:   Type = wybe.count
Types: Finding type of expr y @count:31:54
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:31:35
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Type checking foreign llvm call sub(64 bit unsigned, 64 bit unsigned, 64 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?#result @count:31:5
Types:   Type = wybe.count
Types: Type checking foreign llvm call move(64 bit unsigned, 64 bit unsigned)
Types: Now mode checking proc -
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt >=(y @count:31:65, x @count:31:71)
Types: Mode checking call   : {>=(y @count:31:65, x @count:31:71)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Finding type of expr y @count:31:65
Types:   Type = wybe.count
Types: Finding type of expr x @count:31:71
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.>=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 31, column 65): Type error in call to >=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 31, column 65): Type error in call to >=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.>=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.>=<0>(wybe.count,wybe.count),Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: [({test} wybe.count.>=<0>(wybe.count,wybe.count),Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Exact mode matches: [({test} wybe.count.>=<0>(wybe.count,wybe.count),Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Finding type of expr y @count:31:65
Types:   Type = wybe.count
Types: Finding type of expr x @count:31:71
Types:   Type = wybe.count
Types: Finalising call    :  {wybe.count.<0>>=(y:wybe.count @count:31:65, x:wybe.count @count:31:71)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.count.<0>>=(y:wybe.count @count:31:65, x:wybe.count @count:31:71)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '-'
Types: Now assigned = semipure test computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm sub(x @count:31:52, y @count:31:54, ?tmp#0 @count:31:35)
Types: Mode checking foreign call {foreign llvm sub(x @count:31:52, y @count:31:54, ?tmp#0 @count:31:35)}
Types:     with assigned semipure test computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:31:52
Types:   Type = wybe.count
Types: Finding type of expr y @count:31:54
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:31:35
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,wybe.count,?wybe.count]
Types: New instr = {foreign llvm sub(x:wybe.count @count:31:52, y:wybe.count @count:31:54, ?tmp#0:wybe.count @count:31:35)}
Types: Now assigned = semipure test computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @count:31:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @count:31:5)}
Types:     with assigned semipure test computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?#result @count:31:5
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:31:5)}
Types: Now assigned = semipure test computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc '-'
Types: Mode checked body   : [{wybe.count.<0>>=(y:wybe.count @count:31:65, x:wybe.count @count:31:71)} @count:31:65,{foreign llvm sub(x:wybe.count @count:31:52, y:wybe.count @count:31:54, ?tmp#0:wybe.count @count:31:35)} @count:31:35,{foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:31:5)} @count:31:5]
Types: Vars defined by body: semipure test computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking -
Types: ** Type checking -: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm add(z @count:32:59, y @count:32:61, ?tmp#0 @count:32:42)
Types:         =(?x @count:32:38, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y","z"]
Types: Recording parameter types: ?x:wybe.count, y:wybe.count, z:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of 'z' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable z type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {foreign llvm add(z @count:32:59, y @count:32:61, ?tmp#0 @count:32:42)}
Types: Recording casts in {=(?x @count:32:38, tmp#0)}
Types: *** Before calls Typing {x::wybe.count, y::wybe.count, z::wybe.count}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {=(?x @count:32:38, tmp#0)} @count:32:38, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)]}Typing {x::wybe.count, y::wybe.count, z::wybe.count}; {} (with no errors)
Types: Type checking call {=(?x @count:32:38, tmp#0)} @count:32:38
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr ?x @count:32:38
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Actual types: [wybe.count,0]
Types: Matching types [wybe.count,0] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 32, column 38): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.count,0] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 32, column 38): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.count,0] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors)
Types: Finding type of expr z @count:32:59
Types:   Type = wybe.count
Types: Finding type of expr y @count:32:61
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:32:42
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Type checking foreign llvm call add(64 bit unsigned, 64 bit unsigned, 64 bit unsigned)
Types: Now mode checking proc -
Types: bound vars: semipure normal (total) computation binding {y, z}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm add(z @count:32:59, y @count:32:61, ?tmp#0 @count:32:42)
Types: Mode checking foreign call {foreign llvm add(z @count:32:59, y @count:32:61, ?tmp#0 @count:32:42)}
Types:     with assigned semipure normal (total) computation binding {y, z}, break set = Everything, with resources {}
Types: Mode check exp z
Types: Mode check exp resulted in z
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr z @count:32:59
Types:   Type = wybe.count
Types: Finding type of expr y @count:32:61
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:32:42
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,wybe.count,?wybe.count]
Types: New instr = {foreign llvm add(z:wybe.count @count:32:59, y:wybe.count @count:32:61, ?tmp#0:wybe.count @count:32:42)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @count:32:38, tmp#0)
Types: Mode checking call   : {=(?x @count:32:38, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @count:32:38
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 32, column 38): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 32, column 38): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 32, column 38): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 32, column 38): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.=<0>(wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @count:32:38)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?x @count:32:38
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:32:38)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Mode check end of Det proc '-'
Types: Mode checked body   : [{foreign llvm add(z:wybe.count @count:32:59, y:wybe.count @count:32:61, ?tmp#0:wybe.count @count:32:42)} @count:32:42,{foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:32:38)} @count:32:38]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking -
Types: ** Type checking -: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm sub(z @count:33:59, x @count:33:61, ?tmp#0 @count:33:42)
Types:         =(?y @count:33:38, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y","z"]
Types: Recording parameter types: x:wybe.count, ?y:wybe.count, z:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of 'z' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable z type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {foreign llvm sub(z @count:33:59, x @count:33:61, ?tmp#0 @count:33:42)}
Types: Recording casts in {=(?y @count:33:38, tmp#0)}
Types: *** Before calls Typing {x::wybe.count, y::wybe.count, z::wybe.count}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {=(?y @count:33:38, tmp#0)} @count:33:38, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)]}Typing {x::wybe.count, y::wybe.count, z::wybe.count}; {} (with no errors)
Types: Type checking call {=(?y @count:33:38, tmp#0)} @count:33:38
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr ?y @count:33:38
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Actual types: [wybe.count,0]
Types: Matching types [wybe.count,0] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 33, column 38): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.count,0] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 33, column 38): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.count,0] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors)
Types: Finding type of expr z @count:33:59
Types:   Type = wybe.count
Types: Finding type of expr x @count:33:61
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:33:42
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Type checking foreign llvm call sub(64 bit unsigned, 64 bit unsigned, 64 bit unsigned)
Types: Now mode checking proc -
Types: bound vars: semipure normal (total) computation binding {x, z}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm sub(z @count:33:59, x @count:33:61, ?tmp#0 @count:33:42)
Types: Mode checking foreign call {foreign llvm sub(z @count:33:59, x @count:33:61, ?tmp#0 @count:33:42)}
Types:     with assigned semipure normal (total) computation binding {x, z}, break set = Everything, with resources {}
Types: Mode check exp z
Types: Mode check exp resulted in z
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr z @count:33:59
Types:   Type = wybe.count
Types: Finding type of expr x @count:33:61
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:33:42
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,wybe.count,?wybe.count]
Types: New instr = {foreign llvm sub(z:wybe.count @count:33:59, x:wybe.count @count:33:61, ?tmp#0:wybe.count @count:33:42)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check stmt =(?y @count:33:38, tmp#0)
Types: Mode checking call   : {=(?y @count:33:38, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check exp ?y
Types: Mode check exp resulted in ?y
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?y @count:33:38
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 33, column 38): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 33, column 38): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 33, column 38): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 33, column 38): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.=<0>(wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?y @count:33:38)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?y
Types: Mode check exp resulted in ?y
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?y @count:33:38
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count, ?y:wybe.count @count:33:38)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Mode check end of Det proc '-'
Types: Mode checked body   : [{foreign llvm sub(z:wybe.count @count:33:59, x:wybe.count @count:33:61, ?tmp#0:wybe.count @count:33:42)} @count:33:42,{foreign llvm move(tmp#0:wybe.count, ?y:wybe.count @count:33:38)} @count:33:38]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Output parameters   : y
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of -:
Types: 
Types: - > public {test} (0 calls)
Types: 4: -(x:wybe.count @count:31:20, y:wybe.count @count:31:26, ?#result:wybe.count @count:31:5):
Types:     wybe.count.<0>>=(y:wybe.count @count:31:65, x:wybe.count @count:31:71)
Types:     foreign llvm sub(x:wybe.count @count:31:52, y:wybe.count @count:31:54, ?tmp#0:wybe.count @count:31:35)
Types:     foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:31:5)
Types: 
Types: - > public (0 calls)
Types: 4: -(?x:wybe.count @count:32:11, y:wybe.count @count:32:17, z:wybe.count @count:32:5):
Types:     foreign llvm add(z:wybe.count @count:32:59, y:wybe.count @count:32:61, ?tmp#0:wybe.count @count:32:42)
Types:     foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:32:38)
Types: 
Types: - > public (0 calls)
Types: 4: -(x:wybe.count @count:33:10, ?y:wybe.count @count:33:17, z:wybe.count @count:33:5):
Types:     foreign llvm sub(z:wybe.count @count:33:59, x:wybe.count @count:33:61, ?tmp#0:wybe.count @count:33:42)
Types:     foreign llvm move(tmp#0:wybe.count, ?y:wybe.count @count:33:38)
Types: Type checking non-recursive proc wybe.count.-=
Types: ** Type checking decl of proc -=
Types: found 1 definition(s)
Types: Type checking -=
Types: ** Type checking -=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         -(x @count:36:41, y @count:36:45, ?tmp#0 @count:36:41)
Types:         =(?x @count:36:37, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y"]
Types: Recording parameter types: !x:wybe.count, y:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {-(x @count:36:41, y @count:36:45, ?tmp#0 @count:36:41)}
Types: Recording casts in {=(?x @count:36:37, tmp#0)}
Types: *** Before calls Typing {x::wybe.count, y::wybe.count}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {-(x @count:36:41, y @count:36:45, ?tmp#0 @count:36:41)} @count:36:41, typingInfos = [{test} wybe.count.-<0>(wybe.count,wybe.count,?wybe.count),wybe.count.-<1>(?wybe.count,wybe.count,wybe.count),wybe.count.-<2>(wybe.count,?wybe.count,wybe.count)]}
Types:     StmtTypings {typingStmt = {=(?x @count:36:37, tmp#0)} @count:36:37, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)]}Typing {x::wybe.count, y::wybe.count}; {} (with no errors)
Types: Type checking call {-(x @count:36:41, y @count:36:45, ?tmp#0 @count:36:41)} @count:36:41
Types: Candidate types:
Types:     {test} wybe.count.-<0>(wybe.count,wybe.count,?wybe.count)
Types:     wybe.count.-<1>(?wybe.count,wybe.count,wybe.count)
Types:     wybe.count.-<2>(wybe.count,?wybe.count,wybe.count)
Types: Finding type of expr x @count:36:41
Types:   Type = wybe.count
Types: Finding type of expr y @count:36:45
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:36:41
Types:   Type = 0
Types: Actual types: [wybe.count,wybe.count,0]
Types: Matching types [wybe.count,wybe.count,0] with {test} wybe.count.-<0>(wybe.count,wybe.count,?wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Matching types [wybe.count,wybe.count,0] with wybe.count.-<1>(?wybe.count,wybe.count,wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Matching types [wybe.count,wybe.count,0] with wybe.count.-<2>(wybe.count,?wybe.count,wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Type checking call {=(?x @count:36:37, tmp#0)} @count:36:37
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr ?x @count:36:37
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Actual types: [wybe.count,wybe.count]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 36, column 37): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 36, column 37): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 36, column 37): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 36, column 37): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Now mode checking proc -=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt -(x @count:36:41, y @count:36:45, ?tmp#0 @count:36:41)
Types: Mode checking call   : {-(x @count:36:41, y @count:36:45, ?tmp#0 @count:36:41)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:36:41
Types:   Type = wybe.count
Types: Finding type of expr y @count:36:45
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:36:41
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count,wybe.count]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.count,wybe.count,wybe.count] with {test} wybe.count.-<0>(wybe.count,wybe.count,?wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Matching types [wybe.count,wybe.count,wybe.count] with wybe.count.-<1>(?wybe.count,wybe.count,wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Matching types [wybe.count,wybe.count,wybe.count] with wybe.count.-<2>(wybe.count,?wybe.count,wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.-<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)),(wybe.count.-<1>(?wybe.count,wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)),(wybe.count.-<2>(wybe.count,?wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: [({test} wybe.count.-<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Exact mode matches: [({test} wybe.count.-<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Finding type of expr x @count:36:41
Types:   Type = wybe.count
Types: Finding type of expr y @count:36:45
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:36:41
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finalising call    :  {wybe.count.<0>-(x:wybe.count @count:36:41, y:wybe.count @count:36:45, ?tmp#0:wybe.count @count:36:41)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.count.<0>-(x:wybe.count @count:36:41, y:wybe.count @count:36:45, ?tmp#0:wybe.count @count:36:41)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '-='
Types: Now assigned = semipure test computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @count:36:37, tmp#0)
Types: Mode checking call   : {=(?x @count:36:37, tmp#0)}
Types:     with assigned    : semipure test computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @count:36:37
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 36, column 37): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 36, column 37): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 36, column 37): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 36, column 37): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.=<0>(wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @count:36:37)}
Types:     with assigned semipure test computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?x @count:36:37
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:36:37)}
Types: Now assigned = semipure test computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc '-='
Types: Mode checked body   : [{wybe.count.<0>-(x:wybe.count @count:36:41, y:wybe.count @count:36:45, ?tmp#0:wybe.count @count:36:41)} @count:36:41,{foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:36:37)} @count:36:37]
Types: Vars defined by body: semipure test computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of -=:
Types: 
Types: -= > public {test} (0 calls)
Types: 4: -=(!x:wybe.count @count:36:21, y:wybe.count @count:36:29):
Types:     wybe.count.<0>-(x:wybe.count @count:36:41, y:wybe.count @count:36:45, ?tmp#0:wybe.count @count:36:41)
Types:     foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:36:37)
Types: Type checking non-recursive proc wybe.count.decr
Types: ** Type checking decl of proc decr
Types: found 1 definition(s)
Types: Type checking decr
Types: ** Type checking decr: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         -(x @count:84:37, 1:_ @count:84:41, ?tmp#0 @count:84:37)
Types:         =(?x @count:84:33, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x"]
Types: Recording parameter types: !x:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {-(x @count:84:37, 1:_ @count:84:41, ?tmp#0 @count:84:37)}
Types: Recording casts in {=(?x @count:84:33, tmp#0)}
Types: *** Before calls Typing {x::wybe.count}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {-(x @count:84:37, 1:_ @count:84:41, ?tmp#0 @count:84:37)} @count:84:37, typingInfos = [{test} wybe.count.-<0>(wybe.count,wybe.count,?wybe.count),wybe.count.-<1>(?wybe.count,wybe.count,wybe.count),wybe.count.-<2>(wybe.count,?wybe.count,wybe.count)]}
Types:     StmtTypings {typingStmt = {=(?x @count:84:33, tmp#0)} @count:84:33, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)]}Typing {x::wybe.count}; {} (with no errors)
Types: Type checking call {-(x @count:84:37, 1:_ @count:84:41, ?tmp#0 @count:84:37)} @count:84:37
Types: Candidate types:
Types:     {test} wybe.count.-<0>(wybe.count,wybe.count,?wybe.count)
Types:     wybe.count.-<1>(?wybe.count,wybe.count,wybe.count)
Types:     wybe.count.-<2>(wybe.count,?wybe.count,wybe.count)
Types: Finding type of expr x @count:84:37
Types:   Type = wybe.count
Types: Finding type of expr 1:_ @count:84:41
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:84:37
Types:   Type = 0
Types: Actual types: [wybe.count,wybe.count,0]
Types: Matching types [wybe.count,wybe.count,0] with {test} wybe.count.-<0>(wybe.count,wybe.count,?wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Matching types [wybe.count,wybe.count,0] with wybe.count.-<1>(?wybe.count,wybe.count,wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Matching types [wybe.count,wybe.count,0] with wybe.count.-<2>(wybe.count,?wybe.count,wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors)
Types: Type checking call {=(?x @count:84:33, tmp#0)} @count:84:33
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr ?x @count:84:33
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Actual types: [wybe.count,wybe.count]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 84, column 33): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 84, column 33): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 84, column 33): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 84, column 33): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors)
Types: Now mode checking proc decr
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt -(x @count:84:37, 1:_ @count:84:41, ?tmp#0 @count:84:37)
Types: Mode checking call   : {-(x @count:84:37, 1:_ @count:84:41, ?tmp#0 @count:84:37)}
Types:     with assigned    : semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp 1:_
Types: Mode check exp resulted in 1:_
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:84:37
Types:   Type = wybe.count
Types: Finding type of expr 1:_ @count:84:41
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:84:37
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count,wybe.count]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.count,wybe.count,wybe.count] with {test} wybe.count.-<0>(wybe.count,wybe.count,?wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Matching types [wybe.count,wybe.count,wybe.count] with wybe.count.-<1>(?wybe.count,wybe.count,wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Matching types [wybe.count,wybe.count,wybe.count] with wybe.count.-<2>(wybe.count,?wybe.count,wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.-<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors)),(wybe.count.-<1>(?wybe.count,wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors)),(wybe.count.-<2>(wybe.count,?wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: [({test} wybe.count.-<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors))]
Types: Exact mode matches: [({test} wybe.count.-<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors))]
Types: Finding type of expr x @count:84:37
Types:   Type = wybe.count
Types: Finding type of expr 1:_ @count:84:41
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:84:37
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finalising call    :  {wybe.count.<0>-(x:wybe.count @count:84:37, 1:wybe.count @count:84:41, ?tmp#0:wybe.count @count:84:37)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.count.<0>-(x:wybe.count @count:84:37, 1:wybe.count @count:84:41, ?tmp#0:wybe.count @count:84:37)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc 'decr'
Types: Now assigned = semipure test computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @count:84:33, tmp#0)
Types: Mode checking call   : {=(?x @count:84:33, tmp#0)}
Types:     with assigned    : semipure test computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @count:84:33
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 84, column 33): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 84, column 33): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 84, column 33): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 84, column 33): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.=<0>(wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @count:84:33)}
Types:     with assigned semipure test computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?x @count:84:33
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:84:33)}
Types: Now assigned = semipure test computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'decr'
Types: Mode checked body   : [{wybe.count.<0>-(x:wybe.count @count:84:37, 1:wybe.count @count:84:41, ?tmp#0:wybe.count @count:84:37)} @count:84:37,{foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:84:33)} @count:84:33]
Types: Vars defined by body: semipure test computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of decr:
Types: 
Types: decr > public {test} (0 calls)
Types: 4: decr(!x:wybe.count @count:84:25):
Types:     wybe.count.<0>-(x:wybe.count @count:84:37, 1:wybe.count @count:84:41, ?tmp#0:wybe.count @count:84:37)
Types:     foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:84:33)
Types: Type checking non-recursive proc wybe.count.+
Types: ** Type checking decl of proc +
Types: found 3 definition(s)
Types: Type checking +
Types: ** Type checking +: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm add(x @count:15:42, y @count:15:44, ?tmp#0 @count:15:25)
Types:         foreign llvm move(tmp#0, ?#result @count:15:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.count, y:wybe.count, ?#result:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of '#result' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable #result type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {foreign llvm add(x @count:15:42, y @count:15:44, ?tmp#0 @count:15:25)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @count:15:5)}
Types: Unifying move argument types tmp#0 and ?#result @count:15:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @count:15:5
Types:   Type = wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: *** Before calls Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Finding type of expr x @count:15:42
Types:   Type = wybe.count
Types: Finding type of expr y @count:15:44
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:15:25
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Type checking foreign llvm call add(64 bit unsigned, 64 bit unsigned, 64 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?#result @count:15:5
Types:   Type = wybe.count
Types: Type checking foreign llvm call move(64 bit unsigned, 64 bit unsigned)
Types: Now mode checking proc +
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm add(x @count:15:42, y @count:15:44, ?tmp#0 @count:15:25)
Types: Mode checking foreign call {foreign llvm add(x @count:15:42, y @count:15:44, ?tmp#0 @count:15:25)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:15:42
Types:   Type = wybe.count
Types: Finding type of expr y @count:15:44
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:15:25
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,wybe.count,?wybe.count]
Types: New instr = {foreign llvm add(x:wybe.count @count:15:42, y:wybe.count @count:15:44, ?tmp#0:wybe.count @count:15:25)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @count:15:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @count:15:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?#result @count:15:5
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:15:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '+'
Types: Mode checked body   : [{foreign llvm add(x:wybe.count @count:15:42, y:wybe.count @count:15:44, ?tmp#0:wybe.count @count:15:25)} @count:15:25,{foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:15:5)} @count:15:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking +
Types: ** Type checking +: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         >=(z @count:17:5, y @count:17:11)
Types:         foreign llvm sub(z @count:18:27, y @count:18:29, ?tmp#0 @count:18:10)
Types:         =(?x @count:18:6, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y","z"]
Types: Recording parameter types: ?x:wybe.count, y:wybe.count, z:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of 'z' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable z type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {>=(z @count:17:5, y @count:17:11)}
Types: Recording casts in {foreign llvm sub(z @count:18:27, y @count:18:29, ?tmp#0 @count:18:10)}
Types: Recording casts in {=(?x @count:18:6, tmp#0)}
Types: *** Before calls Typing {x::wybe.count, y::wybe.count, z::wybe.count}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {>=(z @count:17:5, y @count:17:11)} @count:17:5, typingInfos = [wybe.comparison.>=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.>=<0>(wybe.count,wybe.count,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {=(?x @count:18:6, tmp#0)} @count:18:6, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)]}Typing {x::wybe.count, y::wybe.count, z::wybe.count}; {} (with no errors)
Types: Type checking call {>=(z @count:17:5, y @count:17:11)} @count:17:5
Types: Candidate types:
Types:     wybe.comparison.>=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.>=<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr z @count:17:5
Types:   Type = wybe.count
Types: Finding type of expr y @count:17:11
Types:   Type = wybe.count
Types: Actual types: [wybe.count,wybe.count]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.>=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 17, column 5): Type error in call to >=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 17, column 5): Type error in call to >=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.>=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {x::wybe.count, y::wybe.count, z::wybe.count}; {} (with no errors)]
Types: Resulting typing = Typing {x::wybe.count, y::wybe.count, z::wybe.count}; {} (with no errors)
Types: Type checking call {=(?x @count:18:6, tmp#0)} @count:18:6
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr ?x @count:18:6
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Actual types: [wybe.count,0]
Types: Matching types [wybe.count,0] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 18, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.count,0] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 18, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.count,0] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors)
Types: Finding type of expr z @count:18:27
Types:   Type = wybe.count
Types: Finding type of expr y @count:18:29
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:18:10
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Type checking foreign llvm call sub(64 bit unsigned, 64 bit unsigned, 64 bit unsigned)
Types: Now mode checking proc +
Types: bound vars: semipure normal (total) computation binding {y, z}, break set = Everything, with resources {}
Types: Mode check stmt >=(z @count:17:5, y @count:17:11)
Types: Mode checking call   : {>=(z @count:17:5, y @count:17:11)}
Types:     with assigned    : semipure normal (total) computation binding {y, z}, break set = Everything, with resources {}
Types: Mode check exp z
Types: Mode check exp resulted in z
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Finding type of expr z @count:17:5
Types:   Type = wybe.count
Types: Finding type of expr y @count:17:11
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.>=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 17, column 5): Type error in call to >=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 17, column 5): Type error in call to >=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.>=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.>=<0>(wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: [({test} wybe.count.>=<0>(wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors))]
Types: Exact mode matches: [({test} wybe.count.>=<0>(wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors))]
Types: Finding type of expr z @count:17:5
Types:   Type = wybe.count
Types: Finding type of expr y @count:17:11
Types:   Type = wybe.count
Types: Finalising call    :  {wybe.count.<0>>=(z:wybe.count @count:17:5, y:wybe.count @count:17:11)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"y", "z"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.count.<0>>=(z:wybe.count @count:17:5, y:wybe.count @count:17:11)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '+'
Types: Now assigned = semipure test computation binding {y, z}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm sub(z @count:18:27, y @count:18:29, ?tmp#0 @count:18:10)
Types: Mode checking foreign call {foreign llvm sub(z @count:18:27, y @count:18:29, ?tmp#0 @count:18:10)}
Types:     with assigned semipure test computation binding {y, z}, break set = Everything, with resources {}
Types: Mode check exp z
Types: Mode check exp resulted in z
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr z @count:18:27
Types:   Type = wybe.count
Types: Finding type of expr y @count:18:29
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:18:10
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,wybe.count,?wybe.count]
Types: New instr = {foreign llvm sub(z:wybe.count @count:18:27, y:wybe.count @count:18:29, ?tmp#0:wybe.count @count:18:10)}
Types: Now assigned = semipure test computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @count:18:6, tmp#0)
Types: Mode checking call   : {=(?x @count:18:6, tmp#0)}
Types:     with assigned    : semipure test computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @count:18:6
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 18, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 18, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 18, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 18, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.=<0>(wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @count:18:6)}
Types:     with assigned semipure test computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?x @count:18:6
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:18:6)}
Types: Now assigned = semipure test computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc '+'
Types: Mode checked body   : [{wybe.count.<0>>=(z:wybe.count @count:17:5, y:wybe.count @count:17:11)} @count:17:5,{foreign llvm sub(z:wybe.count @count:18:27, y:wybe.count @count:18:29, ?tmp#0:wybe.count @count:18:10)} @count:18:10,{foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:18:6)} @count:18:6]
Types: Vars defined by body: semipure test computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking +
Types: ** Type checking +: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         >=(z @count:21:5, x @count:21:11)
Types:         foreign llvm sub(z @count:22:27, x @count:22:29, ?tmp#0 @count:22:10)
Types:         =(?y @count:22:6, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y","z"]
Types: Recording parameter types: x:wybe.count, ?y:wybe.count, z:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of 'z' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable z type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {>=(z @count:21:5, x @count:21:11)}
Types: Recording casts in {foreign llvm sub(z @count:22:27, x @count:22:29, ?tmp#0 @count:22:10)}
Types: Recording casts in {=(?y @count:22:6, tmp#0)}
Types: *** Before calls Typing {x::wybe.count, y::wybe.count, z::wybe.count}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {>=(z @count:21:5, x @count:21:11)} @count:21:5, typingInfos = [wybe.comparison.>=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.>=<0>(wybe.count,wybe.count,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {=(?y @count:22:6, tmp#0)} @count:22:6, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)]}Typing {x::wybe.count, y::wybe.count, z::wybe.count}; {} (with no errors)
Types: Type checking call {>=(z @count:21:5, x @count:21:11)} @count:21:5
Types: Candidate types:
Types:     wybe.comparison.>=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.>=<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr z @count:21:5
Types:   Type = wybe.count
Types: Finding type of expr x @count:21:11
Types:   Type = wybe.count
Types: Actual types: [wybe.count,wybe.count]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.>=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 21, column 5): Type error in call to >=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 21, column 5): Type error in call to >=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.>=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {x::wybe.count, y::wybe.count, z::wybe.count}; {} (with no errors)]
Types: Resulting typing = Typing {x::wybe.count, y::wybe.count, z::wybe.count}; {} (with no errors)
Types: Type checking call {=(?y @count:22:6, tmp#0)} @count:22:6
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr ?y @count:22:6
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Actual types: [wybe.count,0]
Types: Matching types [wybe.count,0] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 22, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.count,0] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 22, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.count,0] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors)
Types: Finding type of expr z @count:22:27
Types:   Type = wybe.count
Types: Finding type of expr x @count:22:29
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:22:10
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Type checking foreign llvm call sub(64 bit unsigned, 64 bit unsigned, 64 bit unsigned)
Types: Now mode checking proc +
Types: bound vars: semipure normal (total) computation binding {x, z}, break set = Everything, with resources {}
Types: Mode check stmt >=(z @count:21:5, x @count:21:11)
Types: Mode checking call   : {>=(z @count:21:5, x @count:21:11)}
Types:     with assigned    : semipure normal (total) computation binding {x, z}, break set = Everything, with resources {}
Types: Mode check exp z
Types: Mode check exp resulted in z
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Finding type of expr z @count:21:5
Types:   Type = wybe.count
Types: Finding type of expr x @count:21:11
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.>=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 21, column 5): Type error in call to >=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 21, column 5): Type error in call to >=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.>=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.>=<0>(wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: [({test} wybe.count.>=<0>(wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors))]
Types: Exact mode matches: [({test} wybe.count.>=<0>(wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors))]
Types: Finding type of expr z @count:21:5
Types:   Type = wybe.count
Types: Finding type of expr x @count:21:11
Types:   Type = wybe.count
Types: Finalising call    :  {wybe.count.<0>>=(z:wybe.count @count:21:5, x:wybe.count @count:21:11)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "z"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.count.<0>>=(z:wybe.count @count:21:5, x:wybe.count @count:21:11)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '+'
Types: Now assigned = semipure test computation binding {x, z}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm sub(z @count:22:27, x @count:22:29, ?tmp#0 @count:22:10)
Types: Mode checking foreign call {foreign llvm sub(z @count:22:27, x @count:22:29, ?tmp#0 @count:22:10)}
Types:     with assigned semipure test computation binding {x, z}, break set = Everything, with resources {}
Types: Mode check exp z
Types: Mode check exp resulted in z
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr z @count:22:27
Types:   Type = wybe.count
Types: Finding type of expr x @count:22:29
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:22:10
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,wybe.count,?wybe.count]
Types: New instr = {foreign llvm sub(z:wybe.count @count:22:27, x:wybe.count @count:22:29, ?tmp#0:wybe.count @count:22:10)}
Types: Now assigned = semipure test computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check stmt =(?y @count:22:6, tmp#0)
Types: Mode checking call   : {=(?y @count:22:6, tmp#0)}
Types:     with assigned    : semipure test computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check exp ?y
Types: Mode check exp resulted in ?y
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?y @count:22:6
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 22, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 22, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 22, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 22, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.=<0>(wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count, z::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?y @count:22:6)}
Types:     with assigned semipure test computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?y
Types: Mode check exp resulted in ?y
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?y @count:22:6
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count, ?y:wybe.count @count:22:6)}
Types: Now assigned = semipure test computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc '+'
Types: Mode checked body   : [{wybe.count.<0>>=(z:wybe.count @count:21:5, x:wybe.count @count:21:11)} @count:21:5,{foreign llvm sub(z:wybe.count @count:22:27, x:wybe.count @count:22:29, ?tmp#0:wybe.count @count:22:10)} @count:22:10,{foreign llvm move(tmp#0:wybe.count, ?y:wybe.count @count:22:6)} @count:22:6]
Types: Vars defined by body: semipure test computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Output parameters   : y
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of +:
Types: 
Types: + > public (0 calls)
Types: 4: +(x:wybe.count @count:15:10, y:wybe.count @count:15:16, ?#result:wybe.count @count:15:5):
Types:     foreign llvm add(x:wybe.count @count:15:42, y:wybe.count @count:15:44, ?tmp#0:wybe.count @count:15:25)
Types:     foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:15:5)
Types: 
Types: + > public {test} (0 calls)
Types: 4: +(?x:wybe.count @count:16:21, y:wybe.count @count:16:27, z:wybe.count @count:16:5):
Types:     wybe.count.<0>>=(z:wybe.count @count:17:5, y:wybe.count @count:17:11)
Types:     foreign llvm sub(z:wybe.count @count:18:27, y:wybe.count @count:18:29, ?tmp#0:wybe.count @count:18:10)
Types:     foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:18:6)
Types: 
Types: + > public {test} (0 calls)
Types: 4: +(x:wybe.count @count:20:20, ?y:wybe.count @count:20:27, z:wybe.count @count:20:5):
Types:     wybe.count.<0>>=(z:wybe.count @count:21:5, x:wybe.count @count:21:11)
Types:     foreign llvm sub(z:wybe.count @count:22:27, x:wybe.count @count:22:29, ?tmp#0:wybe.count @count:22:10)
Types:     foreign llvm move(tmp#0:wybe.count, ?y:wybe.count @count:22:6)
Types: Type checking non-recursive proc wybe.count.+=
Types: ** Type checking decl of proc +=
Types: found 1 definition(s)
Types: Type checking +=
Types: ** Type checking +=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         +(x @count:26:31, y @count:26:35, ?tmp#0 @count:26:31)
Types:         =(?x @count:26:27, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y"]
Types: Recording parameter types: !x:wybe.count, y:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {+(x @count:26:31, y @count:26:35, ?tmp#0 @count:26:31)}
Types: Recording casts in {=(?x @count:26:27, tmp#0)}
Types: *** Before calls Typing {x::wybe.count, y::wybe.count}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {+(x @count:26:31, y @count:26:35, ?tmp#0 @count:26:31)} @count:26:31, typingInfos = [wybe.count.+<0>(wybe.count,wybe.count,?wybe.count),{test} wybe.count.+<1>(?wybe.count,wybe.count,wybe.count),{test} wybe.count.+<2>(wybe.count,?wybe.count,wybe.count)]}
Types:     StmtTypings {typingStmt = {=(?x @count:26:27, tmp#0)} @count:26:27, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)]}Typing {x::wybe.count, y::wybe.count}; {} (with no errors)
Types: Type checking call {+(x @count:26:31, y @count:26:35, ?tmp#0 @count:26:31)} @count:26:31
Types: Candidate types:
Types:     wybe.count.+<0>(wybe.count,wybe.count,?wybe.count)
Types:     {test} wybe.count.+<1>(?wybe.count,wybe.count,wybe.count)
Types:     {test} wybe.count.+<2>(wybe.count,?wybe.count,wybe.count)
Types: Finding type of expr x @count:26:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:26:35
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:26:31
Types:   Type = 0
Types: Actual types: [wybe.count,wybe.count,0]
Types: Matching types [wybe.count,wybe.count,0] with wybe.count.+<0>(wybe.count,wybe.count,?wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Matching types [wybe.count,wybe.count,0] with {test} wybe.count.+<1>(?wybe.count,wybe.count,wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Matching types [wybe.count,wybe.count,0] with {test} wybe.count.+<2>(wybe.count,?wybe.count,wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Type checking call {=(?x @count:26:27, tmp#0)} @count:26:27
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr ?x @count:26:27
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Actual types: [wybe.count,wybe.count]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 26, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 26, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 26, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 26, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Now mode checking proc +=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt +(x @count:26:31, y @count:26:35, ?tmp#0 @count:26:31)
Types: Mode checking call   : {+(x @count:26:31, y @count:26:35, ?tmp#0 @count:26:31)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:26:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:26:35
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:26:31
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count,wybe.count]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.count,wybe.count,wybe.count] with wybe.count.+<0>(wybe.count,wybe.count,?wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Matching types [wybe.count,wybe.count,wybe.count] with {test} wybe.count.+<1>(?wybe.count,wybe.count,wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Matching types [wybe.count,wybe.count,wybe.count] with {test} wybe.count.+<2>(wybe.count,?wybe.count,wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [(wybe.count.+<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)),({test} wybe.count.+<1>(?wybe.count,wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)),({test} wybe.count.+<2>(wybe.count,?wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: [(wybe.count.+<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Exact mode matches: [(wybe.count.+<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Finding type of expr x @count:26:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:26:35
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:26:31
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finalising call    :  {wybe.count.<0>+(x:wybe.count @count:26:31, y:wybe.count @count:26:35, ?tmp#0:wybe.count @count:26:31)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.count.<0>+(x:wybe.count @count:26:31, y:wybe.count @count:26:35, ?tmp#0:wybe.count @count:26:31)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '+='
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @count:26:27, tmp#0)
Types: Mode checking call   : {=(?x @count:26:27, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @count:26:27
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 26, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 26, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 26, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 26, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.=<0>(wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @count:26:27)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?x @count:26:27
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:26:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '+='
Types: Mode checked body   : [{wybe.count.<0>+(x:wybe.count @count:26:31, y:wybe.count @count:26:35, ?tmp#0:wybe.count @count:26:31)} @count:26:31,{foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:26:27)} @count:26:27]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of +=:
Types: 
Types: += > public (0 calls)
Types: 4: +=(!x:wybe.count @count:26:11, y:wybe.count @count:26:19):
Types:     wybe.count.<0>+(x:wybe.count @count:26:31, y:wybe.count @count:26:35, ?tmp#0:wybe.count @count:26:31)
Types:     foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:26:27)
Types: Type checking non-recursive proc wybe.count.incr
Types: ** Type checking decl of proc incr
Types: found 1 definition(s)
Types: Type checking incr
Types: ** Type checking incr: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         +(x @count:81:27, 1:_ @count:81:31, ?tmp#0 @count:81:27)
Types:         =(?x @count:81:23, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x"]
Types: Recording parameter types: !x:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {+(x @count:81:27, 1:_ @count:81:31, ?tmp#0 @count:81:27)}
Types: Recording casts in {=(?x @count:81:23, tmp#0)}
Types: *** Before calls Typing {x::wybe.count}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {+(x @count:81:27, 1:_ @count:81:31, ?tmp#0 @count:81:27)} @count:81:27, typingInfos = [wybe.count.+<0>(wybe.count,wybe.count,?wybe.count),{test} wybe.count.+<1>(?wybe.count,wybe.count,wybe.count),{test} wybe.count.+<2>(wybe.count,?wybe.count,wybe.count)]}
Types:     StmtTypings {typingStmt = {=(?x @count:81:23, tmp#0)} @count:81:23, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)]}Typing {x::wybe.count}; {} (with no errors)
Types: Type checking call {+(x @count:81:27, 1:_ @count:81:31, ?tmp#0 @count:81:27)} @count:81:27
Types: Candidate types:
Types:     wybe.count.+<0>(wybe.count,wybe.count,?wybe.count)
Types:     {test} wybe.count.+<1>(?wybe.count,wybe.count,wybe.count)
Types:     {test} wybe.count.+<2>(wybe.count,?wybe.count,wybe.count)
Types: Finding type of expr x @count:81:27
Types:   Type = wybe.count
Types: Finding type of expr 1:_ @count:81:31
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:81:27
Types:   Type = 0
Types: Actual types: [wybe.count,wybe.count,0]
Types: Matching types [wybe.count,wybe.count,0] with wybe.count.+<0>(wybe.count,wybe.count,?wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Matching types [wybe.count,wybe.count,0] with {test} wybe.count.+<1>(?wybe.count,wybe.count,wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Matching types [wybe.count,wybe.count,0] with {test} wybe.count.+<2>(wybe.count,?wybe.count,wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors)
Types: Type checking call {=(?x @count:81:23, tmp#0)} @count:81:23
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr ?x @count:81:23
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Actual types: [wybe.count,wybe.count]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 81, column 23): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 81, column 23): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 81, column 23): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 81, column 23): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors)
Types: Now mode checking proc incr
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt +(x @count:81:27, 1:_ @count:81:31, ?tmp#0 @count:81:27)
Types: Mode checking call   : {+(x @count:81:27, 1:_ @count:81:31, ?tmp#0 @count:81:27)}
Types:     with assigned    : semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp 1:_
Types: Mode check exp resulted in 1:_
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:81:27
Types:   Type = wybe.count
Types: Finding type of expr 1:_ @count:81:31
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:81:27
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count,wybe.count]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.count,wybe.count,wybe.count] with wybe.count.+<0>(wybe.count,wybe.count,?wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Matching types [wybe.count,wybe.count,wybe.count] with {test} wybe.count.+<1>(?wybe.count,wybe.count,wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Matching types [wybe.count,wybe.count,wybe.count] with {test} wybe.count.+<2>(wybe.count,?wybe.count,wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [(wybe.count.+<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors)),({test} wybe.count.+<1>(?wybe.count,wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors)),({test} wybe.count.+<2>(wybe.count,?wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: [(wybe.count.+<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors))]
Types: Exact mode matches: [(wybe.count.+<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors))]
Types: Finding type of expr x @count:81:27
Types:   Type = wybe.count
Types: Finding type of expr 1:_ @count:81:31
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:81:27
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finalising call    :  {wybe.count.<0>+(x:wybe.count @count:81:27, 1:wybe.count @count:81:31, ?tmp#0:wybe.count @count:81:27)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.count.<0>+(x:wybe.count @count:81:27, 1:wybe.count @count:81:31, ?tmp#0:wybe.count @count:81:27)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'incr'
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @count:81:23, tmp#0)
Types: Mode checking call   : {=(?x @count:81:23, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @count:81:23
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 81, column 23): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 81, column 23): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 81, column 23): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 81, column 23): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.=<0>(wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @count:81:23)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?x @count:81:23
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:81:23)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'incr'
Types: Mode checked body   : [{wybe.count.<0>+(x:wybe.count @count:81:27, 1:wybe.count @count:81:31, ?tmp#0:wybe.count @count:81:27)} @count:81:27,{foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:81:23)} @count:81:23]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of incr:
Types: 
Types: incr > public (0 calls)
Types: 4: incr(!x:wybe.count @count:81:15):
Types:     wybe.count.<0>+(x:wybe.count @count:81:27, 1:wybe.count @count:81:31, ?tmp#0:wybe.count @count:81:27)
Types:     foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:81:23)
Types: Type checking non-recursive proc wybe.count.*
Types: ** Type checking decl of proc *
Types: found 1 definition(s)
Types: Type checking *
Types: ** Type checking *: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm mul(x @count:39:42, y @count:39:44, ?tmp#0 @count:39:25)
Types:         foreign llvm move(tmp#0, ?#result @count:39:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.count, y:wybe.count, ?#result:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of '#result' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable #result type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {foreign llvm mul(x @count:39:42, y @count:39:44, ?tmp#0 @count:39:25)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @count:39:5)}
Types: Unifying move argument types tmp#0 and ?#result @count:39:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @count:39:5
Types:   Type = wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: *** Before calls Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Finding type of expr x @count:39:42
Types:   Type = wybe.count
Types: Finding type of expr y @count:39:44
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:39:25
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Type checking foreign llvm call mul(64 bit unsigned, 64 bit unsigned, 64 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?#result @count:39:5
Types:   Type = wybe.count
Types: Type checking foreign llvm call move(64 bit unsigned, 64 bit unsigned)
Types: Now mode checking proc *
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm mul(x @count:39:42, y @count:39:44, ?tmp#0 @count:39:25)
Types: Mode checking foreign call {foreign llvm mul(x @count:39:42, y @count:39:44, ?tmp#0 @count:39:25)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:39:42
Types:   Type = wybe.count
Types: Finding type of expr y @count:39:44
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:39:25
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,wybe.count,?wybe.count]
Types: New instr = {foreign llvm mul(x:wybe.count @count:39:42, y:wybe.count @count:39:44, ?tmp#0:wybe.count @count:39:25)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @count:39:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @count:39:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?#result @count:39:5
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:39:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '*'
Types: Mode checked body   : [{foreign llvm mul(x:wybe.count @count:39:42, y:wybe.count @count:39:44, ?tmp#0:wybe.count @count:39:25)} @count:39:25,{foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:39:5)} @count:39:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of *:
Types: 
Types: * > public (0 calls)
Types: 4: *(x:wybe.count @count:39:10, y:wybe.count @count:39:16, ?#result:wybe.count @count:39:5):
Types:     foreign llvm mul(x:wybe.count @count:39:42, y:wybe.count @count:39:44, ?tmp#0:wybe.count @count:39:25)
Types:     foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:39:5)
Types: Type checking non-recursive proc wybe.count.*=
Types: ** Type checking decl of proc *=
Types: found 1 definition(s)
Types: Type checking *=
Types: ** Type checking *=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         *(x @count:42:31, y @count:42:35, ?tmp#0 @count:42:31)
Types:         =(?x @count:42:27, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y"]
Types: Recording parameter types: !x:wybe.count, y:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {*(x @count:42:31, y @count:42:35, ?tmp#0 @count:42:31)}
Types: Recording casts in {=(?x @count:42:27, tmp#0)}
Types: *** Before calls Typing {x::wybe.count, y::wybe.count}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {*(x @count:42:31, y @count:42:35, ?tmp#0 @count:42:31)} @count:42:31, typingInfos = [wybe.count.*<0>(wybe.count,wybe.count,?wybe.count)]}
Types:     StmtTypings {typingStmt = {=(?x @count:42:27, tmp#0)} @count:42:27, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)]}Typing {x::wybe.count, y::wybe.count}; {} (with no errors)
Types: Type checking call {*(x @count:42:31, y @count:42:35, ?tmp#0 @count:42:31)} @count:42:31
Types: Candidate types:
Types:     wybe.count.*<0>(wybe.count,wybe.count,?wybe.count)
Types: Finding type of expr x @count:42:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:42:35
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:42:31
Types:   Type = 0
Types: Actual types: [wybe.count,wybe.count,0]
Types: Matching types [wybe.count,wybe.count,0] with wybe.count.*<0>(wybe.count,wybe.count,?wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Type checking call {=(?x @count:42:27, tmp#0)} @count:42:27
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr ?x @count:42:27
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Actual types: [wybe.count,wybe.count]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 42, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 42, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 42, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 42, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Now mode checking proc *=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt *(x @count:42:31, y @count:42:35, ?tmp#0 @count:42:31)
Types: Mode checking call   : {*(x @count:42:31, y @count:42:35, ?tmp#0 @count:42:31)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:42:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:42:35
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:42:31
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count,wybe.count]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.count,wybe.count,wybe.count] with wybe.count.*<0>(wybe.count,wybe.count,?wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [(wybe.count.*<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: [(wybe.count.*<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Exact mode matches: [(wybe.count.*<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Finding type of expr x @count:42:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:42:35
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:42:31
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finalising call    :  {wybe.count.<0>*(x:wybe.count @count:42:31, y:wybe.count @count:42:35, ?tmp#0:wybe.count @count:42:31)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.count.<0>*(x:wybe.count @count:42:31, y:wybe.count @count:42:35, ?tmp#0:wybe.count @count:42:31)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '*='
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @count:42:27, tmp#0)
Types: Mode checking call   : {=(?x @count:42:27, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @count:42:27
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 42, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 42, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 42, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 42, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.=<0>(wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @count:42:27)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?x @count:42:27
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:42:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '*='
Types: Mode checked body   : [{wybe.count.<0>*(x:wybe.count @count:42:31, y:wybe.count @count:42:35, ?tmp#0:wybe.count @count:42:31)} @count:42:31,{foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:42:27)} @count:42:27]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of *=:
Types: 
Types: *= > public (0 calls)
Types: 4: *=(!x:wybe.count @count:42:11, y:wybe.count @count:42:19):
Types:     wybe.count.<0>*(x:wybe.count @count:42:31, y:wybe.count @count:42:35, ?tmp#0:wybe.count @count:42:31)
Types:     foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:42:27)
Types: Type checking non-recursive proc wybe.count.%
Types: ** Type checking decl of proc %
Types: found 1 definition(s)
Types: Type checking %
Types: ** Type checking %: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm urem(x @count:51:43, y @count:51:45, ?tmp#0 @count:51:25)
Types:         foreign llvm move(tmp#0, ?#result @count:51:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.count, y:wybe.count, ?#result:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types:     type of '#result' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable #result type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {foreign llvm urem(x @count:51:43, y @count:51:45, ?tmp#0 @count:51:25)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @count:51:5)}
Types: Unifying move argument types tmp#0 and ?#result @count:51:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @count:51:5
Types:   Type = wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: *** Before calls Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.count, tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Finding type of expr x @count:51:43
Types:   Type = wybe.count
Types: Finding type of expr y @count:51:45
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:51:25
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Type checking foreign llvm call urem(64 bit unsigned, 64 bit unsigned, 64 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?#result @count:51:5
Types:   Type = wybe.count
Types: Type checking foreign llvm call move(64 bit unsigned, 64 bit unsigned)
Types: Now mode checking proc %
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm urem(x @count:51:43, y @count:51:45, ?tmp#0 @count:51:25)
Types: Mode checking foreign call {foreign llvm urem(x @count:51:43, y @count:51:45, ?tmp#0 @count:51:25)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:51:43
Types:   Type = wybe.count
Types: Finding type of expr y @count:51:45
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:51:25
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,wybe.count,?wybe.count]
Types: New instr = {foreign llvm urem(x:wybe.count @count:51:43, y:wybe.count @count:51:45, ?tmp#0:wybe.count @count:51:25)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @count:51:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @count:51:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?#result @count:51:5
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:51:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '%'
Types: Mode checked body   : [{foreign llvm urem(x:wybe.count @count:51:43, y:wybe.count @count:51:45, ?tmp#0:wybe.count @count:51:25)} @count:51:25,{foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:51:5)} @count:51:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of %:
Types: 
Types: % > public (0 calls)
Types: 4: %(x:wybe.count @count:51:10, y:wybe.count @count:51:16, ?#result:wybe.count @count:51:5):
Types:     foreign llvm urem(x:wybe.count @count:51:43, y:wybe.count @count:51:45, ?tmp#0:wybe.count @count:51:25)
Types:     foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:51:5)
Types: Type checking non-recursive proc wybe.count.%=
Types: ** Type checking decl of proc %=
Types: found 1 definition(s)
Types: Type checking %=
Types: ** Type checking %=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         %(x @count:54:31, y @count:54:35, ?tmp#0 @count:54:31)
Types:         =(?x @count:54:27, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y"]
Types: Recording parameter types: !x:wybe.count, y:wybe.count
Types:     type of 'x' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable x type constrained to wybe.count
Types:     type of 'y' is wybe.count
Types: Unifying types wybe.count (-> wybe.count) and any (-> any)
Types:   Unification yields wybe.count
Types: Variable y type constrained to wybe.count
Types: Recording resource types: 
Types: Recording casts in {%(x @count:54:31, y @count:54:35, ?tmp#0 @count:54:31)}
Types: Recording casts in {=(?x @count:54:27, tmp#0)}
Types: *** Before calls Typing {x::wybe.count, y::wybe.count}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {%(x @count:54:31, y @count:54:35, ?tmp#0 @count:54:31)} @count:54:31, typingInfos = [wybe.count.%<0>(wybe.count,wybe.count,?wybe.count)]}
Types:     StmtTypings {typingStmt = {=(?x @count:54:27, tmp#0)} @count:54:27, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)]}Typing {x::wybe.count, y::wybe.count}; {} (with no errors)
Types: Type checking call {%(x @count:54:31, y @count:54:35, ?tmp#0 @count:54:31)} @count:54:31
Types: Candidate types:
Types:     wybe.count.%<0>(wybe.count,wybe.count,?wybe.count)
Types: Finding type of expr x @count:54:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:54:35
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:54:31
Types:   Type = 0
Types: Actual types: [wybe.count,wybe.count,0]
Types: Matching types [wybe.count,wybe.count,0] with wybe.count.%<0>(wybe.count,wybe.count,?wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Type checking call {=(?x @count:54:27, tmp#0)} @count:54:27
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.count.=<0>(wybe.count,wybe.count,?wybe.bool)
Types: Finding type of expr ?x @count:54:27
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Actual types: [wybe.count,wybe.count]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 54, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 54, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 54, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 54, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Valid types = [Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors)
Types: Now mode checking proc %=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt %(x @count:54:31, y @count:54:35, ?tmp#0 @count:54:31)
Types: Mode checking call   : {%(x @count:54:31, y @count:54:35, ?tmp#0 @count:54:31)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @count:54:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:54:35
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:54:31
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count,wybe.count]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.count,wybe.count,wybe.count] with wybe.count.%<0>(wybe.count,wybe.count,?wybe.count)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [(wybe.count.%<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: [(wybe.count.%<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Exact mode matches: [(wybe.count.%<0>(wybe.count,wybe.count,?wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Finding type of expr x @count:54:31
Types:   Type = wybe.count
Types: Finding type of expr y @count:54:35
Types:   Type = wybe.count
Types: Finding type of expr ?tmp#0 @count:54:31
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finalising call    :  {wybe.count.<0>%(x:wybe.count @count:54:31, y:wybe.count @count:54:35, ?tmp#0:wybe.count @count:54:31)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.count.<0>%(x:wybe.count @count:54:31, y:wybe.count @count:54:35, ?tmp#0:wybe.count @count:54:31)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '%='
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @count:54:27, tmp#0)
Types: Mode checking call   : {=(?x @count:54:27, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @count:54:27
Types:   Type = wybe.count
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types:     actual types     : [wybe.count,wybe.count]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.count,wybe.count] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 54, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 54, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 54, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.count (-> wybe.count) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/count.wybe" (line 54, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.count,wybe.count] with {test} wybe.count.=<0>(wybe.count,wybe.count)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Unifying types wybe.count (-> wybe.count) and wybe.count (-> wybe.count)
Types:   Unification yields wybe.count
Types: Type-correct modes   : [({test} wybe.count.=<0>(wybe.count,wybe.count),Typing {tmp#0::0, x::wybe.count, y::wybe.count}; {0::wybe.count} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @count:54:27)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.count
Types:   Type = wybe.count
Types: Finding type of expr ?x @count:54:27
Types:   Type = wybe.count
Types:     types and modes = [wybe.count,?wybe.count]
Types: New instr = {foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:54:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '%='
Types: Mode checked body   : [{wybe.count.<0>%(x:wybe.count @count:54:31, y:wybe.count @count:54:35, ?tmp#0:wybe.count @count:54:31)} @count:54:31,{foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:54:27)} @count:54:27]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of %=:
Types: 
Types: %= > public (0 calls)
Types: 4: %=(!x:wybe.count @count:54:11, y:wybe.count @count:54:19):
Types:     wybe.count.<0>%(x:wybe.count @count:54:31, y:wybe.count @count:54:35, ?tmp#0:wybe.count @count:54:31)
Types:     foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:54:27)
======================================================================
AFTER TYPE CHECK:
 Module wybe
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : 
  imports         : public use wybe.array
                    public use wybe.bool
                    public use wybe.c_string
                    public use wybe.char
                    public use wybe.comparison
                    public use wybe.control
                    public use wybe.count
                    public use wybe.float
                    public use wybe.int
                    public use wybe.io
                    public use wybe.list
                    public use wybe.machine_word
                    public use wybe.memory_management
                    public use wybe.phantom
                    public use wybe.predicate
                    public use wybe.range
                    public use wybe.string
  resources       : 
  submodules      : wybe.array, wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.control, wybe.count, wybe.float, wybe.int, wybe.io, wybe.list, wybe.machine_word, wybe.memory_management, wybe.phantom, wybe.predicate, wybe.range, wybe.string
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.array(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.array.[]<0>
                    wybe.array.[]<1>
                    wybe.array.[|]<0>
                    wybe.array.array<0>
                    wybe.array.array<1>
                    wybe.array.inbounds<0>
                    wybe.array.unsafe_get<0>
                    wybe.array.unsafe_update<0>
  imports         : public use wybe.array.raw_array
                    use wybe.bool
                    use wybe.int
                    use wybe.list
                    use wybe.machine_word
  resources       : 
  submodules      : wybe.array.raw_array
  procs           : 

[] > public {test} (0 calls)
0: [](a:_(T) @array:67:21, idx:int @array:67:29, ?#result:T @array:67:5):
    inbounds(a @array:68:14, idx @array:68:17)
    unsafe_get(a @array:69:10, idx @array:69:23, ?tmp#0 @array:69:10)
    =(?x @array:69:6, tmp#0)
    foreign llvm move(x @array:67:42, ?#result @array:67:5)
[] > public {test} (0 calls)
1: [](!a:_(T) @array:81:22, idx:int @array:81:30, x:T @array:81:39):
    inbounds(a @array:82:14, idx @array:82:17)
    unsafe_update(!a @array:83:20, idx @array:83:23, x @array:83:28)


[|] > public {test} (0 calls)
0: [|](?head:T @array:51:23, ?tail:_(T) @array:51:32, a:_(T) @array:51:43):
    array(?length @array:52:12, ?data @array:52:21, a @array:52:29)
    >(length @array:53:6, 0 @array:53:15)
    word_size_bytes(?tmp#0 @array:54:34)
    foreign lpvm access(data @array:54:25, 0 @array:54:31, tmp#0, 0 @array:54:51, ?head @array:54:55)
    word_size_bytes(?tmp#1 @array:55:28)
    foreign llvm add(data @array:55:22, tmp#1, ?data @array:55:46)
    -(length @array:56:19, 1 @array:56:28, ?tmp#3 @array:56:19)
    array(tmp#3, data @array:56:31, ?tmp#2 @array:56:13)
    =(?tail @array:56:6, tmp#2)


array > public (0 calls)
0: array(x:T @array:18:15, len:int @array:18:20, ?#result:_(T) @array:18:5):
    word_size_bytes(?tmp#1 @array:19:19)
    *(len @array:19:13, tmp#1, ?tmp#0 @array:19:13)
    =(?size @array:19:6, tmp#0)
    foreign lpvm alloc(size @array:20:24, ?data @array:20:31)
    =(?offset @array:21:6, 0 @array:21:15)
    do {
        if {<(offset @array:23:15, size @array:23:24)::

            pass
        else::
            break

        }
        foreign lpvm mutate(data @array:24:29, ?data @array:24:36, offset @array:24:42, 1 @array:24:50, size @array:24:53, 0 @array:24:59, x @array:24:62)
        word_size_bytes(?tmp#2 @array:25:21)
        +=(!offset @array:25:10, tmp#2)
    }
    array(len @array:27:17, data @array:27:22, ?tmp#3 @array:27:11)
    =(?ar @array:27:6, tmp#3)
    foreign llvm move(ar @array:18:36, ?#result @array:18:5)
array > public (0 calls)
1: array(ls:list(T) @array:34:15, ?#result:_(T) @array:34:5):
    length(ls @array:35:19, ?tmp#0 @array:35:12)
    =(?len @array:35:6, tmp#0)
    word_size_bytes(?tmp#2 @array:36:19)
    *(len @array:36:13, tmp#2, ?tmp#1 @array:36:13)
    =(?size @array:36:6, tmp#1)
    foreign lpvm alloc(size @array:37:24, ?data @array:37:31)
    =(?offset @array:38:6, 0 @array:38:15)
    foreign llvm move(ls @array:39:15, ?tmp#3)
    do {
        if {[|](?x @array:39:10, ?tmp#3, tmp#3)::

            foreign lpvm mutate(data @array:40:29, ?data @array:40:36, offset @array:40:42, 1 @array:40:50, size @array:40:53, 0 @array:40:59, x @array:40:62)
            word_size_bytes(?tmp#4 @array:41:21)
            +=(!offset @array:41:10, tmp#4)
        else::
            break

        }
    }
    array(len @array:43:17, data @array:43:22, ?tmp#5 @array:43:11)
    =(?ar @array:43:6, tmp#5)
    foreign llvm move(ar @array:34:34, ?#result @array:34:5)


inbounds > public {test,inline} (0 calls)
0: inbounds(a:_(T) @array:60:33, idx:int @array:60:41):
    <=(0 @array:61:6, idx @array:61:12)
    length(a @array:62:12, ?tmp#0 @array:62:12)
    <(idx @array:62:6, tmp#0)


unsafe_get > public {inline} (0 calls)
0: unsafe_get(a:_(T) @array:75:29, idx:int @array:75:37, ?#result:T @array:75:5):
    raw_data(a @array:76:25, ?tmp#0 @array:76:25)
    word_size_bytes(?tmp#2 @array:76:43)
    *(idx @array:76:37, tmp#2, ?tmp#1 @array:76:37)
    word_size_bytes(?tmp#3 @array:76:60)
    foreign lpvm access(tmp#0, tmp#1, tmp#3, 0 @array:76:77, ?x @array:76:81)
    foreign llvm move(x @array:75:50, ?#result @array:75:5)


unsafe_update > public {inline} (0 calls)
0: unsafe_update(!a:_(T) @array:89:33, idx:int @array:89:41, x:T @array:89:50):
    raw_data(a @array:90:25, ?tmp#0 @array:90:25)
    word_size_bytes(?tmp#2 @array:90:50)
    *(idx @array:90:44, tmp#2, ?tmp#1 @array:90:44)
    length(a @array:91:44, ?tmp#4 @array:91:44)
    word_size_bytes(?tmp#5 @array:91:55)
    *(tmp#4, tmp#5, ?tmp#3 @array:91:44)
    foreign lpvm mutate(tmp#0, ?data @array:90:38, tmp#1, 0 @array:90:67, tmp#3, 0 @array:91:72, x @array:91:75)
    raw_data(!a @array:92:6, data @array:92:19)

LLVM code       : None

--------------------------------------------------
 Module wybe.array.raw_array(T)
  representation  : address
  public submods  : 
  public resources: 
  public procs    : 
  imports         : use wybe
                    use wybe.array
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.bool
  representation  : 1 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.bool.&&<0>
                    wybe.bool.&=<0>
                    wybe.bool.=<0>
                    wybe.bool.^=<0>
                    wybe.bool.^^<0>
                    wybe.bool.false<0>
                    wybe.bool.print<0>
                    wybe.bool.println<0>
                    wybe.bool.succeed<0>
                    wybe.bool.true<0>
                    wybe.bool.|=<0>
                    wybe.bool.||<0>
                    wybe.bool.~<0>
                    wybe.bool.~=<0>
  imports         : use wybe.c_string
                    use wybe.io
  resources       : 
  procs           : 

&& > public {inline} (1 calls)
0: wybe.bool.&&<0>
&&(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:13:27


&= > public {inline} (0 calls)
0: wybe.bool.&=<0>
&=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:13:27


= > public {inline} (0 calls)
0: wybe.bool.=<0>
=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:37:26


^= > public {inline} (0 calls)
0: wybe.bool.^=<0>
^=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:25:27


^^ > public {inline} (1 calls)
0: wybe.bool.^^<0>
^^(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:25:27


false > public {inline} (0 calls)
0: wybe.bool.false<0>
false(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.bool, ?#result##0:wybe.bool)


print > public (1 calls)
0: wybe.bool.print<0>
print(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    case ~x##0:wybe.bool of
    0:
        wybe.c_string.print<0>(c"false":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #1 @bool:47:31

    1:
        wybe.c_string.print<0>(c"true":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:47:31



println > public {inline} (0 calls)
0: wybe.bool.println<0>
println(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.bool.print<0>(~x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:49:33
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#0##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~tmp#0##0:wybe.phantom, ?tmp#1##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#1##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


succeed > public {inline} (0 calls)
0: wybe.bool.succeed<0>
succeed()<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []


true > public {inline} (1 calls)
0: wybe.bool.true<0>
true(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.bool, ?#result##0:wybe.bool)


|= > public {inline} (0 calls)
0: wybe.bool.|=<0>
|=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:19:27


|| > public {inline} (1 calls)
0: wybe.bool.||<0>
||(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:19:27


~ > public {inline} (0 calls)
0: wybe.bool.~<0>
~(p##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, 1:wybe.bool, ?#result##0:wybe.bool) @bool:31:20


~= > public {inline} (0 calls)
0: wybe.bool.~=<0>
~=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:38:27

LLVM code       : None

--------------------------------------------------
 Module wybe.c_string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.c_string.<<0>
                    wybe.c_string.<=<0>
                    wybe.c_string.=<0>
                    wybe.c_string.><0>
                    wybe.c_string.>=<0>
                    wybe.c_string.[]<0>
                    wybe.c_string.[|]<0>
                    wybe.c_string.length<0>
                    wybe.c_string.print<0>
                    wybe.c_string.println<0>
                    wybe.c_string.read<0>
                    wybe.c_string.unsafe_c_string_index<0>
                    wybe.c_string.~=<0>
  imports         : use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.c_string.<<0>
<(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:12:29
    wybe.int.<<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:12:29


<= > public {inline} (0 calls)
0: wybe.c_string.<=<0>
<=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:13:30
    wybe.int.<=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:13:30


= > public {inline} (0 calls)
0: wybe.c_string.=<0>
=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:10:29
    wybe.int.=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:10:29


> > public {inline} (0 calls)
0: wybe.c_string.><0>
>(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:14:29
    wybe.int.><0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:14:29


>= > public {inline} (0 calls)
0: wybe.c_string.>=<0>
>=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:15:30
    wybe.int.>=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:15:30


[] > public (0 calls)
0: wybe.c_string.[]<0>
[](str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, idx##0:wybe.int, ?tmp#2##0:wybe.bool) #0 @c_string:27:6
    case ~tmp#2##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        foreign c strlen(str##0:wybe.c_string, ?tmp#0##0:wybe.int) @c_string:17:29
        wybe.int.<<0>(idx##0:wybe.int, ~tmp#0##0:wybe.int, ?tmp#3##0:wybe.bool) #2 @c_string:28:6
        case ~tmp#3##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




[|] > public (0 calls)
0: wybe.c_string.[|]<0>
[|](?head##0:wybe.char, ?tail##0:wybe.c_string, str##0:wybe.c_string, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(str##0:wybe.c_string, 0:wybe.int, 0:wybe.int, 0:wybe.int, ?head##0:wybe.char) @c_string:20:5
    foreign llvm icmp_ne(head##0:wybe.char, '\NUL':wybe.char, ?not_done##0:wybe.bool) @c_string:21:5
    foreign llvm icmp_eq(~not_done##0:wybe.bool, 1:wybe.bool, ?tmp#1##0:wybe.bool) @bool:37:26
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.c_string, ?tail##0:wybe.c_string)

    1:
        foreign llvm add(~str##0:wybe.c_string, 1:wybe.int, ?tail##0:wybe.c_string) @c_string:23:5
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



length > public {inline} (3 calls)
0: wybe.c_string.length<0>
length(str##0:wybe.c_string, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strlen(~str##0:wybe.c_string, ?#result##0:wybe.int) @c_string:17:29


print > public {inline} (1 calls)
0: wybe.c_string.print<0>
print(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:35:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:35:30


println > public {inline} (0 calls)
0: wybe.c_string.println<0>
println(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @c_string:35:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.c_string.read<0>
read(?x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:39:30
    foreign c read_line(?x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:39:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:39:30


unsafe_c_string_index > public {inline} (1 calls)
0: wybe.c_string.unsafe_c_string_index<0>
unsafe_c_string_index(str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7


~= > public {inline} (0 calls)
0: wybe.c_string.~=<0>
~=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:11:30
    wybe.int.~=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.char
  representation  : 8 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.char.<<0>
                    wybe.char.<=<0>
                    wybe.char.<=><0>
                    wybe.char.=<0>
                    wybe.char.><0>
                    wybe.char.>=<0>
                    wybe.char.chr<0>
                    wybe.char.ord<0>
                    wybe.char.print<0>
                    wybe.char.println<0>
                    wybe.char.read<0>
                    wybe.char.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (4 calls)
0: wybe.char.<<0>
<(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:17:29


<= > public {inline} (0 calls)
0: wybe.char.<=<0>
<=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:18:30


<=> > public (0 calls)
0: wybe.char.<=><0>
<=>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.char, y##0:wybe.char, ?tmp#6##0:wybe.bool) @char:17:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?tmp#5##0:wybe.bool) @char:13:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5



= > public {inline} (2 calls)
0: wybe.char.=<0>
=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:13:29


> > public {inline} (0 calls)
0: wybe.char.><0>
>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:19:29


>= > public {inline} (0 calls)
0: wybe.char.>=<0>
>=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:20:30


chr > public (0 calls)
0: wybe.char.chr<0>
chr(i##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, i##0:wybe.int, ?tmp#1##0:wybe.bool) #0 @char:33:60
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        wybe.int.<=<0>(i##0:wybe.int, 255:wybe.int, ?tmp#2##0:wybe.bool) #1 @char:33:70
        case ~tmp#2##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm cast(~i##0:wybe.int, ?#result##0:wybe.char) @char:33:31
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




ord > public {inline} (0 calls)
0: wybe.char.ord<0>
ord(c##0:wybe.char, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(~c##0:wybe.char, ?#result##0:wybe.int) @char:30:24


print > public {inline} (1 calls)
0: wybe.char.print<0>
print(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:37:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:37:30


println > public {inline} (0 calls)
0: wybe.char.println<0>
println(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @char:37:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.char.read<0>
read(?x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:41:30
    foreign c read_char(?x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:41:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:41:30


~= > public {inline} (0 calls)
0: wybe.char.~=<0>
~=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:14:30

LLVM code       : None

--------------------------------------------------
 Module wybe.comparison
  representation  : 2 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.comparison.<<0>
                    wybe.comparison.<=<0>
                    wybe.comparison.=<0>
                    wybe.comparison.><0>
                    wybe.comparison.>=<0>
                    wybe.comparison.equal<0>
                    wybe.comparison.greater<0>
                    wybe.comparison.lesser<0>
                    wybe.comparison.~=<0>
  imports         : use wybe.bool
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.comparison.<<0>
<(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:12:29


<= > public {inline} (0 calls)
0: wybe.comparison.<=<0>
<=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:13:30


= > public {inline} (0 calls)
0: wybe.comparison.=<0>
=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:10:29


> > public {inline} (0 calls)
0: wybe.comparison.><0>
>(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:14:29


>= > public {inline} (0 calls)
0: wybe.comparison.>=<0>
>=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:15:30


equal > public {inline} (0 calls)
0: wybe.comparison.equal<0>
equal(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison)


greater > public {inline} (0 calls)
0: wybe.comparison.greater<0>
greater(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison)


lesser > public {inline} (0 calls)
0: wybe.comparison.lesser<0>
lesser(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison)


~= > public {inline} (0 calls)
0: wybe.comparison.~=<0>
~=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.control
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.control.assert<0>
                    wybe.control.error<0>
                    wybe.control.error<1>
                    wybe.control.exit<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.int
                    use wybe.string
  resources       : 
  procs           : 

assert > public {semipure} (0 calls)
0: assert(condition:bool @control:26:27) use call_source_location:
    if {~(condition @control:27:11)::

        !error(c"assertion failed" @control:27:31)
    else::
        pass

    }


error > public {terminal,semipure} (0 calls)
0: error(message:string @control:17:35) use call_source_location:
    c_string(message @control:18:77, ?tmp#0 @control:18:68)
    foreign c {terminal,semipure} error_exit(call_source_location @control:18:46, tmp#0)
error > public {terminal,semipure} (0 calls)
1: error(message:c_string @control:21:35) use call_source_location:
    foreign c {terminal,semipure} error_exit(call_source_location @control:22:46, message @control:22:68)


exit > public {terminal,semipure} (0 calls)
0: exit(code:int @control:10:34):
    foreign c {terminal,semipure} exit(code @control:11:40)

LLVM code       : None

--------------------------------------------------
 Module wybe.count
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.count.%<0>
                    wybe.count.%=<0>
                    wybe.count.*<0>
                    wybe.count.*=<0>
                    wybe.count.+<0>
                    wybe.count.+<1>
                    wybe.count.+<2>
                    wybe.count.+=<0>
                    wybe.count.-<0>
                    wybe.count.-<1>
                    wybe.count.-<2>
                    wybe.count.-=<0>
                    wybe.count./<0>
                    wybe.count./=<0>
                    wybe.count.<<0>
                    wybe.count.<=<0>
                    wybe.count.<=><0>
                    wybe.count.=<0>
                    wybe.count.><0>
                    wybe.count.>=<0>
                    wybe.count.decr<0>
                    wybe.count.incr<0>
                    wybe.count.max<0>
                    wybe.count.min<0>
                    wybe.count.print<0>
                    wybe.count.println<0>
                    wybe.count.read<0>
                    wybe.count.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public (0 calls)
0: %(x:wybe.count @count:51:10, y:wybe.count @count:51:16, ?#result:wybe.count @count:51:5):
    foreign llvm urem(x:wybe.count @count:51:43, y:wybe.count @count:51:45, ?tmp#0:wybe.count @count:51:25)
    foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:51:5)


%= > public (0 calls)
0: %=(!x:wybe.count @count:54:11, y:wybe.count @count:54:19):
    wybe.count.<0>%(x:wybe.count @count:54:31, y:wybe.count @count:54:35, ?tmp#0:wybe.count @count:54:31)
    foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:54:27)


* > public (0 calls)
0: *(x:wybe.count @count:39:10, y:wybe.count @count:39:16, ?#result:wybe.count @count:39:5):
    foreign llvm mul(x:wybe.count @count:39:42, y:wybe.count @count:39:44, ?tmp#0:wybe.count @count:39:25)
    foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:39:5)


*= > public (0 calls)
0: *=(!x:wybe.count @count:42:11, y:wybe.count @count:42:19):
    wybe.count.<0>*(x:wybe.count @count:42:31, y:wybe.count @count:42:35, ?tmp#0:wybe.count @count:42:31)
    foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:42:27)


+ > public (0 calls)
0: +(x:wybe.count @count:15:10, y:wybe.count @count:15:16, ?#result:wybe.count @count:15:5):
    foreign llvm add(x:wybe.count @count:15:42, y:wybe.count @count:15:44, ?tmp#0:wybe.count @count:15:25)
    foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:15:5)
+ > public {test} (0 calls)
1: +(?x:wybe.count @count:16:21, y:wybe.count @count:16:27, z:wybe.count @count:16:5):
    wybe.count.<0>>=(z:wybe.count @count:17:5, y:wybe.count @count:17:11)
    foreign llvm sub(z:wybe.count @count:18:27, y:wybe.count @count:18:29, ?tmp#0:wybe.count @count:18:10)
    foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:18:6)
+ > public {test} (0 calls)
2: +(x:wybe.count @count:20:20, ?y:wybe.count @count:20:27, z:wybe.count @count:20:5):
    wybe.count.<0>>=(z:wybe.count @count:21:5, x:wybe.count @count:21:11)
    foreign llvm sub(z:wybe.count @count:22:27, x:wybe.count @count:22:29, ?tmp#0:wybe.count @count:22:10)
    foreign llvm move(tmp#0:wybe.count, ?y:wybe.count @count:22:6)


+= > public (0 calls)
0: +=(!x:wybe.count @count:26:11, y:wybe.count @count:26:19):
    wybe.count.<0>+(x:wybe.count @count:26:31, y:wybe.count @count:26:35, ?tmp#0:wybe.count @count:26:31)
    foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:26:27)


- > public {test} (0 calls)
0: -(x:wybe.count @count:31:20, y:wybe.count @count:31:26, ?#result:wybe.count @count:31:5):
    wybe.count.<0>>=(y:wybe.count @count:31:65, x:wybe.count @count:31:71)
    foreign llvm sub(x:wybe.count @count:31:52, y:wybe.count @count:31:54, ?tmp#0:wybe.count @count:31:35)
    foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:31:5)
- > public (0 calls)
1: -(?x:wybe.count @count:32:11, y:wybe.count @count:32:17, z:wybe.count @count:32:5):
    foreign llvm add(z:wybe.count @count:32:59, y:wybe.count @count:32:61, ?tmp#0:wybe.count @count:32:42)
    foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:32:38)
- > public (0 calls)
2: -(x:wybe.count @count:33:10, ?y:wybe.count @count:33:17, z:wybe.count @count:33:5):
    foreign llvm sub(z:wybe.count @count:33:59, x:wybe.count @count:33:61, ?tmp#0:wybe.count @count:33:42)
    foreign llvm move(tmp#0:wybe.count, ?y:wybe.count @count:33:38)


-= > public {test} (0 calls)
0: -=(!x:wybe.count @count:36:21, y:wybe.count @count:36:29):
    wybe.count.<0>-(x:wybe.count @count:36:41, y:wybe.count @count:36:45, ?tmp#0:wybe.count @count:36:41)
    foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:36:37)


/ > public (0 calls)
0: /(x:wybe.count @count:45:10, y:wybe.count @count:45:16, ?#result:wybe.count @count:45:5):
    foreign llvm udiv(x:wybe.count @count:45:43, y:wybe.count @count:45:45, ?tmp#0:wybe.count @count:45:25)
    foreign llvm move(tmp#0:wybe.count, ?#result:wybe.count @count:45:5)


/= > public (0 calls)
0: /=(!x:wybe.count @count:48:11, y:wybe.count @count:48:19):
    wybe.count.<0>/(x:wybe.count @count:48:31, y:wybe.count @count:48:35, ?tmp#0:wybe.count @count:48:31)
    foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:48:27)


< > public (0 calls)
0: <(x:wybe.count @count:64:10, y:wybe.count @count:64:17, ?#result:wybe.bool @count:64:5):
    foreign llvm icmp_ult(x:wybe.count @count:64:51, y:wybe.count @count:64:53, ?tmp#0:wybe.bool @count:64:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:64:5)


<= > public (0 calls)
0: <=(x:wybe.count @count:65:10, y:wybe.count @count:65:18, ?#result:wybe.bool @count:65:5):
    foreign llvm icmp_ule(x:wybe.count @count:65:52, y:wybe.count @count:65:54, ?tmp#0:wybe.bool @count:65:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:65:5)


<=> > public (0 calls)
0: <=>(x:wybe.count @count:70:10, y:wybe.count @count:70:20, ?#result:wybe.comparison @count:70:5):
    if {wybe.count.<0><(x:wybe.count @count:71:10, y:wybe.count @count:71:14)::

        wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @count:71:19)
        foreign llvm move(tmp#1:wybe.comparison, ?tmp#0:wybe.comparison)
    else::
        if {wybe.count.<0>=(x:wybe.count @count:71:28, y:wybe.count @count:71:32)::

            wybe.comparison.<0>equal(?tmp#3:wybe.comparison @count:71:37)
            foreign llvm move(tmp#3:wybe.comparison, ?tmp#2:wybe.comparison)
        else::
            wybe.comparison.<0>greater(?tmp#4:wybe.comparison @count:71:53)
            foreign llvm move(tmp#4:wybe.comparison, ?tmp#2:wybe.comparison)

        }
   condition -> {x::wybe.count, y::wybe.count}
   then&else -> {tmp#2::wybe.comparison, x::wybe.count, y::wybe.count}
        foreign llvm move(tmp#2:wybe.comparison @count:71:28, ?tmp#0:wybe.comparison)

    }
   condition -> {x::wybe.count, y::wybe.count}
   then&else -> {tmp#0::wybe.comparison, x::wybe.count, y::wybe.count}
    foreign llvm move(tmp#0:wybe.comparison @count:71:10, ?#result:wybe.comparison @count:70:5)


= > public (0 calls)
0: =(x:wybe.count @count:60:10, y:wybe.count @count:60:17, ?#result:wybe.bool @count:60:5):
    foreign llvm icmp_eq(x:wybe.count @count:60:50, y:wybe.count @count:60:52, ?tmp#0:wybe.bool @count:60:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:60:5)


> > public (0 calls)
0: >(x:wybe.count @count:66:10, y:wybe.count @count:66:17, ?#result:wybe.bool @count:66:5):
    foreign llvm icmp_ugt(x:wybe.count @count:66:51, y:wybe.count @count:66:53, ?tmp#0:wybe.bool @count:66:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:66:5)


>= > public (0 calls)
0: >=(x:wybe.count @count:67:10, y:wybe.count @count:67:18, ?#result:wybe.bool @count:67:5):
    foreign llvm icmp_uge(x:wybe.count @count:67:52, y:wybe.count @count:67:54, ?tmp#0:wybe.bool @count:67:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:67:5)


decr > public {test} (0 calls)
0: decr(!x:wybe.count @count:84:25):
    wybe.count.<0>-(x:wybe.count @count:84:37, 1:wybe.count @count:84:41, ?tmp#0:wybe.count @count:84:37)
    foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:84:33)


incr > public (0 calls)
0: incr(!x:wybe.count @count:81:15):
    wybe.count.<0>+(x:wybe.count @count:81:27, 1:wybe.count @count:81:31, ?tmp#0:wybe.count @count:81:27)
    foreign llvm move(tmp#0:wybe.count, ?x:wybe.count @count:81:23)


max > public (0 calls)
0: max(x:wybe.count @count:75:13, y:wybe.count @count:75:18, ?#result:wybe.count @count:75:5):
    if {wybe.count.<0>>=(x:wybe.count @count:75:31, y:wybe.count @count:75:35)::

        foreign llvm move(x:wybe.count @count:75:39, ?tmp#0:wybe.count)
    else::
        foreign llvm move(y:wybe.count @count:75:50, ?tmp#0:wybe.count)

    }
   condition -> {x::wybe.count, y::wybe.count}
   then&else -> {tmp#0::wybe.count, x::wybe.count, y::wybe.count}
    foreign llvm move(tmp#0:wybe.count @count:75:31, ?#result:wybe.count @count:75:5)


min > public (0 calls)
0: min(x:wybe.count @count:74:13, y:wybe.count @count:74:18, ?#result:wybe.count @count:74:5):
    if {wybe.count.<0><=(x:wybe.count @count:74:31, y:wybe.count @count:74:35)::

        foreign llvm move(x:wybe.count @count:74:39, ?tmp#0:wybe.count)
    else::
        foreign llvm move(y:wybe.count @count:74:50, ?tmp#0:wybe.count)

    }
   condition -> {x::wybe.count, y::wybe.count}
   then&else -> {tmp#0::wybe.count, x::wybe.count, y::wybe.count}
    foreign llvm move(tmp#0:wybe.count @count:74:31, ?#result:wybe.count @count:74:5)


print > public (0 calls)
0: print(x:wybe.count @count:88:15) use !wybe.io.io:
    foreign c print_count(x:wybe.count @count:88:52, !io:wybe.phantom @count:88:56)


println > public (0 calls)
0: println(x:wybe.count @count:90:17) use !wybe.io.io:
    !wybe.count.<0>print(x:wybe.count @count:90:39)
    !wybe.io.<0>nl


read > public (0 calls)
0: read(?x:wybe.count @count:92:15) use !wybe.io.io:
    foreign c read_count(?x:wybe.count @count:92:52, !io:wybe.phantom @count:92:56)


~= > public (0 calls)
0: ~=(x:wybe.count @count:61:10, y:wybe.count @count:61:18, ?#result:wybe.bool @count:61:5):
    foreign llvm icmp_ne(x:wybe.count @count:61:51, y:wybe.count @count:61:53, ?tmp#0:wybe.bool @count:61:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @count:61:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.float
  representation  : 64 bit float
  public submods  : 
  public resources: 
  public procs    : wybe.float.*<0>
                    wybe.float.**<0>
                    wybe.float.*=<0>
                    wybe.float.+<0>
                    wybe.float.+<1>
                    wybe.float.+<2>
                    wybe.float.+=<0>
                    wybe.float.-<0>
                    wybe.float.-<1>
                    wybe.float.-<2>
                    wybe.float.-<3>
                    wybe.float.-<4>
                    wybe.float.-=<0>
                    wybe.float./<0>
                    wybe.float./=<0>
                    wybe.float.<<0>
                    wybe.float.<=<0>
                    wybe.float.<=><0>
                    wybe.float.=<0>
                    wybe.float.><0>
                    wybe.float.>=<0>
                    wybe.float.abs<0>
                    wybe.float.ceil<0>
                    wybe.float.cos<0>
                    wybe.float.e<0>
                    wybe.float.exp<0>
                    wybe.float.floor<0>
                    wybe.float.iceil<0>
                    wybe.float.ifloor<0>
                    wybe.float.iround<0>
                    wybe.float.log<0>
                    wybe.float.log10<0>
                    wybe.float.log2<0>
                    wybe.float.max<0>
                    wybe.float.min<0>
                    wybe.float.pi<0>
                    wybe.float.power<0>
                    wybe.float.print<0>
                    wybe.float.println<0>
                    wybe.float.read<0>
                    wybe.float.round<0>
                    wybe.float.sin<0>
                    wybe.float.sqrt<0>
                    wybe.float.square<0>
                    wybe.float.tan<0>
                    wybe.float.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

* > public (0 calls)
0: *(x:_ @float:45:10, y:_ @float:45:16, ?#result:_ @float:45:5):
    foreign llvm fmul(x @float:45:43, y @float:45:45, ?tmp#0 @float:45:25)
    foreign llvm move(tmp#0, ?#result @float:45:5)


** > public (0 calls)
0: **(x:_ @float:112:10, n:_ @float:112:18, ?#result:_ @float:112:5):
    foreign c llvm.pow.f64(x @float:112:52, n @float:112:54, ?tmp#0 @float:112:27)
    foreign llvm move(tmp#0, ?#result @float:112:5)


*= > public (0 calls)
0: *=(!x:_ @float:48:11, y:_ @float:48:19):
    *(x @float:48:31, y @float:48:35, ?tmp#0 @float:48:31)
    =(?x @float:48:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @float:23:10, y:_ @float:23:17, ?#result:_ @float:23:5):
    foreign llvm fadd(x @float:23:45, y @float:23:47, ?tmp#0 @float:23:27)
    foreign llvm move(tmp#0, ?#result @float:23:5)
+ > public (0 calls)
1: +(?x:_ @float:24:11, y:_ @float:24:17, z:_ @float:24:5):
    foreign llvm fsub(z @float:24:61, y @float:24:63, ?tmp#0 @float:24:43)
    =(?x @float:24:39, tmp#0)
+ > public (0 calls)
2: +(x:_ @float:25:10, ?y:_ @float:25:18, z:_ @float:25:5):
    foreign llvm fsub(z @float:25:61, x @float:25:63, ?tmp#0 @float:25:43)
    =(?y @float:25:39, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @float:28:11, y:_ @float:28:19):
    +(x @float:28:31, y @float:28:35, ?tmp#0 @float:28:31)
    =(?x @float:28:27, tmp#0)


- > public (0 calls)
0: -(x:_ @float:32:10, y:_ @float:32:17, ?#result:_ @float:32:5):
    foreign llvm fsub(x @float:32:45, y @float:32:47, ?tmp#0 @float:32:27)
    foreign llvm move(tmp#0, ?#result @float:32:5)
- > public (0 calls)
1: -(?x:_ @float:33:11, y:_ @float:33:17, z:_ @float:33:5):
    foreign llvm fadd(z @float:33:61, y @float:33:63, ?tmp#0 @float:33:43)
    =(?x @float:33:39, tmp#0)
- > public (0 calls)
2: -(x:_ @float:34:10, ?y:_ @float:34:18, z:_ @float:34:5):
    foreign llvm fsub(z @float:34:61, x @float:34:63, ?tmp#0 @float:34:43)
    =(?y @float:34:39, tmp#0)
- > public (0 calls)
3: -(x:_ @float:38:11, ?#result:_ @float:38:5):
    foreign llvm fsub(0.0 @float:38:39, x @float:38:43, ?tmp#0 @float:38:21)
    foreign llvm move(tmp#0, ?#result @float:38:5)
- > public (0 calls)
4: -(?x:_ @float:39:12, y:_ @float:39:5):
    foreign llvm fsub(0.0 @float:39:55, y @float:39:59, ?tmp#0 @float:39:37)
    =(?x @float:39:33, tmp#0)


-= > public (0 calls)
0: -=(!x:_ @float:42:11, y:_ @float:42:19):
    -(x @float:42:31, y @float:42:35, ?tmp#0 @float:42:31)
    =(?x @float:42:27, tmp#0)


/ > public (0 calls)
0: /(x:_ @float:51:10, y:_ @float:51:16, ?#result:_ @float:51:5):
    foreign llvm fdiv(x @float:51:43, y @float:51:45, ?tmp#0 @float:51:25)
    foreign llvm move(tmp#0, ?#result @float:51:5)


/= > public (0 calls)
0: /=(!x:_ @float:54:11, y:_ @float:54:19):
    /(x @float:54:31, y @float:54:35, ?tmp#0 @float:54:31)
    =(?x @float:54:27, tmp#0)


< > public (0 calls)
0: <(x:_ @float:70:10, y:_ @float:70:17, ?#result:bool @float:70:5):
    foreign llvm fcmp_slt(x @float:70:51, y @float:70:53, ?tmp#0 @float:70:29)
    foreign llvm move(tmp#0, ?#result @float:70:5)


<= > public (0 calls)
0: <=(x:_ @float:71:10, y:_ @float:71:18, ?#result:bool @float:71:5):
    foreign llvm fcmp_sle(x @float:71:52, y @float:71:54, ?tmp#0 @float:71:30)
    foreign llvm move(tmp#0, ?#result @float:71:5)


<=> > public (0 calls)
0: <=>(x:_ @float:76:10, y:_ @float:76:20, ?#result:comparison @float:76:5):
    if {<(x @float:77:10, y @float:77:14)::

        lesser(?tmp#1 @float:77:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @float:77:28, y @float:77:32)::

            equal(?tmp#3 @float:77:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @float:77:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @float:77:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @float:77:10, ?#result @float:76:5)


= > public (0 calls)
0: =(x:_ @float:66:10, y:_ @float:66:17, ?#result:bool @float:66:5):
    foreign llvm fcmp_eq(x @float:66:50, y @float:66:52, ?tmp#0 @float:66:29)
    foreign llvm move(tmp#0, ?#result @float:66:5)


> > public (0 calls)
0: >(x:_ @float:72:10, y:_ @float:72:17, ?#result:bool @float:72:5):
    foreign llvm fcmp_sgt(x @float:72:51, y @float:72:53, ?tmp#0 @float:72:29)
    foreign llvm move(tmp#0, ?#result @float:72:5)


>= > public (0 calls)
0: >=(x:_ @float:73:10, y:_ @float:73:18, ?#result:bool @float:73:5):
    foreign llvm fcmp_sge(x @float:73:52, y @float:73:54, ?tmp#0 @float:73:30)
    foreign llvm move(tmp#0, ?#result @float:73:5)


abs > public (0 calls)
0: abs(x:_ @float:60:13, ?#result:_ @float:60:5):
    foreign c llvm.fabs.f64(x @float:60:48, ?tmp#0 @float:60:22)
    foreign llvm move(tmp#0, ?#result @float:60:5)


ceil > public (0 calls)
0: ceil(x:_ @float:87:14, ?#result:_ @float:87:5):
    foreign c llvm.ceil.f64(x @float:87:49, ?tmp#0 @float:87:23)
    foreign llvm move(tmp#0, ?#result @float:87:5)


cos > public (0 calls)
0: cos(x:_ @float:116:13, ?#result:_ @float:116:5):
    foreign c llvm.cos.f64(x @float:116:47, ?tmp#0 @float:116:22)
    foreign llvm move(tmp#0, ?#result @float:116:5)


e > public (0 calls)
0: e(?#result:_ @float:16:5):
    foreign llvm move(2.7182818284590455 @float:16:15, ?#result @float:16:5)


exp > public (0 calls)
0: exp(x:_ @float:120:13, ?#result:_ @float:120:5):
    foreign c llvm.exp.f64(x @float:120:47, ?tmp#0 @float:120:22)
    foreign llvm move(tmp#0, ?#result @float:120:5)


floor > public (0 calls)
0: floor(x:_ @float:90:15, ?#result:_ @float:90:5):
    foreign c llvm.floor.f64(x @float:90:51, ?tmp#0 @float:90:24)
    foreign llvm move(tmp#0, ?#result @float:90:5)


iceil > public (0 calls)
0: iceil(x:_ @float:99:15, ?#result:int @float:99:5):
    ceil(x @float:99:51, ?tmp#1 @float:99:46)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:99:26)
    foreign llvm move(tmp#0, ?#result @float:99:5)


ifloor > public (0 calls)
0: ifloor(x:_ @float:102:16, ?#result:int @float:102:5):
    floor(x @float:102:53, ?tmp#1 @float:102:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:102:27)
    foreign llvm move(tmp#0, ?#result @float:102:5)


iround > public (0 calls)
0: iround(x:_ @float:96:16, ?#result:int @float:96:5):
    round(x @float:96:53, ?tmp#1 @float:96:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:96:27)
    foreign llvm move(tmp#0, ?#result @float:96:5)


log > public (0 calls)
0: log(x:_ @float:123:13, ?#result:_ @float:123:5):
    foreign c llvm.log.f64(x @float:123:47, ?tmp#0 @float:123:22)
    foreign llvm move(tmp#0, ?#result @float:123:5)


log10 > public (0 calls)
0: log10(x:_ @float:126:15, ?#result:_ @float:126:5):
    foreign c llvm.log10.f64(x @float:126:51, ?tmp#0 @float:126:24)
    foreign llvm move(tmp#0, ?#result @float:126:5)


log2 > public (0 calls)
0: log2(x:_ @float:129:14, ?#result:_ @float:129:5):
    foreign c llvm.log2.f64(x @float:129:49, ?tmp#0 @float:129:23)
    foreign llvm move(tmp#0, ?#result @float:129:5)


max > public (0 calls)
0: max(x:_ @float:81:13, y:_ @float:81:18, ?#result:_ @float:81:5):
    foreign c llvm.maxnum.f64(x @float:81:55, y @float:81:57, ?tmp#0 @float:81:27)
    foreign llvm move(tmp#0, ?#result @float:81:5)


min > public (0 calls)
0: min(x:_ @float:80:13, y:_ @float:80:18, ?#result:_ @float:80:5):
    foreign c llvm.minnum.f64(x @float:80:55, y @float:80:57, ?tmp#0 @float:80:27)
    foreign llvm move(tmp#0, ?#result @float:80:5)


pi > public (0 calls)
0: pi(?#result:_ @float:13:5):
    foreign llvm move(3.141592653589793 @float:13:16, ?#result @float:13:5)


power > public (0 calls)
0: power(x:_ @float:111:15, n:_ @float:111:19, ?#result:_ @float:111:5):
    foreign c llvm.pow.f64(x @float:111:53, n @float:111:55, ?tmp#0 @float:111:28)
    foreign llvm move(tmp#0, ?#result @float:111:5)


print > public (0 calls)
0: print(x:_ @float:133:15) use !io:
    foreign c print_float(x @float:133:52, !io @float:133:56)


println > public (0 calls)
0: println(x:_ @float:135:17) use !io:
    !print(x @float:135:39)
    !nl


read > public (0 calls)
0: read(?x:_ @float:137:15) use !io:
    foreign c read_float(?x @float:137:52, !io @float:137:56)


round > public (0 calls)
0: round(x:_ @float:93:15, ?#result:_ @float:93:5):
    foreign c llvm.round.f64(x @float:93:51, ?tmp#0 @float:93:24)
    foreign llvm move(tmp#0, ?#result @float:93:5)


sin > public (0 calls)
0: sin(x:_ @float:115:13, ?#result:_ @float:115:5):
    foreign c llvm.sin.f64(x @float:115:47, ?tmp#0 @float:115:22)
    foreign llvm move(tmp#0, ?#result @float:115:5)


sqrt > public (0 calls)
0: sqrt(x:_ @float:108:14, ?#result:_ @float:108:5):
    foreign c llvm.sqrt.f64(x @float:108:49, ?tmp#0 @float:108:23)
    foreign llvm move(tmp#0, ?#result @float:108:5)


square > public (0 calls)
0: square(x:_ @float:57:16, ?#result:_ @float:57:5):
    foreign llvm fmul(x @float:57:43, x @float:57:45, ?tmp#0 @float:57:25)
    foreign llvm move(tmp#0, ?#result @float:57:5)


tan > public (0 calls)
0: tan(x:_ @float:117:13, ?#result:_ @float:117:5):
    foreign c llvm.sin.f64(x @float:117:47, ?tmp#1 @float:117:22)
    foreign c llvm.cos.f64(x @float:117:77, ?tmp#2 @float:117:52)
    /(tmp#1, tmp#2, ?tmp#0 @float:117:22)
    foreign llvm move(tmp#0, ?#result @float:117:5)


~= > public (0 calls)
0: ~=(x:_ @float:67:10, y:_ @float:67:18, ?#result:bool @float:67:5):
    foreign llvm fcmp_ne(x @float:67:51, y @float:67:53, ?tmp#0 @float:67:30)
    foreign llvm move(tmp#0, ?#result @float:67:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.int
  representation  : 64 bit signed
  public submods  : 
  public resources: 
  public procs    : wybe.int.%<0>
                    wybe.int.%=<0>
                    wybe.int.*<0>
                    wybe.int.*=<0>
                    wybe.int.+<0>
                    wybe.int.+<1>
                    wybe.int.+<2>
                    wybe.int.+=<0>
                    wybe.int.-<0>
                    wybe.int.-<1>
                    wybe.int.-<2>
                    wybe.int.-<3>
                    wybe.int.-<4>
                    wybe.int.-=<0>
                    wybe.int./<0>
                    wybe.int./=<0>
                    wybe.int.<<0>
                    wybe.int.<<<0>
                    wybe.int.<<=<0>
                    wybe.int.<=<0>
                    wybe.int.<=><0>
                    wybe.int.=<0>
                    wybe.int.><0>
                    wybe.int.>=<0>
                    wybe.int.>><0>
                    wybe.int.>>=<0>
                    wybe.int.decr<0>
                    wybe.int.incr<0>
                    wybe.int.logical_bitshift<0>
                    wybe.int.logical_bitshift<1>
                    wybe.int.max<0>
                    wybe.int.min<0>
                    wybe.int.power<0>
                    wybe.int.print<0>
                    wybe.int.println<0>
                    wybe.int.read<0>
                    wybe.int.signum<0>
                    wybe.int.sqrt<0>
                    wybe.int.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.int.%<0>
%(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:50:25


%= > public {inline} (0 calls)
0: wybe.int.%=<0>
%=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:50:25


* > public {inline} (1 calls)
0: wybe.int.*<0>
*(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:38:25


*= > public {inline} (0 calls)
0: wybe.int.*=<0>
*=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:38:25


+ > public {inline} (2 calls)
0: wybe.int.+<0>
+(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:16:27
+ > public {inline} (0 calls)
1: wybe.int.+<1>
+(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:17:43
+ > public {inline} (0 calls)
2: wybe.int.+<2>
+(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:18:43


+= > public {inline} (0 calls)
0: wybe.int.+=<0>
+=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:16:27


- > public {inline} (2 calls)
0: wybe.int.-<0>
-(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:25:27
- > public {inline} (0 calls)
1: wybe.int.-<1>
-(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.int, ~z##0:wybe.int, ?x##0:wybe.int) @int:26:43
- > public {inline} (0 calls)
2: wybe.int.-<2>
-(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:27:43
- > public {inline} (0 calls)
3: wybe.int.-<3>
-(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~x##0:wybe.int, ?#result##0:wybe.int) @int:31:21
- > public {inline} (0 calls)
4: wybe.int.-<4>
-(?x##0:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:32:37


-= > public {inline} (0 calls)
0: wybe.int.-=<0>
-=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:25:27


/ > public {inline} (1 calls)
0: wybe.int./<0>
/(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:44:25


/= > public {inline} (0 calls)
0: wybe.int./=<0>
/=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:44:25


< > public {inline} (4 calls)
0: wybe.int.<<0>
<(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:87:29


<< > public {inline} (1 calls)
0: wybe.int.<<<0>
<<(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:56:27


<<= > public {inline} (0 calls)
0: wybe.int.<<=<0>
<<=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:56:27


<= > public {inline} (3 calls)
0: wybe.int.<=<0>
<=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:88:30


<=> > public (0 calls)
0: wybe.int.<=><0>
<=>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(x##0:wybe.int, y##0:wybe.int, ?tmp#6##0:wybe.bool) @int:87:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?tmp#5##0:wybe.bool) @int:83:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5



= > public {inline} (2 calls)
0: wybe.int.=<0>
=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:83:29


> > public {inline} (0 calls)
0: wybe.int.><0>
>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sgt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:89:29


>= > public {inline} (3 calls)
0: wybe.int.>=<0>
>=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:90:30


>> > public {inline} (1 calls)
0: wybe.int.>><0>
>>(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:65:27


>>= > public {inline} (0 calls)
0: wybe.int.>>=<0>
>>=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:65:27


decr > public {inline} (0 calls)
0: wybe.int.decr<0>
decr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:25:27


incr > public {inline} (0 calls)
0: wybe.int.incr<0>
incr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:16:27


logical_bitshift > public {inline} (1 calls)
0: wybe.int.logical_bitshift<0>
logical_bitshift(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:74:40
logical_bitshift > public {inline} (0 calls)
1: wybe.int.logical_bitshift<1>
logical_bitshift(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:74:40


max > public (0 calls)
0: wybe.int.max<0>
max(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:90:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:98:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:98:5



min > public (0 calls)
0: wybe.int.min<0>
min(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:88:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:97:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:97:5



power > public {inline} (0 calls)
0: wybe.int.power<0>
power(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c ipow(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:107:29


print > public {inline} (1 calls)
0: wybe.int.print<0>
print(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:119:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:119:30


println > public {inline} (0 calls)
0: wybe.int.println<0>
println(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @int:119:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.int.read<0>
read(?x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:123:30
    foreign c read_int(?x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:123:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:123:30


signum > public {inline} (0 calls)
0: wybe.int.signum<0>
signum(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c signum(~x##0:wybe.int, ?#result##0:wybe.int) @int:114:25


sqrt > public {inline} (0 calls)
0: wybe.int.sqrt<0>
sqrt(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c isqrt(~x##0:wybe.int, ?#result##0:wybe.int) @int:104:23


~= > public {inline} (0 calls)
0: wybe.int.~=<0>
~=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:84:30

LLVM code       : None

--------------------------------------------------
 Module wybe.io
  representation  : (not a type)
  public submods  : phantom -> wybe.phantom
  public resources: io: wybe.io.io
  public procs    : wybe.io.<0>
                    wybe.io.eof<0>
                    wybe.io.nl<0>
  imports         : use wybe.char
                    public use wybe.phantom
  resources       : io: fromList [(wybe.io.io,wybe.phantom = 0:phantom @io:13:27 @io:13:5)]
  procs           : 

module top-level code > public {inline,semipure} (0 calls)
0: wybe.io.<0>
()<{}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm store(0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:13:5


eof > public {inline} (0 calls)
0: wybe.io.eof<0>
eof(?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(-1:wybe.int, ?#result##0:wybe.char) @io:20:29


nl > public {inline} (0 calls)
0: wybe.io.nl<0>
nl()<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @io:17:31
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31

LLVM code       : None

--------------------------------------------------
 Module wybe.list(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.list.,,<0>
                    wybe.list.[]<0>
                    wybe.list.all<0>
                    wybe.list.any<0>
                    wybe.list.empty<0>
                    wybe.list.filter<0>
                    wybe.list.foldl<0>
                    wybe.list.foldr<0>
                    wybe.list.length<0>
                    wybe.list.list<0>
                    wybe.list.map<0>
                    wybe.list.map<1>
                    wybe.list.map<2>
                    wybe.list.print<0>
                    wybe.list.println<0>
                    wybe.list.reverse<0>
  imports         : use wybe.array
                    use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
                    use wybe.machine_word
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_(T) @list:20:10, y:_(T) @list:20:20, ?#result:_(T) @list:20:5):
    if {[|](?h @list:21:16, ?t @list:21:21, x @list:21:10)::

        ,,(t @list:21:32, y @list:21:37, ?tmp#2 @list:21:32)
        [|](h @list:21:28, tmp#2, ?tmp#1 @list:21:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(y @list:21:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:21:10, ?#result @list:20:5)


[] > public {test} (0 calls)
0: [](xs:_(T) @list:31:21, idx:int @list:31:30, ?#result:T @list:31:5):
    >=(idx @list:32:5, 0 @list:32:13)
    index1(xs @list:33:17, idx @list:33:21, ?tmp#0 @list:33:10)
    =(?x @list:33:6, tmp#0)
    foreign llvm move(x @list:31:43, ?#result @list:31:5)


all > public {test} (0 calls)
0: all(p:{test}(T) @list:61:20, xs:_(T) @list:61:33):
    foreign llvm move(xs @list:62:15, ?tmp#0)
    do {
        if {[|](?x @list:62:10, ?tmp#0, tmp#0)::

            p(x @list:63:11)
        else::
            break

        }
    }


any > public {test} (0 calls)
0: any(p:{test}(T) @list:69:20, xs:_(T) @list:69:33):
    [|](?x @list:70:7, ?xs @list:70:12, xs @list:70:18)
    (   p(x @list:71:8)
    | any(p @list:71:17, xs @list:71:20))


empty > public {test} (0 calls)
0: empty(xs:_(T) @list:15:22):
    if {[|](?tmp#0 @list:16:11, ?tmp#1 @list:16:15, xs @list:16:20)::

        fail
    else::
        pass

    }


filter > public (0 calls)
0: filter(p:{test}(T) @list:95:16, !xs:_(T) @list:95:30):
    [](?tmp#0 @list:96:12)
    =(?out @list:96:6, tmp#0)
    foreign llvm move(xs @list:97:15, ?tmp#1)
    do {
        if {[|](?x @list:97:10, ?tmp#1, tmp#1)::

            if {p(x @list:98:16)::

                [|](x @list:98:30, out @list:98:34, ?tmp#2 @list:98:29)
                =(?out @list:98:23, tmp#2)
            else::
                pass

            }
        else::
            break

        }
    }
    reverse(out @list:100:19, ?tmp#3 @list:100:11)
    =(?as @list:100:6, tmp#3)


foldl > public (0 calls)
0: foldl(f:(A, !B) @list:77:15, as:_(A) @list:77:26, !b:B @list:77:36):
    foreign llvm move(as @list:78:15, ?tmp#0)
    do {
        if {[|](?a @list:78:10, ?tmp#0, tmp#0)::

            f(a @list:79:11, !b @list:79:15)
        else::
            break

        }
    }


foldr > public (0 calls)
0: foldr(f:(A, !B) @list:86:15, as:_(A) @list:86:26, !b:B @list:86:36):
    if {[|](?a @list:87:12, ?as @list:87:17, as @list:87:23)::

        foldr(f @list:88:15, as @list:88:18, !b @list:88:23)
        f(a @list:89:11, !b @list:89:15)
    else::
        pass

    }


index1 > {test} (0 calls)
0: index1(xs:_(T) @list:148:19, idx:int @list:148:28, ?#result:T @list:148:1):
    [|](?x @list:149:7, ?xs @list:149:12, xs @list:149:18)
    (   =(idx @list:150:6, 0 @list:150:12)
    | (   -(idx @list:150:27, 1 @list:150:33, ?tmp#0 @list:150:27)
        & index1(xs @list:150:23, tmp#0, ?x @list:150:37)))
    foreign llvm move(x @list:148:41, ?#result @list:148:1)


length > public (0 calls)
0: length(x:_(T) @list:24:16, ?#result:int @list:24:5):
    length1(x @list:24:38, 0 @list:24:41, ?tmp#0 @list:24:30)
    foreign llvm move(tmp#0, ?#result @list:24:5)


length1 > (0 calls)
0: length1(x:_(T) @list:140:13, acc:int @list:140:21, ?#result:int @list:140:1):
    if {[|](?h @list:141:16, ?t @list:141:21, x @list:141:10)::

        +(acc @list:141:38, 1 @list:141:44, ?tmp#2 @list:141:38)
        length1(t @list:141:35, tmp#2, ?tmp#1 @list:141:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(acc @list:141:57, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:141:10, ?#result @list:140:1)


list > public (0 calls)
0: list(ar:array(T) @list:128:14, ?#result:_(T) @list:128:5):
    [](?tmp#0 @list:129:11)
    =(?ls @list:129:6, tmp#0)
    foreign llvm move(ar @list:130:15, ?tmp#1)
    do {
        if {[|](?x @list:130:10, ?tmp#1, tmp#1)::

            [|](x @list:131:16, ls @list:131:20, ?tmp#2 @list:131:15)
            =(?ls @list:131:10, tmp#2)
        else::
            break

        }
    }
    reverse(ls @list:133:13, ?ls @list:133:18)
    foreign llvm move(ls @list:128:34, ?#result @list:128:5)


map > public (0 calls)
0: map(f:{resource}(T) @list:41:13, xs:_(T) @list:41:30):
    foreign llvm move(xs @list:42:15, ?tmp#0)
    do {
        if {[|](?x @list:42:10, ?tmp#0, tmp#0)::

            !f(x @list:43:12)
        else::
            break

        }
    }
map > public (0 calls)
1: map(f:(A, ?B) @list:49:13, as:_(A) @list:49:24, ?#result:_(B) @list:49:5):
    if {[|](?a @list:50:12, ?as @list:50:17, as @list:50:23)::

        f(a @list:50:33, ?tmp#2 @list:50:31)
        map(f @list:50:42, as @list:50:45, ?tmp#3 @list:50:38)
        [|](tmp#2, tmp#3, ?tmp#1 @list:50:29)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:50:61)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:50:10, ?#result @list:49:5)
map > public (0 calls)
2: map(f:(A, B, ?C) @list:55:13, as:_(A) @list:55:27, bs:_(B) @list:55:36, ?#result:_(C) @list:55:5):
    if {(   [|](?a @list:56:12, ?as @list:56:17, as @list:56:23)
        & [|](?b @list:56:30, ?bs @list:56:35, bs @list:56:41))::

        f(a @list:56:51, b @list:56:54, ?tmp#2 @list:56:49)
        map(f @list:56:63, as @list:56:66, bs @list:56:70, ?tmp#3 @list:56:59)
        [|](tmp#2, tmp#3, ?tmp#1 @list:56:47)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:57:47)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:56:10, ?#result @list:55:5)


print > public (0 calls)
0: print(printer:{resource}(T) @list:108:15, xs:_(T) @list:108:38) use !io:
    !print('[' @list:109:12)
    if {[|](?x @list:110:12, ?xs @list:110:17, xs @list:110:23)::

        !printer(x @list:111:18)
        !print1(printer @list:112:17, xs @list:112:26)
    else::
        pass

    }
    !print(']' @list:114:12)


print1 > (0 calls)
0: print1(printer:{resource}(T) @list:154:12, xs:_(T) @list:154:35) use !io:
    if {[|](?x @list:155:12, ?xs @list:155:17, xs @list:155:23)::

        !print(',' @list:156:16)
        !printer(x @list:157:18)
        !print1(printer @list:158:17, xs @list:158:26)
    else::
        pass

    }


println > public (0 calls)
0: println(printer:{resource}(T) @list:119:17, xs:_(T) @list:119:40) use !io:
    !print(printer @list:120:12, xs @list:120:21)
    !nl


reverse > public (0 calls)
0: reverse(x:_(T) @list:27:17, ?#result:_(T) @list:27:5):
    [](?tmp#1 @list:27:44)
    reverse1(x @list:27:41, tmp#1, ?tmp#0 @list:27:32)
    foreign llvm move(tmp#0, ?#result @list:27:5)


reverse1 > (0 calls)
0: reverse1(x:_(T) @list:144:14, tail:_(T) @list:144:22, ?#result:_(T) @list:144:1):
    if {[|](?h @list:145:16, ?t @list:145:21, x @list:145:10)::

        [|](h @list:145:40, tail @list:145:44, ?tmp#2 @list:145:39)
        reverse1(t @list:145:36, tmp#2, ?tmp#1 @list:145:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(tail @list:145:61, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:145:10, ?#result @list:144:1)

LLVM code       : None

--------------------------------------------------
 Module wybe.machine_word
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.machine_word.word_size_bits<0>
                    wybe.machine_word.word_size_bytes<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

word_size_bits > public (0 calls)
0: word_size_bits(?#result:int @machine_word:12:5):
    word_size_bytes(?tmp#1 @machine_word:12:34)
    *(8 @machine_word:12:30, tmp#1, ?tmp#0 @machine_word:12:30)
    foreign llvm move(tmp#0, ?#result @machine_word:12:5)


word_size_bytes > public (0 calls)
0: word_size_bytes(?#result:int @machine_word:10:5):
    foreign llvm move(8 @machine_word:10:31, ?#result @machine_word:10:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.memory_management
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.memory_management.malloc_count<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

malloc_count > public {semipure} (0 calls)
0: malloc_count(?x:int @memory_management:11:34):
    foreign c {impure} malloc_count(?x @memory_management:12:38)

LLVM code       : None

--------------------------------------------------
 Module wybe.phantom
 modifiers       : {unique} 
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : 
  imports         : 
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.predicate
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.predicate.const<0>
                    wybe.predicate.id<0>
  imports         : 
  resources       : 
  procs           : 

const > public {inline} (0 calls)
0: wybe.predicate.const<0>
const(a##0:A <{}; {}; {0}>, [b##0:B <{}; {}; {1}>], ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:8:5


id > public {inline} (0 calls)
0: wybe.predicate.id<0>
id(a##0:A <{}; {}; {0}>, ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:6:5

LLVM code       : None

--------------------------------------------------
 Module wybe.range
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.range...<0>
                    wybe.range.[]<0>
                    wybe.range.[|]<0>
                    wybe.range.irange<0>
                    wybe.range.size<0>
                    wybe.range.xrange<0>
  imports         : use wybe.bool
                    use wybe.int
  resources       : 
  procs           : 

.. > public (0 calls)
0: ..(start:int @range:38:10, end:int @range:38:23, ?#result:_ @range:38:5):
    if {<=(start @range:39:27, end @range:39:37)::

        foreign llvm move(1 @range:39:44, ?tmp#1)
    else::
        foreign llvm move(-1 @range:39:56, ?tmp#1)

    }
    construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)
    foreign llvm move(tmp#0, ?#result @range:38:5)


[] > public {test} (0 calls)
0: [](r:_ @range:20:19, idx:int @range:20:24, ?value:int @range:20:34):
    <=(0 @range:21:6, idx @range:21:12)
    range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)
    *(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)
    +(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)
    =(?value @range:23:6, tmp#0)
    if {<=(0 @range:24:10, stride @range:24:16)::

        <(value @range:24:27, end @range:24:35)
    else::
        <(end @range:24:51, value @range:24:57)

    }


[|] > public {test} (0 calls)
0: [|](?value:int @range:12:23, ?rest:_ @range:12:35, current:_ @range:12:43):
    range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)
    ~=(value @range:14:6, end @range:14:16)
    +(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)
    range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)
    =(?rest @range:15:6, tmp#0)


construct > (0 calls)
0: construct(start:int @range:49:15, stride:int @range:49:26, end:int @range:49:38, ?#result:_ @range:49:1):
    -(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)
    %(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)
    =(?diff @range:50:6, tmp#0)
    if {<=(0 @range:51:19, stride @range:51:25)::

        if {=(diff @range:52:26, 0 @range:52:33)::

            max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
            -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
            max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
            foreign llvm move(tmp#5, ?tmp#3)

        }
        foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
    else::
        if {=(diff @range:55:26, 0 @range:55:33)::

            min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
            foreign llvm move(tmp#9, ?tmp#8)
        else::
            +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
            min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
            foreign llvm move(tmp#10, ?tmp#8)

        }
        foreign llvm move(tmp#8 @range:55:26, ?tmp#2)

    }
    =(?final @range:51:6, tmp#2 @range:51:19)
    range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)
    =(?r @range:58:6, tmp#12)
    foreign llvm move(r @range:49:51, ?#result @range:49:1)


irange > public (0 calls)
0: irange(start:int @range:32:16, stride:int @range:32:27, end:int @range:32:39, ?#result:_ @range:32:5):
    if {<(stride @range:33:41, 0 @range:33:50)::

        foreign llvm move(-1 @range:33:55, ?tmp#2)
    else::
        foreign llvm move(1 @range:33:68, ?tmp#2)

    }
    +(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)
    construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)
    foreign llvm move(tmp#0, ?#result @range:32:5)


size > public (0 calls)
0: size(r:_ @range:42:14, ?#result:int @range:42:5):
    range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)
    if {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
        & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
        & signum(tmp#3, ?tmp#2 @range:44:29)
        & ~=(tmp#1, tmp#2))::

        foreign llvm move(0 @range:44:52, ?tmp#0)
    else::
        if {<=(0 @range:45:10, stride @range:45:16)::

            -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
            -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
            /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
            +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
            foreign llvm move(tmp#5, ?tmp#4)
        else::
            -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
            -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
            -(stride @range:46:39, ?tmp#13 @range:46:38)
            /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
            +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
            foreign llvm move(tmp#9, ?tmp#4)

        }
        foreign llvm move(tmp#4 @range:45:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)


xrange > public (0 calls)
0: xrange(start:int @range:28:16, stride:int @range:28:27, end:int @range:28:39, ?#result:_ @range:28:5):
    construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)
    foreign llvm move(tmp#0, ?#result @range:28:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.string
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.string.,,<0>
                    wybe.string.<<0>
                    wybe.string.<=<0>
                    wybe.string.<=><0>
                    wybe.string.=<0>
                    wybe.string.><0>
                    wybe.string.>=<0>
                    wybe.string.[]<0>
                    wybe.string.[]<1>
                    wybe.string.[|]<0>
                    wybe.string.c_string<0>
                    wybe.string.length<0>
                    wybe.string.print<0>
                    wybe.string.println<0>
                    wybe.string.read<0>
                    wybe.string.string<0>
                    wybe.string.string<1>
                    wybe.string.~=<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.char
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
                    use wybe.range
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_ @string:64:10, y:_ @string:64:17, ?#result:_ @string:64:5):
    if {(   empty(?tmp#1 @string:65:14)
        & =(x @string:65:10, tmp#1))::

        foreign llvm move(y @string:65:23, ?tmp#0)
    else::
        if {(   empty(?tmp#3 @string:66:14)
            & =(y @string:66:10, tmp#3))::

            foreign llvm move(x @string:66:23, ?tmp#2)
        else::
            concat(x @string:67:25, y @string:67:28, ?tmp#4 @string:67:18)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:66:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:65:10, ?#result @string:64:5)


< > public (0 calls)
0: <(x:_ @string:119:10, y:_ @string:119:17, ?#result:bool @string:119:5):
    <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
    equal(?tmp#2 @string:119:44)
    <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
    foreign llvm move(tmp#0, ?#result @string:119:5)


<= > public (0 calls)
0: <=(x:_ @string:120:10, y:_ @string:120:18, ?#result:bool @string:120:5):
    <=>(x @string:120:31, y @string:120:39, ?tmp#1 @string:120:31)
    equal(?tmp#2 @string:120:46)
    <=(tmp#1, tmp#2, ?tmp#0 @string:120:30)
    foreign llvm move(tmp#0, ?#result @string:120:5)


<=> > public (0 calls)
0: <=>(x:_ @string:125:10, y:_ @string:125:20, ?#result:comparison @string:125:5):
    equal(?tmp#0 @string:126:10)
    =(?c @string:126:6, tmp#0)
    foreign llvm move(x @string:127:16, ?tmp#1)
    foreign llvm move(y @string:127:26, ?tmp#2)
    do {
        if {[|](?cx @string:127:10, ?tmp#1, tmp#1)::

            if {[|](?cy @string:127:20, ?tmp#2, tmp#2)::

                if {<(cx @string:128:14, cy @string:128:19)::

                    lesser(?tmp#3 @string:128:30)
                    =(?c @string:128:26, tmp#3)
                    break
                else::
                    if {>(cx @string:129:14, cy @string:129:19)::

                        greater(?tmp#4 @string:129:30)
                        =(?c @string:129:26, tmp#4)
                        break
                    else::
                        pass

                    }

                }
            else::
                break

            }
        else::
            break

        }
    }
    if {(   equal(?tmp#5 @string:132:14)
        & =(c @string:132:10, tmp#5))::

        length(x @string:133:22, ?tmp#6 @string:133:15)
        =(?lx @string:133:10, tmp#6)
        length(y @string:134:22, ?tmp#7 @string:134:15)
        =(?ly @string:134:10, tmp#7)
        if {<(lx @string:135:14, ly @string:135:19)::

            lesser(?tmp#8 @string:135:30)
            =(?c @string:135:26, tmp#8)
        else::
            if {>(lx @string:135:39, ly @string:135:44)::

                greater(?tmp#9 @string:135:55)
                =(?c @string:135:51, tmp#9)
            else::
                pass

            }

        }
    else::
        pass

    }
    foreign llvm move(c @string:125:38, ?#result @string:125:5)


= > public (0 calls)
0: =(x:_ @string:115:10, y:_ @string:115:17, ?#result:bool @string:115:5):
    <=>(x @string:115:30, y @string:115:38, ?tmp#1 @string:115:30)
    equal(?tmp#2 @string:115:44)
    =(tmp#1, tmp#2, ?tmp#0 @string:115:29)
    foreign llvm move(tmp#0, ?#result @string:115:5)


> > public (0 calls)
0: >(x:_ @string:121:10, y:_ @string:121:17, ?#result:bool @string:121:5):
    <=>(x @string:121:30, y @string:121:38, ?tmp#1 @string:121:30)
    equal(?tmp#2 @string:121:44)
    >(tmp#1, tmp#2, ?tmp#0 @string:121:29)
    foreign llvm move(tmp#0, ?#result @string:121:5)


>= > public (0 calls)
0: >=(x:_ @string:122:10, y:_ @string:122:18, ?#result:bool @string:122:5):
    <=>(x @string:122:31, y @string:122:39, ?tmp#1 @string:122:31)
    equal(?tmp#2 @string:122:46)
    >=(tmp#1, tmp#2, ?tmp#0 @string:122:30)
    foreign llvm move(tmp#0, ?#result @string:122:5)


[] > public {test} (0 calls)
0: [](s:_ @string:91:19, idx:int @string:91:24, ?c:char @string:91:34):
    if {buffer(?len @string:93:17, ?str @string:93:23, s @string:92:10)::

        <=(0 @string:94:14, idx @string:94:20)
        <(idx @string:95:14, len @string:95:20)
        unsafe_c_string_index(str @string:96:35, idx @string:96:40, ?c @string:96:46)
    else::
        if {concat(?left @string:97:17, ?right @string:97:24, s @string:92:10)::

            length(left @string:98:32, ?tmp#0 @string:98:25)
            =(?left_len @string:98:14, tmp#0)
            if {<(idx @string:99:18, left_len @string:99:24)::

                [](left @string:99:41, idx @string:99:46, ?tmp#1 @string:99:41)
                =(?c @string:99:37, tmp#1)
            else::
                -(idx @string:100:37, left_len @string:100:43, ?tmp#3 @string:100:37)
                [](right @string:100:31, tmp#3, ?tmp#2 @string:100:31)
                =(?c @string:100:27, tmp#2)

            }
        else::
            if {slice(?base @string:102:16, ?range @string:102:23, s @string:92:10)::

                [](range @string:102:43, idx @string:102:49, ?tmp#5 @string:102:43)
                [](base @string:102:38, tmp#5, ?tmp#4 @string:102:38)
                =(?c @string:102:34, tmp#4)
            else::
                if {singleton(?c @string:103:20, s @string:92:10)::

                    =(idx @string:103:27, 0 @string:103:33)
                else::
                    fail

                }

            }

        }

    }
[] > public (0 calls)
1: [](s:_ @string:109:12, r:range @string:109:17, ?#result:_ @string:109:5):
    slice(s @string:109:36, r @string:109:39, ?tmp#0 @string:109:30)
    foreign llvm move(tmp#0, ?#result @string:109:5)


[|] > public {test} (0 calls)
0: [|](?head:char @string:71:23, ?tail:_ @string:71:35, s:_ @string:71:43):
    if {buffer(?len @string:73:17, ?str @string:73:23, s @string:72:10)::

        [|](?head @string:74:15, ?str @string:74:23, str @string:74:30)
        if {=(len @string:75:26, 1 @string:75:32)::

            empty(?tmp#1 @string:75:37)
            foreign llvm move(tmp#1, ?tmp#0)
        else::
            -(len @string:75:60, 1 @string:75:66, ?tmp#3 @string:75:60)
            buffer(tmp#3, str @string:75:69, ?tmp#2 @string:75:53)
            foreign llvm move(tmp#2, ?tmp#0)

        }
        =(?tail @string:75:14, tmp#0 @string:75:26)
    else::
        if {concat(?left @string:76:17, ?right @string:76:24, s @string:72:10)::

            if {[|](?head @string:77:20, ?t @string:77:28, left @string:77:33)::

                concat(t @string:77:56, right @string:77:59, ?tmp#4 @string:77:49)
                =(?tail @string:77:42, tmp#4)
            else::
                [|](?head @string:78:28, ?tail @string:78:36, right @string:78:44)

            }
        else::
            if {slice(?base @string:80:16, ?range @string:80:23, s @string:72:10)::

                do {
                    [|](?idx @string:82:19, ?range @string:82:26, range @string:82:35)
                    if {(   [](base @string:83:30, idx @string:83:35, ?tmp#5 @string:83:30)
                        & =(?head @string:83:23, tmp#5))::

                        slice(base @string:83:57, range @string:83:63, ?tmp#6 @string:83:51)
                        =(?tail @string:83:44, tmp#6)
                        break
                    else::
                        pass

                    }
                }
            else::
                if {singleton(?head @string:85:20, s @string:72:10)::

                    empty(?tmp#7 @string:85:37)
                    =(?tail @string:85:30, tmp#7)
                else::
                    fail

                }

            }

        }

    }


c_string > public (0 calls)
0: c_string(s:_ @string:40:18, ?#result:c_string @string:40:5):
    if {buffer(?tmp#0 @string:41:21, ?str @string:41:25, s @string:41:10)::

        pass
    else::
        length(s @string:43:27, ?tmp#2 @string:43:20)
        +(tmp#2, 1 @string:43:32, ?tmp#1 @string:43:20)
        =(?len @string:43:14, tmp#1)
        foreign lpvm alloc(len @string:44:32, ?str @string:44:38)
        true(?tmp#3 @string:45:49)
        foreign lpvm mutate(str @string:45:33, ?str @string:45:39, len @string:45:44, tmp#3, len @string:45:55, 0 @string:45:60, '\NUL' @string:45:63)
        =(?offset @string:46:14, 0 @string:46:23)
        pack(s @string:47:18, !str @string:47:22, len @string:47:27, !offset @string:47:33)

    }
    foreign llvm move(str @string:40:34, ?#result @string:40:5)


fixed_range_size > (0 calls)
0: fixed_range_size(hi:int @string:184:22, r:range @string:184:30, ?sz:int @string:184:40):
    range(?start @string:185:16, ?stride @string:185:24, ?end @string:185:33, r @string:185:5)
    if {<=(0 @string:186:10, stride @string:186:16)::

        -(start @string:187:39, ?tmp#4 @string:187:38)
        /(tmp#4, stride @string:187:47, ?tmp#3 @string:187:38)
        *(tmp#3, stride @string:187:56, ?tmp#2 @string:187:38)
        +(start @string:187:30, tmp#2, ?tmp#1 @string:187:30)
        max(start @string:187:23, tmp#1, ?tmp#0 @string:187:19)
        =(?lo @string:187:14, tmp#0)
        min(hi @string:188:23, end @string:188:27, ?tmp#5 @string:188:19)
        =(?hi @string:188:14, tmp#5)
    else::
        max(-1 @string:190:23, end @string:190:27, ?tmp#6 @string:190:19)
        =(?lo @string:190:14, tmp#6)
        +(hi @string:191:30, stride @string:191:35, ?tmp#10 @string:191:30)
        -(start @string:191:45, hi @string:191:53, ?tmp#13 @string:191:45)
        -(tmp#13, 1 @string:191:58, ?tmp#12 @string:191:45)
        -(stride @string:191:64, ?tmp#14 @string:191:63)
        %(tmp#12, tmp#14, ?tmp#11 @string:191:44)
        +(tmp#10, tmp#11, ?tmp#9 @string:191:30)
        +(tmp#9, 1 @string:191:73, ?tmp#8 @string:191:30)
        min(start @string:191:23, tmp#8, ?tmp#7 @string:191:19)
        =(?hi @string:191:14, tmp#7)
        -(stride @string:192:24, ?tmp#15 @string:192:23)
        =(?stride @string:192:14, tmp#15)

    }
    if {<=(hi @string:194:16, lo @string:194:23)::

        foreign llvm move(0 @string:194:29, ?tmp#16)
    else::
        -(hi @string:194:42, lo @string:194:47, ?tmp#20 @string:194:42)
        -(tmp#20, 1 @string:194:52, ?tmp#19 @string:194:42)
        /(tmp#19, stride @string:194:57, ?tmp#18 @string:194:41)
        +(tmp#18, 1 @string:194:66, ?tmp#17 @string:194:41)
        foreign llvm move(tmp#17, ?tmp#16)

    }
    =(?sz @string:194:6, tmp#16 @string:194:16)


length > public (0 calls)
0: length(s:_ @string:52:16, ?#result:int @string:52:5):
    if {buffer(?len @string:53:22, ?tmp#1 @string:53:27, s @string:53:10)::

        foreign llvm move(len @string:53:33, ?tmp#0)
    else::
        if {concat(?left @string:54:22, ?right @string:54:29, s @string:54:10)::

            length(left @string:54:46, ?tmp#4 @string:54:39)
            length(right @string:54:61, ?tmp#5 @string:54:54)
            +(tmp#4, tmp#5, ?tmp#3 @string:54:39)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            if {slice(?base @string:55:21, ?range @string:55:28, s @string:55:10)::

                length(base @string:55:62, ?tmp#8 @string:55:55)
                fixed_range_size(tmp#8, range @string:55:69, ?tmp#7 @string:55:38)
                foreign llvm move(tmp#7, ?tmp#6)
            else::
                if {singleton(?tmp#10 @string:56:24, s @string:56:10)::

                    foreign llvm move(1 @string:56:30, ?tmp#9)
                else::
                    foreign llvm move(0 @string:57:18, ?tmp#9)

                }
                foreign llvm move(tmp#9 @string:56:10, ?tmp#6)

            }
            foreign llvm move(tmp#6 @string:55:10, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:54:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:53:10, ?#result @string:52:5)


pack > (0 calls)
0: pack(s:_ @string:160:10, !raw:c_string @string:160:16, size:int @string:160:30, !offset:int @string:160:41):
    if {buffer(?tmp#0 @string:162:16, ?str @string:162:20, s @string:161:10)::

        foreign llvm move(str @string:163:23, ?tmp#1)
        do {
            if {[|](?c @string:163:18, ?tmp#1, tmp#1)::

                true(?tmp#2 @string:164:56)
                foreign lpvm mutate(raw @string:164:37, ?raw @string:164:43, offset @string:164:48, tmp#2, size @string:164:62, 0 @string:164:68, c @string:164:71)
                incr(!offset @string:165:23)
            else::
                break

            }
        }
    else::
        if {concat(?left @string:167:17, ?right @string:167:24, s @string:161:10)::

            pack(left @string:168:18, !raw @string:168:25, size @string:168:30, !offset @string:168:37)
            pack(right @string:169:18, !raw @string:169:26, size @string:169:31, !offset @string:169:38)
            incr(!offset @string:170:19)
        else::
            if {slice(?tmp#3 @string:171:15, ?tmp#4 @string:171:18, s @string:161:10)::

                foreign llvm move(s @string:172:23, ?tmp#5)
                do {
                    if {[|](?c @string:172:18, ?tmp#5, tmp#5)::

                        true(?tmp#6 @string:173:56)
                        foreign lpvm mutate(raw @string:173:37, ?raw @string:173:43, offset @string:173:48, tmp#6, size @string:173:62, 0 @string:173:68, c @string:173:71)
                        incr(!offset @string:174:23)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:176:20, s @string:161:10)::

                    true(?tmp#7 @string:177:52)
                    foreign lpvm mutate(raw @string:177:33, ?raw @string:177:39, offset @string:177:44, tmp#7, size @string:177:58, 0 @string:177:64, c @string:177:67)
                    incr(!offset @string:178:19)
                else::
                    fail

                }

            }

        }

    }


print > public (0 calls)
0: print(x:_ @string:142:15) use !io:
    if {buffer(?tmp#0 @string:144:16, ?str @string:144:20, x @string:143:10)::

        !print(str @string:144:35)
    else::
        if {concat(?left @string:145:17, ?right @string:145:24, x @string:143:10)::

            !print(left @string:145:41)
            !print(right @string:145:55)
        else::
            if {slice(?tmp#1 @string:146:15, ?tmp#2 @string:146:18, x @string:143:10)::

                foreign llvm move(x @string:146:34, ?tmp#3)
                do {
                    if {[|](?c @string:146:29, ?tmp#3, tmp#3)::

                        !print(c @string:146:45)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:147:20, x @string:143:10)::

                    !print(c @string:147:33)
                else::
                    fail

                }

            }

        }

    }


println > public (0 calls)
0: println(x:_ @string:151:17) use !io:
    !print(x @string:151:39)
    !nl


read > public (0 calls)
0: read(?x:_ @string:153:15) use !io:
    !read(?str:c_string @string:153:37)
    string(str @string:153:64, ?tmp#0 @string:153:57)
    =(?x @string:153:53, tmp#0)


string > public (0 calls)
0: string(str:c_string @string:28:16, ?#result:_ @string:28:5):
    length(str @string:29:19, ?tmp#0 @string:29:12)
    =(?len @string:29:6, tmp#0)
    if {=(len @string:30:15, 0 @string:30:21)::

        empty(?tmp#2 @string:30:26)
        foreign llvm move(tmp#2, ?tmp#1)
    else::
        if {=(len @string:31:15, 1 @string:31:21)::

            foreign lpvm access(str @string:31:56, 0 @string:31:61, 1 @string:31:64, 0 @string:31:67, ?tmp#5 @string:31:36)
            singleton(tmp#5, ?tmp#4 @string:31:26)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            buffer(len @string:32:33, str @string:32:38, ?tmp#6 @string:32:26)
            foreign llvm move(tmp#6, ?tmp#3)

        }
        foreign llvm move(tmp#3 @string:31:15, ?tmp#1)

    }
    =(?s @string:30:6, tmp#1 @string:30:15)
    foreign llvm move(s @string:28:34, ?#result @string:28:5)
string > public (0 calls)
1: string(c:char @string:37:16, ?#result:_ @string:37:5):
    singleton(c @string:37:38, ?tmp#0 @string:37:28)
    foreign llvm move(tmp#0, ?#result @string:37:5)


~= > public (0 calls)
0: ~=(x:_ @string:116:10, y:_ @string:116:18, ?#result:bool @string:116:5):
    <=>(x @string:116:31, y @string:116:39, ?tmp#1 @string:116:31)
    equal(?tmp#2 @string:116:46)
    ~=(tmp#1, tmp#2, ?tmp#0 @string:116:30)
    foreign llvm move(tmp#0, ?#result @string:116:5)

LLVM code       : None

======================================================================
AFTER FLATTENING:
 Module wybe
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : 
  imports         : public use wybe.array
                    public use wybe.bool
                    public use wybe.c_string
                    public use wybe.char
                    public use wybe.comparison
                    public use wybe.control
                    public use wybe.count
                    public use wybe.float
                    public use wybe.int
                    public use wybe.io
                    public use wybe.list
                    public use wybe.machine_word
                    public use wybe.memory_management
                    public use wybe.phantom
                    public use wybe.predicate
                    public use wybe.range
                    public use wybe.string
  resources       : 
  submodules      : wybe.array, wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.control, wybe.count, wybe.float, wybe.int, wybe.io, wybe.list, wybe.machine_word, wybe.memory_management, wybe.phantom, wybe.predicate, wybe.range, wybe.string
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.array(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.array.[]<0>
                    wybe.array.[]<1>
                    wybe.array.[|]<0>
                    wybe.array.array<0>
                    wybe.array.array<1>
                    wybe.array.inbounds<0>
                    wybe.array.unsafe_get<0>
                    wybe.array.unsafe_update<0>
  imports         : public use wybe.array.raw_array
                    use wybe.bool
                    use wybe.int
                    use wybe.list
                    use wybe.machine_word
  resources       : 
  submodules      : wybe.array.raw_array
  procs           : 

[] > public {test} (0 calls)
0: [](a:_(T) @array:67:21, idx:int @array:67:29, ?#result:T @array:67:5):
    inbounds(a @array:68:14, idx @array:68:17)
    unsafe_get(a @array:69:10, idx @array:69:23, ?tmp#0 @array:69:10)
    =(?x @array:69:6, tmp#0)
    foreign llvm move(x @array:67:42, ?#result @array:67:5)
[] > public {test} (0 calls)
1: [](!a:_(T) @array:81:22, idx:int @array:81:30, x:T @array:81:39):
    inbounds(a @array:82:14, idx @array:82:17)
    unsafe_update(!a @array:83:20, idx @array:83:23, x @array:83:28)


[|] > public {test} (0 calls)
0: [|](?head:T @array:51:23, ?tail:_(T) @array:51:32, a:_(T) @array:51:43):
    array(?length @array:52:12, ?data @array:52:21, a @array:52:29)
    >(length @array:53:6, 0 @array:53:15)
    word_size_bytes(?tmp#0 @array:54:34)
    foreign lpvm access(data @array:54:25, 0 @array:54:31, tmp#0, 0 @array:54:51, ?head @array:54:55)
    word_size_bytes(?tmp#1 @array:55:28)
    foreign llvm add(data @array:55:22, tmp#1, ?data @array:55:46)
    -(length @array:56:19, 1 @array:56:28, ?tmp#3 @array:56:19)
    array(tmp#3, data @array:56:31, ?tmp#2 @array:56:13)
    =(?tail @array:56:6, tmp#2)


array > public (0 calls)
0: array(x:T @array:18:15, len:int @array:18:20, ?#result:_(T) @array:18:5):
    word_size_bytes(?tmp#1 @array:19:19)
    *(len @array:19:13, tmp#1, ?tmp#0 @array:19:13)
    =(?size @array:19:6, tmp#0)
    foreign lpvm alloc(size @array:20:24, ?data @array:20:31)
    =(?offset @array:21:6, 0 @array:21:15)
    do {
        if {<(offset @array:23:15, size @array:23:24)::

            pass
        else::
            break

        }
        foreign lpvm mutate(data @array:24:29, ?data @array:24:36, offset @array:24:42, 1 @array:24:50, size @array:24:53, 0 @array:24:59, x @array:24:62)
        word_size_bytes(?tmp#2 @array:25:21)
        +=(!offset @array:25:10, tmp#2)
    }
    array(len @array:27:17, data @array:27:22, ?tmp#3 @array:27:11)
    =(?ar @array:27:6, tmp#3)
    foreign llvm move(ar @array:18:36, ?#result @array:18:5)
array > public (0 calls)
1: array(ls:list(T) @array:34:15, ?#result:_(T) @array:34:5):
    length(ls @array:35:19, ?tmp#0 @array:35:12)
    =(?len @array:35:6, tmp#0)
    word_size_bytes(?tmp#2 @array:36:19)
    *(len @array:36:13, tmp#2, ?tmp#1 @array:36:13)
    =(?size @array:36:6, tmp#1)
    foreign lpvm alloc(size @array:37:24, ?data @array:37:31)
    =(?offset @array:38:6, 0 @array:38:15)
    foreign llvm move(ls @array:39:15, ?tmp#3)
    do {
        if {[|](?x @array:39:10, ?tmp#3, tmp#3)::

            foreign lpvm mutate(data @array:40:29, ?data @array:40:36, offset @array:40:42, 1 @array:40:50, size @array:40:53, 0 @array:40:59, x @array:40:62)
            word_size_bytes(?tmp#4 @array:41:21)
            +=(!offset @array:41:10, tmp#4)
        else::
            break

        }
    }
    array(len @array:43:17, data @array:43:22, ?tmp#5 @array:43:11)
    =(?ar @array:43:6, tmp#5)
    foreign llvm move(ar @array:34:34, ?#result @array:34:5)


inbounds > public {test,inline} (0 calls)
0: inbounds(a:_(T) @array:60:33, idx:int @array:60:41):
    <=(0 @array:61:6, idx @array:61:12)
    length(a @array:62:12, ?tmp#0 @array:62:12)
    <(idx @array:62:6, tmp#0)


unsafe_get > public {inline} (0 calls)
0: unsafe_get(a:_(T) @array:75:29, idx:int @array:75:37, ?#result:T @array:75:5):
    raw_data(a @array:76:25, ?tmp#0 @array:76:25)
    word_size_bytes(?tmp#2 @array:76:43)
    *(idx @array:76:37, tmp#2, ?tmp#1 @array:76:37)
    word_size_bytes(?tmp#3 @array:76:60)
    foreign lpvm access(tmp#0, tmp#1, tmp#3, 0 @array:76:77, ?x @array:76:81)
    foreign llvm move(x @array:75:50, ?#result @array:75:5)


unsafe_update > public {inline} (0 calls)
0: unsafe_update(!a:_(T) @array:89:33, idx:int @array:89:41, x:T @array:89:50):
    raw_data(a @array:90:25, ?tmp#0 @array:90:25)
    word_size_bytes(?tmp#2 @array:90:50)
    *(idx @array:90:44, tmp#2, ?tmp#1 @array:90:44)
    length(a @array:91:44, ?tmp#4 @array:91:44)
    word_size_bytes(?tmp#5 @array:91:55)
    *(tmp#4, tmp#5, ?tmp#3 @array:91:44)
    foreign lpvm mutate(tmp#0, ?data @array:90:38, tmp#1, 0 @array:90:67, tmp#3, 0 @array:91:72, x @array:91:75)
    raw_data(!a @array:92:6, data @array:92:19)

LLVM code       : None

--------------------------------------------------
 Module wybe.array.raw_array(T)
  representation  : address
  public submods  : 
  public resources: 
  public procs    : 
  imports         : use wybe
                    use wybe.array
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.bool
  representation  : 1 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.bool.&&<0>
                    wybe.bool.&=<0>
                    wybe.bool.=<0>
                    wybe.bool.^=<0>
                    wybe.bool.^^<0>
                    wybe.bool.false<0>
                    wybe.bool.print<0>
                    wybe.bool.println<0>
                    wybe.bool.succeed<0>
                    wybe.bool.true<0>
                    wybe.bool.|=<0>
                    wybe.bool.||<0>
                    wybe.bool.~<0>
                    wybe.bool.~=<0>
  imports         : use wybe.c_string
                    use wybe.io
  resources       : 
  procs           : 

&& > public {inline} (1 calls)
0: wybe.bool.&&<0>
&&(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:13:27


&= > public {inline} (0 calls)
0: wybe.bool.&=<0>
&=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:13:27


= > public {inline} (0 calls)
0: wybe.bool.=<0>
=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:37:26


^= > public {inline} (0 calls)
0: wybe.bool.^=<0>
^=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:25:27


^^ > public {inline} (1 calls)
0: wybe.bool.^^<0>
^^(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:25:27


false > public {inline} (0 calls)
0: wybe.bool.false<0>
false(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.bool, ?#result##0:wybe.bool)


print > public (1 calls)
0: wybe.bool.print<0>
print(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    case ~x##0:wybe.bool of
    0:
        wybe.c_string.print<0>(c"false":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #1 @bool:47:31

    1:
        wybe.c_string.print<0>(c"true":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:47:31



println > public {inline} (0 calls)
0: wybe.bool.println<0>
println(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.bool.print<0>(~x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:49:33
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#0##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~tmp#0##0:wybe.phantom, ?tmp#1##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#1##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


succeed > public {inline} (0 calls)
0: wybe.bool.succeed<0>
succeed()<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []


true > public {inline} (1 calls)
0: wybe.bool.true<0>
true(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.bool, ?#result##0:wybe.bool)


|= > public {inline} (0 calls)
0: wybe.bool.|=<0>
|=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:19:27


|| > public {inline} (1 calls)
0: wybe.bool.||<0>
||(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:19:27


~ > public {inline} (0 calls)
0: wybe.bool.~<0>
~(p##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, 1:wybe.bool, ?#result##0:wybe.bool) @bool:31:20


~= > public {inline} (0 calls)
0: wybe.bool.~=<0>
~=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:38:27

LLVM code       : None

--------------------------------------------------
 Module wybe.c_string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.c_string.<<0>
                    wybe.c_string.<=<0>
                    wybe.c_string.=<0>
                    wybe.c_string.><0>
                    wybe.c_string.>=<0>
                    wybe.c_string.[]<0>
                    wybe.c_string.[|]<0>
                    wybe.c_string.length<0>
                    wybe.c_string.print<0>
                    wybe.c_string.println<0>
                    wybe.c_string.read<0>
                    wybe.c_string.unsafe_c_string_index<0>
                    wybe.c_string.~=<0>
  imports         : use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.c_string.<<0>
<(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:12:29
    wybe.int.<<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:12:29


<= > public {inline} (0 calls)
0: wybe.c_string.<=<0>
<=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:13:30
    wybe.int.<=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:13:30


= > public {inline} (0 calls)
0: wybe.c_string.=<0>
=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:10:29
    wybe.int.=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:10:29


> > public {inline} (0 calls)
0: wybe.c_string.><0>
>(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:14:29
    wybe.int.><0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:14:29


>= > public {inline} (0 calls)
0: wybe.c_string.>=<0>
>=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:15:30
    wybe.int.>=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:15:30


[] > public (0 calls)
0: wybe.c_string.[]<0>
[](str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, idx##0:wybe.int, ?tmp#2##0:wybe.bool) #0 @c_string:27:6
    case ~tmp#2##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        foreign c strlen(str##0:wybe.c_string, ?tmp#0##0:wybe.int) @c_string:17:29
        wybe.int.<<0>(idx##0:wybe.int, ~tmp#0##0:wybe.int, ?tmp#3##0:wybe.bool) #2 @c_string:28:6
        case ~tmp#3##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




[|] > public (0 calls)
0: wybe.c_string.[|]<0>
[|](?head##0:wybe.char, ?tail##0:wybe.c_string, str##0:wybe.c_string, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(str##0:wybe.c_string, 0:wybe.int, 0:wybe.int, 0:wybe.int, ?head##0:wybe.char) @c_string:20:5
    foreign llvm icmp_ne(head##0:wybe.char, '\NUL':wybe.char, ?not_done##0:wybe.bool) @c_string:21:5
    foreign llvm icmp_eq(~not_done##0:wybe.bool, 1:wybe.bool, ?tmp#1##0:wybe.bool) @bool:37:26
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.c_string, ?tail##0:wybe.c_string)

    1:
        foreign llvm add(~str##0:wybe.c_string, 1:wybe.int, ?tail##0:wybe.c_string) @c_string:23:5
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



length > public {inline} (3 calls)
0: wybe.c_string.length<0>
length(str##0:wybe.c_string, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strlen(~str##0:wybe.c_string, ?#result##0:wybe.int) @c_string:17:29


print > public {inline} (1 calls)
0: wybe.c_string.print<0>
print(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:35:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:35:30


println > public {inline} (0 calls)
0: wybe.c_string.println<0>
println(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @c_string:35:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.c_string.read<0>
read(?x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:39:30
    foreign c read_line(?x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:39:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:39:30


unsafe_c_string_index > public {inline} (1 calls)
0: wybe.c_string.unsafe_c_string_index<0>
unsafe_c_string_index(str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7


~= > public {inline} (0 calls)
0: wybe.c_string.~=<0>
~=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:11:30
    wybe.int.~=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.char
  representation  : 8 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.char.<<0>
                    wybe.char.<=<0>
                    wybe.char.<=><0>
                    wybe.char.=<0>
                    wybe.char.><0>
                    wybe.char.>=<0>
                    wybe.char.chr<0>
                    wybe.char.ord<0>
                    wybe.char.print<0>
                    wybe.char.println<0>
                    wybe.char.read<0>
                    wybe.char.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (4 calls)
0: wybe.char.<<0>
<(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:17:29


<= > public {inline} (0 calls)
0: wybe.char.<=<0>
<=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:18:30


<=> > public (0 calls)
0: wybe.char.<=><0>
<=>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.char, y##0:wybe.char, ?tmp#6##0:wybe.bool) @char:17:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?tmp#5##0:wybe.bool) @char:13:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5



= > public {inline} (2 calls)
0: wybe.char.=<0>
=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:13:29


> > public {inline} (0 calls)
0: wybe.char.><0>
>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:19:29


>= > public {inline} (0 calls)
0: wybe.char.>=<0>
>=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:20:30


chr > public (0 calls)
0: wybe.char.chr<0>
chr(i##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, i##0:wybe.int, ?tmp#1##0:wybe.bool) #0 @char:33:60
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        wybe.int.<=<0>(i##0:wybe.int, 255:wybe.int, ?tmp#2##0:wybe.bool) #1 @char:33:70
        case ~tmp#2##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm cast(~i##0:wybe.int, ?#result##0:wybe.char) @char:33:31
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




ord > public {inline} (0 calls)
0: wybe.char.ord<0>
ord(c##0:wybe.char, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(~c##0:wybe.char, ?#result##0:wybe.int) @char:30:24


print > public {inline} (1 calls)
0: wybe.char.print<0>
print(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:37:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:37:30


println > public {inline} (0 calls)
0: wybe.char.println<0>
println(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @char:37:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.char.read<0>
read(?x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:41:30
    foreign c read_char(?x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:41:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:41:30


~= > public {inline} (0 calls)
0: wybe.char.~=<0>
~=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:14:30

LLVM code       : None

--------------------------------------------------
 Module wybe.comparison
  representation  : 2 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.comparison.<<0>
                    wybe.comparison.<=<0>
                    wybe.comparison.=<0>
                    wybe.comparison.><0>
                    wybe.comparison.>=<0>
                    wybe.comparison.equal<0>
                    wybe.comparison.greater<0>
                    wybe.comparison.lesser<0>
                    wybe.comparison.~=<0>
  imports         : use wybe.bool
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.comparison.<<0>
<(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:12:29


<= > public {inline} (0 calls)
0: wybe.comparison.<=<0>
<=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:13:30


= > public {inline} (0 calls)
0: wybe.comparison.=<0>
=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:10:29


> > public {inline} (0 calls)
0: wybe.comparison.><0>
>(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:14:29


>= > public {inline} (0 calls)
0: wybe.comparison.>=<0>
>=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:15:30


equal > public {inline} (0 calls)
0: wybe.comparison.equal<0>
equal(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison)


greater > public {inline} (0 calls)
0: wybe.comparison.greater<0>
greater(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison)


lesser > public {inline} (0 calls)
0: wybe.comparison.lesser<0>
lesser(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison)


~= > public {inline} (0 calls)
0: wybe.comparison.~=<0>
~=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.control
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.control.assert<0>
                    wybe.control.error<0>
                    wybe.control.error<1>
                    wybe.control.exit<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.int
                    use wybe.string
  resources       : 
  procs           : 

assert > public {semipure} (0 calls)
0: assert(condition:bool @control:26:27) use call_source_location:
    if {~(condition @control:27:11)::

        !error(c"assertion failed" @control:27:31)
    else::
        pass

    }


error > public {terminal,semipure} (0 calls)
0: error(message:string @control:17:35) use call_source_location:
    c_string(message @control:18:77, ?tmp#0 @control:18:68)
    foreign c {terminal,semipure} error_exit(call_source_location @control:18:46, tmp#0)
error > public {terminal,semipure} (0 calls)
1: error(message:c_string @control:21:35) use call_source_location:
    foreign c {terminal,semipure} error_exit(call_source_location @control:22:46, message @control:22:68)


exit > public {terminal,semipure} (0 calls)
0: exit(code:int @control:10:34):
    foreign c {terminal,semipure} exit(code @control:11:40)

LLVM code       : None

--------------------------------------------------
 Module wybe.count
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.count.%<0>
                    wybe.count.%=<0>
                    wybe.count.*<0>
                    wybe.count.*=<0>
                    wybe.count.+<0>
                    wybe.count.+<1>
                    wybe.count.+<2>
                    wybe.count.+=<0>
                    wybe.count.-<0>
                    wybe.count.-<1>
                    wybe.count.-<2>
                    wybe.count.-=<0>
                    wybe.count./<0>
                    wybe.count./=<0>
                    wybe.count.<<0>
                    wybe.count.<=<0>
                    wybe.count.<=><0>
                    wybe.count.=<0>
                    wybe.count.><0>
                    wybe.count.>=<0>
                    wybe.count.decr<0>
                    wybe.count.incr<0>
                    wybe.count.max<0>
                    wybe.count.min<0>
                    wybe.count.print<0>
                    wybe.count.println<0>
                    wybe.count.read<0>
                    wybe.count.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.count.%<0>
%(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:51:25


%= > public {inline} (0 calls)
0: wybe.count.%=<0>
%=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:51:25


* > public {inline} (1 calls)
0: wybe.count.*<0>
*(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:39:25


*= > public {inline} (0 calls)
0: wybe.count.*=<0>
*=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:39:25


+ > public {inline} (2 calls)
0: wybe.count.+<0>
+(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:15:25
+ > public (0 calls)
1: wybe.count.+<1>
+(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(y##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?x##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~y##0:wybe.count, ?x##0:wybe.count) @count:18:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

+ > public (0 calls)
2: wybe.count.+<2>
+(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?y##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:22:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



+= > public {inline} (0 calls)
0: wybe.count.+=<0>
+=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:15:25


- > public (6 calls)
0: wybe.count.-<0>
-(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?#result##0:wybe.count)

    1:
        foreign llvm sub(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:31:35
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

- > public {inline} (0 calls)
1: wybe.count.-<1>
-(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.count, ~z##0:wybe.count, ?x##0:wybe.count) @count:32:42
- > public {inline} (0 calls)
2: wybe.count.-<2>
-(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:33:42


-= > public (0 calls)
0: wybe.count.-=<0>
-=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, ~y##0:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:36:41
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:36:37
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



/ > public {inline} (1 calls)
0: wybe.count./<0>
/(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:45:25


/= > public {inline} (0 calls)
0: wybe.count./=<0>
/=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:45:25


< > public {inline} (4 calls)
0: wybe.count.<<0>
<(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:64:29


<= > public {inline} (3 calls)
0: wybe.count.<=<0>
<=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:65:30


<=> > public (0 calls)
0: wybe.count.<=><0>
<=>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.count, y##0:wybe.count, ?tmp#6##0:wybe.bool) @count:64:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?tmp#5##0:wybe.bool) @count:60:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5



= > public {inline} (2 calls)
0: wybe.count.=<0>
=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:60:29


> > public {inline} (0 calls)
0: wybe.count.><0>
>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:66:29


>= > public {inline} (12 calls)
0: wybe.count.>=<0>
>=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:67:30


decr > public (0 calls)
0: wybe.count.decr<0>
decr(x##0:wybe.count, ?x##1:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, 1:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:84:37
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:84:33
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



incr > public {inline} (0 calls)
0: wybe.count.incr<0>
incr(x##0:wybe.count, ?x##1:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, 1:wybe.count, ?x##1:wybe.count) @count:15:25


max > public (0 calls)
0: wybe.count.max<0>
max(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:75:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:75:5



min > public (0 calls)
0: wybe.count.min<0>
min(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:65:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:74:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:74:5



print > public {inline} (1 calls)
0: wybe.count.print<0>
print(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:88:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:88:30


println > public {inline} (0 calls)
0: wybe.count.println<0>
println(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @count:88:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.count.read<0>
read(?x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:92:30
    foreign c read_count(?x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:92:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:92:30


~= > public {inline} (0 calls)
0: wybe.count.~=<0>
~=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:61:30

LLVM code       : None

--------------------------------------------------
 Module wybe.float
  representation  : 64 bit float
  public submods  : 
  public resources: 
  public procs    : wybe.float.*<0>
                    wybe.float.**<0>
                    wybe.float.*=<0>
                    wybe.float.+<0>
                    wybe.float.+<1>
                    wybe.float.+<2>
                    wybe.float.+=<0>
                    wybe.float.-<0>
                    wybe.float.-<1>
                    wybe.float.-<2>
                    wybe.float.-<3>
                    wybe.float.-<4>
                    wybe.float.-=<0>
                    wybe.float./<0>
                    wybe.float./=<0>
                    wybe.float.<<0>
                    wybe.float.<=<0>
                    wybe.float.<=><0>
                    wybe.float.=<0>
                    wybe.float.><0>
                    wybe.float.>=<0>
                    wybe.float.abs<0>
                    wybe.float.ceil<0>
                    wybe.float.cos<0>
                    wybe.float.e<0>
                    wybe.float.exp<0>
                    wybe.float.floor<0>
                    wybe.float.iceil<0>
                    wybe.float.ifloor<0>
                    wybe.float.iround<0>
                    wybe.float.log<0>
                    wybe.float.log10<0>
                    wybe.float.log2<0>
                    wybe.float.max<0>
                    wybe.float.min<0>
                    wybe.float.pi<0>
                    wybe.float.power<0>
                    wybe.float.print<0>
                    wybe.float.println<0>
                    wybe.float.read<0>
                    wybe.float.round<0>
                    wybe.float.sin<0>
                    wybe.float.sqrt<0>
                    wybe.float.square<0>
                    wybe.float.tan<0>
                    wybe.float.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

* > public (0 calls)
0: *(x:_ @float:45:10, y:_ @float:45:16, ?#result:_ @float:45:5):
    foreign llvm fmul(x @float:45:43, y @float:45:45, ?tmp#0 @float:45:25)
    foreign llvm move(tmp#0, ?#result @float:45:5)


** > public (0 calls)
0: **(x:_ @float:112:10, n:_ @float:112:18, ?#result:_ @float:112:5):
    foreign c llvm.pow.f64(x @float:112:52, n @float:112:54, ?tmp#0 @float:112:27)
    foreign llvm move(tmp#0, ?#result @float:112:5)


*= > public (0 calls)
0: *=(!x:_ @float:48:11, y:_ @float:48:19):
    *(x @float:48:31, y @float:48:35, ?tmp#0 @float:48:31)
    =(?x @float:48:27, tmp#0)


+ > public (0 calls)
0: +(x:_ @float:23:10, y:_ @float:23:17, ?#result:_ @float:23:5):
    foreign llvm fadd(x @float:23:45, y @float:23:47, ?tmp#0 @float:23:27)
    foreign llvm move(tmp#0, ?#result @float:23:5)
+ > public (0 calls)
1: +(?x:_ @float:24:11, y:_ @float:24:17, z:_ @float:24:5):
    foreign llvm fsub(z @float:24:61, y @float:24:63, ?tmp#0 @float:24:43)
    =(?x @float:24:39, tmp#0)
+ > public (0 calls)
2: +(x:_ @float:25:10, ?y:_ @float:25:18, z:_ @float:25:5):
    foreign llvm fsub(z @float:25:61, x @float:25:63, ?tmp#0 @float:25:43)
    =(?y @float:25:39, tmp#0)


+= > public (0 calls)
0: +=(!x:_ @float:28:11, y:_ @float:28:19):
    +(x @float:28:31, y @float:28:35, ?tmp#0 @float:28:31)
    =(?x @float:28:27, tmp#0)


- > public (0 calls)
0: -(x:_ @float:32:10, y:_ @float:32:17, ?#result:_ @float:32:5):
    foreign llvm fsub(x @float:32:45, y @float:32:47, ?tmp#0 @float:32:27)
    foreign llvm move(tmp#0, ?#result @float:32:5)
- > public (0 calls)
1: -(?x:_ @float:33:11, y:_ @float:33:17, z:_ @float:33:5):
    foreign llvm fadd(z @float:33:61, y @float:33:63, ?tmp#0 @float:33:43)
    =(?x @float:33:39, tmp#0)
- > public (0 calls)
2: -(x:_ @float:34:10, ?y:_ @float:34:18, z:_ @float:34:5):
    foreign llvm fsub(z @float:34:61, x @float:34:63, ?tmp#0 @float:34:43)
    =(?y @float:34:39, tmp#0)
- > public (0 calls)
3: -(x:_ @float:38:11, ?#result:_ @float:38:5):
    foreign llvm fsub(0.0 @float:38:39, x @float:38:43, ?tmp#0 @float:38:21)
    foreign llvm move(tmp#0, ?#result @float:38:5)
- > public (0 calls)
4: -(?x:_ @float:39:12, y:_ @float:39:5):
    foreign llvm fsub(0.0 @float:39:55, y @float:39:59, ?tmp#0 @float:39:37)
    =(?x @float:39:33, tmp#0)


-= > public (0 calls)
0: -=(!x:_ @float:42:11, y:_ @float:42:19):
    -(x @float:42:31, y @float:42:35, ?tmp#0 @float:42:31)
    =(?x @float:42:27, tmp#0)


/ > public (0 calls)
0: /(x:_ @float:51:10, y:_ @float:51:16, ?#result:_ @float:51:5):
    foreign llvm fdiv(x @float:51:43, y @float:51:45, ?tmp#0 @float:51:25)
    foreign llvm move(tmp#0, ?#result @float:51:5)


/= > public (0 calls)
0: /=(!x:_ @float:54:11, y:_ @float:54:19):
    /(x @float:54:31, y @float:54:35, ?tmp#0 @float:54:31)
    =(?x @float:54:27, tmp#0)


< > public (0 calls)
0: <(x:_ @float:70:10, y:_ @float:70:17, ?#result:bool @float:70:5):
    foreign llvm fcmp_slt(x @float:70:51, y @float:70:53, ?tmp#0 @float:70:29)
    foreign llvm move(tmp#0, ?#result @float:70:5)


<= > public (0 calls)
0: <=(x:_ @float:71:10, y:_ @float:71:18, ?#result:bool @float:71:5):
    foreign llvm fcmp_sle(x @float:71:52, y @float:71:54, ?tmp#0 @float:71:30)
    foreign llvm move(tmp#0, ?#result @float:71:5)


<=> > public (0 calls)
0: <=>(x:_ @float:76:10, y:_ @float:76:20, ?#result:comparison @float:76:5):
    if {<(x @float:77:10, y @float:77:14)::

        lesser(?tmp#1 @float:77:19)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        if {=(x @float:77:28, y @float:77:32)::

            equal(?tmp#3 @float:77:37)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            greater(?tmp#4 @float:77:53)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @float:77:28, ?tmp#0)

    }
    foreign llvm move(tmp#0 @float:77:10, ?#result @float:76:5)


= > public (0 calls)
0: =(x:_ @float:66:10, y:_ @float:66:17, ?#result:bool @float:66:5):
    foreign llvm fcmp_eq(x @float:66:50, y @float:66:52, ?tmp#0 @float:66:29)
    foreign llvm move(tmp#0, ?#result @float:66:5)


> > public (0 calls)
0: >(x:_ @float:72:10, y:_ @float:72:17, ?#result:bool @float:72:5):
    foreign llvm fcmp_sgt(x @float:72:51, y @float:72:53, ?tmp#0 @float:72:29)
    foreign llvm move(tmp#0, ?#result @float:72:5)


>= > public (0 calls)
0: >=(x:_ @float:73:10, y:_ @float:73:18, ?#result:bool @float:73:5):
    foreign llvm fcmp_sge(x @float:73:52, y @float:73:54, ?tmp#0 @float:73:30)
    foreign llvm move(tmp#0, ?#result @float:73:5)


abs > public (0 calls)
0: abs(x:_ @float:60:13, ?#result:_ @float:60:5):
    foreign c llvm.fabs.f64(x @float:60:48, ?tmp#0 @float:60:22)
    foreign llvm move(tmp#0, ?#result @float:60:5)


ceil > public (0 calls)
0: ceil(x:_ @float:87:14, ?#result:_ @float:87:5):
    foreign c llvm.ceil.f64(x @float:87:49, ?tmp#0 @float:87:23)
    foreign llvm move(tmp#0, ?#result @float:87:5)


cos > public (0 calls)
0: cos(x:_ @float:116:13, ?#result:_ @float:116:5):
    foreign c llvm.cos.f64(x @float:116:47, ?tmp#0 @float:116:22)
    foreign llvm move(tmp#0, ?#result @float:116:5)


e > public (0 calls)
0: e(?#result:_ @float:16:5):
    foreign llvm move(2.7182818284590455 @float:16:15, ?#result @float:16:5)


exp > public (0 calls)
0: exp(x:_ @float:120:13, ?#result:_ @float:120:5):
    foreign c llvm.exp.f64(x @float:120:47, ?tmp#0 @float:120:22)
    foreign llvm move(tmp#0, ?#result @float:120:5)


floor > public (0 calls)
0: floor(x:_ @float:90:15, ?#result:_ @float:90:5):
    foreign c llvm.floor.f64(x @float:90:51, ?tmp#0 @float:90:24)
    foreign llvm move(tmp#0, ?#result @float:90:5)


iceil > public (0 calls)
0: iceil(x:_ @float:99:15, ?#result:int @float:99:5):
    ceil(x @float:99:51, ?tmp#1 @float:99:46)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:99:26)
    foreign llvm move(tmp#0, ?#result @float:99:5)


ifloor > public (0 calls)
0: ifloor(x:_ @float:102:16, ?#result:int @float:102:5):
    floor(x @float:102:53, ?tmp#1 @float:102:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:102:27)
    foreign llvm move(tmp#0, ?#result @float:102:5)


iround > public (0 calls)
0: iround(x:_ @float:96:16, ?#result:int @float:96:5):
    round(x @float:96:53, ?tmp#1 @float:96:47)
    foreign llvm fptosi(tmp#1, ?tmp#0 @float:96:27)
    foreign llvm move(tmp#0, ?#result @float:96:5)


log > public (0 calls)
0: log(x:_ @float:123:13, ?#result:_ @float:123:5):
    foreign c llvm.log.f64(x @float:123:47, ?tmp#0 @float:123:22)
    foreign llvm move(tmp#0, ?#result @float:123:5)


log10 > public (0 calls)
0: log10(x:_ @float:126:15, ?#result:_ @float:126:5):
    foreign c llvm.log10.f64(x @float:126:51, ?tmp#0 @float:126:24)
    foreign llvm move(tmp#0, ?#result @float:126:5)


log2 > public (0 calls)
0: log2(x:_ @float:129:14, ?#result:_ @float:129:5):
    foreign c llvm.log2.f64(x @float:129:49, ?tmp#0 @float:129:23)
    foreign llvm move(tmp#0, ?#result @float:129:5)


max > public (0 calls)
0: max(x:_ @float:81:13, y:_ @float:81:18, ?#result:_ @float:81:5):
    foreign c llvm.maxnum.f64(x @float:81:55, y @float:81:57, ?tmp#0 @float:81:27)
    foreign llvm move(tmp#0, ?#result @float:81:5)


min > public (0 calls)
0: min(x:_ @float:80:13, y:_ @float:80:18, ?#result:_ @float:80:5):
    foreign c llvm.minnum.f64(x @float:80:55, y @float:80:57, ?tmp#0 @float:80:27)
    foreign llvm move(tmp#0, ?#result @float:80:5)


pi > public (0 calls)
0: pi(?#result:_ @float:13:5):
    foreign llvm move(3.141592653589793 @float:13:16, ?#result @float:13:5)


power > public (0 calls)
0: power(x:_ @float:111:15, n:_ @float:111:19, ?#result:_ @float:111:5):
    foreign c llvm.pow.f64(x @float:111:53, n @float:111:55, ?tmp#0 @float:111:28)
    foreign llvm move(tmp#0, ?#result @float:111:5)


print > public (0 calls)
0: print(x:_ @float:133:15) use !io:
    foreign c print_float(x @float:133:52, !io @float:133:56)


println > public (0 calls)
0: println(x:_ @float:135:17) use !io:
    !print(x @float:135:39)
    !nl


read > public (0 calls)
0: read(?x:_ @float:137:15) use !io:
    foreign c read_float(?x @float:137:52, !io @float:137:56)


round > public (0 calls)
0: round(x:_ @float:93:15, ?#result:_ @float:93:5):
    foreign c llvm.round.f64(x @float:93:51, ?tmp#0 @float:93:24)
    foreign llvm move(tmp#0, ?#result @float:93:5)


sin > public (0 calls)
0: sin(x:_ @float:115:13, ?#result:_ @float:115:5):
    foreign c llvm.sin.f64(x @float:115:47, ?tmp#0 @float:115:22)
    foreign llvm move(tmp#0, ?#result @float:115:5)


sqrt > public (0 calls)
0: sqrt(x:_ @float:108:14, ?#result:_ @float:108:5):
    foreign c llvm.sqrt.f64(x @float:108:49, ?tmp#0 @float:108:23)
    foreign llvm move(tmp#0, ?#result @float:108:5)


square > public (0 calls)
0: square(x:_ @float:57:16, ?#result:_ @float:57:5):
    foreign llvm fmul(x @float:57:43, x @float:57:45, ?tmp#0 @float:57:25)
    foreign llvm move(tmp#0, ?#result @float:57:5)


tan > public (0 calls)
0: tan(x:_ @float:117:13, ?#result:_ @float:117:5):
    foreign c llvm.sin.f64(x @float:117:47, ?tmp#1 @float:117:22)
    foreign c llvm.cos.f64(x @float:117:77, ?tmp#2 @float:117:52)
    /(tmp#1, tmp#2, ?tmp#0 @float:117:22)
    foreign llvm move(tmp#0, ?#result @float:117:5)


~= > public (0 calls)
0: ~=(x:_ @float:67:10, y:_ @float:67:18, ?#result:bool @float:67:5):
    foreign llvm fcmp_ne(x @float:67:51, y @float:67:53, ?tmp#0 @float:67:30)
    foreign llvm move(tmp#0, ?#result @float:67:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.int
  representation  : 64 bit signed
  public submods  : 
  public resources: 
  public procs    : wybe.int.%<0>
                    wybe.int.%=<0>
                    wybe.int.*<0>
                    wybe.int.*=<0>
                    wybe.int.+<0>
                    wybe.int.+<1>
                    wybe.int.+<2>
                    wybe.int.+=<0>
                    wybe.int.-<0>
                    wybe.int.-<1>
                    wybe.int.-<2>
                    wybe.int.-<3>
                    wybe.int.-<4>
                    wybe.int.-=<0>
                    wybe.int./<0>
                    wybe.int./=<0>
                    wybe.int.<<0>
                    wybe.int.<<<0>
                    wybe.int.<<=<0>
                    wybe.int.<=<0>
                    wybe.int.<=><0>
                    wybe.int.=<0>
                    wybe.int.><0>
                    wybe.int.>=<0>
                    wybe.int.>><0>
                    wybe.int.>>=<0>
                    wybe.int.decr<0>
                    wybe.int.incr<0>
                    wybe.int.logical_bitshift<0>
                    wybe.int.logical_bitshift<1>
                    wybe.int.max<0>
                    wybe.int.min<0>
                    wybe.int.power<0>
                    wybe.int.print<0>
                    wybe.int.println<0>
                    wybe.int.read<0>
                    wybe.int.signum<0>
                    wybe.int.sqrt<0>
                    wybe.int.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.int.%<0>
%(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:50:25


%= > public {inline} (0 calls)
0: wybe.int.%=<0>
%=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:50:25


* > public {inline} (1 calls)
0: wybe.int.*<0>
*(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:38:25


*= > public {inline} (0 calls)
0: wybe.int.*=<0>
*=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:38:25


+ > public {inline} (2 calls)
0: wybe.int.+<0>
+(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:16:27
+ > public {inline} (0 calls)
1: wybe.int.+<1>
+(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:17:43
+ > public {inline} (0 calls)
2: wybe.int.+<2>
+(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:18:43


+= > public {inline} (0 calls)
0: wybe.int.+=<0>
+=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:16:27


- > public {inline} (2 calls)
0: wybe.int.-<0>
-(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:25:27
- > public {inline} (0 calls)
1: wybe.int.-<1>
-(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.int, ~z##0:wybe.int, ?x##0:wybe.int) @int:26:43
- > public {inline} (0 calls)
2: wybe.int.-<2>
-(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:27:43
- > public {inline} (0 calls)
3: wybe.int.-<3>
-(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~x##0:wybe.int, ?#result##0:wybe.int) @int:31:21
- > public {inline} (0 calls)
4: wybe.int.-<4>
-(?x##0:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:32:37


-= > public {inline} (0 calls)
0: wybe.int.-=<0>
-=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:25:27


/ > public {inline} (1 calls)
0: wybe.int./<0>
/(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:44:25


/= > public {inline} (0 calls)
0: wybe.int./=<0>
/=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:44:25


< > public {inline} (4 calls)
0: wybe.int.<<0>
<(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:87:29


<< > public {inline} (1 calls)
0: wybe.int.<<<0>
<<(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:56:27


<<= > public {inline} (0 calls)
0: wybe.int.<<=<0>
<<=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:56:27


<= > public {inline} (3 calls)
0: wybe.int.<=<0>
<=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:88:30


<=> > public (0 calls)
0: wybe.int.<=><0>
<=>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(x##0:wybe.int, y##0:wybe.int, ?tmp#6##0:wybe.bool) @int:87:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?tmp#5##0:wybe.bool) @int:83:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5



= > public {inline} (2 calls)
0: wybe.int.=<0>
=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:83:29


> > public {inline} (0 calls)
0: wybe.int.><0>
>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sgt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:89:29


>= > public {inline} (3 calls)
0: wybe.int.>=<0>
>=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:90:30


>> > public {inline} (1 calls)
0: wybe.int.>><0>
>>(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:65:27


>>= > public {inline} (0 calls)
0: wybe.int.>>=<0>
>>=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:65:27


decr > public {inline} (0 calls)
0: wybe.int.decr<0>
decr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:25:27


incr > public {inline} (0 calls)
0: wybe.int.incr<0>
incr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:16:27


logical_bitshift > public {inline} (1 calls)
0: wybe.int.logical_bitshift<0>
logical_bitshift(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:74:40
logical_bitshift > public {inline} (0 calls)
1: wybe.int.logical_bitshift<1>
logical_bitshift(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:74:40


max > public (0 calls)
0: wybe.int.max<0>
max(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:90:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:98:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:98:5



min > public (0 calls)
0: wybe.int.min<0>
min(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:88:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:97:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:97:5



power > public {inline} (0 calls)
0: wybe.int.power<0>
power(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c ipow(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:107:29


print > public {inline} (1 calls)
0: wybe.int.print<0>
print(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:119:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:119:30


println > public {inline} (0 calls)
0: wybe.int.println<0>
println(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @int:119:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.int.read<0>
read(?x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:123:30
    foreign c read_int(?x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:123:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:123:30


signum > public {inline} (0 calls)
0: wybe.int.signum<0>
signum(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c signum(~x##0:wybe.int, ?#result##0:wybe.int) @int:114:25


sqrt > public {inline} (0 calls)
0: wybe.int.sqrt<0>
sqrt(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c isqrt(~x##0:wybe.int, ?#result##0:wybe.int) @int:104:23


~= > public {inline} (0 calls)
0: wybe.int.~=<0>
~=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:84:30

LLVM code       : None

--------------------------------------------------
 Module wybe.io
  representation  : (not a type)
  public submods  : phantom -> wybe.phantom
  public resources: io: wybe.io.io
  public procs    : wybe.io.<0>
                    wybe.io.eof<0>
                    wybe.io.nl<0>
  imports         : use wybe.char
                    public use wybe.phantom
  resources       : io: fromList [(wybe.io.io,wybe.phantom = 0:phantom @io:13:27 @io:13:5)]
  procs           : 

module top-level code > public {inline,semipure} (0 calls)
0: wybe.io.<0>
()<{}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm store(0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:13:5


eof > public {inline} (0 calls)
0: wybe.io.eof<0>
eof(?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(-1:wybe.int, ?#result##0:wybe.char) @io:20:29


nl > public {inline} (0 calls)
0: wybe.io.nl<0>
nl()<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @io:17:31
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31

LLVM code       : None

--------------------------------------------------
 Module wybe.list(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.list.,,<0>
                    wybe.list.[]<0>
                    wybe.list.all<0>
                    wybe.list.any<0>
                    wybe.list.empty<0>
                    wybe.list.filter<0>
                    wybe.list.foldl<0>
                    wybe.list.foldr<0>
                    wybe.list.length<0>
                    wybe.list.list<0>
                    wybe.list.map<0>
                    wybe.list.map<1>
                    wybe.list.map<2>
                    wybe.list.print<0>
                    wybe.list.println<0>
                    wybe.list.reverse<0>
  imports         : use wybe.array
                    use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
                    use wybe.machine_word
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_(T) @list:20:10, y:_(T) @list:20:20, ?#result:_(T) @list:20:5):
    if {[|](?h @list:21:16, ?t @list:21:21, x @list:21:10)::

        ,,(t @list:21:32, y @list:21:37, ?tmp#2 @list:21:32)
        [|](h @list:21:28, tmp#2, ?tmp#1 @list:21:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(y @list:21:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:21:10, ?#result @list:20:5)


[] > public {test} (0 calls)
0: [](xs:_(T) @list:31:21, idx:int @list:31:30, ?#result:T @list:31:5):
    >=(idx @list:32:5, 0 @list:32:13)
    index1(xs @list:33:17, idx @list:33:21, ?tmp#0 @list:33:10)
    =(?x @list:33:6, tmp#0)
    foreign llvm move(x @list:31:43, ?#result @list:31:5)


all > public {test} (0 calls)
0: all(p:{test}(T) @list:61:20, xs:_(T) @list:61:33):
    foreign llvm move(xs @list:62:15, ?tmp#0)
    do {
        if {[|](?x @list:62:10, ?tmp#0, tmp#0)::

            p(x @list:63:11)
        else::
            break

        }
    }


any > public {test} (0 calls)
0: any(p:{test}(T) @list:69:20, xs:_(T) @list:69:33):
    [|](?x @list:70:7, ?xs @list:70:12, xs @list:70:18)
    (   p(x @list:71:8)
    | any(p @list:71:17, xs @list:71:20))


empty > public {test} (0 calls)
0: empty(xs:_(T) @list:15:22):
    if {[|](?tmp#0 @list:16:11, ?tmp#1 @list:16:15, xs @list:16:20)::

        fail
    else::
        pass

    }


filter > public (0 calls)
0: filter(p:{test}(T) @list:95:16, !xs:_(T) @list:95:30):
    [](?tmp#0 @list:96:12)
    =(?out @list:96:6, tmp#0)
    foreign llvm move(xs @list:97:15, ?tmp#1)
    do {
        if {[|](?x @list:97:10, ?tmp#1, tmp#1)::

            if {p(x @list:98:16)::

                [|](x @list:98:30, out @list:98:34, ?tmp#2 @list:98:29)
                =(?out @list:98:23, tmp#2)
            else::
                pass

            }
        else::
            break

        }
    }
    reverse(out @list:100:19, ?tmp#3 @list:100:11)
    =(?as @list:100:6, tmp#3)


foldl > public (0 calls)
0: foldl(f:(A, !B) @list:77:15, as:_(A) @list:77:26, !b:B @list:77:36):
    foreign llvm move(as @list:78:15, ?tmp#0)
    do {
        if {[|](?a @list:78:10, ?tmp#0, tmp#0)::

            f(a @list:79:11, !b @list:79:15)
        else::
            break

        }
    }


foldr > public (0 calls)
0: foldr(f:(A, !B) @list:86:15, as:_(A) @list:86:26, !b:B @list:86:36):
    if {[|](?a @list:87:12, ?as @list:87:17, as @list:87:23)::

        foldr(f @list:88:15, as @list:88:18, !b @list:88:23)
        f(a @list:89:11, !b @list:89:15)
    else::
        pass

    }


index1 > {test} (0 calls)
0: index1(xs:_(T) @list:148:19, idx:int @list:148:28, ?#result:T @list:148:1):
    [|](?x @list:149:7, ?xs @list:149:12, xs @list:149:18)
    (   =(idx @list:150:6, 0 @list:150:12)
    | (   -(idx @list:150:27, 1 @list:150:33, ?tmp#0 @list:150:27)
        & index1(xs @list:150:23, tmp#0, ?x @list:150:37)))
    foreign llvm move(x @list:148:41, ?#result @list:148:1)


length > public (0 calls)
0: length(x:_(T) @list:24:16, ?#result:int @list:24:5):
    length1(x @list:24:38, 0 @list:24:41, ?tmp#0 @list:24:30)
    foreign llvm move(tmp#0, ?#result @list:24:5)


length1 > (0 calls)
0: length1(x:_(T) @list:140:13, acc:int @list:140:21, ?#result:int @list:140:1):
    if {[|](?h @list:141:16, ?t @list:141:21, x @list:141:10)::

        +(acc @list:141:38, 1 @list:141:44, ?tmp#2 @list:141:38)
        length1(t @list:141:35, tmp#2, ?tmp#1 @list:141:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(acc @list:141:57, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:141:10, ?#result @list:140:1)


list > public (0 calls)
0: list(ar:array(T) @list:128:14, ?#result:_(T) @list:128:5):
    [](?tmp#0 @list:129:11)
    =(?ls @list:129:6, tmp#0)
    foreign llvm move(ar @list:130:15, ?tmp#1)
    do {
        if {[|](?x @list:130:10, ?tmp#1, tmp#1)::

            [|](x @list:131:16, ls @list:131:20, ?tmp#2 @list:131:15)
            =(?ls @list:131:10, tmp#2)
        else::
            break

        }
    }
    reverse(ls @list:133:13, ?ls @list:133:18)
    foreign llvm move(ls @list:128:34, ?#result @list:128:5)


map > public (0 calls)
0: map(f:{resource}(T) @list:41:13, xs:_(T) @list:41:30):
    foreign llvm move(xs @list:42:15, ?tmp#0)
    do {
        if {[|](?x @list:42:10, ?tmp#0, tmp#0)::

            !f(x @list:43:12)
        else::
            break

        }
    }
map > public (0 calls)
1: map(f:(A, ?B) @list:49:13, as:_(A) @list:49:24, ?#result:_(B) @list:49:5):
    if {[|](?a @list:50:12, ?as @list:50:17, as @list:50:23)::

        f(a @list:50:33, ?tmp#2 @list:50:31)
        map(f @list:50:42, as @list:50:45, ?tmp#3 @list:50:38)
        [|](tmp#2, tmp#3, ?tmp#1 @list:50:29)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:50:61)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:50:10, ?#result @list:49:5)
map > public (0 calls)
2: map(f:(A, B, ?C) @list:55:13, as:_(A) @list:55:27, bs:_(B) @list:55:36, ?#result:_(C) @list:55:5):
    if {(   [|](?a @list:56:12, ?as @list:56:17, as @list:56:23)
        & [|](?b @list:56:30, ?bs @list:56:35, bs @list:56:41))::

        f(a @list:56:51, b @list:56:54, ?tmp#2 @list:56:49)
        map(f @list:56:63, as @list:56:66, bs @list:56:70, ?tmp#3 @list:56:59)
        [|](tmp#2, tmp#3, ?tmp#1 @list:56:47)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:57:47)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:56:10, ?#result @list:55:5)


print > public (0 calls)
0: print(printer:{resource}(T) @list:108:15, xs:_(T) @list:108:38) use !io:
    !print('[' @list:109:12)
    if {[|](?x @list:110:12, ?xs @list:110:17, xs @list:110:23)::

        !printer(x @list:111:18)
        !print1(printer @list:112:17, xs @list:112:26)
    else::
        pass

    }
    !print(']' @list:114:12)


print1 > (0 calls)
0: print1(printer:{resource}(T) @list:154:12, xs:_(T) @list:154:35) use !io:
    if {[|](?x @list:155:12, ?xs @list:155:17, xs @list:155:23)::

        !print(',' @list:156:16)
        !printer(x @list:157:18)
        !print1(printer @list:158:17, xs @list:158:26)
    else::
        pass

    }


println > public (0 calls)
0: println(printer:{resource}(T) @list:119:17, xs:_(T) @list:119:40) use !io:
    !print(printer @list:120:12, xs @list:120:21)
    !nl


reverse > public (0 calls)
0: reverse(x:_(T) @list:27:17, ?#result:_(T) @list:27:5):
    [](?tmp#1 @list:27:44)
    reverse1(x @list:27:41, tmp#1, ?tmp#0 @list:27:32)
    foreign llvm move(tmp#0, ?#result @list:27:5)


reverse1 > (0 calls)
0: reverse1(x:_(T) @list:144:14, tail:_(T) @list:144:22, ?#result:_(T) @list:144:1):
    if {[|](?h @list:145:16, ?t @list:145:21, x @list:145:10)::

        [|](h @list:145:40, tail @list:145:44, ?tmp#2 @list:145:39)
        reverse1(t @list:145:36, tmp#2, ?tmp#1 @list:145:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(tail @list:145:61, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:145:10, ?#result @list:144:1)

LLVM code       : None

--------------------------------------------------
 Module wybe.machine_word
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.machine_word.word_size_bits<0>
                    wybe.machine_word.word_size_bytes<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

word_size_bits > public (0 calls)
0: word_size_bits(?#result:int @machine_word:12:5):
    word_size_bytes(?tmp#1 @machine_word:12:34)
    *(8 @machine_word:12:30, tmp#1, ?tmp#0 @machine_word:12:30)
    foreign llvm move(tmp#0, ?#result @machine_word:12:5)


word_size_bytes > public (0 calls)
0: word_size_bytes(?#result:int @machine_word:10:5):
    foreign llvm move(8 @machine_word:10:31, ?#result @machine_word:10:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.memory_management
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.memory_management.malloc_count<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

malloc_count > public {semipure} (0 calls)
0: malloc_count(?x:int @memory_management:11:34):
    foreign c {impure} malloc_count(?x @memory_management:12:38)

LLVM code       : None

--------------------------------------------------
 Module wybe.phantom
 modifiers       : {unique} 
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : 
  imports         : 
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.predicate
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.predicate.const<0>
                    wybe.predicate.id<0>
  imports         : 
  resources       : 
  procs           : 

const > public {inline} (0 calls)
0: wybe.predicate.const<0>
const(a##0:A <{}; {}; {0}>, [b##0:B <{}; {}; {1}>], ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:8:5


id > public {inline} (0 calls)
0: wybe.predicate.id<0>
id(a##0:A <{}; {}; {0}>, ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:6:5

LLVM code       : None

--------------------------------------------------
 Module wybe.range
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.range...<0>
                    wybe.range.[]<0>
                    wybe.range.[|]<0>
                    wybe.range.irange<0>
                    wybe.range.size<0>
                    wybe.range.xrange<0>
  imports         : use wybe.bool
                    use wybe.int
  resources       : 
  procs           : 

.. > public (0 calls)
0: ..(start:int @range:38:10, end:int @range:38:23, ?#result:_ @range:38:5):
    if {<=(start @range:39:27, end @range:39:37)::

        foreign llvm move(1 @range:39:44, ?tmp#1)
    else::
        foreign llvm move(-1 @range:39:56, ?tmp#1)

    }
    construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)
    foreign llvm move(tmp#0, ?#result @range:38:5)


[] > public {test} (0 calls)
0: [](r:_ @range:20:19, idx:int @range:20:24, ?value:int @range:20:34):
    <=(0 @range:21:6, idx @range:21:12)
    range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)
    *(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)
    +(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)
    =(?value @range:23:6, tmp#0)
    if {<=(0 @range:24:10, stride @range:24:16)::

        <(value @range:24:27, end @range:24:35)
    else::
        <(end @range:24:51, value @range:24:57)

    }


[|] > public {test} (0 calls)
0: [|](?value:int @range:12:23, ?rest:_ @range:12:35, current:_ @range:12:43):
    range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)
    ~=(value @range:14:6, end @range:14:16)
    +(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)
    range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)
    =(?rest @range:15:6, tmp#0)


construct > (0 calls)
0: construct(start:int @range:49:15, stride:int @range:49:26, end:int @range:49:38, ?#result:_ @range:49:1):
    -(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)
    %(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)
    =(?diff @range:50:6, tmp#0)
    if {<=(0 @range:51:19, stride @range:51:25)::

        if {=(diff @range:52:26, 0 @range:52:33)::

            max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
            -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
            max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
            foreign llvm move(tmp#5, ?tmp#3)

        }
        foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
    else::
        if {=(diff @range:55:26, 0 @range:55:33)::

            min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
            foreign llvm move(tmp#9, ?tmp#8)
        else::
            +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
            min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
            foreign llvm move(tmp#10, ?tmp#8)

        }
        foreign llvm move(tmp#8 @range:55:26, ?tmp#2)

    }
    =(?final @range:51:6, tmp#2 @range:51:19)
    range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)
    =(?r @range:58:6, tmp#12)
    foreign llvm move(r @range:49:51, ?#result @range:49:1)


irange > public (0 calls)
0: irange(start:int @range:32:16, stride:int @range:32:27, end:int @range:32:39, ?#result:_ @range:32:5):
    if {<(stride @range:33:41, 0 @range:33:50)::

        foreign llvm move(-1 @range:33:55, ?tmp#2)
    else::
        foreign llvm move(1 @range:33:68, ?tmp#2)

    }
    +(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)
    construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)
    foreign llvm move(tmp#0, ?#result @range:32:5)


size > public (0 calls)
0: size(r:_ @range:42:14, ?#result:int @range:42:5):
    range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)
    if {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
        & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
        & signum(tmp#3, ?tmp#2 @range:44:29)
        & ~=(tmp#1, tmp#2))::

        foreign llvm move(0 @range:44:52, ?tmp#0)
    else::
        if {<=(0 @range:45:10, stride @range:45:16)::

            -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
            -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
            /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
            +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
            foreign llvm move(tmp#5, ?tmp#4)
        else::
            -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
            -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
            -(stride @range:46:39, ?tmp#13 @range:46:38)
            /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
            +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
            foreign llvm move(tmp#9, ?tmp#4)

        }
        foreign llvm move(tmp#4 @range:45:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)


xrange > public (0 calls)
0: xrange(start:int @range:28:16, stride:int @range:28:27, end:int @range:28:39, ?#result:_ @range:28:5):
    construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)
    foreign llvm move(tmp#0, ?#result @range:28:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.string
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.string.,,<0>
                    wybe.string.<<0>
                    wybe.string.<=<0>
                    wybe.string.<=><0>
                    wybe.string.=<0>
                    wybe.string.><0>
                    wybe.string.>=<0>
                    wybe.string.[]<0>
                    wybe.string.[]<1>
                    wybe.string.[|]<0>
                    wybe.string.c_string<0>
                    wybe.string.length<0>
                    wybe.string.print<0>
                    wybe.string.println<0>
                    wybe.string.read<0>
                    wybe.string.string<0>
                    wybe.string.string<1>
                    wybe.string.~=<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.char
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
                    use wybe.range
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_ @string:64:10, y:_ @string:64:17, ?#result:_ @string:64:5):
    if {(   empty(?tmp#1 @string:65:14)
        & =(x @string:65:10, tmp#1))::

        foreign llvm move(y @string:65:23, ?tmp#0)
    else::
        if {(   empty(?tmp#3 @string:66:14)
            & =(y @string:66:10, tmp#3))::

            foreign llvm move(x @string:66:23, ?tmp#2)
        else::
            concat(x @string:67:25, y @string:67:28, ?tmp#4 @string:67:18)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:66:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:65:10, ?#result @string:64:5)


< > public (0 calls)
0: <(x:_ @string:119:10, y:_ @string:119:17, ?#result:bool @string:119:5):
    <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
    equal(?tmp#2 @string:119:44)
    <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
    foreign llvm move(tmp#0, ?#result @string:119:5)


<= > public (0 calls)
0: <=(x:_ @string:120:10, y:_ @string:120:18, ?#result:bool @string:120:5):
    <=>(x @string:120:31, y @string:120:39, ?tmp#1 @string:120:31)
    equal(?tmp#2 @string:120:46)
    <=(tmp#1, tmp#2, ?tmp#0 @string:120:30)
    foreign llvm move(tmp#0, ?#result @string:120:5)


<=> > public (0 calls)
0: <=>(x:_ @string:125:10, y:_ @string:125:20, ?#result:comparison @string:125:5):
    equal(?tmp#0 @string:126:10)
    =(?c @string:126:6, tmp#0)
    foreign llvm move(x @string:127:16, ?tmp#1)
    foreign llvm move(y @string:127:26, ?tmp#2)
    do {
        if {[|](?cx @string:127:10, ?tmp#1, tmp#1)::

            if {[|](?cy @string:127:20, ?tmp#2, tmp#2)::

                if {<(cx @string:128:14, cy @string:128:19)::

                    lesser(?tmp#3 @string:128:30)
                    =(?c @string:128:26, tmp#3)
                    break
                else::
                    if {>(cx @string:129:14, cy @string:129:19)::

                        greater(?tmp#4 @string:129:30)
                        =(?c @string:129:26, tmp#4)
                        break
                    else::
                        pass

                    }

                }
            else::
                break

            }
        else::
            break

        }
    }
    if {(   equal(?tmp#5 @string:132:14)
        & =(c @string:132:10, tmp#5))::

        length(x @string:133:22, ?tmp#6 @string:133:15)
        =(?lx @string:133:10, tmp#6)
        length(y @string:134:22, ?tmp#7 @string:134:15)
        =(?ly @string:134:10, tmp#7)
        if {<(lx @string:135:14, ly @string:135:19)::

            lesser(?tmp#8 @string:135:30)
            =(?c @string:135:26, tmp#8)
        else::
            if {>(lx @string:135:39, ly @string:135:44)::

                greater(?tmp#9 @string:135:55)
                =(?c @string:135:51, tmp#9)
            else::
                pass

            }

        }
    else::
        pass

    }
    foreign llvm move(c @string:125:38, ?#result @string:125:5)


= > public (0 calls)
0: =(x:_ @string:115:10, y:_ @string:115:17, ?#result:bool @string:115:5):
    <=>(x @string:115:30, y @string:115:38, ?tmp#1 @string:115:30)
    equal(?tmp#2 @string:115:44)
    =(tmp#1, tmp#2, ?tmp#0 @string:115:29)
    foreign llvm move(tmp#0, ?#result @string:115:5)


> > public (0 calls)
0: >(x:_ @string:121:10, y:_ @string:121:17, ?#result:bool @string:121:5):
    <=>(x @string:121:30, y @string:121:38, ?tmp#1 @string:121:30)
    equal(?tmp#2 @string:121:44)
    >(tmp#1, tmp#2, ?tmp#0 @string:121:29)
    foreign llvm move(tmp#0, ?#result @string:121:5)


>= > public (0 calls)
0: >=(x:_ @string:122:10, y:_ @string:122:18, ?#result:bool @string:122:5):
    <=>(x @string:122:31, y @string:122:39, ?tmp#1 @string:122:31)
    equal(?tmp#2 @string:122:46)
    >=(tmp#1, tmp#2, ?tmp#0 @string:122:30)
    foreign llvm move(tmp#0, ?#result @string:122:5)


[] > public {test} (0 calls)
0: [](s:_ @string:91:19, idx:int @string:91:24, ?c:char @string:91:34):
    if {buffer(?len @string:93:17, ?str @string:93:23, s @string:92:10)::

        <=(0 @string:94:14, idx @string:94:20)
        <(idx @string:95:14, len @string:95:20)
        unsafe_c_string_index(str @string:96:35, idx @string:96:40, ?c @string:96:46)
    else::
        if {concat(?left @string:97:17, ?right @string:97:24, s @string:92:10)::

            length(left @string:98:32, ?tmp#0 @string:98:25)
            =(?left_len @string:98:14, tmp#0)
            if {<(idx @string:99:18, left_len @string:99:24)::

                [](left @string:99:41, idx @string:99:46, ?tmp#1 @string:99:41)
                =(?c @string:99:37, tmp#1)
            else::
                -(idx @string:100:37, left_len @string:100:43, ?tmp#3 @string:100:37)
                [](right @string:100:31, tmp#3, ?tmp#2 @string:100:31)
                =(?c @string:100:27, tmp#2)

            }
        else::
            if {slice(?base @string:102:16, ?range @string:102:23, s @string:92:10)::

                [](range @string:102:43, idx @string:102:49, ?tmp#5 @string:102:43)
                [](base @string:102:38, tmp#5, ?tmp#4 @string:102:38)
                =(?c @string:102:34, tmp#4)
            else::
                if {singleton(?c @string:103:20, s @string:92:10)::

                    =(idx @string:103:27, 0 @string:103:33)
                else::
                    fail

                }

            }

        }

    }
[] > public (0 calls)
1: [](s:_ @string:109:12, r:range @string:109:17, ?#result:_ @string:109:5):
    slice(s @string:109:36, r @string:109:39, ?tmp#0 @string:109:30)
    foreign llvm move(tmp#0, ?#result @string:109:5)


[|] > public {test} (0 calls)
0: [|](?head:char @string:71:23, ?tail:_ @string:71:35, s:_ @string:71:43):
    if {buffer(?len @string:73:17, ?str @string:73:23, s @string:72:10)::

        [|](?head @string:74:15, ?str @string:74:23, str @string:74:30)
        if {=(len @string:75:26, 1 @string:75:32)::

            empty(?tmp#1 @string:75:37)
            foreign llvm move(tmp#1, ?tmp#0)
        else::
            -(len @string:75:60, 1 @string:75:66, ?tmp#3 @string:75:60)
            buffer(tmp#3, str @string:75:69, ?tmp#2 @string:75:53)
            foreign llvm move(tmp#2, ?tmp#0)

        }
        =(?tail @string:75:14, tmp#0 @string:75:26)
    else::
        if {concat(?left @string:76:17, ?right @string:76:24, s @string:72:10)::

            if {[|](?head @string:77:20, ?t @string:77:28, left @string:77:33)::

                concat(t @string:77:56, right @string:77:59, ?tmp#4 @string:77:49)
                =(?tail @string:77:42, tmp#4)
            else::
                [|](?head @string:78:28, ?tail @string:78:36, right @string:78:44)

            }
        else::
            if {slice(?base @string:80:16, ?range @string:80:23, s @string:72:10)::

                do {
                    [|](?idx @string:82:19, ?range @string:82:26, range @string:82:35)
                    if {(   [](base @string:83:30, idx @string:83:35, ?tmp#5 @string:83:30)
                        & =(?head @string:83:23, tmp#5))::

                        slice(base @string:83:57, range @string:83:63, ?tmp#6 @string:83:51)
                        =(?tail @string:83:44, tmp#6)
                        break
                    else::
                        pass

                    }
                }
            else::
                if {singleton(?head @string:85:20, s @string:72:10)::

                    empty(?tmp#7 @string:85:37)
                    =(?tail @string:85:30, tmp#7)
                else::
                    fail

                }

            }

        }

    }


c_string > public (0 calls)
0: c_string(s:_ @string:40:18, ?#result:c_string @string:40:5):
    if {buffer(?tmp#0 @string:41:21, ?str @string:41:25, s @string:41:10)::

        pass
    else::
        length(s @string:43:27, ?tmp#2 @string:43:20)
        +(tmp#2, 1 @string:43:32, ?tmp#1 @string:43:20)
        =(?len @string:43:14, tmp#1)
        foreign lpvm alloc(len @string:44:32, ?str @string:44:38)
        true(?tmp#3 @string:45:49)
        foreign lpvm mutate(str @string:45:33, ?str @string:45:39, len @string:45:44, tmp#3, len @string:45:55, 0 @string:45:60, '\NUL' @string:45:63)
        =(?offset @string:46:14, 0 @string:46:23)
        pack(s @string:47:18, !str @string:47:22, len @string:47:27, !offset @string:47:33)

    }
    foreign llvm move(str @string:40:34, ?#result @string:40:5)


fixed_range_size > (0 calls)
0: fixed_range_size(hi:int @string:184:22, r:range @string:184:30, ?sz:int @string:184:40):
    range(?start @string:185:16, ?stride @string:185:24, ?end @string:185:33, r @string:185:5)
    if {<=(0 @string:186:10, stride @string:186:16)::

        -(start @string:187:39, ?tmp#4 @string:187:38)
        /(tmp#4, stride @string:187:47, ?tmp#3 @string:187:38)
        *(tmp#3, stride @string:187:56, ?tmp#2 @string:187:38)
        +(start @string:187:30, tmp#2, ?tmp#1 @string:187:30)
        max(start @string:187:23, tmp#1, ?tmp#0 @string:187:19)
        =(?lo @string:187:14, tmp#0)
        min(hi @string:188:23, end @string:188:27, ?tmp#5 @string:188:19)
        =(?hi @string:188:14, tmp#5)
    else::
        max(-1 @string:190:23, end @string:190:27, ?tmp#6 @string:190:19)
        =(?lo @string:190:14, tmp#6)
        +(hi @string:191:30, stride @string:191:35, ?tmp#10 @string:191:30)
        -(start @string:191:45, hi @string:191:53, ?tmp#13 @string:191:45)
        -(tmp#13, 1 @string:191:58, ?tmp#12 @string:191:45)
        -(stride @string:191:64, ?tmp#14 @string:191:63)
        %(tmp#12, tmp#14, ?tmp#11 @string:191:44)
        +(tmp#10, tmp#11, ?tmp#9 @string:191:30)
        +(tmp#9, 1 @string:191:73, ?tmp#8 @string:191:30)
        min(start @string:191:23, tmp#8, ?tmp#7 @string:191:19)
        =(?hi @string:191:14, tmp#7)
        -(stride @string:192:24, ?tmp#15 @string:192:23)
        =(?stride @string:192:14, tmp#15)

    }
    if {<=(hi @string:194:16, lo @string:194:23)::

        foreign llvm move(0 @string:194:29, ?tmp#16)
    else::
        -(hi @string:194:42, lo @string:194:47, ?tmp#20 @string:194:42)
        -(tmp#20, 1 @string:194:52, ?tmp#19 @string:194:42)
        /(tmp#19, stride @string:194:57, ?tmp#18 @string:194:41)
        +(tmp#18, 1 @string:194:66, ?tmp#17 @string:194:41)
        foreign llvm move(tmp#17, ?tmp#16)

    }
    =(?sz @string:194:6, tmp#16 @string:194:16)


length > public (0 calls)
0: length(s:_ @string:52:16, ?#result:int @string:52:5):
    if {buffer(?len @string:53:22, ?tmp#1 @string:53:27, s @string:53:10)::

        foreign llvm move(len @string:53:33, ?tmp#0)
    else::
        if {concat(?left @string:54:22, ?right @string:54:29, s @string:54:10)::

            length(left @string:54:46, ?tmp#4 @string:54:39)
            length(right @string:54:61, ?tmp#5 @string:54:54)
            +(tmp#4, tmp#5, ?tmp#3 @string:54:39)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            if {slice(?base @string:55:21, ?range @string:55:28, s @string:55:10)::

                length(base @string:55:62, ?tmp#8 @string:55:55)
                fixed_range_size(tmp#8, range @string:55:69, ?tmp#7 @string:55:38)
                foreign llvm move(tmp#7, ?tmp#6)
            else::
                if {singleton(?tmp#10 @string:56:24, s @string:56:10)::

                    foreign llvm move(1 @string:56:30, ?tmp#9)
                else::
                    foreign llvm move(0 @string:57:18, ?tmp#9)

                }
                foreign llvm move(tmp#9 @string:56:10, ?tmp#6)

            }
            foreign llvm move(tmp#6 @string:55:10, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:54:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:53:10, ?#result @string:52:5)


pack > (0 calls)
0: pack(s:_ @string:160:10, !raw:c_string @string:160:16, size:int @string:160:30, !offset:int @string:160:41):
    if {buffer(?tmp#0 @string:162:16, ?str @string:162:20, s @string:161:10)::

        foreign llvm move(str @string:163:23, ?tmp#1)
        do {
            if {[|](?c @string:163:18, ?tmp#1, tmp#1)::

                true(?tmp#2 @string:164:56)
                foreign lpvm mutate(raw @string:164:37, ?raw @string:164:43, offset @string:164:48, tmp#2, size @string:164:62, 0 @string:164:68, c @string:164:71)
                incr(!offset @string:165:23)
            else::
                break

            }
        }
    else::
        if {concat(?left @string:167:17, ?right @string:167:24, s @string:161:10)::

            pack(left @string:168:18, !raw @string:168:25, size @string:168:30, !offset @string:168:37)
            pack(right @string:169:18, !raw @string:169:26, size @string:169:31, !offset @string:169:38)
            incr(!offset @string:170:19)
        else::
            if {slice(?tmp#3 @string:171:15, ?tmp#4 @string:171:18, s @string:161:10)::

                foreign llvm move(s @string:172:23, ?tmp#5)
                do {
                    if {[|](?c @string:172:18, ?tmp#5, tmp#5)::

                        true(?tmp#6 @string:173:56)
                        foreign lpvm mutate(raw @string:173:37, ?raw @string:173:43, offset @string:173:48, tmp#6, size @string:173:62, 0 @string:173:68, c @string:173:71)
                        incr(!offset @string:174:23)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:176:20, s @string:161:10)::

                    true(?tmp#7 @string:177:52)
                    foreign lpvm mutate(raw @string:177:33, ?raw @string:177:39, offset @string:177:44, tmp#7, size @string:177:58, 0 @string:177:64, c @string:177:67)
                    incr(!offset @string:178:19)
                else::
                    fail

                }

            }

        }

    }


print > public (0 calls)
0: print(x:_ @string:142:15) use !io:
    if {buffer(?tmp#0 @string:144:16, ?str @string:144:20, x @string:143:10)::

        !print(str @string:144:35)
    else::
        if {concat(?left @string:145:17, ?right @string:145:24, x @string:143:10)::

            !print(left @string:145:41)
            !print(right @string:145:55)
        else::
            if {slice(?tmp#1 @string:146:15, ?tmp#2 @string:146:18, x @string:143:10)::

                foreign llvm move(x @string:146:34, ?tmp#3)
                do {
                    if {[|](?c @string:146:29, ?tmp#3, tmp#3)::

                        !print(c @string:146:45)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:147:20, x @string:143:10)::

                    !print(c @string:147:33)
                else::
                    fail

                }

            }

        }

    }


println > public (0 calls)
0: println(x:_ @string:151:17) use !io:
    !print(x @string:151:39)
    !nl


read > public (0 calls)
0: read(?x:_ @string:153:15) use !io:
    !read(?str:c_string @string:153:37)
    string(str @string:153:64, ?tmp#0 @string:153:57)
    =(?x @string:153:53, tmp#0)


string > public (0 calls)
0: string(str:c_string @string:28:16, ?#result:_ @string:28:5):
    length(str @string:29:19, ?tmp#0 @string:29:12)
    =(?len @string:29:6, tmp#0)
    if {=(len @string:30:15, 0 @string:30:21)::

        empty(?tmp#2 @string:30:26)
        foreign llvm move(tmp#2, ?tmp#1)
    else::
        if {=(len @string:31:15, 1 @string:31:21)::

            foreign lpvm access(str @string:31:56, 0 @string:31:61, 1 @string:31:64, 0 @string:31:67, ?tmp#5 @string:31:36)
            singleton(tmp#5, ?tmp#4 @string:31:26)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            buffer(len @string:32:33, str @string:32:38, ?tmp#6 @string:32:26)
            foreign llvm move(tmp#6, ?tmp#3)

        }
        foreign llvm move(tmp#3 @string:31:15, ?tmp#1)

    }
    =(?s @string:30:6, tmp#1 @string:30:15)
    foreign llvm move(s @string:28:34, ?#result @string:28:5)
string > public (0 calls)
1: string(c:char @string:37:16, ?#result:_ @string:37:5):
    singleton(c @string:37:38, ?tmp#0 @string:37:28)
    foreign llvm move(tmp#0, ?#result @string:37:5)


~= > public (0 calls)
0: ~=(x:_ @string:116:10, y:_ @string:116:18, ?#result:bool @string:116:5):
    <=>(x @string:116:31, y @string:116:39, ?tmp#1 @string:116:31)
    equal(?tmp#2 @string:116:46)
    ~=(tmp#1, tmp#2, ?tmp#0 @string:116:30)
    foreign llvm move(tmp#0, ?#result @string:116:5)

LLVM code       : None

Types: **** Validating parameter types in module wybe.float
Types: Validating def of *
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of **
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param n:_
Types: Param is n:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of *=
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Validating def of +
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of +
Types: Checking type _ of param ?x:_
Types: Param is ?x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Checking type _ of param z:_
Types: Param is z:wybe.float
Types: Validating def of +
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param ?y:_
Types: Param is ?y:wybe.float
Types: Checking type _ of param z:_
Types: Param is z:wybe.float
Types: Validating def of +=
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Validating def of -
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of -
Types: Checking type _ of param ?x:_
Types: Param is ?x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Checking type _ of param z:_
Types: Param is z:wybe.float
Types: Validating def of -
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param ?y:_
Types: Param is ?y:wybe.float
Types: Checking type _ of param z:_
Types: Param is z:wybe.float
Types: Validating def of -
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of -
Types: Checking type _ of param ?x:_
Types: Param is ?x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Validating def of -=
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Validating def of /
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of /=
Types: Checking type _ of param !x:_
Types: Param is !x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Validating def of <
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of <=
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of <=>
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Checking type comparison of param ?#result:comparison
Types: Param is ?#result:wybe.comparison
Types: Validating def of =
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of >
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of >=
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of abs
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of ceil
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of cos
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of e
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of exp
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of floor
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of iceil
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type int of param ?#result:int
Types: Param is ?#result:wybe.int
Types: Validating def of ifloor
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type int of param ?#result:int
Types: Param is ?#result:wybe.int
Types: Validating def of iround
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type int of param ?#result:int
Types: Param is ?#result:wybe.int
Types: Validating def of log
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of log10
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of log2
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of max
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of min
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of pi
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of power
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param n:_
Types: Param is n:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of print
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Validating def of println
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Validating def of read
Types: Checking type _ of param ?x:_
Types: Param is ?x:wybe.float
Types: Validating def of round
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of sin
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of sqrt
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of square
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of tan
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.float
Types: Validating def of ~=
Types: Checking type _ of param x:_
Types: Param is x:wybe.float
Types: Checking type _ of param y:_
Types: Param is y:wybe.float
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: **** Re-exiting module wybe.float
Types: **** Type checking modules wybe.float
Types: **** Strongly connected components:
Types:     wybe.float.~=
Types:     wybe.float.square
Types:     wybe.float.sqrt
Types:     wybe.float.sin
Types:     wybe.float.round
Types:     wybe.float.read
Types:     wybe.float.print
Types:     wybe.float.println
Types:     wybe.float.power
Types:     wybe.float.pi
Types:     wybe.float.min
Types:     wybe.float.max
Types:     wybe.float.log2
Types:     wybe.float.log10
Types:     wybe.float.log
Types:     wybe.float.iround
Types:     wybe.float.floor
Types:     wybe.float.ifloor
Types:     wybe.float.exp
Types:     wybe.float.e
Types:     wybe.float.cos
Types:     wybe.float.ceil
Types:     wybe.float.iceil
Types:     wybe.float.abs
Types:     wybe.float.>=
Types:     wybe.float.>
Types:     wybe.float.=
Types:     wybe.float.<=
Types:     wybe.float.<
Types:     wybe.float.<=>
Types:     wybe.float./
Types:     wybe.float./=
Types:     wybe.float.tan
Types:     wybe.float.-
Types:     wybe.float.-=
Types:     wybe.float.+
Types:     wybe.float.+=
Types:     wybe.float.**
Types:     wybe.float.*
Types:     wybe.float.*=
Types: Type checking non-recursive proc wybe.float.~=
Types: ** Type checking decl of proc ~=
Types: found 1 definition(s)
Types: Type checking ~=
Types: ** Type checking ~=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm fcmp_ne(x @float:67:51, y @float:67:53, ?tmp#0 @float:67:30)
Types:         foreign llvm move(tmp#0, ?#result @float:67:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.float, y:wybe.float, ?#result:wybe.bool
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm fcmp_ne(x @float:67:51, y @float:67:53, ?tmp#0 @float:67:30)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:67:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:67:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:67:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @float:67:51
Types:   Type = wybe.float
Types: Finding type of expr y @float:67:53
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:67:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call fcmp_ne(64 bit float, 64 bit float, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @float:67:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc ~=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fcmp_ne(x @float:67:51, y @float:67:53, ?tmp#0 @float:67:30)
Types: Mode checking foreign call {foreign llvm fcmp_ne(x @float:67:51, y @float:67:53, ?tmp#0 @float:67:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:67:51
Types:   Type = wybe.float
Types: Finding type of expr y @float:67:53
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:67:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.float,wybe.float,?wybe.bool]
Types: New instr = {foreign llvm fcmp_ne(x:wybe.float @float:67:51, y:wybe.float @float:67:53, ?tmp#0:wybe.bool @float:67:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:67:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:67:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @float:67:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:67:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '~='
Types: Mode checked body   : [{foreign llvm fcmp_ne(x:wybe.float @float:67:51, y:wybe.float @float:67:53, ?tmp#0:wybe.bool @float:67:30)} @float:67:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:67:5)} @float:67:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of ~=:
Types: 
Types: ~= > public (0 calls)
Types: 4: ~=(x:wybe.float @float:67:10, y:wybe.float @float:67:18, ?#result:wybe.bool @float:67:5):
Types:     foreign llvm fcmp_ne(x:wybe.float @float:67:51, y:wybe.float @float:67:53, ?tmp#0:wybe.bool @float:67:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:67:5)
Types: Type checking non-recursive proc wybe.float.square
Types: ** Type checking decl of proc square
Types: found 1 definition(s)
Types: Type checking square
Types: ** Type checking square: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm fmul(x @float:57:43, x @float:57:45, ?tmp#0 @float:57:25)
Types:         foreign llvm move(tmp#0, ?#result @float:57:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x"]
Types: Recording parameter types: x:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign llvm fmul(x @float:57:43, x @float:57:45, ?tmp#0 @float:57:25)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:57:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:57:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:57:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:57:43
Types:   Type = wybe.float
Types: Finding type of expr x @float:57:45
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:57:25
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign llvm call fmul(64 bit float, 64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:57:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc square
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fmul(x @float:57:43, x @float:57:45, ?tmp#0 @float:57:25)
Types: Mode checking foreign call {foreign llvm fmul(x @float:57:43, x @float:57:45, ?tmp#0 @float:57:25)}
Types:     with assigned semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:57:43
Types:   Type = wybe.float
Types: Finding type of expr x @float:57:45
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:57:25
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,wybe.float,?wybe.float]
Types: New instr = {foreign llvm fmul(x:wybe.float @float:57:43, x:wybe.float @float:57:45, ?tmp#0:wybe.float @float:57:25)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:57:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:57:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:57:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:57:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'square'
Types: Mode checked body   : [{foreign llvm fmul(x:wybe.float @float:57:43, x:wybe.float @float:57:45, ?tmp#0:wybe.float @float:57:25)} @float:57:25,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:57:5)} @float:57:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of square:
Types: 
Types: square > public (0 calls)
Types: 4: square(x:wybe.float @float:57:16, ?#result:wybe.float @float:57:5):
Types:     foreign llvm fmul(x:wybe.float @float:57:43, x:wybe.float @float:57:45, ?tmp#0:wybe.float @float:57:25)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:57:5)
Types: Type checking non-recursive proc wybe.float.sqrt
Types: ** Type checking decl of proc sqrt
Types: found 1 definition(s)
Types: Type checking sqrt
Types: ** Type checking sqrt: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c llvm.sqrt.f64(x @float:108:49, ?tmp#0 @float:108:23)
Types:         foreign llvm move(tmp#0, ?#result @float:108:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x"]
Types: Recording parameter types: x:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign c llvm.sqrt.f64(x @float:108:49, ?tmp#0 @float:108:23)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:108:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:108:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:108:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:108:49
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:108:23
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign c call llvm.sqrt.f64(64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:108:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc sqrt
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt foreign c llvm.sqrt.f64(x @float:108:49, ?tmp#0 @float:108:23)
Types: Mode checking foreign call {foreign c llvm.sqrt.f64(x @float:108:49, ?tmp#0 @float:108:23)}
Types:     with assigned semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:108:49
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:108:23
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign c llvm.sqrt.f64(x:wybe.float @float:108:49, ?tmp#0:wybe.float @float:108:23)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:108:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:108:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:108:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:108:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'sqrt'
Types: Mode checked body   : [{foreign c llvm.sqrt.f64(x:wybe.float @float:108:49, ?tmp#0:wybe.float @float:108:23)} @float:108:23,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:108:5)} @float:108:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of sqrt:
Types: 
Types: sqrt > public (0 calls)
Types: 4: sqrt(x:wybe.float @float:108:14, ?#result:wybe.float @float:108:5):
Types:     foreign c llvm.sqrt.f64(x:wybe.float @float:108:49, ?tmp#0:wybe.float @float:108:23)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:108:5)
Types: Type checking non-recursive proc wybe.float.sin
Types: ** Type checking decl of proc sin
Types: found 1 definition(s)
Types: Type checking sin
Types: ** Type checking sin: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c llvm.sin.f64(x @float:115:47, ?tmp#0 @float:115:22)
Types:         foreign llvm move(tmp#0, ?#result @float:115:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x"]
Types: Recording parameter types: x:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign c llvm.sin.f64(x @float:115:47, ?tmp#0 @float:115:22)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:115:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:115:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:115:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:115:47
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:115:22
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign c call llvm.sin.f64(64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:115:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc sin
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt foreign c llvm.sin.f64(x @float:115:47, ?tmp#0 @float:115:22)
Types: Mode checking foreign call {foreign c llvm.sin.f64(x @float:115:47, ?tmp#0 @float:115:22)}
Types:     with assigned semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:115:47
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:115:22
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign c llvm.sin.f64(x:wybe.float @float:115:47, ?tmp#0:wybe.float @float:115:22)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:115:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:115:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:115:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:115:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'sin'
Types: Mode checked body   : [{foreign c llvm.sin.f64(x:wybe.float @float:115:47, ?tmp#0:wybe.float @float:115:22)} @float:115:22,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:115:5)} @float:115:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of sin:
Types: 
Types: sin > public (0 calls)
Types: 4: sin(x:wybe.float @float:115:13, ?#result:wybe.float @float:115:5):
Types:     foreign c llvm.sin.f64(x:wybe.float @float:115:47, ?tmp#0:wybe.float @float:115:22)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:115:5)
Types: Type checking non-recursive proc wybe.float.round
Types: ** Type checking decl of proc round
Types: found 1 definition(s)
Types: Type checking round
Types: ** Type checking round: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c llvm.round.f64(x @float:93:51, ?tmp#0 @float:93:24)
Types:         foreign llvm move(tmp#0, ?#result @float:93:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x"]
Types: Recording parameter types: x:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign c llvm.round.f64(x @float:93:51, ?tmp#0 @float:93:24)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:93:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:93:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:93:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:93:51
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:93:24
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign c call llvm.round.f64(64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:93:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc round
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt foreign c llvm.round.f64(x @float:93:51, ?tmp#0 @float:93:24)
Types: Mode checking foreign call {foreign c llvm.round.f64(x @float:93:51, ?tmp#0 @float:93:24)}
Types:     with assigned semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:93:51
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:93:24
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign c llvm.round.f64(x:wybe.float @float:93:51, ?tmp#0:wybe.float @float:93:24)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:93:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:93:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:93:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:93:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'round'
Types: Mode checked body   : [{foreign c llvm.round.f64(x:wybe.float @float:93:51, ?tmp#0:wybe.float @float:93:24)} @float:93:24,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:93:5)} @float:93:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of round:
Types: 
Types: round > public (0 calls)
Types: 4: round(x:wybe.float @float:93:15, ?#result:wybe.float @float:93:5):
Types:     foreign c llvm.round.f64(x:wybe.float @float:93:51, ?tmp#0:wybe.float @float:93:24)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:93:5)
Types: Type checking non-recursive proc wybe.float.read
Types: ** Type checking decl of proc read
Types: found 1 definition(s)
Types: Type checking read
Types: ** Type checking read: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         foreign c read_float(?x @float:137:52, !io @float:137:56)
Types:    and defaults: 
Types:    with assigned vars: fromList ["io","x"]
Types: Recording parameter types: ?x:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {foreign c read_float(?x @float:137:52, !io @float:137:56)}
Types: *** Before calls Typing {io::wybe.phantom, x::wybe.float}; {} (with no errors)
Types:   With calls:
Types:   Typing {io::wybe.phantom, x::wybe.float}; {} (with no errors)
Types: Finding type of expr ?x @float:137:52
Types:   Type = wybe.float
Types: Finding type of expr !io @float:137:56
Types:   Type = wybe.phantom
Types: Type checking foreign c call read_float(64 bit float)
Types: Now mode checking proc read
Types: bound vars: semipure normal (total) computation binding {io}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt foreign c read_float(?x @float:137:52, !io @float:137:56)
Types: Mode checking foreign call {foreign c read_float(?x @float:137:52, !io @float:137:56)}
Types:     with assigned semipure normal (total) computation binding {io}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp !io
Types: Mode check exp resulted in !io
Types: Finding type of expr ?x @float:137:52
Types:   Type = wybe.float
Types: Finding type of expr !io @float:137:56
Types:   Type = wybe.phantom
Types:     types and modes = [?wybe.float,!wybe.phantom]
Types: New instr = {foreign c read_float(?x:wybe.float @float:137:52, !io:wybe.phantom @float:137:56)}
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'read'
Types: Mode checked body   : [{foreign c read_float(?x:wybe.float @float:137:52, !io:wybe.phantom @float:137:56)} @float:137:30]
Types: Vars defined by body: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : x
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of read:
Types: 
Types: read > public (0 calls)
Types: 4: read(?x:wybe.float @float:137:15) use !wybe.io.io:
Types:     foreign c read_float(?x:wybe.float @float:137:52, !io:wybe.phantom @float:137:56)
Types: Type checking non-recursive proc wybe.float.print
Types: ** Type checking decl of proc print
Types: found 1 definition(s)
Types: Type checking print
Types: ** Type checking print: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         foreign c print_float(x @float:133:52, !io @float:133:56)
Types:    and defaults: 
Types:    with assigned vars: fromList ["io","x"]
Types: Recording parameter types: x:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {foreign c print_float(x @float:133:52, !io @float:133:56)}
Types: *** Before calls Typing {io::wybe.phantom, x::wybe.float}; {} (with no errors)
Types:   With calls:
Types:   Typing {io::wybe.phantom, x::wybe.float}; {} (with no errors)
Types: Finding type of expr x @float:133:52
Types:   Type = wybe.float
Types: Finding type of expr !io @float:133:56
Types:   Type = wybe.phantom
Types: Type checking foreign c call print_float(64 bit float)
Types: Now mode checking proc print
Types: bound vars: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt foreign c print_float(x @float:133:52, !io @float:133:56)
Types: Mode checking foreign call {foreign c print_float(x @float:133:52, !io @float:133:56)}
Types:     with assigned semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp !io
Types: Mode check exp resulted in !io
Types: Finding type of expr x @float:133:52
Types:   Type = wybe.float
Types: Finding type of expr !io @float:133:56
Types:   Type = wybe.phantom
Types:     types and modes = [wybe.float,!wybe.phantom]
Types: New instr = {foreign c print_float(x:wybe.float @float:133:52, !io:wybe.phantom @float:133:56)}
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'print'
Types: Mode checked body   : [{foreign c print_float(x:wybe.float @float:133:52, !io:wybe.phantom @float:133:56)} @float:133:30]
Types: Vars defined by body: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : 
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of print:
Types: 
Types: print > public (0 calls)
Types: 4: print(x:wybe.float @float:133:15) use !wybe.io.io:
Types:     foreign c print_float(x:wybe.float @float:133:52, !io:wybe.phantom @float:133:56)
Types: Type checking non-recursive proc wybe.float.println
Types: ** Type checking decl of proc println
Types: found 1 definition(s)
Types: Type checking println
Types: ** Type checking println: Typing {}; {} (with no errors)
Types:    with resources: fromList [!wybe.io.io]
Types:    containing calls: 
Types:         !print(x @float:135:39)
Types:         !nl
Types:    and defaults: 
Types:    with assigned vars: fromList ["io","x"]
Types: Recording parameter types: x:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types: Recording resource types: !wybe.io.io
Types: Unifying types wybe.phantom (-> wybe.phantom) and any (-> any)
Types:   Unification yields wybe.phantom
Types: Variable io type constrained to wybe.phantom
Types: Recording casts in {!print(x @float:135:39)}
Types: Recording casts in {!nl}
Types: *** Before calls Typing {io::wybe.phantom, x::wybe.float}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {!print(x @float:135:39)} @float:135:33, typingInfos = [wybe.bool.print<0>(wybe.bool) use io, ?io,wybe.float.print<0>(wybe.float) use io, ?io,wybe.int.print<0>(wybe.int) use io, ?io]}
Types:     StmtTypings {typingStmt = {!nl} @float:135:44, typingInfos = [wybe.io.nl<0>() use io, ?io]}Typing {io::wybe.phantom, x::wybe.float}; {} (with no errors)
Types: Type checking call {!print(x @float:135:39)} @float:135:33
Types: Candidate types:
Types:     wybe.bool.print<0>(wybe.bool) use io, ?io
Types:     wybe.float.print<0>(wybe.float) use io, ?io
Types:     wybe.int.print<0>(wybe.int) use io, ?io
Types: Finding type of expr x @float:135:39
Types:   Type = wybe.float
Types: Actual types: [wybe.float]
Types: Matching types [wybe.float] with wybe.bool.print<0>(wybe.bool) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 135, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Matching types [wybe.float] with wybe.float.print<0>(wybe.float) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float] with wybe.int.print<0>(wybe.int) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 135, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Valid types = [Typing {io::wybe.phantom, x::wybe.float}; {} (with no errors)]
Types: Resulting typing = Typing {io::wybe.phantom, x::wybe.float}; {} (with no errors)
Types: Type checking call {!nl} @float:135:44
Types: Candidate types:
Types:     wybe.io.nl<0>() use io, ?io
Types: Actual types: []
Types: Matching types [] with wybe.io.nl<0>() use io, ?io
Types: Call arity 0; proc arity 0 - 0
Types: Filling  0 optional arguments
Types: Valid types = [Typing {io::wybe.phantom, x::wybe.float}; {} (with no errors)]
Types: Resulting typing = Typing {io::wybe.phantom, x::wybe.float}; {} (with no errors)
Types: Now mode checking proc println
Types: bound vars: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt !print(x @float:135:39)
Types: Mode checking call   : {!print(x @float:135:39)}
Types:     with assigned    : semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Finding type of expr x @float:135:39
Types:   Type = wybe.float
Types:     actual types     : [wybe.float]
Types:     actual modes     : [(ParamIn,True,Nothing)]
Types: Matching types [wybe.float] with wybe.bool.print<0>(wybe.bool) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 135, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Matching types [wybe.float] with wybe.float.print<0>(wybe.float) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float] with wybe.int.print<0>(wybe.int) use io, ?io
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 135, column 33): Type error in call to print, argument 1]
Types:   Unification yields XXX
Types: Type-correct modes   : [(wybe.float.print<0>(wybe.float) use io, ?io,Typing {io::wybe.phantom, x::wybe.float}; {} (with no errors))]
Types: Possible mode matches: [(wybe.float.print<0>(wybe.float) use io, ?io,Typing {io::wybe.phantom, x::wybe.float}; {} (with no errors))]
Types: Exact mode matches: [(wybe.float.print<0>(wybe.float) use io, ?io,Typing {io::wybe.phantom, x::wybe.float}; {} (with no errors))]
Types: Finding type of expr x @float:135:39
Types:   Type = wybe.float
Types: Finalising call    :  {!wybe.float.<0>print(x:wybe.float @float:135:39)}
Types: Input resources    :  {wybe.io.io}
Types: Output resources   :  {wybe.io.io}
Types: Specials in call   :  {}
Types: Available vars     :  {"io", "x"}
Types: Available resources:  {wybe.io.io}
Types: Generated special stmts = []
Types: New instr = {!wybe.float.<0>print(x:wybe.float @float:135:39)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'println'
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check stmt !nl
Types: Mode checking call   : {!nl}
Types:     with assigned    : semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types:     actual types     : []
Types:     actual modes     : []
Types: Matching types [] with wybe.io.nl<0>() use io, ?io
Types: Call arity 0; proc arity 0 - 0
Types: Filling  0 optional arguments
Types: Type-correct modes   : [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.float}; {} (with no errors))]
Types: Possible mode matches: [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.float}; {} (with no errors))]
Types: Exact mode matches: [(wybe.io.nl<0>() use io, ?io,Typing {io::wybe.phantom, x::wybe.float}; {} (with no errors))]
Types: Finalising call    :  {!wybe.io.<0>nl}
Types: Input resources    :  {wybe.io.io}
Types: Output resources   :  {wybe.io.io}
Types: Specials in call   :  {}
Types: Available vars     :  {"io", "x"}
Types: Available resources:  {wybe.io.io}
Types: Generated special stmts = []
Types: New instr = {!wybe.io.<0>nl}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'println'
Types: Now assigned = semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Mode check end of Det proc 'println'
Types: Mode checked body   : [{!wybe.float.<0>print(x:wybe.float @float:135:39)} @float:135:33,{!wybe.io.<0>nl} @float:135:44]
Types: Vars defined by body: semipure normal (total) computation binding {io, x}, break set = Everything, with resources {wybe.io.io}
Types: Output parameters   : 
Types: Output resources    : io
Types: ===== NO Need to check again.
Types: ** New definition of println:
Types: 
Types: println > public (0 calls)
Types: 4: println(x:wybe.float @float:135:17) use !wybe.io.io:
Types:     !wybe.float.<0>print(x:wybe.float @float:135:39)
Types:     !wybe.io.<0>nl
Types: Type checking non-recursive proc wybe.float.power
Types: ** Type checking decl of proc power
Types: found 1 definition(s)
Types: Type checking power
Types: ** Type checking power: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c llvm.pow.f64(x @float:111:53, n @float:111:55, ?tmp#0 @float:111:28)
Types:         foreign llvm move(tmp#0, ?#result @float:111:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","n","tmp#0","x"]
Types: Recording parameter types: x:wybe.float, n:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'n' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable n type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign c llvm.pow.f64(x @float:111:53, n @float:111:55, ?tmp#0 @float:111:28)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:111:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:111:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:111:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, n::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, n::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:111:53
Types:   Type = wybe.float
Types: Finding type of expr n @float:111:55
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:111:28
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign c call llvm.pow.f64(64 bit float, 64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:111:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc power
Types: bound vars: semipure normal (total) computation binding {n, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign c llvm.pow.f64(x @float:111:53, n @float:111:55, ?tmp#0 @float:111:28)
Types: Mode checking foreign call {foreign c llvm.pow.f64(x @float:111:53, n @float:111:55, ?tmp#0 @float:111:28)}
Types:     with assigned semipure normal (total) computation binding {n, x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp n
Types: Mode check exp resulted in n
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:111:53
Types:   Type = wybe.float
Types: Finding type of expr n @float:111:55
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:111:28
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,wybe.float,?wybe.float]
Types: New instr = {foreign c llvm.pow.f64(x:wybe.float @float:111:53, n:wybe.float @float:111:55, ?tmp#0:wybe.float @float:111:28)}
Types: Now assigned = semipure normal (total) computation binding {n, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:111:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:111:5)}
Types:     with assigned semipure normal (total) computation binding {n, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:111:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:111:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, n, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'power'
Types: Mode checked body   : [{foreign c llvm.pow.f64(x:wybe.float @float:111:53, n:wybe.float @float:111:55, ?tmp#0:wybe.float @float:111:28)} @float:111:28,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:111:5)} @float:111:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, n, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of power:
Types: 
Types: power > public (0 calls)
Types: 4: power(x:wybe.float @float:111:15, n:wybe.float @float:111:19, ?#result:wybe.float @float:111:5):
Types:     foreign c llvm.pow.f64(x:wybe.float @float:111:53, n:wybe.float @float:111:55, ?tmp#0:wybe.float @float:111:28)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:111:5)
Types: Type checking non-recursive proc wybe.float.pi
Types: ** Type checking decl of proc pi
Types: found 1 definition(s)
Types: Type checking pi
Types: ** Type checking pi: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm move(3.141592653589793 @float:13:16, ?#result @float:13:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result"]
Types: Recording parameter types: ?#result:wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign llvm move(3.141592653589793 @float:13:16, ?#result @float:13:5)}
Types: Unifying move argument types 3.141592653589793 @float:13:16 and ?#result @float:13:5
Types: Finding type of expr 3.141592653589793 @float:13:16
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:13:5
Types:   Type = wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float}; {} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float}; {} (with no errors)
Types: Finding type of expr 3.141592653589793 @float:13:16
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:13:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc pi
Types: bound vars: semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(3.141592653589793 @float:13:16, ?#result @float:13:5)
Types: Mode checking foreign call {foreign llvm move(3.141592653589793 @float:13:16, ?#result @float:13:5)}
Types:     with assigned semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check exp 3.141592653589793
Types: Mode check exp resulted in 3.141592653589793
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr 3.141592653589793 @float:13:16
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:13:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(3.141592653589793:wybe.float @float:13:16, ?#result:wybe.float @float:13:5)}
Types: Now assigned = semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'pi'
Types: Mode checked body   : [{foreign llvm move(3.141592653589793:wybe.float @float:13:16, ?#result:wybe.float @float:13:5)} @float:13:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of pi:
Types: 
Types: pi > public (0 calls)
Types: 4: pi(?#result:wybe.float @float:13:5):
Types:     foreign llvm move(3.141592653589793:wybe.float @float:13:16, ?#result:wybe.float @float:13:5)
Types: Type checking non-recursive proc wybe.float.min
Types: ** Type checking decl of proc min
Types: found 1 definition(s)
Types: Type checking min
Types: ** Type checking min: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c llvm.minnum.f64(x @float:80:55, y @float:80:57, ?tmp#0 @float:80:27)
Types:         foreign llvm move(tmp#0, ?#result @float:80:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.float, y:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign c llvm.minnum.f64(x @float:80:55, y @float:80:57, ?tmp#0 @float:80:27)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:80:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:80:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:80:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:80:55
Types:   Type = wybe.float
Types: Finding type of expr y @float:80:57
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:80:27
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign c call llvm.minnum.f64(64 bit float, 64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:80:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc min
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign c llvm.minnum.f64(x @float:80:55, y @float:80:57, ?tmp#0 @float:80:27)
Types: Mode checking foreign call {foreign c llvm.minnum.f64(x @float:80:55, y @float:80:57, ?tmp#0 @float:80:27)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:80:55
Types:   Type = wybe.float
Types: Finding type of expr y @float:80:57
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:80:27
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,wybe.float,?wybe.float]
Types: New instr = {foreign c llvm.minnum.f64(x:wybe.float @float:80:55, y:wybe.float @float:80:57, ?tmp#0:wybe.float @float:80:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:80:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:80:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:80:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:80:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'min'
Types: Mode checked body   : [{foreign c llvm.minnum.f64(x:wybe.float @float:80:55, y:wybe.float @float:80:57, ?tmp#0:wybe.float @float:80:27)} @float:80:27,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:80:5)} @float:80:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of min:
Types: 
Types: min > public (0 calls)
Types: 4: min(x:wybe.float @float:80:13, y:wybe.float @float:80:18, ?#result:wybe.float @float:80:5):
Types:     foreign c llvm.minnum.f64(x:wybe.float @float:80:55, y:wybe.float @float:80:57, ?tmp#0:wybe.float @float:80:27)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:80:5)
Types: Type checking non-recursive proc wybe.float.max
Types: ** Type checking decl of proc max
Types: found 1 definition(s)
Types: Type checking max
Types: ** Type checking max: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c llvm.maxnum.f64(x @float:81:55, y @float:81:57, ?tmp#0 @float:81:27)
Types:         foreign llvm move(tmp#0, ?#result @float:81:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.float, y:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign c llvm.maxnum.f64(x @float:81:55, y @float:81:57, ?tmp#0 @float:81:27)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:81:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:81:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:81:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:81:55
Types:   Type = wybe.float
Types: Finding type of expr y @float:81:57
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:81:27
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign c call llvm.maxnum.f64(64 bit float, 64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:81:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc max
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign c llvm.maxnum.f64(x @float:81:55, y @float:81:57, ?tmp#0 @float:81:27)
Types: Mode checking foreign call {foreign c llvm.maxnum.f64(x @float:81:55, y @float:81:57, ?tmp#0 @float:81:27)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:81:55
Types:   Type = wybe.float
Types: Finding type of expr y @float:81:57
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:81:27
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,wybe.float,?wybe.float]
Types: New instr = {foreign c llvm.maxnum.f64(x:wybe.float @float:81:55, y:wybe.float @float:81:57, ?tmp#0:wybe.float @float:81:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:81:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:81:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:81:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:81:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'max'
Types: Mode checked body   : [{foreign c llvm.maxnum.f64(x:wybe.float @float:81:55, y:wybe.float @float:81:57, ?tmp#0:wybe.float @float:81:27)} @float:81:27,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:81:5)} @float:81:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of max:
Types: 
Types: max > public (0 calls)
Types: 4: max(x:wybe.float @float:81:13, y:wybe.float @float:81:18, ?#result:wybe.float @float:81:5):
Types:     foreign c llvm.maxnum.f64(x:wybe.float @float:81:55, y:wybe.float @float:81:57, ?tmp#0:wybe.float @float:81:27)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:81:5)
Types: Type checking non-recursive proc wybe.float.log2
Types: ** Type checking decl of proc log2
Types: found 1 definition(s)
Types: Type checking log2
Types: ** Type checking log2: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c llvm.log2.f64(x @float:129:49, ?tmp#0 @float:129:23)
Types:         foreign llvm move(tmp#0, ?#result @float:129:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x"]
Types: Recording parameter types: x:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign c llvm.log2.f64(x @float:129:49, ?tmp#0 @float:129:23)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:129:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:129:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:129:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:129:49
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:129:23
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign c call llvm.log2.f64(64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:129:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc log2
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt foreign c llvm.log2.f64(x @float:129:49, ?tmp#0 @float:129:23)
Types: Mode checking foreign call {foreign c llvm.log2.f64(x @float:129:49, ?tmp#0 @float:129:23)}
Types:     with assigned semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:129:49
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:129:23
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign c llvm.log2.f64(x:wybe.float @float:129:49, ?tmp#0:wybe.float @float:129:23)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:129:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:129:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:129:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:129:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'log2'
Types: Mode checked body   : [{foreign c llvm.log2.f64(x:wybe.float @float:129:49, ?tmp#0:wybe.float @float:129:23)} @float:129:23,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:129:5)} @float:129:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of log2:
Types: 
Types: log2 > public (0 calls)
Types: 4: log2(x:wybe.float @float:129:14, ?#result:wybe.float @float:129:5):
Types:     foreign c llvm.log2.f64(x:wybe.float @float:129:49, ?tmp#0:wybe.float @float:129:23)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:129:5)
Types: Type checking non-recursive proc wybe.float.log10
Types: ** Type checking decl of proc log10
Types: found 1 definition(s)
Types: Type checking log10
Types: ** Type checking log10: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c llvm.log10.f64(x @float:126:51, ?tmp#0 @float:126:24)
Types:         foreign llvm move(tmp#0, ?#result @float:126:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x"]
Types: Recording parameter types: x:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign c llvm.log10.f64(x @float:126:51, ?tmp#0 @float:126:24)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:126:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:126:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:126:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:126:51
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:126:24
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign c call llvm.log10.f64(64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:126:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc log10
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt foreign c llvm.log10.f64(x @float:126:51, ?tmp#0 @float:126:24)
Types: Mode checking foreign call {foreign c llvm.log10.f64(x @float:126:51, ?tmp#0 @float:126:24)}
Types:     with assigned semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:126:51
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:126:24
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign c llvm.log10.f64(x:wybe.float @float:126:51, ?tmp#0:wybe.float @float:126:24)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:126:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:126:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:126:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:126:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'log10'
Types: Mode checked body   : [{foreign c llvm.log10.f64(x:wybe.float @float:126:51, ?tmp#0:wybe.float @float:126:24)} @float:126:24,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:126:5)} @float:126:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of log10:
Types: 
Types: log10 > public (0 calls)
Types: 4: log10(x:wybe.float @float:126:15, ?#result:wybe.float @float:126:5):
Types:     foreign c llvm.log10.f64(x:wybe.float @float:126:51, ?tmp#0:wybe.float @float:126:24)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:126:5)
Types: Type checking non-recursive proc wybe.float.log
Types: ** Type checking decl of proc log
Types: found 1 definition(s)
Types: Type checking log
Types: ** Type checking log: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c llvm.log.f64(x @float:123:47, ?tmp#0 @float:123:22)
Types:         foreign llvm move(tmp#0, ?#result @float:123:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x"]
Types: Recording parameter types: x:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign c llvm.log.f64(x @float:123:47, ?tmp#0 @float:123:22)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:123:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:123:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:123:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:123:47
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:123:22
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign c call llvm.log.f64(64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:123:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc log
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt foreign c llvm.log.f64(x @float:123:47, ?tmp#0 @float:123:22)
Types: Mode checking foreign call {foreign c llvm.log.f64(x @float:123:47, ?tmp#0 @float:123:22)}
Types:     with assigned semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:123:47
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:123:22
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign c llvm.log.f64(x:wybe.float @float:123:47, ?tmp#0:wybe.float @float:123:22)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:123:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:123:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:123:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:123:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'log'
Types: Mode checked body   : [{foreign c llvm.log.f64(x:wybe.float @float:123:47, ?tmp#0:wybe.float @float:123:22)} @float:123:22,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:123:5)} @float:123:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of log:
Types: 
Types: log > public (0 calls)
Types: 4: log(x:wybe.float @float:123:13, ?#result:wybe.float @float:123:5):
Types:     foreign c llvm.log.f64(x:wybe.float @float:123:47, ?tmp#0:wybe.float @float:123:22)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:123:5)
Types: Type checking non-recursive proc wybe.float.iround
Types: ** Type checking decl of proc iround
Types: found 1 definition(s)
Types: Type checking iround
Types: ** Type checking iround: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         round(x @float:96:53, ?tmp#1 @float:96:47)
Types:         foreign llvm fptosi(tmp#1, ?tmp#0 @float:96:27)
Types:         foreign llvm move(tmp#0, ?#result @float:96:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","tmp#1","x"]
Types: Recording parameter types: x:wybe.float, ?#result:wybe.int
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {round(x @float:96:53, ?tmp#1 @float:96:47)}
Types: Recording casts in {foreign llvm fptosi(tmp#1, ?tmp#0 @float:96:27)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:96:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:96:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:96:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, tmp#0::0, x::wybe.float}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {round(x @float:96:53, ?tmp#1 @float:96:47)} @float:96:47, typingInfos = [wybe.float.round<0>(wybe.float,?wybe.float)]}Typing {#result::wybe.int, tmp#0::0, x::wybe.float}; {0::wybe.int} (with no errors)
Types: Type checking call {round(x @float:96:53, ?tmp#1 @float:96:47)} @float:96:47
Types: Candidate types:
Types:     wybe.float.round<0>(wybe.float,?wybe.float)
Types: Finding type of expr x @float:96:53
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#1 @float:96:47
Types:   Type = 1
Types: Actual types: [wybe.float,1]
Types: Matching types [wybe.float,1] with wybe.float.round<0>(wybe.float,?wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Valid types = [Typing {#result::wybe.int, tmp#0::0, tmp#1::1, x::wybe.float}; {0::wybe.int, 1::wybe.float} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, tmp#0::0, tmp#1::1, x::wybe.float}; {0::wybe.int, 1::wybe.float} (with no errors)
Types: Finding type of expr tmp#1
Types: Type variable 1 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:96:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call fptosi(64 bit float, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @float:96:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc iround
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt round(x @float:96:53, ?tmp#1 @float:96:47)
Types: Mode checking call   : {round(x @float:96:53, ?tmp#1 @float:96:47)}
Types:     with assigned    : semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr x @float:96:53
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#1 @float:96:47
Types: Type variable 1 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.float,wybe.float] with wybe.float.round<0>(wybe.float,?wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type-correct modes   : [(wybe.float.round<0>(wybe.float,?wybe.float),Typing {#result::wybe.int, tmp#0::0, tmp#1::1, x::wybe.float}; {0::wybe.int, 1::wybe.float} (with no errors))]
Types: Possible mode matches: [(wybe.float.round<0>(wybe.float,?wybe.float),Typing {#result::wybe.int, tmp#0::0, tmp#1::1, x::wybe.float}; {0::wybe.int, 1::wybe.float} (with no errors))]
Types: Exact mode matches: [(wybe.float.round<0>(wybe.float,?wybe.float),Typing {#result::wybe.int, tmp#0::0, tmp#1::1, x::wybe.float}; {0::wybe.int, 1::wybe.float} (with no errors))]
Types: Finding type of expr x @float:96:53
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#1 @float:96:47
Types: Type variable 1 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finalising call    :  {wybe.float.<0>round(x:wybe.float @float:96:53, ?tmp#1:wybe.float @float:96:47)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.float.<0>round(x:wybe.float @float:96:53, ?tmp#1:wybe.float @float:96:47)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'iround'
Types: Now assigned = semipure normal (total) computation binding {tmp#1, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fptosi(tmp#1, ?tmp#0 @float:96:27)
Types: Mode checking foreign call {foreign llvm fptosi(tmp#1, ?tmp#0 @float:96:27)}
Types:     with assigned semipure normal (total) computation binding {tmp#1, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#1
Types: Type variable 1 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:96:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.float,?wybe.int]
Types: New instr = {foreign llvm fptosi(tmp#1:wybe.float, ?tmp#0:wybe.int @float:96:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#1, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:96:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:96:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, tmp#1, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @float:96:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @float:96:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, tmp#1, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'iround'
Types: Mode checked body   : [{wybe.float.<0>round(x:wybe.float @float:96:53, ?tmp#1:wybe.float @float:96:47)} @float:96:47,{foreign llvm fptosi(tmp#1:wybe.float, ?tmp#0:wybe.int @float:96:27)} @float:96:27,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @float:96:5)} @float:96:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, tmp#1, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of iround:
Types: 
Types: iround > public (0 calls)
Types: 4: iround(x:wybe.float @float:96:16, ?#result:wybe.int @float:96:5):
Types:     wybe.float.<0>round(x:wybe.float @float:96:53, ?tmp#1:wybe.float @float:96:47)
Types:     foreign llvm fptosi(tmp#1:wybe.float, ?tmp#0:wybe.int @float:96:27)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @float:96:5)
Types: Type checking non-recursive proc wybe.float.floor
Types: ** Type checking decl of proc floor
Types: found 1 definition(s)
Types: Type checking floor
Types: ** Type checking floor: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c llvm.floor.f64(x @float:90:51, ?tmp#0 @float:90:24)
Types:         foreign llvm move(tmp#0, ?#result @float:90:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x"]
Types: Recording parameter types: x:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign c llvm.floor.f64(x @float:90:51, ?tmp#0 @float:90:24)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:90:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:90:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:90:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:90:51
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:90:24
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign c call llvm.floor.f64(64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:90:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc floor
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt foreign c llvm.floor.f64(x @float:90:51, ?tmp#0 @float:90:24)
Types: Mode checking foreign call {foreign c llvm.floor.f64(x @float:90:51, ?tmp#0 @float:90:24)}
Types:     with assigned semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:90:51
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:90:24
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign c llvm.floor.f64(x:wybe.float @float:90:51, ?tmp#0:wybe.float @float:90:24)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:90:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:90:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:90:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:90:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'floor'
Types: Mode checked body   : [{foreign c llvm.floor.f64(x:wybe.float @float:90:51, ?tmp#0:wybe.float @float:90:24)} @float:90:24,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:90:5)} @float:90:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of floor:
Types: 
Types: floor > public (0 calls)
Types: 4: floor(x:wybe.float @float:90:15, ?#result:wybe.float @float:90:5):
Types:     foreign c llvm.floor.f64(x:wybe.float @float:90:51, ?tmp#0:wybe.float @float:90:24)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:90:5)
Types: Type checking non-recursive proc wybe.float.ifloor
Types: ** Type checking decl of proc ifloor
Types: found 1 definition(s)
Types: Type checking ifloor
Types: ** Type checking ifloor: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         floor(x @float:102:53, ?tmp#1 @float:102:47)
Types:         foreign llvm fptosi(tmp#1, ?tmp#0 @float:102:27)
Types:         foreign llvm move(tmp#0, ?#result @float:102:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","tmp#1","x"]
Types: Recording parameter types: x:wybe.float, ?#result:wybe.int
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {floor(x @float:102:53, ?tmp#1 @float:102:47)}
Types: Recording casts in {foreign llvm fptosi(tmp#1, ?tmp#0 @float:102:27)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:102:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:102:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:102:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, tmp#0::0, x::wybe.float}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {floor(x @float:102:53, ?tmp#1 @float:102:47)} @float:102:47, typingInfos = [wybe.float.floor<0>(wybe.float,?wybe.float)]}Typing {#result::wybe.int, tmp#0::0, x::wybe.float}; {0::wybe.int} (with no errors)
Types: Type checking call {floor(x @float:102:53, ?tmp#1 @float:102:47)} @float:102:47
Types: Candidate types:
Types:     wybe.float.floor<0>(wybe.float,?wybe.float)
Types: Finding type of expr x @float:102:53
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#1 @float:102:47
Types:   Type = 1
Types: Actual types: [wybe.float,1]
Types: Matching types [wybe.float,1] with wybe.float.floor<0>(wybe.float,?wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Valid types = [Typing {#result::wybe.int, tmp#0::0, tmp#1::1, x::wybe.float}; {0::wybe.int, 1::wybe.float} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, tmp#0::0, tmp#1::1, x::wybe.float}; {0::wybe.int, 1::wybe.float} (with no errors)
Types: Finding type of expr tmp#1
Types: Type variable 1 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:102:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call fptosi(64 bit float, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @float:102:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc ifloor
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt floor(x @float:102:53, ?tmp#1 @float:102:47)
Types: Mode checking call   : {floor(x @float:102:53, ?tmp#1 @float:102:47)}
Types:     with assigned    : semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr x @float:102:53
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#1 @float:102:47
Types: Type variable 1 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.float,wybe.float] with wybe.float.floor<0>(wybe.float,?wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type-correct modes   : [(wybe.float.floor<0>(wybe.float,?wybe.float),Typing {#result::wybe.int, tmp#0::0, tmp#1::1, x::wybe.float}; {0::wybe.int, 1::wybe.float} (with no errors))]
Types: Possible mode matches: [(wybe.float.floor<0>(wybe.float,?wybe.float),Typing {#result::wybe.int, tmp#0::0, tmp#1::1, x::wybe.float}; {0::wybe.int, 1::wybe.float} (with no errors))]
Types: Exact mode matches: [(wybe.float.floor<0>(wybe.float,?wybe.float),Typing {#result::wybe.int, tmp#0::0, tmp#1::1, x::wybe.float}; {0::wybe.int, 1::wybe.float} (with no errors))]
Types: Finding type of expr x @float:102:53
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#1 @float:102:47
Types: Type variable 1 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finalising call    :  {wybe.float.<0>floor(x:wybe.float @float:102:53, ?tmp#1:wybe.float @float:102:47)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.float.<0>floor(x:wybe.float @float:102:53, ?tmp#1:wybe.float @float:102:47)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'ifloor'
Types: Now assigned = semipure normal (total) computation binding {tmp#1, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fptosi(tmp#1, ?tmp#0 @float:102:27)
Types: Mode checking foreign call {foreign llvm fptosi(tmp#1, ?tmp#0 @float:102:27)}
Types:     with assigned semipure normal (total) computation binding {tmp#1, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#1
Types: Type variable 1 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:102:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.float,?wybe.int]
Types: New instr = {foreign llvm fptosi(tmp#1:wybe.float, ?tmp#0:wybe.int @float:102:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#1, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:102:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:102:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, tmp#1, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @float:102:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @float:102:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, tmp#1, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'ifloor'
Types: Mode checked body   : [{wybe.float.<0>floor(x:wybe.float @float:102:53, ?tmp#1:wybe.float @float:102:47)} @float:102:47,{foreign llvm fptosi(tmp#1:wybe.float, ?tmp#0:wybe.int @float:102:27)} @float:102:27,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @float:102:5)} @float:102:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, tmp#1, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of ifloor:
Types: 
Types: ifloor > public (0 calls)
Types: 4: ifloor(x:wybe.float @float:102:16, ?#result:wybe.int @float:102:5):
Types:     wybe.float.<0>floor(x:wybe.float @float:102:53, ?tmp#1:wybe.float @float:102:47)
Types:     foreign llvm fptosi(tmp#1:wybe.float, ?tmp#0:wybe.int @float:102:27)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @float:102:5)
Types: Type checking non-recursive proc wybe.float.exp
Types: ** Type checking decl of proc exp
Types: found 1 definition(s)
Types: Type checking exp
Types: ** Type checking exp: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c llvm.exp.f64(x @float:120:47, ?tmp#0 @float:120:22)
Types:         foreign llvm move(tmp#0, ?#result @float:120:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x"]
Types: Recording parameter types: x:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign c llvm.exp.f64(x @float:120:47, ?tmp#0 @float:120:22)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:120:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:120:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:120:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:120:47
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:120:22
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign c call llvm.exp.f64(64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:120:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc exp
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt foreign c llvm.exp.f64(x @float:120:47, ?tmp#0 @float:120:22)
Types: Mode checking foreign call {foreign c llvm.exp.f64(x @float:120:47, ?tmp#0 @float:120:22)}
Types:     with assigned semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:120:47
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:120:22
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign c llvm.exp.f64(x:wybe.float @float:120:47, ?tmp#0:wybe.float @float:120:22)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:120:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:120:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:120:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:120:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'exp'
Types: Mode checked body   : [{foreign c llvm.exp.f64(x:wybe.float @float:120:47, ?tmp#0:wybe.float @float:120:22)} @float:120:22,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:120:5)} @float:120:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of exp:
Types: 
Types: exp > public (0 calls)
Types: 4: exp(x:wybe.float @float:120:13, ?#result:wybe.float @float:120:5):
Types:     foreign c llvm.exp.f64(x:wybe.float @float:120:47, ?tmp#0:wybe.float @float:120:22)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:120:5)
Types: Type checking non-recursive proc wybe.float.e
Types: ** Type checking decl of proc e
Types: found 1 definition(s)
Types: Type checking e
Types: ** Type checking e: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm move(2.7182818284590455 @float:16:15, ?#result @float:16:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result"]
Types: Recording parameter types: ?#result:wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign llvm move(2.7182818284590455 @float:16:15, ?#result @float:16:5)}
Types: Unifying move argument types 2.7182818284590455 @float:16:15 and ?#result @float:16:5
Types: Finding type of expr 2.7182818284590455 @float:16:15
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:16:5
Types:   Type = wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float}; {} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float}; {} (with no errors)
Types: Finding type of expr 2.7182818284590455 @float:16:15
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:16:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc e
Types: bound vars: semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(2.7182818284590455 @float:16:15, ?#result @float:16:5)
Types: Mode checking foreign call {foreign llvm move(2.7182818284590455 @float:16:15, ?#result @float:16:5)}
Types:     with assigned semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check exp 2.7182818284590455
Types: Mode check exp resulted in 2.7182818284590455
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr 2.7182818284590455 @float:16:15
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:16:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(2.7182818284590455:wybe.float @float:16:15, ?#result:wybe.float @float:16:5)}
Types: Now assigned = semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'e'
Types: Mode checked body   : [{foreign llvm move(2.7182818284590455:wybe.float @float:16:15, ?#result:wybe.float @float:16:5)} @float:16:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of e:
Types: 
Types: e > public (0 calls)
Types: 4: e(?#result:wybe.float @float:16:5):
Types:     foreign llvm move(2.7182818284590455:wybe.float @float:16:15, ?#result:wybe.float @float:16:5)
Types: Type checking non-recursive proc wybe.float.cos
Types: ** Type checking decl of proc cos
Types: found 1 definition(s)
Types: Type checking cos
Types: ** Type checking cos: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c llvm.cos.f64(x @float:116:47, ?tmp#0 @float:116:22)
Types:         foreign llvm move(tmp#0, ?#result @float:116:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x"]
Types: Recording parameter types: x:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign c llvm.cos.f64(x @float:116:47, ?tmp#0 @float:116:22)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:116:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:116:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:116:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:116:47
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:116:22
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign c call llvm.cos.f64(64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:116:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc cos
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt foreign c llvm.cos.f64(x @float:116:47, ?tmp#0 @float:116:22)
Types: Mode checking foreign call {foreign c llvm.cos.f64(x @float:116:47, ?tmp#0 @float:116:22)}
Types:     with assigned semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:116:47
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:116:22
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign c llvm.cos.f64(x:wybe.float @float:116:47, ?tmp#0:wybe.float @float:116:22)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:116:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:116:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:116:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:116:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'cos'
Types: Mode checked body   : [{foreign c llvm.cos.f64(x:wybe.float @float:116:47, ?tmp#0:wybe.float @float:116:22)} @float:116:22,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:116:5)} @float:116:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of cos:
Types: 
Types: cos > public (0 calls)
Types: 4: cos(x:wybe.float @float:116:13, ?#result:wybe.float @float:116:5):
Types:     foreign c llvm.cos.f64(x:wybe.float @float:116:47, ?tmp#0:wybe.float @float:116:22)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:116:5)
Types: Type checking non-recursive proc wybe.float.ceil
Types: ** Type checking decl of proc ceil
Types: found 1 definition(s)
Types: Type checking ceil
Types: ** Type checking ceil: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c llvm.ceil.f64(x @float:87:49, ?tmp#0 @float:87:23)
Types:         foreign llvm move(tmp#0, ?#result @float:87:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x"]
Types: Recording parameter types: x:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign c llvm.ceil.f64(x @float:87:49, ?tmp#0 @float:87:23)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:87:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:87:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:87:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:87:49
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:87:23
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign c call llvm.ceil.f64(64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:87:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc ceil
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt foreign c llvm.ceil.f64(x @float:87:49, ?tmp#0 @float:87:23)
Types: Mode checking foreign call {foreign c llvm.ceil.f64(x @float:87:49, ?tmp#0 @float:87:23)}
Types:     with assigned semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:87:49
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:87:23
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign c llvm.ceil.f64(x:wybe.float @float:87:49, ?tmp#0:wybe.float @float:87:23)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:87:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:87:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:87:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:87:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'ceil'
Types: Mode checked body   : [{foreign c llvm.ceil.f64(x:wybe.float @float:87:49, ?tmp#0:wybe.float @float:87:23)} @float:87:23,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:87:5)} @float:87:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of ceil:
Types: 
Types: ceil > public (0 calls)
Types: 4: ceil(x:wybe.float @float:87:14, ?#result:wybe.float @float:87:5):
Types:     foreign c llvm.ceil.f64(x:wybe.float @float:87:49, ?tmp#0:wybe.float @float:87:23)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:87:5)
Types: Type checking non-recursive proc wybe.float.iceil
Types: ** Type checking decl of proc iceil
Types: found 1 definition(s)
Types: Type checking iceil
Types: ** Type checking iceil: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         ceil(x @float:99:51, ?tmp#1 @float:99:46)
Types:         foreign llvm fptosi(tmp#1, ?tmp#0 @float:99:26)
Types:         foreign llvm move(tmp#0, ?#result @float:99:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","tmp#1","x"]
Types: Recording parameter types: x:wybe.float, ?#result:wybe.int
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {ceil(x @float:99:51, ?tmp#1 @float:99:46)}
Types: Recording casts in {foreign llvm fptosi(tmp#1, ?tmp#0 @float:99:26)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:99:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:99:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:99:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, tmp#0::0, x::wybe.float}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {ceil(x @float:99:51, ?tmp#1 @float:99:46)} @float:99:46, typingInfos = [wybe.float.ceil<0>(wybe.float,?wybe.float)]}Typing {#result::wybe.int, tmp#0::0, x::wybe.float}; {0::wybe.int} (with no errors)
Types: Type checking call {ceil(x @float:99:51, ?tmp#1 @float:99:46)} @float:99:46
Types: Candidate types:
Types:     wybe.float.ceil<0>(wybe.float,?wybe.float)
Types: Finding type of expr x @float:99:51
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#1 @float:99:46
Types:   Type = 1
Types: Actual types: [wybe.float,1]
Types: Matching types [wybe.float,1] with wybe.float.ceil<0>(wybe.float,?wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Valid types = [Typing {#result::wybe.int, tmp#0::0, tmp#1::1, x::wybe.float}; {0::wybe.int, 1::wybe.float} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, tmp#0::0, tmp#1::1, x::wybe.float}; {0::wybe.int, 1::wybe.float} (with no errors)
Types: Finding type of expr tmp#1
Types: Type variable 1 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:99:26
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call fptosi(64 bit float, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @float:99:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc iceil
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt ceil(x @float:99:51, ?tmp#1 @float:99:46)
Types: Mode checking call   : {ceil(x @float:99:51, ?tmp#1 @float:99:46)}
Types:     with assigned    : semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr x @float:99:51
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#1 @float:99:46
Types: Type variable 1 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.float,wybe.float] with wybe.float.ceil<0>(wybe.float,?wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type-correct modes   : [(wybe.float.ceil<0>(wybe.float,?wybe.float),Typing {#result::wybe.int, tmp#0::0, tmp#1::1, x::wybe.float}; {0::wybe.int, 1::wybe.float} (with no errors))]
Types: Possible mode matches: [(wybe.float.ceil<0>(wybe.float,?wybe.float),Typing {#result::wybe.int, tmp#0::0, tmp#1::1, x::wybe.float}; {0::wybe.int, 1::wybe.float} (with no errors))]
Types: Exact mode matches: [(wybe.float.ceil<0>(wybe.float,?wybe.float),Typing {#result::wybe.int, tmp#0::0, tmp#1::1, x::wybe.float}; {0::wybe.int, 1::wybe.float} (with no errors))]
Types: Finding type of expr x @float:99:51
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#1 @float:99:46
Types: Type variable 1 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finalising call    :  {wybe.float.<0>ceil(x:wybe.float @float:99:51, ?tmp#1:wybe.float @float:99:46)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.float.<0>ceil(x:wybe.float @float:99:51, ?tmp#1:wybe.float @float:99:46)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'iceil'
Types: Now assigned = semipure normal (total) computation binding {tmp#1, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fptosi(tmp#1, ?tmp#0 @float:99:26)
Types: Mode checking foreign call {foreign llvm fptosi(tmp#1, ?tmp#0 @float:99:26)}
Types:     with assigned semipure normal (total) computation binding {tmp#1, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#1
Types: Type variable 1 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:99:26
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.float,?wybe.int]
Types: New instr = {foreign llvm fptosi(tmp#1:wybe.float, ?tmp#0:wybe.int @float:99:26)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#1, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:99:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:99:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, tmp#1, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @float:99:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @float:99:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, tmp#1, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'iceil'
Types: Mode checked body   : [{wybe.float.<0>ceil(x:wybe.float @float:99:51, ?tmp#1:wybe.float @float:99:46)} @float:99:46,{foreign llvm fptosi(tmp#1:wybe.float, ?tmp#0:wybe.int @float:99:26)} @float:99:26,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @float:99:5)} @float:99:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, tmp#1, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of iceil:
Types: 
Types: iceil > public (0 calls)
Types: 4: iceil(x:wybe.float @float:99:15, ?#result:wybe.int @float:99:5):
Types:     wybe.float.<0>ceil(x:wybe.float @float:99:51, ?tmp#1:wybe.float @float:99:46)
Types:     foreign llvm fptosi(tmp#1:wybe.float, ?tmp#0:wybe.int @float:99:26)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @float:99:5)
Types: Type checking non-recursive proc wybe.float.abs
Types: ** Type checking decl of proc abs
Types: found 1 definition(s)
Types: Type checking abs
Types: ** Type checking abs: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c llvm.fabs.f64(x @float:60:48, ?tmp#0 @float:60:22)
Types:         foreign llvm move(tmp#0, ?#result @float:60:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x"]
Types: Recording parameter types: x:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign c llvm.fabs.f64(x @float:60:48, ?tmp#0 @float:60:22)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:60:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:60:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:60:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:60:48
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:60:22
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign c call llvm.fabs.f64(64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:60:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc abs
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt foreign c llvm.fabs.f64(x @float:60:48, ?tmp#0 @float:60:22)
Types: Mode checking foreign call {foreign c llvm.fabs.f64(x @float:60:48, ?tmp#0 @float:60:22)}
Types:     with assigned semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:60:48
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:60:22
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign c llvm.fabs.f64(x:wybe.float @float:60:48, ?tmp#0:wybe.float @float:60:22)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:60:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:60:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:60:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:60:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'abs'
Types: Mode checked body   : [{foreign c llvm.fabs.f64(x:wybe.float @float:60:48, ?tmp#0:wybe.float @float:60:22)} @float:60:22,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:60:5)} @float:60:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of abs:
Types: 
Types: abs > public (0 calls)
Types: 4: abs(x:wybe.float @float:60:13, ?#result:wybe.float @float:60:5):
Types:     foreign c llvm.fabs.f64(x:wybe.float @float:60:48, ?tmp#0:wybe.float @float:60:22)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:60:5)
Types: Type checking non-recursive proc wybe.float.>=
Types: ** Type checking decl of proc >=
Types: found 1 definition(s)
Types: Type checking >=
Types: ** Type checking >=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm fcmp_sge(x @float:73:52, y @float:73:54, ?tmp#0 @float:73:30)
Types:         foreign llvm move(tmp#0, ?#result @float:73:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.float, y:wybe.float, ?#result:wybe.bool
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm fcmp_sge(x @float:73:52, y @float:73:54, ?tmp#0 @float:73:30)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:73:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:73:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:73:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @float:73:52
Types:   Type = wybe.float
Types: Finding type of expr y @float:73:54
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:73:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call fcmp_sge(64 bit float, 64 bit float, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @float:73:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc >=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fcmp_sge(x @float:73:52, y @float:73:54, ?tmp#0 @float:73:30)
Types: Mode checking foreign call {foreign llvm fcmp_sge(x @float:73:52, y @float:73:54, ?tmp#0 @float:73:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:73:52
Types:   Type = wybe.float
Types: Finding type of expr y @float:73:54
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:73:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.float,wybe.float,?wybe.bool]
Types: New instr = {foreign llvm fcmp_sge(x:wybe.float @float:73:52, y:wybe.float @float:73:54, ?tmp#0:wybe.bool @float:73:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:73:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:73:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @float:73:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:73:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '>='
Types: Mode checked body   : [{foreign llvm fcmp_sge(x:wybe.float @float:73:52, y:wybe.float @float:73:54, ?tmp#0:wybe.bool @float:73:30)} @float:73:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:73:5)} @float:73:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of >=:
Types: 
Types: >= > public (0 calls)
Types: 4: >=(x:wybe.float @float:73:10, y:wybe.float @float:73:18, ?#result:wybe.bool @float:73:5):
Types:     foreign llvm fcmp_sge(x:wybe.float @float:73:52, y:wybe.float @float:73:54, ?tmp#0:wybe.bool @float:73:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:73:5)
Types: Type checking non-recursive proc wybe.float.>
Types: ** Type checking decl of proc >
Types: found 1 definition(s)
Types: Type checking >
Types: ** Type checking >: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm fcmp_sgt(x @float:72:51, y @float:72:53, ?tmp#0 @float:72:29)
Types:         foreign llvm move(tmp#0, ?#result @float:72:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.float, y:wybe.float, ?#result:wybe.bool
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm fcmp_sgt(x @float:72:51, y @float:72:53, ?tmp#0 @float:72:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:72:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:72:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:72:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @float:72:51
Types:   Type = wybe.float
Types: Finding type of expr y @float:72:53
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:72:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call fcmp_sgt(64 bit float, 64 bit float, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @float:72:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc >
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fcmp_sgt(x @float:72:51, y @float:72:53, ?tmp#0 @float:72:29)
Types: Mode checking foreign call {foreign llvm fcmp_sgt(x @float:72:51, y @float:72:53, ?tmp#0 @float:72:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:72:51
Types:   Type = wybe.float
Types: Finding type of expr y @float:72:53
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:72:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.float,wybe.float,?wybe.bool]
Types: New instr = {foreign llvm fcmp_sgt(x:wybe.float @float:72:51, y:wybe.float @float:72:53, ?tmp#0:wybe.bool @float:72:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:72:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:72:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @float:72:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:72:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '>'
Types: Mode checked body   : [{foreign llvm fcmp_sgt(x:wybe.float @float:72:51, y:wybe.float @float:72:53, ?tmp#0:wybe.bool @float:72:29)} @float:72:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:72:5)} @float:72:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of >:
Types: 
Types: > > public (0 calls)
Types: 4: >(x:wybe.float @float:72:10, y:wybe.float @float:72:17, ?#result:wybe.bool @float:72:5):
Types:     foreign llvm fcmp_sgt(x:wybe.float @float:72:51, y:wybe.float @float:72:53, ?tmp#0:wybe.bool @float:72:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:72:5)
Types: Type checking non-recursive proc wybe.float.=
Types: ** Type checking decl of proc =
Types: found 1 definition(s)
Types: Type checking =
Types: ** Type checking =: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm fcmp_eq(x @float:66:50, y @float:66:52, ?tmp#0 @float:66:29)
Types:         foreign llvm move(tmp#0, ?#result @float:66:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.float, y:wybe.float, ?#result:wybe.bool
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm fcmp_eq(x @float:66:50, y @float:66:52, ?tmp#0 @float:66:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:66:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:66:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:66:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @float:66:50
Types:   Type = wybe.float
Types: Finding type of expr y @float:66:52
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:66:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call fcmp_eq(64 bit float, 64 bit float, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @float:66:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc =
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fcmp_eq(x @float:66:50, y @float:66:52, ?tmp#0 @float:66:29)
Types: Mode checking foreign call {foreign llvm fcmp_eq(x @float:66:50, y @float:66:52, ?tmp#0 @float:66:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:66:50
Types:   Type = wybe.float
Types: Finding type of expr y @float:66:52
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:66:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.float,wybe.float,?wybe.bool]
Types: New instr = {foreign llvm fcmp_eq(x:wybe.float @float:66:50, y:wybe.float @float:66:52, ?tmp#0:wybe.bool @float:66:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:66:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:66:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @float:66:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:66:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '='
Types: Mode checked body   : [{foreign llvm fcmp_eq(x:wybe.float @float:66:50, y:wybe.float @float:66:52, ?tmp#0:wybe.bool @float:66:29)} @float:66:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:66:5)} @float:66:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of =:
Types: 
Types: = > public (0 calls)
Types: 4: =(x:wybe.float @float:66:10, y:wybe.float @float:66:17, ?#result:wybe.bool @float:66:5):
Types:     foreign llvm fcmp_eq(x:wybe.float @float:66:50, y:wybe.float @float:66:52, ?tmp#0:wybe.bool @float:66:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:66:5)
Types: Type checking non-recursive proc wybe.float.<=
Types: ** Type checking decl of proc <=
Types: found 1 definition(s)
Types: Type checking <=
Types: ** Type checking <=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm fcmp_sle(x @float:71:52, y @float:71:54, ?tmp#0 @float:71:30)
Types:         foreign llvm move(tmp#0, ?#result @float:71:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.float, y:wybe.float, ?#result:wybe.bool
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm fcmp_sle(x @float:71:52, y @float:71:54, ?tmp#0 @float:71:30)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:71:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:71:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:71:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @float:71:52
Types:   Type = wybe.float
Types: Finding type of expr y @float:71:54
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:71:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call fcmp_sle(64 bit float, 64 bit float, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @float:71:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc <=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fcmp_sle(x @float:71:52, y @float:71:54, ?tmp#0 @float:71:30)
Types: Mode checking foreign call {foreign llvm fcmp_sle(x @float:71:52, y @float:71:54, ?tmp#0 @float:71:30)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:71:52
Types:   Type = wybe.float
Types: Finding type of expr y @float:71:54
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:71:30
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.float,wybe.float,?wybe.bool]
Types: New instr = {foreign llvm fcmp_sle(x:wybe.float @float:71:52, y:wybe.float @float:71:54, ?tmp#0:wybe.bool @float:71:30)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:71:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:71:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @float:71:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:71:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<='
Types: Mode checked body   : [{foreign llvm fcmp_sle(x:wybe.float @float:71:52, y:wybe.float @float:71:54, ?tmp#0:wybe.bool @float:71:30)} @float:71:30,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:71:5)} @float:71:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <=:
Types: 
Types: <= > public (0 calls)
Types: 4: <=(x:wybe.float @float:71:10, y:wybe.float @float:71:18, ?#result:wybe.bool @float:71:5):
Types:     foreign llvm fcmp_sle(x:wybe.float @float:71:52, y:wybe.float @float:71:54, ?tmp#0:wybe.bool @float:71:30)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:71:5)
Types: Type checking non-recursive proc wybe.float.<
Types: ** Type checking decl of proc <
Types: found 1 definition(s)
Types: Type checking <
Types: ** Type checking <: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm fcmp_slt(x @float:70:51, y @float:70:53, ?tmp#0 @float:70:29)
Types:         foreign llvm move(tmp#0, ?#result @float:70:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.float, y:wybe.float, ?#result:wybe.bool
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {foreign llvm fcmp_slt(x @float:70:51, y @float:70:53, ?tmp#0 @float:70:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:70:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:70:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:70:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.bool, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.bool} (with no errors)
Types: Finding type of expr x @float:70:51
Types:   Type = wybe.float
Types: Finding type of expr y @float:70:53
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:70:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call fcmp_slt(64 bit float, 64 bit float, 1 bit unsigned)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @float:70:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc <
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fcmp_slt(x @float:70:51, y @float:70:53, ?tmp#0 @float:70:29)
Types: Mode checking foreign call {foreign llvm fcmp_slt(x @float:70:51, y @float:70:53, ?tmp#0 @float:70:29)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:70:51
Types:   Type = wybe.float
Types: Finding type of expr y @float:70:53
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:70:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.float,wybe.float,?wybe.bool]
Types: New instr = {foreign llvm fcmp_slt(x:wybe.float @float:70:51, y:wybe.float @float:70:53, ?tmp#0:wybe.bool @float:70:29)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:70:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:70:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @float:70:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:70:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<'
Types: Mode checked body   : [{foreign llvm fcmp_slt(x:wybe.float @float:70:51, y:wybe.float @float:70:53, ?tmp#0:wybe.bool @float:70:29)} @float:70:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:70:5)} @float:70:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <:
Types: 
Types: < > public (0 calls)
Types: 4: <(x:wybe.float @float:70:10, y:wybe.float @float:70:17, ?#result:wybe.bool @float:70:5):
Types:     foreign llvm fcmp_slt(x:wybe.float @float:70:51, y:wybe.float @float:70:53, ?tmp#0:wybe.bool @float:70:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:70:5)
Types: Type checking non-recursive proc wybe.float.<=>
Types: ** Type checking decl of proc <=>
Types: found 1 definition(s)
Types: Type checking <=>
Types: ** Type checking <=>: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         <(x @float:77:10, y @float:77:14)
Types:         lesser(?tmp#1 @float:77:19)
Types:         foreign llvm move(tmp#1, ?tmp#0)
Types:         =(x @float:77:28, y @float:77:32)
Types:         equal(?tmp#3 @float:77:37)
Types:         foreign llvm move(tmp#3, ?tmp#2)
Types:         greater(?tmp#4 @float:77:53)
Types:         foreign llvm move(tmp#4, ?tmp#2)
Types:         foreign llvm move(tmp#2 @float:77:28, ?tmp#0)
Types:         foreign llvm move(tmp#0 @float:77:10, ?#result @float:76:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","tmp#1","tmp#2","tmp#3","tmp#4","x","y"]
Types: Recording parameter types: x:wybe.float, y:wybe.float, ?#result:wybe.comparison
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types:     type of '#result' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable #result type constrained to wybe.comparison
Types: Recording resource types: 
Types: Recording casts in {<(x @float:77:10, y @float:77:14)}
Types: Recording casts in {lesser(?tmp#1 @float:77:19)}
Types: Recording casts in {foreign llvm move(tmp#1, ?tmp#0)}
Types: Unifying move argument types tmp#1 and ?tmp#0
Types: Finding type of expr tmp#1
Types:   Type = 0
Types: Finding type of expr ?tmp#0
Types:   Type = 1
Types: Type variable 0 is bound to Nothing
Types: Type variable 1 is bound to Nothing
Types: Unifying types 0 (-> 0) and 1 (-> 1)
Types:   Unification yields 0
Types: Recording casts in {=(x @float:77:28, y @float:77:32)}
Types: Recording casts in {equal(?tmp#3 @float:77:37)}
Types: Recording casts in {foreign llvm move(tmp#3, ?tmp#2)}
Types: Unifying move argument types tmp#3 and ?tmp#2
Types: Finding type of expr tmp#3
Types:   Type = 2
Types: Finding type of expr ?tmp#2
Types:   Type = 3
Types: Type variable 2 is bound to Nothing
Types: Type variable 3 is bound to Nothing
Types: Unifying types 2 (-> 2) and 3 (-> 3)
Types:   Unification yields 2
Types: Recording casts in {greater(?tmp#4 @float:77:53)}
Types: Recording casts in {foreign llvm move(tmp#4, ?tmp#2)}
Types: Unifying move argument types tmp#4 and ?tmp#2
Types: Finding type of expr tmp#4
Types:   Type = 4
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Nothing
Types:   Type = 2
Types: Type variable 4 is bound to Nothing
Types: Type variable 2 is bound to Nothing
Types: Unifying types 4 (-> 4) and 2 (-> 2)
Types:   Unification yields 2
Types: Recording casts in {foreign llvm move(tmp#2 @float:77:28, ?tmp#0)}
Types: Unifying move argument types tmp#2 @float:77:28 and ?tmp#0
Types: Finding type of expr tmp#2 @float:77:28
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Nothing
Types:   Type = 2
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Nothing
Types:   Type = 0
Types: Type variable 2 is bound to Nothing
Types: Type variable 0 is bound to Nothing
Types: Unifying types 2 (-> 2) and 0 (-> 0)
Types:   Unification yields 0
Types: Recording casts in {foreign llvm move(tmp#0 @float:77:10, ?#result @float:76:5)}
Types: Unifying move argument types tmp#0 @float:77:10 and ?#result @float:76:5
Types: Finding type of expr tmp#0 @float:77:10
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Nothing
Types:   Type = 0
Types: Finding type of expr ?#result @float:76:5
Types:   Type = wybe.comparison
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: *** Before calls Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {<(x @float:77:10, y @float:77:14)} @float:77:10, typingInfos = [wybe.comparison.<<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.float.<<0>(wybe.float,wybe.float,?wybe.bool),wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {lesser(?tmp#1 @float:77:19)} @float:77:19, typingInfos = [wybe.comparison.lesser<0>(?wybe.comparison)]}
Types:     StmtTypings {typingStmt = {=(x @float:77:28, y @float:77:32)} @float:77:28, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {equal(?tmp#3 @float:77:37)} @float:77:37, typingInfos = [wybe.comparison.equal<0>(?wybe.comparison)]}
Types:     StmtTypings {typingStmt = {greater(?tmp#4 @float:77:53)} @float:77:53, typingInfos = [wybe.comparison.greater<0>(?wybe.comparison)]}Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {<(x @float:77:10, y @float:77:14)} @float:77:10
Types: Candidate types:
Types:     wybe.comparison.<<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.float.<<0>(wybe.float,wybe.float,?wybe.bool)
Types:     wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr x @float:77:10
Types:   Type = wybe.float
Types: Finding type of expr y @float:77:14
Types:   Type = wybe.float
Types: Actual types: [wybe.float,wybe.float]
Types: Matching types [wybe.float,wybe.float] with {test} wybe.comparison.<<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 10): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 10): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.float.<<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float] with {test} wybe.int.<<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 10): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 10): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {lesser(?tmp#1 @float:77:19)} @float:77:19
Types: Candidate types:
Types:     wybe.comparison.lesser<0>(?wybe.comparison)
Types: Finding type of expr ?tmp#1 @float:77:19
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Actual types: [wybe.comparison]
Types: Matching types [wybe.comparison] with wybe.comparison.lesser<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {=(x @float:77:28, y @float:77:32)} @float:77:28
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr x @float:77:28
Types:   Type = wybe.float
Types: Finding type of expr y @float:77:32
Types:   Type = wybe.float
Types: Actual types: [wybe.float,wybe.float]
Types: Matching types [wybe.float,wybe.float] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {equal(?tmp#3 @float:77:37)} @float:77:37
Types: Candidate types:
Types:     wybe.comparison.equal<0>(?wybe.comparison)
Types: Finding type of expr ?tmp#3 @float:77:37
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Actual types: [wybe.comparison]
Types: Matching types [wybe.comparison] with wybe.comparison.equal<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Type checking call {greater(?tmp#4 @float:77:53)} @float:77:53
Types: Candidate types:
Types:     wybe.comparison.greater<0>(?wybe.comparison)
Types: Finding type of expr ?tmp#4 @float:77:53
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Actual types: [wybe.comparison]
Types: Matching types [wybe.comparison] with wybe.comparison.greater<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Valid types = [Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors)
Types: Finding type of expr tmp#1
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Finding type of expr tmp#3
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Finding type of expr tmp#4
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Finding type of expr tmp#2 @float:77:28
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Finding type of expr tmp#0 @float:77:10
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?#result @float:76:5
Types:   Type = wybe.comparison
Types: Type checking foreign llvm call move(2 bit unsigned, 2 bit unsigned)
Types: Now mode checking proc <=>
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt if {<(x @float:77:10, y @float:77:14)::
Types: 
Types:                     lesser(?tmp#1 @float:77:19)
Types:                     foreign llvm move(tmp#1, ?tmp#0)
Types:                 else::
Types:                     if {=(x @float:77:28, y @float:77:32)::
Types: 
Types:                         equal(?tmp#3 @float:77:37)
Types:                         foreign llvm move(tmp#3, ?tmp#2)
Types:                     else::
Types:                         greater(?tmp#4 @float:77:53)
Types:                         foreign llvm move(tmp#4, ?tmp#2)
Types: 
Types:                     }
Types:                     foreign llvm move(tmp#2 @float:77:28, ?tmp#0)
Types: 
Types:                 }
Types: Mode checking conditional {if {<(x @float:77:10, y @float:77:14)::
Types: 
Types:         lesser(?tmp#1 @float:77:19)
Types:         foreign llvm move(tmp#1, ?tmp#0)
Types:     else::
Types:         if {=(x @float:77:28, y @float:77:32)::
Types: 
Types:             equal(?tmp#3 @float:77:37)
Types:             foreign llvm move(tmp#3, ?tmp#2)
Types:         else::
Types:             greater(?tmp#4 @float:77:53)
Types:             foreign llvm move(tmp#4, ?tmp#2)
Types: 
Types:         }
Types:         foreign llvm move(tmp#2 @float:77:28, ?tmp#0)
Types: 
Types:     }}
Types: Mode checking call   : {<(x @float:77:10, y @float:77:14)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Finding type of expr x @float:77:10
Types:   Type = wybe.float
Types: Finding type of expr y @float:77:14
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.float,wybe.float] with {test} wybe.comparison.<<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 10): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 10): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.float.<<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float] with {test} wybe.int.<<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 10): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 10): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.float.<<0>(wybe.float,wybe.float),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [({test} wybe.float.<<0>(wybe.float,wybe.float),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [({test} wybe.float.<<0>(wybe.float,wybe.float),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr x @float:77:10
Types:   Type = wybe.float
Types: Finding type of expr y @float:77:14
Types:   Type = wybe.float
Types: Finalising call    :  {wybe.float.<0><(x:wybe.float @float:77:10, y:wybe.float @float:77:14)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.float.<0><(x:wybe.float @float:77:10, y:wybe.float @float:77:14)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '<=>'
Types: Assigned by test: semipure test computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt lesser(?tmp#1 @float:77:19)
Types: Mode checking call   : {lesser(?tmp#1 @float:77:19)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr ?tmp#1 @float:77:19
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     actual types     : [wybe.comparison]
Types:     actual modes     : [(ParamOut,False,Nothing)]
Types: Matching types [wybe.comparison] with wybe.comparison.lesser<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Type-correct modes   : [(wybe.comparison.lesser<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [(wybe.comparison.lesser<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [(wybe.comparison.lesser<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr ?tmp#1 @float:77:19
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finalising call    :  {wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @float:77:19)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @float:77:19)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<=>'
Types: Now assigned = semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#1, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(tmp#1, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#1
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#1:wybe.comparison, ?tmp#0:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Assigned by then branch: semipure normal (total) computation binding {tmp#0, tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt if {=(x @float:77:28, y @float:77:32)::
Types: 
Types:                     equal(?tmp#3 @float:77:37)
Types:                     foreign llvm move(tmp#3, ?tmp#2)
Types:                 else::
Types:                     greater(?tmp#4 @float:77:53)
Types:                     foreign llvm move(tmp#4, ?tmp#2)
Types: 
Types:                 }
Types: Mode checking conditional {if {=(x @float:77:28, y @float:77:32)::
Types: 
Types:         equal(?tmp#3 @float:77:37)
Types:         foreign llvm move(tmp#3, ?tmp#2)
Types:     else::
Types:         greater(?tmp#4 @float:77:53)
Types:         foreign llvm move(tmp#4, ?tmp#2)
Types: 
Types:     }}
Types: Mode checking call   : {=(x @float:77:28, y @float:77:32)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Finding type of expr x @float:77:28
Types:   Type = wybe.float
Types: Finding type of expr y @float:77:32
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.float,wybe.float] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 28): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 77, column 28): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.float.=<0>(wybe.float,wybe.float),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [({test} wybe.float.=<0>(wybe.float,wybe.float),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [({test} wybe.float.=<0>(wybe.float,wybe.float),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr x @float:77:28
Types:   Type = wybe.float
Types: Finding type of expr y @float:77:32
Types:   Type = wybe.float
Types: Finalising call    :  {wybe.float.<0>=(x:wybe.float @float:77:28, y:wybe.float @float:77:32)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.float.<0>=(x:wybe.float @float:77:28, y:wybe.float @float:77:32)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '<=>'
Types: Assigned by test: semipure test computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt equal(?tmp#3 @float:77:37)
Types: Mode checking call   : {equal(?tmp#3 @float:77:37)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp ?tmp#3
Types: Mode check exp resulted in ?tmp#3
Types: Finding type of expr ?tmp#3 @float:77:37
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     actual types     : [wybe.comparison]
Types:     actual modes     : [(ParamOut,False,Nothing)]
Types: Matching types [wybe.comparison] with wybe.comparison.equal<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Type-correct modes   : [(wybe.comparison.equal<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [(wybe.comparison.equal<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [(wybe.comparison.equal<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr ?tmp#3 @float:77:37
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finalising call    :  {wybe.comparison.<0>equal(?tmp#3:wybe.comparison @float:77:37)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.comparison.<0>equal(?tmp#3:wybe.comparison @float:77:37)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<=>'
Types: Now assigned = semipure normal (total) computation binding {tmp#3, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#3, ?tmp#2)
Types: Mode checking foreign call {foreign llvm move(tmp#3, ?tmp#2)}
Types:     with assigned semipure normal (total) computation binding {tmp#3, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#3
Types: Mode check exp resulted in tmp#3
Types: Mode check exp ?tmp#2
Types: Mode check exp resulted in ?tmp#2
Types: Finding type of expr tmp#3
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#3:wybe.comparison, ?tmp#2:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {tmp#2, tmp#3, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Assigned by then branch: semipure normal (total) computation binding {tmp#2, tmp#3, x, y}, break set = Everything, with resources {}
Types: Mode check stmt greater(?tmp#4 @float:77:53)
Types: Mode checking call   : {greater(?tmp#4 @float:77:53)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp ?tmp#4
Types: Mode check exp resulted in ?tmp#4
Types: Finding type of expr ?tmp#4 @float:77:53
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     actual types     : [wybe.comparison]
Types:     actual modes     : [(ParamOut,False,Nothing)]
Types: Matching types [wybe.comparison] with wybe.comparison.greater<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Type-correct modes   : [(wybe.comparison.greater<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Possible mode matches: [(wybe.comparison.greater<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Exact mode matches: [(wybe.comparison.greater<0>(?wybe.comparison),Typing {#result::wybe.comparison, tmp#0::1, tmp#1::0, tmp#2::3, tmp#3::2, tmp#4::4, x::wybe.float, y::wybe.float}; {0::wybe.comparison, 1::0, 2::0, 3::2, 4::2} (with no errors))]
Types: Finding type of expr ?tmp#4 @float:77:53
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finalising call    :  {wybe.comparison.<0>greater(?tmp#4:wybe.comparison @float:77:53)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.comparison.<0>greater(?tmp#4:wybe.comparison @float:77:53)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<=>'
Types: Now assigned = semipure normal (total) computation binding {tmp#4, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#4, ?tmp#2)
Types: Mode checking foreign call {foreign llvm move(tmp#4, ?tmp#2)}
Types:     with assigned semipure normal (total) computation binding {tmp#4, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#4
Types: Mode check exp resulted in tmp#4
Types: Mode check exp ?tmp#2
Types: Mode check exp resulted in ?tmp#2
Types: Finding type of expr tmp#4
Types: Type variable 4 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#4:wybe.comparison, ?tmp#2:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {tmp#2, tmp#4, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Assigned by else branch: semipure normal (total) computation binding {tmp#2, tmp#4, x, y}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {tmp#2, x, y}, break set = Everything, with resources {}
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types: Now assigned = semipure normal (total) computation binding {tmp#2, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#2 @float:77:28, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(tmp#2 @float:77:28, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {tmp#2, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#2
Types: Mode check exp resulted in tmp#2
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#2 @float:77:28
Types: Type variable 3 is bound to Just 2
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#2:wybe.comparison @float:77:28, ?tmp#0:wybe.comparison)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#2, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Assigned by else branch: semipure normal (total) computation binding {tmp#0, tmp#2, x, y}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0 @float:77:10, ?#result @float:76:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0 @float:77:10, ?#result @float:76:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0 @float:77:10
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?#result @float:76:5
Types:   Type = wybe.comparison
Types:     types and modes = [wybe.comparison,?wybe.comparison]
Types: New instr = {foreign llvm move(tmp#0:wybe.comparison @float:77:10, ?#result:wybe.comparison @float:76:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<=>'
Types: Mode checked body   : [{if {wybe.float.<0><(x:wybe.float @float:77:10, y:wybe.float @float:77:14)::
Types: 
Types:         wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @float:77:19)
Types:         foreign llvm move(tmp#1:wybe.comparison, ?tmp#0:wybe.comparison)
Types:     else::
Types:         if {wybe.float.<0>=(x:wybe.float @float:77:28, y:wybe.float @float:77:32)::
Types: 
Types:             wybe.comparison.<0>equal(?tmp#3:wybe.comparison @float:77:37)
Types:             foreign llvm move(tmp#3:wybe.comparison, ?tmp#2:wybe.comparison)
Types:         else::
Types:             wybe.comparison.<0>greater(?tmp#4:wybe.comparison @float:77:53)
Types:             foreign llvm move(tmp#4:wybe.comparison, ?tmp#2:wybe.comparison)
Types: 
Types:         }
Types:    condition -> {x::wybe.float, y::wybe.float}
Types:    then&else -> {tmp#2::wybe.comparison, x::wybe.float, y::wybe.float}
Types:         foreign llvm move(tmp#2:wybe.comparison @float:77:28, ?tmp#0:wybe.comparison)
Types: 
Types:     }
Types:    condition -> {x::wybe.float, y::wybe.float}
Types:    then&else -> {tmp#0::wybe.comparison, x::wybe.float, y::wybe.float}} @float:77:10,{foreign llvm move(tmp#0:wybe.comparison @float:77:10, ?#result:wybe.comparison @float:76:5)} @float:76:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <=>:
Types: 
Types: <=> > public (0 calls)
Types: 4: <=>(x:wybe.float @float:76:10, y:wybe.float @float:76:20, ?#result:wybe.comparison @float:76:5):
Types:     if {wybe.float.<0><(x:wybe.float @float:77:10, y:wybe.float @float:77:14)::
Types: 
Types:         wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @float:77:19)
Types:         foreign llvm move(tmp#1:wybe.comparison, ?tmp#0:wybe.comparison)
Types:     else::
Types:         if {wybe.float.<0>=(x:wybe.float @float:77:28, y:wybe.float @float:77:32)::
Types: 
Types:             wybe.comparison.<0>equal(?tmp#3:wybe.comparison @float:77:37)
Types:             foreign llvm move(tmp#3:wybe.comparison, ?tmp#2:wybe.comparison)
Types:         else::
Types:             wybe.comparison.<0>greater(?tmp#4:wybe.comparison @float:77:53)
Types:             foreign llvm move(tmp#4:wybe.comparison, ?tmp#2:wybe.comparison)
Types: 
Types:         }
Types:    condition -> {x::wybe.float, y::wybe.float}
Types:    then&else -> {tmp#2::wybe.comparison, x::wybe.float, y::wybe.float}
Types:         foreign llvm move(tmp#2:wybe.comparison @float:77:28, ?tmp#0:wybe.comparison)
Types: 
Types:     }
Types:    condition -> {x::wybe.float, y::wybe.float}
Types:    then&else -> {tmp#0::wybe.comparison, x::wybe.float, y::wybe.float}
Types:     foreign llvm move(tmp#0:wybe.comparison @float:77:10, ?#result:wybe.comparison @float:76:5)
Types: Type checking non-recursive proc wybe.float./
Types: ** Type checking decl of proc /
Types: found 1 definition(s)
Types: Type checking /
Types: ** Type checking /: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm fdiv(x @float:51:43, y @float:51:45, ?tmp#0 @float:51:25)
Types:         foreign llvm move(tmp#0, ?#result @float:51:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.float, y:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign llvm fdiv(x @float:51:43, y @float:51:45, ?tmp#0 @float:51:25)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:51:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:51:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:51:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:51:43
Types:   Type = wybe.float
Types: Finding type of expr y @float:51:45
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:51:25
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign llvm call fdiv(64 bit float, 64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:51:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc /
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fdiv(x @float:51:43, y @float:51:45, ?tmp#0 @float:51:25)
Types: Mode checking foreign call {foreign llvm fdiv(x @float:51:43, y @float:51:45, ?tmp#0 @float:51:25)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:51:43
Types:   Type = wybe.float
Types: Finding type of expr y @float:51:45
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:51:25
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,wybe.float,?wybe.float]
Types: New instr = {foreign llvm fdiv(x:wybe.float @float:51:43, y:wybe.float @float:51:45, ?tmp#0:wybe.float @float:51:25)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:51:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:51:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:51:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:51:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '/'
Types: Mode checked body   : [{foreign llvm fdiv(x:wybe.float @float:51:43, y:wybe.float @float:51:45, ?tmp#0:wybe.float @float:51:25)} @float:51:25,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:51:5)} @float:51:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of /:
Types: 
Types: / > public (0 calls)
Types: 4: /(x:wybe.float @float:51:10, y:wybe.float @float:51:16, ?#result:wybe.float @float:51:5):
Types:     foreign llvm fdiv(x:wybe.float @float:51:43, y:wybe.float @float:51:45, ?tmp#0:wybe.float @float:51:25)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:51:5)
Types: Type checking non-recursive proc wybe.float./=
Types: ** Type checking decl of proc /=
Types: found 1 definition(s)
Types: Type checking /=
Types: ** Type checking /=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         /(x @float:54:31, y @float:54:35, ?tmp#0 @float:54:31)
Types:         =(?x @float:54:27, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y"]
Types: Recording parameter types: !x:wybe.float, y:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {/(x @float:54:31, y @float:54:35, ?tmp#0 @float:54:31)}
Types: Recording casts in {=(?x @float:54:27, tmp#0)}
Types: *** Before calls Typing {x::wybe.float, y::wybe.float}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {/(x @float:54:31, y @float:54:35, ?tmp#0 @float:54:31)} @float:54:31, typingInfos = [wybe.float./<0>(wybe.float,wybe.float,?wybe.float),wybe.int./<0>(wybe.int,wybe.int,?wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?x @float:54:27, tmp#0)} @float:54:27, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.float, y::wybe.float}; {} (with no errors)
Types: Type checking call {/(x @float:54:31, y @float:54:35, ?tmp#0 @float:54:31)} @float:54:31
Types: Candidate types:
Types:     wybe.float./<0>(wybe.float,wybe.float,?wybe.float)
Types:     wybe.int./<0>(wybe.int,wybe.int,?wybe.int)
Types: Finding type of expr x @float:54:31
Types:   Type = wybe.float
Types: Finding type of expr y @float:54:35
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:54:31
Types:   Type = 0
Types: Actual types: [wybe.float,wybe.float,0]
Types: Matching types [wybe.float,wybe.float,0] with wybe.float./<0>(wybe.float,wybe.float,?wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float,0] with wybe.int./<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 54, column 31): Type error in call to /, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 54, column 31): Type error in call to /, argument 2]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types: Type checking call {=(?x @float:54:27, tmp#0)} @float:54:27
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @float:54:27
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Actual types: [wybe.float,wybe.float]
Types: Matching types [wybe.float,wybe.float] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 54, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 54, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 54, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 54, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 54, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 54, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types: Now mode checking proc /=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt /(x @float:54:31, y @float:54:35, ?tmp#0 @float:54:31)
Types: Mode checking call   : {/(x @float:54:31, y @float:54:35, ?tmp#0 @float:54:31)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:54:31
Types:   Type = wybe.float
Types: Finding type of expr y @float:54:35
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:54:31
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float,wybe.float]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.float./<0>(wybe.float,wybe.float,?wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.int./<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 54, column 31): Type error in call to /, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 54, column 31): Type error in call to /, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 54, column 31): Type error in call to /, argument 3]
Types:   Unification yields XXX
Types: Type-correct modes   : [(wybe.float./<0>(wybe.float,wybe.float,?wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors))]
Types: Possible mode matches: [(wybe.float./<0>(wybe.float,wybe.float,?wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors))]
Types: Exact mode matches: [(wybe.float./<0>(wybe.float,wybe.float,?wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors))]
Types: Finding type of expr x @float:54:31
Types:   Type = wybe.float
Types: Finding type of expr y @float:54:35
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:54:31
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finalising call    :  {wybe.float.<0>/(x:wybe.float @float:54:31, y:wybe.float @float:54:35, ?tmp#0:wybe.float @float:54:31)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.float.<0>/(x:wybe.float @float:54:31, y:wybe.float @float:54:35, ?tmp#0:wybe.float @float:54:31)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '/='
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @float:54:27, tmp#0)
Types: Mode checking call   : {=(?x @float:54:27, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @float:54:27
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.float,wybe.float] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 54, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 54, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 54, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 54, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 54, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 54, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.float.=<0>(wybe.float,wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @float:54:27)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?x @float:54:27
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:54:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '/='
Types: Mode checked body   : [{wybe.float.<0>/(x:wybe.float @float:54:31, y:wybe.float @float:54:35, ?tmp#0:wybe.float @float:54:31)} @float:54:31,{foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:54:27)} @float:54:27]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of /=:
Types: 
Types: /= > public (0 calls)
Types: 4: /=(!x:wybe.float @float:54:11, y:wybe.float @float:54:19):
Types:     wybe.float.<0>/(x:wybe.float @float:54:31, y:wybe.float @float:54:35, ?tmp#0:wybe.float @float:54:31)
Types:     foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:54:27)
Types: Type checking non-recursive proc wybe.float.tan
Types: ** Type checking decl of proc tan
Types: found 1 definition(s)
Types: Type checking tan
Types: ** Type checking tan: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c llvm.sin.f64(x @float:117:47, ?tmp#1 @float:117:22)
Types:         foreign c llvm.cos.f64(x @float:117:77, ?tmp#2 @float:117:52)
Types:         /(tmp#1, tmp#2, ?tmp#0 @float:117:22)
Types:         foreign llvm move(tmp#0, ?#result @float:117:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","tmp#1","tmp#2","x"]
Types: Recording parameter types: x:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign c llvm.sin.f64(x @float:117:47, ?tmp#1 @float:117:22)}
Types: Recording casts in {foreign c llvm.cos.f64(x @float:117:77, ?tmp#2 @float:117:52)}
Types: Recording casts in {/(tmp#1, tmp#2, ?tmp#0 @float:117:22)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:117:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:117:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:117:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {/(tmp#1, tmp#2, ?tmp#0 @float:117:22)} @float:117:22, typingInfos = [wybe.float./<0>(wybe.float,wybe.float,?wybe.float),wybe.int./<0>(wybe.int,wybe.int,?wybe.int)]}Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types: Type checking call {/(tmp#1, tmp#2, ?tmp#0 @float:117:22)} @float:117:22
Types: Candidate types:
Types:     wybe.float./<0>(wybe.float,wybe.float,?wybe.float)
Types:     wybe.int./<0>(wybe.int,wybe.int,?wybe.int)
Types: Finding type of expr tmp#1
Types:   Type = 1
Types: Finding type of expr tmp#2
Types:   Type = 2
Types: Finding type of expr ?tmp#0 @float:117:22
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Actual types: [1,2,wybe.float]
Types: Matching types [1,2,wybe.float] with wybe.float./<0>(wybe.float,wybe.float,?wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type variable 2 is bound to Nothing
Types: Unifying types 2 (-> 2) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [1,2,wybe.float] with wybe.int./<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 2 is bound to Nothing
Types: Unifying types 2 (-> 2) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 117, column 22): Type error in call to /, argument 3]
Types:   Unification yields XXX
Types: Valid types = [Typing {#result::wybe.float, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.float}; {0::wybe.float, 1::wybe.float, 2::wybe.float} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.float, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.float}; {0::wybe.float, 1::wybe.float, 2::wybe.float} (with no errors)
Types: Finding type of expr x @float:117:47
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#1 @float:117:22
Types: Type variable 1 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign c call llvm.sin.f64(64 bit float, 64 bit float)
Types: Finding type of expr x @float:117:77
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#2 @float:117:52
Types: Type variable 2 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign c call llvm.cos.f64(64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:117:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc tan
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt foreign c llvm.sin.f64(x @float:117:47, ?tmp#1 @float:117:22)
Types: Mode checking foreign call {foreign c llvm.sin.f64(x @float:117:47, ?tmp#1 @float:117:22)}
Types:     with assigned semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr x @float:117:47
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#1 @float:117:22
Types: Type variable 1 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign c llvm.sin.f64(x:wybe.float @float:117:47, ?tmp#1:wybe.float @float:117:22)}
Types: Now assigned = semipure normal (total) computation binding {tmp#1, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign c llvm.cos.f64(x @float:117:77, ?tmp#2 @float:117:52)
Types: Mode checking foreign call {foreign c llvm.cos.f64(x @float:117:77, ?tmp#2 @float:117:52)}
Types:     with assigned semipure normal (total) computation binding {tmp#1, x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#2
Types: Mode check exp resulted in ?tmp#2
Types: Finding type of expr x @float:117:77
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#2 @float:117:52
Types: Type variable 2 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign c llvm.cos.f64(x:wybe.float @float:117:77, ?tmp#2:wybe.float @float:117:52)}
Types: Now assigned = semipure normal (total) computation binding {tmp#1, tmp#2, x}, break set = Everything, with resources {}
Types: Mode check stmt /(tmp#1, tmp#2, ?tmp#0 @float:117:22)
Types: Mode checking call   : {/(tmp#1, tmp#2, ?tmp#0 @float:117:22)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#1, tmp#2, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp tmp#2
Types: Mode check exp resulted in tmp#2
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#1
Types: Type variable 1 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr tmp#2
Types: Type variable 2 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:117:22
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float,wybe.float]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.float./<0>(wybe.float,wybe.float,?wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.int./<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 117, column 22): Type error in call to /, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 117, column 22): Type error in call to /, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 117, column 22): Type error in call to /, argument 3]
Types:   Unification yields XXX
Types: Type-correct modes   : [(wybe.float./<0>(wybe.float,wybe.float,?wybe.float),Typing {#result::wybe.float, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.float}; {0::wybe.float, 1::wybe.float, 2::wybe.float} (with no errors))]
Types: Possible mode matches: [(wybe.float./<0>(wybe.float,wybe.float,?wybe.float),Typing {#result::wybe.float, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.float}; {0::wybe.float, 1::wybe.float, 2::wybe.float} (with no errors))]
Types: Exact mode matches: [(wybe.float./<0>(wybe.float,wybe.float,?wybe.float),Typing {#result::wybe.float, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.float}; {0::wybe.float, 1::wybe.float, 2::wybe.float} (with no errors))]
Types: Finding type of expr tmp#1
Types: Type variable 1 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr tmp#2
Types: Type variable 2 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:117:22
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finalising call    :  {wybe.float.<0>/(tmp#1:wybe.float, tmp#2:wybe.float, ?tmp#0:wybe.float @float:117:22)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"tmp#1", "tmp#2", "x"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.float.<0>/(tmp#1:wybe.float, tmp#2:wybe.float, ?tmp#0:wybe.float @float:117:22)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'tan'
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#1, tmp#2, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:117:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:117:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, tmp#1, tmp#2, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:117:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:117:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, tmp#1, tmp#2, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'tan'
Types: Mode checked body   : [{foreign c llvm.sin.f64(x:wybe.float @float:117:47, ?tmp#1:wybe.float @float:117:22)} @float:117:22,{foreign c llvm.cos.f64(x:wybe.float @float:117:77, ?tmp#2:wybe.float @float:117:52)} @float:117:52,{wybe.float.<0>/(tmp#1:wybe.float, tmp#2:wybe.float, ?tmp#0:wybe.float @float:117:22)} @float:117:22,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:117:5)} @float:117:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, tmp#1, tmp#2, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of tan:
Types: 
Types: tan > public (0 calls)
Types: 4: tan(x:wybe.float @float:117:13, ?#result:wybe.float @float:117:5):
Types:     foreign c llvm.sin.f64(x:wybe.float @float:117:47, ?tmp#1:wybe.float @float:117:22)
Types:     foreign c llvm.cos.f64(x:wybe.float @float:117:77, ?tmp#2:wybe.float @float:117:52)
Types:     wybe.float.<0>/(tmp#1:wybe.float, tmp#2:wybe.float, ?tmp#0:wybe.float @float:117:22)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:117:5)
Types: Type checking non-recursive proc wybe.float.-
Types: ** Type checking decl of proc -
Types: found 5 definition(s)
Types: Type checking -
Types: ** Type checking -: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm fsub(x @float:32:45, y @float:32:47, ?tmp#0 @float:32:27)
Types:         foreign llvm move(tmp#0, ?#result @float:32:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.float, y:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign llvm fsub(x @float:32:45, y @float:32:47, ?tmp#0 @float:32:27)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:32:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:32:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:32:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:32:45
Types:   Type = wybe.float
Types: Finding type of expr y @float:32:47
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:32:27
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign llvm call fsub(64 bit float, 64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:32:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc -
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fsub(x @float:32:45, y @float:32:47, ?tmp#0 @float:32:27)
Types: Mode checking foreign call {foreign llvm fsub(x @float:32:45, y @float:32:47, ?tmp#0 @float:32:27)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:32:45
Types:   Type = wybe.float
Types: Finding type of expr y @float:32:47
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:32:27
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,wybe.float,?wybe.float]
Types: New instr = {foreign llvm fsub(x:wybe.float @float:32:45, y:wybe.float @float:32:47, ?tmp#0:wybe.float @float:32:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:32:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:32:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:32:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:32:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '-'
Types: Mode checked body   : [{foreign llvm fsub(x:wybe.float @float:32:45, y:wybe.float @float:32:47, ?tmp#0:wybe.float @float:32:27)} @float:32:27,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:32:5)} @float:32:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking -
Types: ** Type checking -: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm fadd(z @float:33:61, y @float:33:63, ?tmp#0 @float:33:43)
Types:         =(?x @float:33:39, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y","z"]
Types: Recording parameter types: ?x:wybe.float, y:wybe.float, z:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types:     type of 'z' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable z type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign llvm fadd(z @float:33:61, y @float:33:63, ?tmp#0 @float:33:43)}
Types: Recording casts in {=(?x @float:33:39, tmp#0)}
Types: *** Before calls Typing {x::wybe.float, y::wybe.float, z::wybe.float}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {=(?x @float:33:39, tmp#0)} @float:33:39, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.float, y::wybe.float, z::wybe.float}; {} (with no errors)
Types: Type checking call {=(?x @float:33:39, tmp#0)} @float:33:39
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @float:33:39
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Actual types: [wybe.float,0]
Types: Matching types [wybe.float,0] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 33, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.float,0] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 33, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.float,0] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,0] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 33, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.float, y::wybe.float, z::wybe.float}; {0::wybe.float} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.float, y::wybe.float, z::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr z @float:33:61
Types:   Type = wybe.float
Types: Finding type of expr y @float:33:63
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:33:43
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign llvm call fadd(64 bit float, 64 bit float, 64 bit float)
Types: Now mode checking proc -
Types: bound vars: semipure normal (total) computation binding {y, z}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fadd(z @float:33:61, y @float:33:63, ?tmp#0 @float:33:43)
Types: Mode checking foreign call {foreign llvm fadd(z @float:33:61, y @float:33:63, ?tmp#0 @float:33:43)}
Types:     with assigned semipure normal (total) computation binding {y, z}, break set = Everything, with resources {}
Types: Mode check exp z
Types: Mode check exp resulted in z
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr z @float:33:61
Types:   Type = wybe.float
Types: Finding type of expr y @float:33:63
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:33:43
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,wybe.float,?wybe.float]
Types: New instr = {foreign llvm fadd(z:wybe.float @float:33:61, y:wybe.float @float:33:63, ?tmp#0:wybe.float @float:33:43)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @float:33:39, tmp#0)
Types: Mode checking call   : {=(?x @float:33:39, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @float:33:39
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.float,wybe.float] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 33, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 33, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 33, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 33, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 33, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 33, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.float.=<0>(wybe.float,wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float, z::wybe.float}; {0::wybe.float} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @float:33:39)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?x @float:33:39
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:33:39)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Mode check end of Det proc '-'
Types: Mode checked body   : [{foreign llvm fadd(z:wybe.float @float:33:61, y:wybe.float @float:33:63, ?tmp#0:wybe.float @float:33:43)} @float:33:43,{foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:33:39)} @float:33:39]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking -
Types: ** Type checking -: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm fsub(z @float:34:61, x @float:34:63, ?tmp#0 @float:34:43)
Types:         =(?y @float:34:39, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y","z"]
Types: Recording parameter types: x:wybe.float, ?y:wybe.float, z:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types:     type of 'z' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable z type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign llvm fsub(z @float:34:61, x @float:34:63, ?tmp#0 @float:34:43)}
Types: Recording casts in {=(?y @float:34:39, tmp#0)}
Types: *** Before calls Typing {x::wybe.float, y::wybe.float, z::wybe.float}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {=(?y @float:34:39, tmp#0)} @float:34:39, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.float, y::wybe.float, z::wybe.float}; {} (with no errors)
Types: Type checking call {=(?y @float:34:39, tmp#0)} @float:34:39
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?y @float:34:39
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Actual types: [wybe.float,0]
Types: Matching types [wybe.float,0] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 34, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.float,0] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 34, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.float,0] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,0] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 34, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.float, y::wybe.float, z::wybe.float}; {0::wybe.float} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.float, y::wybe.float, z::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr z @float:34:61
Types:   Type = wybe.float
Types: Finding type of expr x @float:34:63
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:34:43
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign llvm call fsub(64 bit float, 64 bit float, 64 bit float)
Types: Now mode checking proc -
Types: bound vars: semipure normal (total) computation binding {x, z}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fsub(z @float:34:61, x @float:34:63, ?tmp#0 @float:34:43)
Types: Mode checking foreign call {foreign llvm fsub(z @float:34:61, x @float:34:63, ?tmp#0 @float:34:43)}
Types:     with assigned semipure normal (total) computation binding {x, z}, break set = Everything, with resources {}
Types: Mode check exp z
Types: Mode check exp resulted in z
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr z @float:34:61
Types:   Type = wybe.float
Types: Finding type of expr x @float:34:63
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:34:43
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,wybe.float,?wybe.float]
Types: New instr = {foreign llvm fsub(z:wybe.float @float:34:61, x:wybe.float @float:34:63, ?tmp#0:wybe.float @float:34:43)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check stmt =(?y @float:34:39, tmp#0)
Types: Mode checking call   : {=(?y @float:34:39, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check exp ?y
Types: Mode check exp resulted in ?y
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?y @float:34:39
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.float,wybe.float] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 34, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 34, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 34, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 34, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 34, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 34, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.float.=<0>(wybe.float,wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float, z::wybe.float}; {0::wybe.float} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?y @float:34:39)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?y
Types: Mode check exp resulted in ?y
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?y @float:34:39
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?y:wybe.float @float:34:39)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Mode check end of Det proc '-'
Types: Mode checked body   : [{foreign llvm fsub(z:wybe.float @float:34:61, x:wybe.float @float:34:63, ?tmp#0:wybe.float @float:34:43)} @float:34:43,{foreign llvm move(tmp#0:wybe.float, ?y:wybe.float @float:34:39)} @float:34:39]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Output parameters   : y
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking -
Types: ** Type checking -: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm fsub(0.0 @float:38:39, x @float:38:43, ?tmp#0 @float:38:21)
Types:         foreign llvm move(tmp#0, ?#result @float:38:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x"]
Types: Recording parameter types: x:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign llvm fsub(0.0 @float:38:39, x @float:38:43, ?tmp#0 @float:38:21)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:38:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:38:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:38:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr 0.0 @float:38:39
Types:   Type = wybe.float
Types: Finding type of expr x @float:38:43
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:38:21
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign llvm call fsub(64 bit float, 64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:38:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc -
Types: bound vars: semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fsub(0.0 @float:38:39, x @float:38:43, ?tmp#0 @float:38:21)
Types: Mode checking foreign call {foreign llvm fsub(0.0 @float:38:39, x @float:38:43, ?tmp#0 @float:38:21)}
Types:     with assigned semipure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check exp 0.0
Types: Mode check exp resulted in 0.0
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr 0.0 @float:38:39
Types:   Type = wybe.float
Types: Finding type of expr x @float:38:43
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:38:21
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,wybe.float,?wybe.float]
Types: New instr = {foreign llvm fsub(0.0:wybe.float @float:38:39, x:wybe.float @float:38:43, ?tmp#0:wybe.float @float:38:21)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:38:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:38:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:38:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:38:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc '-'
Types: Mode checked body   : [{foreign llvm fsub(0.0:wybe.float @float:38:39, x:wybe.float @float:38:43, ?tmp#0:wybe.float @float:38:21)} @float:38:21,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:38:5)} @float:38:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking -
Types: ** Type checking -: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm fsub(0.0 @float:39:55, y @float:39:59, ?tmp#0 @float:39:37)
Types:         =(?x @float:39:33, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y"]
Types: Recording parameter types: ?x:wybe.float, y:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign llvm fsub(0.0 @float:39:55, y @float:39:59, ?tmp#0 @float:39:37)}
Types: Recording casts in {=(?x @float:39:33, tmp#0)}
Types: *** Before calls Typing {x::wybe.float, y::wybe.float}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {=(?x @float:39:33, tmp#0)} @float:39:33, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.float, y::wybe.float}; {} (with no errors)
Types: Type checking call {=(?x @float:39:33, tmp#0)} @float:39:33
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @float:39:33
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Actual types: [wybe.float,0]
Types: Matching types [wybe.float,0] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 39, column 33): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.float,0] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 39, column 33): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.float,0] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,0] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 39, column 33): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr 0.0 @float:39:55
Types:   Type = wybe.float
Types: Finding type of expr y @float:39:59
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:39:37
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign llvm call fsub(64 bit float, 64 bit float, 64 bit float)
Types: Now mode checking proc -
Types: bound vars: semipure normal (total) computation binding {y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fsub(0.0 @float:39:55, y @float:39:59, ?tmp#0 @float:39:37)
Types: Mode checking foreign call {foreign llvm fsub(0.0 @float:39:55, y @float:39:59, ?tmp#0 @float:39:37)}
Types:     with assigned semipure normal (total) computation binding {y}, break set = Everything, with resources {}
Types: Mode check exp 0.0
Types: Mode check exp resulted in 0.0
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr 0.0 @float:39:55
Types:   Type = wybe.float
Types: Finding type of expr y @float:39:59
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:39:37
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,wybe.float,?wybe.float]
Types: New instr = {foreign llvm fsub(0.0:wybe.float @float:39:55, y:wybe.float @float:39:59, ?tmp#0:wybe.float @float:39:37)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, y}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @float:39:33, tmp#0)
Types: Mode checking call   : {=(?x @float:39:33, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, y}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @float:39:33
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.float,wybe.float] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 39, column 33): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 39, column 33): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 39, column 33): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 39, column 33): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 39, column 33): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 39, column 33): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.float.=<0>(wybe.float,wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @float:39:33)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?x @float:39:33
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:39:33)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '-'
Types: Mode checked body   : [{foreign llvm fsub(0.0:wybe.float @float:39:55, y:wybe.float @float:39:59, ?tmp#0:wybe.float @float:39:37)} @float:39:37,{foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:39:33)} @float:39:33]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of -:
Types: 
Types: - > public (0 calls)
Types: 4: -(x:wybe.float @float:32:10, y:wybe.float @float:32:17, ?#result:wybe.float @float:32:5):
Types:     foreign llvm fsub(x:wybe.float @float:32:45, y:wybe.float @float:32:47, ?tmp#0:wybe.float @float:32:27)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:32:5)
Types: 
Types: - > public (0 calls)
Types: 4: -(?x:wybe.float @float:33:11, y:wybe.float @float:33:17, z:wybe.float @float:33:5):
Types:     foreign llvm fadd(z:wybe.float @float:33:61, y:wybe.float @float:33:63, ?tmp#0:wybe.float @float:33:43)
Types:     foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:33:39)
Types: 
Types: - > public (0 calls)
Types: 4: -(x:wybe.float @float:34:10, ?y:wybe.float @float:34:18, z:wybe.float @float:34:5):
Types:     foreign llvm fsub(z:wybe.float @float:34:61, x:wybe.float @float:34:63, ?tmp#0:wybe.float @float:34:43)
Types:     foreign llvm move(tmp#0:wybe.float, ?y:wybe.float @float:34:39)
Types: 
Types: - > public (0 calls)
Types: 4: -(x:wybe.float @float:38:11, ?#result:wybe.float @float:38:5):
Types:     foreign llvm fsub(0.0:wybe.float @float:38:39, x:wybe.float @float:38:43, ?tmp#0:wybe.float @float:38:21)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:38:5)
Types: 
Types: - > public (0 calls)
Types: 4: -(?x:wybe.float @float:39:12, y:wybe.float @float:39:5):
Types:     foreign llvm fsub(0.0:wybe.float @float:39:55, y:wybe.float @float:39:59, ?tmp#0:wybe.float @float:39:37)
Types:     foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:39:33)
Types: Type checking non-recursive proc wybe.float.-=
Types: ** Type checking decl of proc -=
Types: found 1 definition(s)
Types: Type checking -=
Types: ** Type checking -=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         -(x @float:42:31, y @float:42:35, ?tmp#0 @float:42:31)
Types:         =(?x @float:42:27, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y"]
Types: Recording parameter types: !x:wybe.float, y:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {-(x @float:42:31, y @float:42:35, ?tmp#0 @float:42:31)}
Types: Recording casts in {=(?x @float:42:27, tmp#0)}
Types: *** Before calls Typing {x::wybe.float, y::wybe.float}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {-(x @float:42:31, y @float:42:35, ?tmp#0 @float:42:31)} @float:42:31, typingInfos = [wybe.float.-<0>(wybe.float,wybe.float,?wybe.float),wybe.float.-<1>(?wybe.float,wybe.float,wybe.float),wybe.float.-<2>(wybe.float,?wybe.float,wybe.float),wybe.float.-<3>(wybe.float,?wybe.float),wybe.float.-<4>(?wybe.float,wybe.float),wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),wybe.int.-<3>(wybe.int,?wybe.int),wybe.int.-<4>(?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?x @float:42:27, tmp#0)} @float:42:27, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.float, y::wybe.float}; {} (with no errors)
Types: Type checking call {-(x @float:42:31, y @float:42:35, ?tmp#0 @float:42:31)} @float:42:31
Types: Candidate types:
Types:     wybe.float.-<0>(wybe.float,wybe.float,?wybe.float)
Types:     wybe.float.-<1>(?wybe.float,wybe.float,wybe.float)
Types:     wybe.float.-<2>(wybe.float,?wybe.float,wybe.float)
Types:     wybe.float.-<3>(wybe.float,?wybe.float)
Types:     wybe.float.-<4>(?wybe.float,wybe.float)
Types:     wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types:     wybe.int.-<3>(wybe.int,?wybe.int)
Types:     wybe.int.-<4>(?wybe.int,wybe.int)
Types: Finding type of expr x @float:42:31
Types:   Type = wybe.float
Types: Finding type of expr y @float:42:35
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:42:31
Types:   Type = 0
Types: Actual types: [wybe.float,wybe.float,0]
Types: Matching types [wybe.float,wybe.float,0] with wybe.float.-<0>(wybe.float,wybe.float,?wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float,0] with wybe.float.-<1>(?wybe.float,wybe.float,wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float,0] with wybe.float.-<2>(wybe.float,?wybe.float,wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float,0] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 31): Type error in call to -, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 31): Type error in call to -, argument 2]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.float,wybe.float,0] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 31): Type error in call to -, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 31): Type error in call to -, argument 2]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.float,wybe.float,0] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 31): Type error in call to -, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 31): Type error in call to -, argument 2]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types: Type checking call {=(?x @float:42:27, tmp#0)} @float:42:27
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @float:42:27
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Actual types: [wybe.float,wybe.float]
Types: Matching types [wybe.float,wybe.float] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types: Now mode checking proc -=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt -(x @float:42:31, y @float:42:35, ?tmp#0 @float:42:31)
Types: Mode checking call   : {-(x @float:42:31, y @float:42:35, ?tmp#0 @float:42:31)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:42:31
Types:   Type = wybe.float
Types: Finding type of expr y @float:42:35
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:42:31
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float,wybe.float]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.float.-<0>(wybe.float,wybe.float,?wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.float.-<1>(?wybe.float,wybe.float,wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.float.-<2>(wybe.float,?wybe.float,wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 31): Type error in call to -, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 31): Type error in call to -, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 31): Type error in call to -, argument 3]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 31): Type error in call to -, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 31): Type error in call to -, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 31): Type error in call to -, argument 3]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 31): Type error in call to -, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 31): Type error in call to -, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 31): Type error in call to -, argument 3]
Types:   Unification yields XXX
Types: Type-correct modes   : [(wybe.float.-<0>(wybe.float,wybe.float,?wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)),(wybe.float.-<1>(?wybe.float,wybe.float,wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)),(wybe.float.-<2>(wybe.float,?wybe.float,wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors))]
Types: Possible mode matches: [(wybe.float.-<0>(wybe.float,wybe.float,?wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors))]
Types: Exact mode matches: [(wybe.float.-<0>(wybe.float,wybe.float,?wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors))]
Types: Finding type of expr x @float:42:31
Types:   Type = wybe.float
Types: Finding type of expr y @float:42:35
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:42:31
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finalising call    :  {wybe.float.<0>-(x:wybe.float @float:42:31, y:wybe.float @float:42:35, ?tmp#0:wybe.float @float:42:31)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.float.<0>-(x:wybe.float @float:42:31, y:wybe.float @float:42:35, ?tmp#0:wybe.float @float:42:31)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '-='
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @float:42:27, tmp#0)
Types: Mode checking call   : {=(?x @float:42:27, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @float:42:27
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.float,wybe.float] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 42, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.float.=<0>(wybe.float,wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @float:42:27)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?x @float:42:27
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:42:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '-='
Types: Mode checked body   : [{wybe.float.<0>-(x:wybe.float @float:42:31, y:wybe.float @float:42:35, ?tmp#0:wybe.float @float:42:31)} @float:42:31,{foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:42:27)} @float:42:27]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of -=:
Types: 
Types: -= > public (0 calls)
Types: 4: -=(!x:wybe.float @float:42:11, y:wybe.float @float:42:19):
Types:     wybe.float.<0>-(x:wybe.float @float:42:31, y:wybe.float @float:42:35, ?tmp#0:wybe.float @float:42:31)
Types:     foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:42:27)
Types: Type checking non-recursive proc wybe.float.+
Types: ** Type checking decl of proc +
Types: found 3 definition(s)
Types: Type checking +
Types: ** Type checking +: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm fadd(x @float:23:45, y @float:23:47, ?tmp#0 @float:23:27)
Types:         foreign llvm move(tmp#0, ?#result @float:23:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.float, y:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign llvm fadd(x @float:23:45, y @float:23:47, ?tmp#0 @float:23:27)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:23:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:23:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:23:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:23:45
Types:   Type = wybe.float
Types: Finding type of expr y @float:23:47
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:23:27
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign llvm call fadd(64 bit float, 64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:23:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc +
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fadd(x @float:23:45, y @float:23:47, ?tmp#0 @float:23:27)
Types: Mode checking foreign call {foreign llvm fadd(x @float:23:45, y @float:23:47, ?tmp#0 @float:23:27)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:23:45
Types:   Type = wybe.float
Types: Finding type of expr y @float:23:47
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:23:27
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,wybe.float,?wybe.float]
Types: New instr = {foreign llvm fadd(x:wybe.float @float:23:45, y:wybe.float @float:23:47, ?tmp#0:wybe.float @float:23:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:23:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:23:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:23:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:23:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '+'
Types: Mode checked body   : [{foreign llvm fadd(x:wybe.float @float:23:45, y:wybe.float @float:23:47, ?tmp#0:wybe.float @float:23:27)} @float:23:27,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:23:5)} @float:23:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking +
Types: ** Type checking +: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm fsub(z @float:24:61, y @float:24:63, ?tmp#0 @float:24:43)
Types:         =(?x @float:24:39, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y","z"]
Types: Recording parameter types: ?x:wybe.float, y:wybe.float, z:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types:     type of 'z' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable z type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign llvm fsub(z @float:24:61, y @float:24:63, ?tmp#0 @float:24:43)}
Types: Recording casts in {=(?x @float:24:39, tmp#0)}
Types: *** Before calls Typing {x::wybe.float, y::wybe.float, z::wybe.float}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {=(?x @float:24:39, tmp#0)} @float:24:39, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.float, y::wybe.float, z::wybe.float}; {} (with no errors)
Types: Type checking call {=(?x @float:24:39, tmp#0)} @float:24:39
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @float:24:39
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Actual types: [wybe.float,0]
Types: Matching types [wybe.float,0] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 24, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.float,0] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 24, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.float,0] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,0] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 24, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.float, y::wybe.float, z::wybe.float}; {0::wybe.float} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.float, y::wybe.float, z::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr z @float:24:61
Types:   Type = wybe.float
Types: Finding type of expr y @float:24:63
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:24:43
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign llvm call fsub(64 bit float, 64 bit float, 64 bit float)
Types: Now mode checking proc +
Types: bound vars: semipure normal (total) computation binding {y, z}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fsub(z @float:24:61, y @float:24:63, ?tmp#0 @float:24:43)
Types: Mode checking foreign call {foreign llvm fsub(z @float:24:61, y @float:24:63, ?tmp#0 @float:24:43)}
Types:     with assigned semipure normal (total) computation binding {y, z}, break set = Everything, with resources {}
Types: Mode check exp z
Types: Mode check exp resulted in z
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr z @float:24:61
Types:   Type = wybe.float
Types: Finding type of expr y @float:24:63
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:24:43
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,wybe.float,?wybe.float]
Types: New instr = {foreign llvm fsub(z:wybe.float @float:24:61, y:wybe.float @float:24:63, ?tmp#0:wybe.float @float:24:43)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @float:24:39, tmp#0)
Types: Mode checking call   : {=(?x @float:24:39, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @float:24:39
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.float,wybe.float] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 24, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 24, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 24, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 24, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 24, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 24, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.float.=<0>(wybe.float,wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float, z::wybe.float}; {0::wybe.float} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @float:24:39)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, y, z}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?x @float:24:39
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:24:39)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Mode check end of Det proc '+'
Types: Mode checked body   : [{foreign llvm fsub(z:wybe.float @float:24:61, y:wybe.float @float:24:63, ?tmp#0:wybe.float @float:24:43)} @float:24:43,{foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:24:39)} @float:24:39]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking +
Types: ** Type checking +: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm fsub(z @float:25:61, x @float:25:63, ?tmp#0 @float:25:43)
Types:         =(?y @float:25:39, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y","z"]
Types: Recording parameter types: x:wybe.float, ?y:wybe.float, z:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types:     type of 'z' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable z type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign llvm fsub(z @float:25:61, x @float:25:63, ?tmp#0 @float:25:43)}
Types: Recording casts in {=(?y @float:25:39, tmp#0)}
Types: *** Before calls Typing {x::wybe.float, y::wybe.float, z::wybe.float}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {=(?y @float:25:39, tmp#0)} @float:25:39, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.float, y::wybe.float, z::wybe.float}; {} (with no errors)
Types: Type checking call {=(?y @float:25:39, tmp#0)} @float:25:39
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?y @float:25:39
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Actual types: [wybe.float,0]
Types: Matching types [wybe.float,0] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 25, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.float,0] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 25, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.float,0] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,0] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 25, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.float, y::wybe.float, z::wybe.float}; {0::wybe.float} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.float, y::wybe.float, z::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr z @float:25:61
Types:   Type = wybe.float
Types: Finding type of expr x @float:25:63
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:25:43
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign llvm call fsub(64 bit float, 64 bit float, 64 bit float)
Types: Now mode checking proc +
Types: bound vars: semipure normal (total) computation binding {x, z}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fsub(z @float:25:61, x @float:25:63, ?tmp#0 @float:25:43)
Types: Mode checking foreign call {foreign llvm fsub(z @float:25:61, x @float:25:63, ?tmp#0 @float:25:43)}
Types:     with assigned semipure normal (total) computation binding {x, z}, break set = Everything, with resources {}
Types: Mode check exp z
Types: Mode check exp resulted in z
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr z @float:25:61
Types:   Type = wybe.float
Types: Finding type of expr x @float:25:63
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:25:43
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,wybe.float,?wybe.float]
Types: New instr = {foreign llvm fsub(z:wybe.float @float:25:61, x:wybe.float @float:25:63, ?tmp#0:wybe.float @float:25:43)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check stmt =(?y @float:25:39, tmp#0)
Types: Mode checking call   : {=(?y @float:25:39, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check exp ?y
Types: Mode check exp resulted in ?y
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?y @float:25:39
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.float,wybe.float] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 25, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 25, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 25, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 25, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 25, column 39): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 25, column 39): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.float.=<0>(wybe.float,wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float, z::wybe.float}; {0::wybe.float} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?y @float:25:39)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, z}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?y
Types: Mode check exp resulted in ?y
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?y @float:25:39
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?y:wybe.float @float:25:39)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Mode check end of Det proc '+'
Types: Mode checked body   : [{foreign llvm fsub(z:wybe.float @float:25:61, x:wybe.float @float:25:63, ?tmp#0:wybe.float @float:25:43)} @float:25:43,{foreign llvm move(tmp#0:wybe.float, ?y:wybe.float @float:25:39)} @float:25:39]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y, z}, break set = Everything, with resources {}
Types: Output parameters   : y
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of +:
Types: 
Types: + > public (0 calls)
Types: 4: +(x:wybe.float @float:23:10, y:wybe.float @float:23:17, ?#result:wybe.float @float:23:5):
Types:     foreign llvm fadd(x:wybe.float @float:23:45, y:wybe.float @float:23:47, ?tmp#0:wybe.float @float:23:27)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:23:5)
Types: 
Types: + > public (0 calls)
Types: 4: +(?x:wybe.float @float:24:11, y:wybe.float @float:24:17, z:wybe.float @float:24:5):
Types:     foreign llvm fsub(z:wybe.float @float:24:61, y:wybe.float @float:24:63, ?tmp#0:wybe.float @float:24:43)
Types:     foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:24:39)
Types: 
Types: + > public (0 calls)
Types: 4: +(x:wybe.float @float:25:10, ?y:wybe.float @float:25:18, z:wybe.float @float:25:5):
Types:     foreign llvm fsub(z:wybe.float @float:25:61, x:wybe.float @float:25:63, ?tmp#0:wybe.float @float:25:43)
Types:     foreign llvm move(tmp#0:wybe.float, ?y:wybe.float @float:25:39)
Types: Type checking non-recursive proc wybe.float.+=
Types: ** Type checking decl of proc +=
Types: found 1 definition(s)
Types: Type checking +=
Types: ** Type checking +=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         +(x @float:28:31, y @float:28:35, ?tmp#0 @float:28:31)
Types:         =(?x @float:28:27, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y"]
Types: Recording parameter types: !x:wybe.float, y:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {+(x @float:28:31, y @float:28:35, ?tmp#0 @float:28:31)}
Types: Recording casts in {=(?x @float:28:27, tmp#0)}
Types: *** Before calls Typing {x::wybe.float, y::wybe.float}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {+(x @float:28:31, y @float:28:35, ?tmp#0 @float:28:31)} @float:28:31, typingInfos = [wybe.float.+<0>(wybe.float,wybe.float,?wybe.float),wybe.float.+<1>(?wybe.float,wybe.float,wybe.float),wybe.float.+<2>(wybe.float,?wybe.float,wybe.float),wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?x @float:28:27, tmp#0)} @float:28:27, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.float, y::wybe.float}; {} (with no errors)
Types: Type checking call {+(x @float:28:31, y @float:28:35, ?tmp#0 @float:28:31)} @float:28:31
Types: Candidate types:
Types:     wybe.float.+<0>(wybe.float,wybe.float,?wybe.float)
Types:     wybe.float.+<1>(?wybe.float,wybe.float,wybe.float)
Types:     wybe.float.+<2>(wybe.float,?wybe.float,wybe.float)
Types:     wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Finding type of expr x @float:28:31
Types:   Type = wybe.float
Types: Finding type of expr y @float:28:35
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:28:31
Types:   Type = 0
Types: Actual types: [wybe.float,wybe.float,0]
Types: Matching types [wybe.float,wybe.float,0] with wybe.float.+<0>(wybe.float,wybe.float,?wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float,0] with wybe.float.+<1>(?wybe.float,wybe.float,wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float,0] with wybe.float.+<2>(wybe.float,?wybe.float,wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float,0] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 31): Type error in call to +, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 31): Type error in call to +, argument 2]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.float,wybe.float,0] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 31): Type error in call to +, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 31): Type error in call to +, argument 2]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.float,wybe.float,0] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 31): Type error in call to +, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 31): Type error in call to +, argument 2]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types: Type checking call {=(?x @float:28:27, tmp#0)} @float:28:27
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @float:28:27
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Actual types: [wybe.float,wybe.float]
Types: Matching types [wybe.float,wybe.float] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types: Now mode checking proc +=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt +(x @float:28:31, y @float:28:35, ?tmp#0 @float:28:31)
Types: Mode checking call   : {+(x @float:28:31, y @float:28:35, ?tmp#0 @float:28:31)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:28:31
Types:   Type = wybe.float
Types: Finding type of expr y @float:28:35
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:28:31
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float,wybe.float]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.float.+<0>(wybe.float,wybe.float,?wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.float.+<1>(?wybe.float,wybe.float,wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.float.+<2>(wybe.float,?wybe.float,wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 31): Type error in call to +, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 31): Type error in call to +, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 31): Type error in call to +, argument 3]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 31): Type error in call to +, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 31): Type error in call to +, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 31): Type error in call to +, argument 3]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 31): Type error in call to +, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 31): Type error in call to +, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 31): Type error in call to +, argument 3]
Types:   Unification yields XXX
Types: Type-correct modes   : [(wybe.float.+<0>(wybe.float,wybe.float,?wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)),(wybe.float.+<1>(?wybe.float,wybe.float,wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)),(wybe.float.+<2>(wybe.float,?wybe.float,wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors))]
Types: Possible mode matches: [(wybe.float.+<0>(wybe.float,wybe.float,?wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors))]
Types: Exact mode matches: [(wybe.float.+<0>(wybe.float,wybe.float,?wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors))]
Types: Finding type of expr x @float:28:31
Types:   Type = wybe.float
Types: Finding type of expr y @float:28:35
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:28:31
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finalising call    :  {wybe.float.<0>+(x:wybe.float @float:28:31, y:wybe.float @float:28:35, ?tmp#0:wybe.float @float:28:31)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.float.<0>+(x:wybe.float @float:28:31, y:wybe.float @float:28:35, ?tmp#0:wybe.float @float:28:31)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '+='
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @float:28:27, tmp#0)
Types: Mode checking call   : {=(?x @float:28:27, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @float:28:27
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.float,wybe.float] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 28, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.float.=<0>(wybe.float,wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @float:28:27)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?x @float:28:27
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:28:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '+='
Types: Mode checked body   : [{wybe.float.<0>+(x:wybe.float @float:28:31, y:wybe.float @float:28:35, ?tmp#0:wybe.float @float:28:31)} @float:28:31,{foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:28:27)} @float:28:27]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of +=:
Types: 
Types: += > public (0 calls)
Types: 4: +=(!x:wybe.float @float:28:11, y:wybe.float @float:28:19):
Types:     wybe.float.<0>+(x:wybe.float @float:28:31, y:wybe.float @float:28:35, ?tmp#0:wybe.float @float:28:31)
Types:     foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:28:27)
Types: Type checking non-recursive proc wybe.float.**
Types: ** Type checking decl of proc **
Types: found 1 definition(s)
Types: Type checking **
Types: ** Type checking **: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c llvm.pow.f64(x @float:112:52, n @float:112:54, ?tmp#0 @float:112:27)
Types:         foreign llvm move(tmp#0, ?#result @float:112:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","n","tmp#0","x"]
Types: Recording parameter types: x:wybe.float, n:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'n' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable n type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign c llvm.pow.f64(x @float:112:52, n @float:112:54, ?tmp#0 @float:112:27)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:112:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:112:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:112:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, n::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, n::wybe.float, tmp#0::0, x::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:112:52
Types:   Type = wybe.float
Types: Finding type of expr n @float:112:54
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:112:27
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign c call llvm.pow.f64(64 bit float, 64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:112:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc **
Types: bound vars: semipure normal (total) computation binding {n, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign c llvm.pow.f64(x @float:112:52, n @float:112:54, ?tmp#0 @float:112:27)
Types: Mode checking foreign call {foreign c llvm.pow.f64(x @float:112:52, n @float:112:54, ?tmp#0 @float:112:27)}
Types:     with assigned semipure normal (total) computation binding {n, x}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp n
Types: Mode check exp resulted in n
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:112:52
Types:   Type = wybe.float
Types: Finding type of expr n @float:112:54
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:112:27
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,wybe.float,?wybe.float]
Types: New instr = {foreign c llvm.pow.f64(x:wybe.float @float:112:52, n:wybe.float @float:112:54, ?tmp#0:wybe.float @float:112:27)}
Types: Now assigned = semipure normal (total) computation binding {n, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:112:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:112:5)}
Types:     with assigned semipure normal (total) computation binding {n, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:112:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:112:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, n, tmp#0, x}, break set = Everything, with resources {}
Types: Mode check end of Det proc '**'
Types: Mode checked body   : [{foreign c llvm.pow.f64(x:wybe.float @float:112:52, n:wybe.float @float:112:54, ?tmp#0:wybe.float @float:112:27)} @float:112:27,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:112:5)} @float:112:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, n, tmp#0, x}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of **:
Types: 
Types: ** > public (0 calls)
Types: 4: **(x:wybe.float @float:112:10, n:wybe.float @float:112:18, ?#result:wybe.float @float:112:5):
Types:     foreign c llvm.pow.f64(x:wybe.float @float:112:52, n:wybe.float @float:112:54, ?tmp#0:wybe.float @float:112:27)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:112:5)
Types: Type checking non-recursive proc wybe.float.*
Types: ** Type checking decl of proc *
Types: found 1 definition(s)
Types: Type checking *
Types: ** Type checking *: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm fmul(x @float:45:43, y @float:45:45, ?tmp#0 @float:45:25)
Types:         foreign llvm move(tmp#0, ?#result @float:45:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","x","y"]
Types: Recording parameter types: x:wybe.float, y:wybe.float, ?#result:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types:     type of '#result' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable #result type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {foreign llvm fmul(x @float:45:43, y @float:45:45, ?tmp#0 @float:45:25)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @float:45:5)}
Types: Unifying move argument types tmp#0 and ?#result @float:45:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @float:45:5
Types:   Type = wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: *** Before calls Typing {#result::wybe.float, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.float, tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types: Finding type of expr x @float:45:43
Types:   Type = wybe.float
Types: Finding type of expr y @float:45:45
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:45:25
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Type checking foreign llvm call fmul(64 bit float, 64 bit float, 64 bit float)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:45:5
Types:   Type = wybe.float
Types: Type checking foreign llvm call move(64 bit float, 64 bit float)
Types: Now mode checking proc *
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm fmul(x @float:45:43, y @float:45:45, ?tmp#0 @float:45:25)
Types: Mode checking foreign call {foreign llvm fmul(x @float:45:43, y @float:45:45, ?tmp#0 @float:45:25)}
Types:     with assigned semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:45:43
Types:   Type = wybe.float
Types: Finding type of expr y @float:45:45
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:45:25
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,wybe.float,?wybe.float]
Types: New instr = {foreign llvm fmul(x:wybe.float @float:45:43, y:wybe.float @float:45:45, ?tmp#0:wybe.float @float:45:25)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @float:45:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @float:45:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?#result @float:45:5
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:45:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '*'
Types: Mode checked body   : [{foreign llvm fmul(x:wybe.float @float:45:43, y:wybe.float @float:45:45, ?tmp#0:wybe.float @float:45:25)} @float:45:25,{foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:45:5)} @float:45:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of *:
Types: 
Types: * > public (0 calls)
Types: 4: *(x:wybe.float @float:45:10, y:wybe.float @float:45:16, ?#result:wybe.float @float:45:5):
Types:     foreign llvm fmul(x:wybe.float @float:45:43, y:wybe.float @float:45:45, ?tmp#0:wybe.float @float:45:25)
Types:     foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:45:5)
Types: Type checking non-recursive proc wybe.float.*=
Types: ** Type checking decl of proc *=
Types: found 1 definition(s)
Types: Type checking *=
Types: ** Type checking *=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         *(x @float:48:31, y @float:48:35, ?tmp#0 @float:48:31)
Types:         =(?x @float:48:27, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["tmp#0","x","y"]
Types: Recording parameter types: !x:wybe.float, y:wybe.float
Types:     type of 'x' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable x type constrained to wybe.float
Types:     type of 'y' is wybe.float
Types: Unifying types wybe.float (-> wybe.float) and any (-> any)
Types:   Unification yields wybe.float
Types: Variable y type constrained to wybe.float
Types: Recording resource types: 
Types: Recording casts in {*(x @float:48:31, y @float:48:35, ?tmp#0 @float:48:31)}
Types: Recording casts in {=(?x @float:48:27, tmp#0)}
Types: *** Before calls Typing {x::wybe.float, y::wybe.float}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {*(x @float:48:31, y @float:48:35, ?tmp#0 @float:48:31)} @float:48:31, typingInfos = [wybe.float.*<0>(wybe.float,wybe.float,?wybe.float),wybe.int.*<0>(wybe.int,wybe.int,?wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?x @float:48:27, tmp#0)} @float:48:27, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {x::wybe.float, y::wybe.float}; {} (with no errors)
Types: Type checking call {*(x @float:48:31, y @float:48:35, ?tmp#0 @float:48:31)} @float:48:31
Types: Candidate types:
Types:     wybe.float.*<0>(wybe.float,wybe.float,?wybe.float)
Types:     wybe.int.*<0>(wybe.int,wybe.int,?wybe.int)
Types: Finding type of expr x @float:48:31
Types:   Type = wybe.float
Types: Finding type of expr y @float:48:35
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:48:31
Types:   Type = 0
Types: Actual types: [wybe.float,wybe.float,0]
Types: Matching types [wybe.float,wybe.float,0] with wybe.float.*<0>(wybe.float,wybe.float,?wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float,0] with wybe.int.*<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 48, column 31): Type error in call to *, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 48, column 31): Type error in call to *, argument 2]
Types:   Unification yields XXX
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types: Type checking call {=(?x @float:48:27, tmp#0)} @float:48:27
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.float.=<0>(wybe.float,wybe.float,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr ?x @float:48:27
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Actual types: [wybe.float,wybe.float]
Types: Matching types [wybe.float,wybe.float] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 48, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 48, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 48, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 48, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 48, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 48, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)]
Types: Resulting typing = Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors)
Types: Now mode checking proc *=
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt *(x @float:48:31, y @float:48:35, ?tmp#0 @float:48:31)
Types: Mode checking call   : {*(x @float:48:31, y @float:48:35, ?tmp#0 @float:48:31)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr x @float:48:31
Types:   Type = wybe.float
Types: Finding type of expr y @float:48:35
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:48:31
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float,wybe.float]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.float.*<0>(wybe.float,wybe.float,?wybe.float)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float,wybe.float] with wybe.int.*<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 48, column 31): Type error in call to *, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 48, column 31): Type error in call to *, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 48, column 31): Type error in call to *, argument 3]
Types:   Unification yields XXX
Types: Type-correct modes   : [(wybe.float.*<0>(wybe.float,wybe.float,?wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors))]
Types: Possible mode matches: [(wybe.float.*<0>(wybe.float,wybe.float,?wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors))]
Types: Exact mode matches: [(wybe.float.*<0>(wybe.float,wybe.float,?wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors))]
Types: Finding type of expr x @float:48:31
Types:   Type = wybe.float
Types: Finding type of expr y @float:48:35
Types:   Type = wybe.float
Types: Finding type of expr ?tmp#0 @float:48:31
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finalising call    :  {wybe.float.<0>*(x:wybe.float @float:48:31, y:wybe.float @float:48:35, ?tmp#0:wybe.float @float:48:31)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.float.<0>*(x:wybe.float @float:48:31, y:wybe.float @float:48:35, ?tmp#0:wybe.float @float:48:31)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '*='
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check stmt =(?x @float:48:27, tmp#0)
Types: Mode checking call   : {=(?x @float:48:27, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?x @float:48:27
Types:   Type = wybe.float
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types:     actual types     : [wybe.float,wybe.float]
Types:     actual modes     : [(ParamOut,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.float,wybe.float] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 48, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 48, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 48, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.comparison (-> wybe.comparison)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 48, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.float,wybe.float] with {test} wybe.float.=<0>(wybe.float,wybe.float)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Unifying types wybe.float (-> wybe.float) and wybe.float (-> wybe.float)
Types:   Unification yields wybe.float
Types: Matching types [wybe.float,wybe.float] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 48, column 27): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.float (-> wybe.float) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/float.wybe" (line 48, column 27): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.float.=<0>(wybe.float,wybe.float),Typing {tmp#0::0, x::wybe.float, y::wybe.float}; {0::wybe.float} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?x @float:48:27)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.float
Types:   Type = wybe.float
Types: Finding type of expr ?x @float:48:27
Types:   Type = wybe.float
Types:     types and modes = [wybe.float,?wybe.float]
Types: New instr = {foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:48:27)}
Types: Now assigned = semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '*='
Types: Mode checked body   : [{wybe.float.<0>*(x:wybe.float @float:48:31, y:wybe.float @float:48:35, ?tmp#0:wybe.float @float:48:31)} @float:48:31,{foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:48:27)} @float:48:27]
Types: Vars defined by body: semipure normal (total) computation binding {tmp#0, x, y}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of *=:
Types: 
Types: *= > public (0 calls)
Types: 4: *=(!x:wybe.float @float:48:11, y:wybe.float @float:48:19):
Types:     wybe.float.<0>*(x:wybe.float @float:48:31, y:wybe.float @float:48:35, ?tmp#0:wybe.float @float:48:31)
Types:     foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:48:27)
======================================================================
AFTER TYPE CHECK:
 Module wybe
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : 
  imports         : public use wybe.array
                    public use wybe.bool
                    public use wybe.c_string
                    public use wybe.char
                    public use wybe.comparison
                    public use wybe.control
                    public use wybe.count
                    public use wybe.float
                    public use wybe.int
                    public use wybe.io
                    public use wybe.list
                    public use wybe.machine_word
                    public use wybe.memory_management
                    public use wybe.phantom
                    public use wybe.predicate
                    public use wybe.range
                    public use wybe.string
  resources       : 
  submodules      : wybe.array, wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.control, wybe.count, wybe.float, wybe.int, wybe.io, wybe.list, wybe.machine_word, wybe.memory_management, wybe.phantom, wybe.predicate, wybe.range, wybe.string
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.array(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.array.[]<0>
                    wybe.array.[]<1>
                    wybe.array.[|]<0>
                    wybe.array.array<0>
                    wybe.array.array<1>
                    wybe.array.inbounds<0>
                    wybe.array.unsafe_get<0>
                    wybe.array.unsafe_update<0>
  imports         : public use wybe.array.raw_array
                    use wybe.bool
                    use wybe.int
                    use wybe.list
                    use wybe.machine_word
  resources       : 
  submodules      : wybe.array.raw_array
  procs           : 

[] > public {test} (0 calls)
0: [](a:_(T) @array:67:21, idx:int @array:67:29, ?#result:T @array:67:5):
    inbounds(a @array:68:14, idx @array:68:17)
    unsafe_get(a @array:69:10, idx @array:69:23, ?tmp#0 @array:69:10)
    =(?x @array:69:6, tmp#0)
    foreign llvm move(x @array:67:42, ?#result @array:67:5)
[] > public {test} (0 calls)
1: [](!a:_(T) @array:81:22, idx:int @array:81:30, x:T @array:81:39):
    inbounds(a @array:82:14, idx @array:82:17)
    unsafe_update(!a @array:83:20, idx @array:83:23, x @array:83:28)


[|] > public {test} (0 calls)
0: [|](?head:T @array:51:23, ?tail:_(T) @array:51:32, a:_(T) @array:51:43):
    array(?length @array:52:12, ?data @array:52:21, a @array:52:29)
    >(length @array:53:6, 0 @array:53:15)
    word_size_bytes(?tmp#0 @array:54:34)
    foreign lpvm access(data @array:54:25, 0 @array:54:31, tmp#0, 0 @array:54:51, ?head @array:54:55)
    word_size_bytes(?tmp#1 @array:55:28)
    foreign llvm add(data @array:55:22, tmp#1, ?data @array:55:46)
    -(length @array:56:19, 1 @array:56:28, ?tmp#3 @array:56:19)
    array(tmp#3, data @array:56:31, ?tmp#2 @array:56:13)
    =(?tail @array:56:6, tmp#2)


array > public (0 calls)
0: array(x:T @array:18:15, len:int @array:18:20, ?#result:_(T) @array:18:5):
    word_size_bytes(?tmp#1 @array:19:19)
    *(len @array:19:13, tmp#1, ?tmp#0 @array:19:13)
    =(?size @array:19:6, tmp#0)
    foreign lpvm alloc(size @array:20:24, ?data @array:20:31)
    =(?offset @array:21:6, 0 @array:21:15)
    do {
        if {<(offset @array:23:15, size @array:23:24)::

            pass
        else::
            break

        }
        foreign lpvm mutate(data @array:24:29, ?data @array:24:36, offset @array:24:42, 1 @array:24:50, size @array:24:53, 0 @array:24:59, x @array:24:62)
        word_size_bytes(?tmp#2 @array:25:21)
        +=(!offset @array:25:10, tmp#2)
    }
    array(len @array:27:17, data @array:27:22, ?tmp#3 @array:27:11)
    =(?ar @array:27:6, tmp#3)
    foreign llvm move(ar @array:18:36, ?#result @array:18:5)
array > public (0 calls)
1: array(ls:list(T) @array:34:15, ?#result:_(T) @array:34:5):
    length(ls @array:35:19, ?tmp#0 @array:35:12)
    =(?len @array:35:6, tmp#0)
    word_size_bytes(?tmp#2 @array:36:19)
    *(len @array:36:13, tmp#2, ?tmp#1 @array:36:13)
    =(?size @array:36:6, tmp#1)
    foreign lpvm alloc(size @array:37:24, ?data @array:37:31)
    =(?offset @array:38:6, 0 @array:38:15)
    foreign llvm move(ls @array:39:15, ?tmp#3)
    do {
        if {[|](?x @array:39:10, ?tmp#3, tmp#3)::

            foreign lpvm mutate(data @array:40:29, ?data @array:40:36, offset @array:40:42, 1 @array:40:50, size @array:40:53, 0 @array:40:59, x @array:40:62)
            word_size_bytes(?tmp#4 @array:41:21)
            +=(!offset @array:41:10, tmp#4)
        else::
            break

        }
    }
    array(len @array:43:17, data @array:43:22, ?tmp#5 @array:43:11)
    =(?ar @array:43:6, tmp#5)
    foreign llvm move(ar @array:34:34, ?#result @array:34:5)


inbounds > public {test,inline} (0 calls)
0: inbounds(a:_(T) @array:60:33, idx:int @array:60:41):
    <=(0 @array:61:6, idx @array:61:12)
    length(a @array:62:12, ?tmp#0 @array:62:12)
    <(idx @array:62:6, tmp#0)


unsafe_get > public {inline} (0 calls)
0: unsafe_get(a:_(T) @array:75:29, idx:int @array:75:37, ?#result:T @array:75:5):
    raw_data(a @array:76:25, ?tmp#0 @array:76:25)
    word_size_bytes(?tmp#2 @array:76:43)
    *(idx @array:76:37, tmp#2, ?tmp#1 @array:76:37)
    word_size_bytes(?tmp#3 @array:76:60)
    foreign lpvm access(tmp#0, tmp#1, tmp#3, 0 @array:76:77, ?x @array:76:81)
    foreign llvm move(x @array:75:50, ?#result @array:75:5)


unsafe_update > public {inline} (0 calls)
0: unsafe_update(!a:_(T) @array:89:33, idx:int @array:89:41, x:T @array:89:50):
    raw_data(a @array:90:25, ?tmp#0 @array:90:25)
    word_size_bytes(?tmp#2 @array:90:50)
    *(idx @array:90:44, tmp#2, ?tmp#1 @array:90:44)
    length(a @array:91:44, ?tmp#4 @array:91:44)
    word_size_bytes(?tmp#5 @array:91:55)
    *(tmp#4, tmp#5, ?tmp#3 @array:91:44)
    foreign lpvm mutate(tmp#0, ?data @array:90:38, tmp#1, 0 @array:90:67, tmp#3, 0 @array:91:72, x @array:91:75)
    raw_data(!a @array:92:6, data @array:92:19)

LLVM code       : None

--------------------------------------------------
 Module wybe.array.raw_array(T)
  representation  : address
  public submods  : 
  public resources: 
  public procs    : 
  imports         : use wybe
                    use wybe.array
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.bool
  representation  : 1 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.bool.&&<0>
                    wybe.bool.&=<0>
                    wybe.bool.=<0>
                    wybe.bool.^=<0>
                    wybe.bool.^^<0>
                    wybe.bool.false<0>
                    wybe.bool.print<0>
                    wybe.bool.println<0>
                    wybe.bool.succeed<0>
                    wybe.bool.true<0>
                    wybe.bool.|=<0>
                    wybe.bool.||<0>
                    wybe.bool.~<0>
                    wybe.bool.~=<0>
  imports         : use wybe.c_string
                    use wybe.io
  resources       : 
  procs           : 

&& > public {inline} (1 calls)
0: wybe.bool.&&<0>
&&(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:13:27


&= > public {inline} (0 calls)
0: wybe.bool.&=<0>
&=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:13:27


= > public {inline} (0 calls)
0: wybe.bool.=<0>
=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:37:26


^= > public {inline} (0 calls)
0: wybe.bool.^=<0>
^=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:25:27


^^ > public {inline} (1 calls)
0: wybe.bool.^^<0>
^^(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:25:27


false > public {inline} (0 calls)
0: wybe.bool.false<0>
false(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.bool, ?#result##0:wybe.bool)


print > public (1 calls)
0: wybe.bool.print<0>
print(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    case ~x##0:wybe.bool of
    0:
        wybe.c_string.print<0>(c"false":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #1 @bool:47:31

    1:
        wybe.c_string.print<0>(c"true":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:47:31



println > public {inline} (0 calls)
0: wybe.bool.println<0>
println(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.bool.print<0>(~x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:49:33
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#0##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~tmp#0##0:wybe.phantom, ?tmp#1##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#1##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


succeed > public {inline} (0 calls)
0: wybe.bool.succeed<0>
succeed()<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []


true > public {inline} (1 calls)
0: wybe.bool.true<0>
true(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.bool, ?#result##0:wybe.bool)


|= > public {inline} (0 calls)
0: wybe.bool.|=<0>
|=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:19:27


|| > public {inline} (1 calls)
0: wybe.bool.||<0>
||(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:19:27


~ > public {inline} (0 calls)
0: wybe.bool.~<0>
~(p##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, 1:wybe.bool, ?#result##0:wybe.bool) @bool:31:20


~= > public {inline} (0 calls)
0: wybe.bool.~=<0>
~=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:38:27

LLVM code       : None

--------------------------------------------------
 Module wybe.c_string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.c_string.<<0>
                    wybe.c_string.<=<0>
                    wybe.c_string.=<0>
                    wybe.c_string.><0>
                    wybe.c_string.>=<0>
                    wybe.c_string.[]<0>
                    wybe.c_string.[|]<0>
                    wybe.c_string.length<0>
                    wybe.c_string.print<0>
                    wybe.c_string.println<0>
                    wybe.c_string.read<0>
                    wybe.c_string.unsafe_c_string_index<0>
                    wybe.c_string.~=<0>
  imports         : use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.c_string.<<0>
<(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:12:29
    wybe.int.<<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:12:29


<= > public {inline} (0 calls)
0: wybe.c_string.<=<0>
<=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:13:30
    wybe.int.<=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:13:30


= > public {inline} (0 calls)
0: wybe.c_string.=<0>
=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:10:29
    wybe.int.=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:10:29


> > public {inline} (0 calls)
0: wybe.c_string.><0>
>(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:14:29
    wybe.int.><0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:14:29


>= > public {inline} (0 calls)
0: wybe.c_string.>=<0>
>=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:15:30
    wybe.int.>=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:15:30


[] > public (0 calls)
0: wybe.c_string.[]<0>
[](str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, idx##0:wybe.int, ?tmp#2##0:wybe.bool) #0 @c_string:27:6
    case ~tmp#2##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        foreign c strlen(str##0:wybe.c_string, ?tmp#0##0:wybe.int) @c_string:17:29
        wybe.int.<<0>(idx##0:wybe.int, ~tmp#0##0:wybe.int, ?tmp#3##0:wybe.bool) #2 @c_string:28:6
        case ~tmp#3##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




[|] > public (0 calls)
0: wybe.c_string.[|]<0>
[|](?head##0:wybe.char, ?tail##0:wybe.c_string, str##0:wybe.c_string, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(str##0:wybe.c_string, 0:wybe.int, 0:wybe.int, 0:wybe.int, ?head##0:wybe.char) @c_string:20:5
    foreign llvm icmp_ne(head##0:wybe.char, '\NUL':wybe.char, ?not_done##0:wybe.bool) @c_string:21:5
    foreign llvm icmp_eq(~not_done##0:wybe.bool, 1:wybe.bool, ?tmp#1##0:wybe.bool) @bool:37:26
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.c_string, ?tail##0:wybe.c_string)

    1:
        foreign llvm add(~str##0:wybe.c_string, 1:wybe.int, ?tail##0:wybe.c_string) @c_string:23:5
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



length > public {inline} (3 calls)
0: wybe.c_string.length<0>
length(str##0:wybe.c_string, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strlen(~str##0:wybe.c_string, ?#result##0:wybe.int) @c_string:17:29


print > public {inline} (1 calls)
0: wybe.c_string.print<0>
print(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:35:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:35:30


println > public {inline} (0 calls)
0: wybe.c_string.println<0>
println(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @c_string:35:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.c_string.read<0>
read(?x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:39:30
    foreign c read_line(?x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:39:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:39:30


unsafe_c_string_index > public {inline} (1 calls)
0: wybe.c_string.unsafe_c_string_index<0>
unsafe_c_string_index(str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7


~= > public {inline} (0 calls)
0: wybe.c_string.~=<0>
~=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:11:30
    wybe.int.~=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.char
  representation  : 8 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.char.<<0>
                    wybe.char.<=<0>
                    wybe.char.<=><0>
                    wybe.char.=<0>
                    wybe.char.><0>
                    wybe.char.>=<0>
                    wybe.char.chr<0>
                    wybe.char.ord<0>
                    wybe.char.print<0>
                    wybe.char.println<0>
                    wybe.char.read<0>
                    wybe.char.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (4 calls)
0: wybe.char.<<0>
<(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:17:29


<= > public {inline} (0 calls)
0: wybe.char.<=<0>
<=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:18:30


<=> > public (0 calls)
0: wybe.char.<=><0>
<=>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.char, y##0:wybe.char, ?tmp#6##0:wybe.bool) @char:17:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?tmp#5##0:wybe.bool) @char:13:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5



= > public {inline} (2 calls)
0: wybe.char.=<0>
=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:13:29


> > public {inline} (0 calls)
0: wybe.char.><0>
>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:19:29


>= > public {inline} (0 calls)
0: wybe.char.>=<0>
>=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:20:30


chr > public (0 calls)
0: wybe.char.chr<0>
chr(i##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, i##0:wybe.int, ?tmp#1##0:wybe.bool) #0 @char:33:60
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        wybe.int.<=<0>(i##0:wybe.int, 255:wybe.int, ?tmp#2##0:wybe.bool) #1 @char:33:70
        case ~tmp#2##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm cast(~i##0:wybe.int, ?#result##0:wybe.char) @char:33:31
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




ord > public {inline} (0 calls)
0: wybe.char.ord<0>
ord(c##0:wybe.char, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(~c##0:wybe.char, ?#result##0:wybe.int) @char:30:24


print > public {inline} (1 calls)
0: wybe.char.print<0>
print(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:37:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:37:30


println > public {inline} (0 calls)
0: wybe.char.println<0>
println(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @char:37:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.char.read<0>
read(?x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:41:30
    foreign c read_char(?x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:41:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:41:30


~= > public {inline} (0 calls)
0: wybe.char.~=<0>
~=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:14:30

LLVM code       : None

--------------------------------------------------
 Module wybe.comparison
  representation  : 2 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.comparison.<<0>
                    wybe.comparison.<=<0>
                    wybe.comparison.=<0>
                    wybe.comparison.><0>
                    wybe.comparison.>=<0>
                    wybe.comparison.equal<0>
                    wybe.comparison.greater<0>
                    wybe.comparison.lesser<0>
                    wybe.comparison.~=<0>
  imports         : use wybe.bool
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.comparison.<<0>
<(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:12:29


<= > public {inline} (0 calls)
0: wybe.comparison.<=<0>
<=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:13:30


= > public {inline} (0 calls)
0: wybe.comparison.=<0>
=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:10:29


> > public {inline} (0 calls)
0: wybe.comparison.><0>
>(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:14:29


>= > public {inline} (0 calls)
0: wybe.comparison.>=<0>
>=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:15:30


equal > public {inline} (0 calls)
0: wybe.comparison.equal<0>
equal(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison)


greater > public {inline} (0 calls)
0: wybe.comparison.greater<0>
greater(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison)


lesser > public {inline} (0 calls)
0: wybe.comparison.lesser<0>
lesser(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison)


~= > public {inline} (0 calls)
0: wybe.comparison.~=<0>
~=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.control
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.control.assert<0>
                    wybe.control.error<0>
                    wybe.control.error<1>
                    wybe.control.exit<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.int
                    use wybe.string
  resources       : 
  procs           : 

assert > public {semipure} (0 calls)
0: assert(condition:bool @control:26:27) use call_source_location:
    if {~(condition @control:27:11)::

        !error(c"assertion failed" @control:27:31)
    else::
        pass

    }


error > public {terminal,semipure} (0 calls)
0: error(message:string @control:17:35) use call_source_location:
    c_string(message @control:18:77, ?tmp#0 @control:18:68)
    foreign c {terminal,semipure} error_exit(call_source_location @control:18:46, tmp#0)
error > public {terminal,semipure} (0 calls)
1: error(message:c_string @control:21:35) use call_source_location:
    foreign c {terminal,semipure} error_exit(call_source_location @control:22:46, message @control:22:68)


exit > public {terminal,semipure} (0 calls)
0: exit(code:int @control:10:34):
    foreign c {terminal,semipure} exit(code @control:11:40)

LLVM code       : None

--------------------------------------------------
 Module wybe.count
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.count.%<0>
                    wybe.count.%=<0>
                    wybe.count.*<0>
                    wybe.count.*=<0>
                    wybe.count.+<0>
                    wybe.count.+<1>
                    wybe.count.+<2>
                    wybe.count.+=<0>
                    wybe.count.-<0>
                    wybe.count.-<1>
                    wybe.count.-<2>
                    wybe.count.-=<0>
                    wybe.count./<0>
                    wybe.count./=<0>
                    wybe.count.<<0>
                    wybe.count.<=<0>
                    wybe.count.<=><0>
                    wybe.count.=<0>
                    wybe.count.><0>
                    wybe.count.>=<0>
                    wybe.count.decr<0>
                    wybe.count.incr<0>
                    wybe.count.max<0>
                    wybe.count.min<0>
                    wybe.count.print<0>
                    wybe.count.println<0>
                    wybe.count.read<0>
                    wybe.count.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.count.%<0>
%(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:51:25


%= > public {inline} (0 calls)
0: wybe.count.%=<0>
%=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:51:25


* > public {inline} (1 calls)
0: wybe.count.*<0>
*(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:39:25


*= > public {inline} (0 calls)
0: wybe.count.*=<0>
*=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:39:25


+ > public {inline} (2 calls)
0: wybe.count.+<0>
+(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:15:25
+ > public (0 calls)
1: wybe.count.+<1>
+(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(y##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?x##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~y##0:wybe.count, ?x##0:wybe.count) @count:18:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

+ > public (0 calls)
2: wybe.count.+<2>
+(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?y##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:22:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



+= > public {inline} (0 calls)
0: wybe.count.+=<0>
+=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:15:25


- > public (6 calls)
0: wybe.count.-<0>
-(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?#result##0:wybe.count)

    1:
        foreign llvm sub(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:31:35
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

- > public {inline} (0 calls)
1: wybe.count.-<1>
-(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.count, ~z##0:wybe.count, ?x##0:wybe.count) @count:32:42
- > public {inline} (0 calls)
2: wybe.count.-<2>
-(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:33:42


-= > public (0 calls)
0: wybe.count.-=<0>
-=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, ~y##0:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:36:41
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:36:37
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



/ > public {inline} (1 calls)
0: wybe.count./<0>
/(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:45:25


/= > public {inline} (0 calls)
0: wybe.count./=<0>
/=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:45:25


< > public {inline} (4 calls)
0: wybe.count.<<0>
<(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:64:29


<= > public {inline} (3 calls)
0: wybe.count.<=<0>
<=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:65:30


<=> > public (0 calls)
0: wybe.count.<=><0>
<=>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.count, y##0:wybe.count, ?tmp#6##0:wybe.bool) @count:64:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?tmp#5##0:wybe.bool) @count:60:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5



= > public {inline} (2 calls)
0: wybe.count.=<0>
=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:60:29


> > public {inline} (0 calls)
0: wybe.count.><0>
>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:66:29


>= > public {inline} (12 calls)
0: wybe.count.>=<0>
>=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:67:30


decr > public (0 calls)
0: wybe.count.decr<0>
decr(x##0:wybe.count, ?x##1:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, 1:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:84:37
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:84:33
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



incr > public {inline} (0 calls)
0: wybe.count.incr<0>
incr(x##0:wybe.count, ?x##1:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, 1:wybe.count, ?x##1:wybe.count) @count:15:25


max > public (0 calls)
0: wybe.count.max<0>
max(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:75:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:75:5



min > public (0 calls)
0: wybe.count.min<0>
min(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:65:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:74:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:74:5



print > public {inline} (1 calls)
0: wybe.count.print<0>
print(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:88:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:88:30


println > public {inline} (0 calls)
0: wybe.count.println<0>
println(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @count:88:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.count.read<0>
read(?x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:92:30
    foreign c read_count(?x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:92:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:92:30


~= > public {inline} (0 calls)
0: wybe.count.~=<0>
~=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:61:30

LLVM code       : None

--------------------------------------------------
 Module wybe.float
  representation  : 64 bit float
  public submods  : 
  public resources: 
  public procs    : wybe.float.*<0>
                    wybe.float.**<0>
                    wybe.float.*=<0>
                    wybe.float.+<0>
                    wybe.float.+<1>
                    wybe.float.+<2>
                    wybe.float.+=<0>
                    wybe.float.-<0>
                    wybe.float.-<1>
                    wybe.float.-<2>
                    wybe.float.-<3>
                    wybe.float.-<4>
                    wybe.float.-=<0>
                    wybe.float./<0>
                    wybe.float./=<0>
                    wybe.float.<<0>
                    wybe.float.<=<0>
                    wybe.float.<=><0>
                    wybe.float.=<0>
                    wybe.float.><0>
                    wybe.float.>=<0>
                    wybe.float.abs<0>
                    wybe.float.ceil<0>
                    wybe.float.cos<0>
                    wybe.float.e<0>
                    wybe.float.exp<0>
                    wybe.float.floor<0>
                    wybe.float.iceil<0>
                    wybe.float.ifloor<0>
                    wybe.float.iround<0>
                    wybe.float.log<0>
                    wybe.float.log10<0>
                    wybe.float.log2<0>
                    wybe.float.max<0>
                    wybe.float.min<0>
                    wybe.float.pi<0>
                    wybe.float.power<0>
                    wybe.float.print<0>
                    wybe.float.println<0>
                    wybe.float.read<0>
                    wybe.float.round<0>
                    wybe.float.sin<0>
                    wybe.float.sqrt<0>
                    wybe.float.square<0>
                    wybe.float.tan<0>
                    wybe.float.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

* > public (0 calls)
0: *(x:wybe.float @float:45:10, y:wybe.float @float:45:16, ?#result:wybe.float @float:45:5):
    foreign llvm fmul(x:wybe.float @float:45:43, y:wybe.float @float:45:45, ?tmp#0:wybe.float @float:45:25)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:45:5)


** > public (0 calls)
0: **(x:wybe.float @float:112:10, n:wybe.float @float:112:18, ?#result:wybe.float @float:112:5):
    foreign c llvm.pow.f64(x:wybe.float @float:112:52, n:wybe.float @float:112:54, ?tmp#0:wybe.float @float:112:27)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:112:5)


*= > public (0 calls)
0: *=(!x:wybe.float @float:48:11, y:wybe.float @float:48:19):
    wybe.float.<0>*(x:wybe.float @float:48:31, y:wybe.float @float:48:35, ?tmp#0:wybe.float @float:48:31)
    foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:48:27)


+ > public (0 calls)
0: +(x:wybe.float @float:23:10, y:wybe.float @float:23:17, ?#result:wybe.float @float:23:5):
    foreign llvm fadd(x:wybe.float @float:23:45, y:wybe.float @float:23:47, ?tmp#0:wybe.float @float:23:27)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:23:5)
+ > public (0 calls)
1: +(?x:wybe.float @float:24:11, y:wybe.float @float:24:17, z:wybe.float @float:24:5):
    foreign llvm fsub(z:wybe.float @float:24:61, y:wybe.float @float:24:63, ?tmp#0:wybe.float @float:24:43)
    foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:24:39)
+ > public (0 calls)
2: +(x:wybe.float @float:25:10, ?y:wybe.float @float:25:18, z:wybe.float @float:25:5):
    foreign llvm fsub(z:wybe.float @float:25:61, x:wybe.float @float:25:63, ?tmp#0:wybe.float @float:25:43)
    foreign llvm move(tmp#0:wybe.float, ?y:wybe.float @float:25:39)


+= > public (0 calls)
0: +=(!x:wybe.float @float:28:11, y:wybe.float @float:28:19):
    wybe.float.<0>+(x:wybe.float @float:28:31, y:wybe.float @float:28:35, ?tmp#0:wybe.float @float:28:31)
    foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:28:27)


- > public (0 calls)
0: -(x:wybe.float @float:32:10, y:wybe.float @float:32:17, ?#result:wybe.float @float:32:5):
    foreign llvm fsub(x:wybe.float @float:32:45, y:wybe.float @float:32:47, ?tmp#0:wybe.float @float:32:27)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:32:5)
- > public (0 calls)
1: -(?x:wybe.float @float:33:11, y:wybe.float @float:33:17, z:wybe.float @float:33:5):
    foreign llvm fadd(z:wybe.float @float:33:61, y:wybe.float @float:33:63, ?tmp#0:wybe.float @float:33:43)
    foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:33:39)
- > public (0 calls)
2: -(x:wybe.float @float:34:10, ?y:wybe.float @float:34:18, z:wybe.float @float:34:5):
    foreign llvm fsub(z:wybe.float @float:34:61, x:wybe.float @float:34:63, ?tmp#0:wybe.float @float:34:43)
    foreign llvm move(tmp#0:wybe.float, ?y:wybe.float @float:34:39)
- > public (0 calls)
3: -(x:wybe.float @float:38:11, ?#result:wybe.float @float:38:5):
    foreign llvm fsub(0.0:wybe.float @float:38:39, x:wybe.float @float:38:43, ?tmp#0:wybe.float @float:38:21)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:38:5)
- > public (0 calls)
4: -(?x:wybe.float @float:39:12, y:wybe.float @float:39:5):
    foreign llvm fsub(0.0:wybe.float @float:39:55, y:wybe.float @float:39:59, ?tmp#0:wybe.float @float:39:37)
    foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:39:33)


-= > public (0 calls)
0: -=(!x:wybe.float @float:42:11, y:wybe.float @float:42:19):
    wybe.float.<0>-(x:wybe.float @float:42:31, y:wybe.float @float:42:35, ?tmp#0:wybe.float @float:42:31)
    foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:42:27)


/ > public (0 calls)
0: /(x:wybe.float @float:51:10, y:wybe.float @float:51:16, ?#result:wybe.float @float:51:5):
    foreign llvm fdiv(x:wybe.float @float:51:43, y:wybe.float @float:51:45, ?tmp#0:wybe.float @float:51:25)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:51:5)


/= > public (0 calls)
0: /=(!x:wybe.float @float:54:11, y:wybe.float @float:54:19):
    wybe.float.<0>/(x:wybe.float @float:54:31, y:wybe.float @float:54:35, ?tmp#0:wybe.float @float:54:31)
    foreign llvm move(tmp#0:wybe.float, ?x:wybe.float @float:54:27)


< > public (0 calls)
0: <(x:wybe.float @float:70:10, y:wybe.float @float:70:17, ?#result:wybe.bool @float:70:5):
    foreign llvm fcmp_slt(x:wybe.float @float:70:51, y:wybe.float @float:70:53, ?tmp#0:wybe.bool @float:70:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:70:5)


<= > public (0 calls)
0: <=(x:wybe.float @float:71:10, y:wybe.float @float:71:18, ?#result:wybe.bool @float:71:5):
    foreign llvm fcmp_sle(x:wybe.float @float:71:52, y:wybe.float @float:71:54, ?tmp#0:wybe.bool @float:71:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:71:5)


<=> > public (0 calls)
0: <=>(x:wybe.float @float:76:10, y:wybe.float @float:76:20, ?#result:wybe.comparison @float:76:5):
    if {wybe.float.<0><(x:wybe.float @float:77:10, y:wybe.float @float:77:14)::

        wybe.comparison.<0>lesser(?tmp#1:wybe.comparison @float:77:19)
        foreign llvm move(tmp#1:wybe.comparison, ?tmp#0:wybe.comparison)
    else::
        if {wybe.float.<0>=(x:wybe.float @float:77:28, y:wybe.float @float:77:32)::

            wybe.comparison.<0>equal(?tmp#3:wybe.comparison @float:77:37)
            foreign llvm move(tmp#3:wybe.comparison, ?tmp#2:wybe.comparison)
        else::
            wybe.comparison.<0>greater(?tmp#4:wybe.comparison @float:77:53)
            foreign llvm move(tmp#4:wybe.comparison, ?tmp#2:wybe.comparison)

        }
   condition -> {x::wybe.float, y::wybe.float}
   then&else -> {tmp#2::wybe.comparison, x::wybe.float, y::wybe.float}
        foreign llvm move(tmp#2:wybe.comparison @float:77:28, ?tmp#0:wybe.comparison)

    }
   condition -> {x::wybe.float, y::wybe.float}
   then&else -> {tmp#0::wybe.comparison, x::wybe.float, y::wybe.float}
    foreign llvm move(tmp#0:wybe.comparison @float:77:10, ?#result:wybe.comparison @float:76:5)


= > public (0 calls)
0: =(x:wybe.float @float:66:10, y:wybe.float @float:66:17, ?#result:wybe.bool @float:66:5):
    foreign llvm fcmp_eq(x:wybe.float @float:66:50, y:wybe.float @float:66:52, ?tmp#0:wybe.bool @float:66:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:66:5)


> > public (0 calls)
0: >(x:wybe.float @float:72:10, y:wybe.float @float:72:17, ?#result:wybe.bool @float:72:5):
    foreign llvm fcmp_sgt(x:wybe.float @float:72:51, y:wybe.float @float:72:53, ?tmp#0:wybe.bool @float:72:29)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:72:5)


>= > public (0 calls)
0: >=(x:wybe.float @float:73:10, y:wybe.float @float:73:18, ?#result:wybe.bool @float:73:5):
    foreign llvm fcmp_sge(x:wybe.float @float:73:52, y:wybe.float @float:73:54, ?tmp#0:wybe.bool @float:73:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:73:5)


abs > public (0 calls)
0: abs(x:wybe.float @float:60:13, ?#result:wybe.float @float:60:5):
    foreign c llvm.fabs.f64(x:wybe.float @float:60:48, ?tmp#0:wybe.float @float:60:22)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:60:5)


ceil > public (0 calls)
0: ceil(x:wybe.float @float:87:14, ?#result:wybe.float @float:87:5):
    foreign c llvm.ceil.f64(x:wybe.float @float:87:49, ?tmp#0:wybe.float @float:87:23)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:87:5)


cos > public (0 calls)
0: cos(x:wybe.float @float:116:13, ?#result:wybe.float @float:116:5):
    foreign c llvm.cos.f64(x:wybe.float @float:116:47, ?tmp#0:wybe.float @float:116:22)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:116:5)


e > public (0 calls)
0: e(?#result:wybe.float @float:16:5):
    foreign llvm move(2.7182818284590455:wybe.float @float:16:15, ?#result:wybe.float @float:16:5)


exp > public (0 calls)
0: exp(x:wybe.float @float:120:13, ?#result:wybe.float @float:120:5):
    foreign c llvm.exp.f64(x:wybe.float @float:120:47, ?tmp#0:wybe.float @float:120:22)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:120:5)


floor > public (0 calls)
0: floor(x:wybe.float @float:90:15, ?#result:wybe.float @float:90:5):
    foreign c llvm.floor.f64(x:wybe.float @float:90:51, ?tmp#0:wybe.float @float:90:24)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:90:5)


iceil > public (0 calls)
0: iceil(x:wybe.float @float:99:15, ?#result:wybe.int @float:99:5):
    wybe.float.<0>ceil(x:wybe.float @float:99:51, ?tmp#1:wybe.float @float:99:46)
    foreign llvm fptosi(tmp#1:wybe.float, ?tmp#0:wybe.int @float:99:26)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @float:99:5)


ifloor > public (0 calls)
0: ifloor(x:wybe.float @float:102:16, ?#result:wybe.int @float:102:5):
    wybe.float.<0>floor(x:wybe.float @float:102:53, ?tmp#1:wybe.float @float:102:47)
    foreign llvm fptosi(tmp#1:wybe.float, ?tmp#0:wybe.int @float:102:27)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @float:102:5)


iround > public (0 calls)
0: iround(x:wybe.float @float:96:16, ?#result:wybe.int @float:96:5):
    wybe.float.<0>round(x:wybe.float @float:96:53, ?tmp#1:wybe.float @float:96:47)
    foreign llvm fptosi(tmp#1:wybe.float, ?tmp#0:wybe.int @float:96:27)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @float:96:5)


log > public (0 calls)
0: log(x:wybe.float @float:123:13, ?#result:wybe.float @float:123:5):
    foreign c llvm.log.f64(x:wybe.float @float:123:47, ?tmp#0:wybe.float @float:123:22)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:123:5)


log10 > public (0 calls)
0: log10(x:wybe.float @float:126:15, ?#result:wybe.float @float:126:5):
    foreign c llvm.log10.f64(x:wybe.float @float:126:51, ?tmp#0:wybe.float @float:126:24)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:126:5)


log2 > public (0 calls)
0: log2(x:wybe.float @float:129:14, ?#result:wybe.float @float:129:5):
    foreign c llvm.log2.f64(x:wybe.float @float:129:49, ?tmp#0:wybe.float @float:129:23)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:129:5)


max > public (0 calls)
0: max(x:wybe.float @float:81:13, y:wybe.float @float:81:18, ?#result:wybe.float @float:81:5):
    foreign c llvm.maxnum.f64(x:wybe.float @float:81:55, y:wybe.float @float:81:57, ?tmp#0:wybe.float @float:81:27)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:81:5)


min > public (0 calls)
0: min(x:wybe.float @float:80:13, y:wybe.float @float:80:18, ?#result:wybe.float @float:80:5):
    foreign c llvm.minnum.f64(x:wybe.float @float:80:55, y:wybe.float @float:80:57, ?tmp#0:wybe.float @float:80:27)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:80:5)


pi > public (0 calls)
0: pi(?#result:wybe.float @float:13:5):
    foreign llvm move(3.141592653589793:wybe.float @float:13:16, ?#result:wybe.float @float:13:5)


power > public (0 calls)
0: power(x:wybe.float @float:111:15, n:wybe.float @float:111:19, ?#result:wybe.float @float:111:5):
    foreign c llvm.pow.f64(x:wybe.float @float:111:53, n:wybe.float @float:111:55, ?tmp#0:wybe.float @float:111:28)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:111:5)


print > public (0 calls)
0: print(x:wybe.float @float:133:15) use !wybe.io.io:
    foreign c print_float(x:wybe.float @float:133:52, !io:wybe.phantom @float:133:56)


println > public (0 calls)
0: println(x:wybe.float @float:135:17) use !wybe.io.io:
    !wybe.float.<0>print(x:wybe.float @float:135:39)
    !wybe.io.<0>nl


read > public (0 calls)
0: read(?x:wybe.float @float:137:15) use !wybe.io.io:
    foreign c read_float(?x:wybe.float @float:137:52, !io:wybe.phantom @float:137:56)


round > public (0 calls)
0: round(x:wybe.float @float:93:15, ?#result:wybe.float @float:93:5):
    foreign c llvm.round.f64(x:wybe.float @float:93:51, ?tmp#0:wybe.float @float:93:24)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:93:5)


sin > public (0 calls)
0: sin(x:wybe.float @float:115:13, ?#result:wybe.float @float:115:5):
    foreign c llvm.sin.f64(x:wybe.float @float:115:47, ?tmp#0:wybe.float @float:115:22)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:115:5)


sqrt > public (0 calls)
0: sqrt(x:wybe.float @float:108:14, ?#result:wybe.float @float:108:5):
    foreign c llvm.sqrt.f64(x:wybe.float @float:108:49, ?tmp#0:wybe.float @float:108:23)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:108:5)


square > public (0 calls)
0: square(x:wybe.float @float:57:16, ?#result:wybe.float @float:57:5):
    foreign llvm fmul(x:wybe.float @float:57:43, x:wybe.float @float:57:45, ?tmp#0:wybe.float @float:57:25)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:57:5)


tan > public (0 calls)
0: tan(x:wybe.float @float:117:13, ?#result:wybe.float @float:117:5):
    foreign c llvm.sin.f64(x:wybe.float @float:117:47, ?tmp#1:wybe.float @float:117:22)
    foreign c llvm.cos.f64(x:wybe.float @float:117:77, ?tmp#2:wybe.float @float:117:52)
    wybe.float.<0>/(tmp#1:wybe.float, tmp#2:wybe.float, ?tmp#0:wybe.float @float:117:22)
    foreign llvm move(tmp#0:wybe.float, ?#result:wybe.float @float:117:5)


~= > public (0 calls)
0: ~=(x:wybe.float @float:67:10, y:wybe.float @float:67:18, ?#result:wybe.bool @float:67:5):
    foreign llvm fcmp_ne(x:wybe.float @float:67:51, y:wybe.float @float:67:53, ?tmp#0:wybe.bool @float:67:30)
    foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @float:67:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.int
  representation  : 64 bit signed
  public submods  : 
  public resources: 
  public procs    : wybe.int.%<0>
                    wybe.int.%=<0>
                    wybe.int.*<0>
                    wybe.int.*=<0>
                    wybe.int.+<0>
                    wybe.int.+<1>
                    wybe.int.+<2>
                    wybe.int.+=<0>
                    wybe.int.-<0>
                    wybe.int.-<1>
                    wybe.int.-<2>
                    wybe.int.-<3>
                    wybe.int.-<4>
                    wybe.int.-=<0>
                    wybe.int./<0>
                    wybe.int./=<0>
                    wybe.int.<<0>
                    wybe.int.<<<0>
                    wybe.int.<<=<0>
                    wybe.int.<=<0>
                    wybe.int.<=><0>
                    wybe.int.=<0>
                    wybe.int.><0>
                    wybe.int.>=<0>
                    wybe.int.>><0>
                    wybe.int.>>=<0>
                    wybe.int.decr<0>
                    wybe.int.incr<0>
                    wybe.int.logical_bitshift<0>
                    wybe.int.logical_bitshift<1>
                    wybe.int.max<0>
                    wybe.int.min<0>
                    wybe.int.power<0>
                    wybe.int.print<0>
                    wybe.int.println<0>
                    wybe.int.read<0>
                    wybe.int.signum<0>
                    wybe.int.sqrt<0>
                    wybe.int.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.int.%<0>
%(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:50:25


%= > public {inline} (0 calls)
0: wybe.int.%=<0>
%=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:50:25


* > public {inline} (1 calls)
0: wybe.int.*<0>
*(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:38:25


*= > public {inline} (0 calls)
0: wybe.int.*=<0>
*=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:38:25


+ > public {inline} (2 calls)
0: wybe.int.+<0>
+(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:16:27
+ > public {inline} (0 calls)
1: wybe.int.+<1>
+(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:17:43
+ > public {inline} (0 calls)
2: wybe.int.+<2>
+(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:18:43


+= > public {inline} (0 calls)
0: wybe.int.+=<0>
+=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:16:27


- > public {inline} (2 calls)
0: wybe.int.-<0>
-(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:25:27
- > public {inline} (0 calls)
1: wybe.int.-<1>
-(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.int, ~z##0:wybe.int, ?x##0:wybe.int) @int:26:43
- > public {inline} (0 calls)
2: wybe.int.-<2>
-(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:27:43
- > public {inline} (0 calls)
3: wybe.int.-<3>
-(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~x##0:wybe.int, ?#result##0:wybe.int) @int:31:21
- > public {inline} (0 calls)
4: wybe.int.-<4>
-(?x##0:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:32:37


-= > public {inline} (0 calls)
0: wybe.int.-=<0>
-=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:25:27


/ > public {inline} (1 calls)
0: wybe.int./<0>
/(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:44:25


/= > public {inline} (0 calls)
0: wybe.int./=<0>
/=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:44:25


< > public {inline} (4 calls)
0: wybe.int.<<0>
<(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:87:29


<< > public {inline} (1 calls)
0: wybe.int.<<<0>
<<(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:56:27


<<= > public {inline} (0 calls)
0: wybe.int.<<=<0>
<<=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:56:27


<= > public {inline} (3 calls)
0: wybe.int.<=<0>
<=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:88:30


<=> > public (0 calls)
0: wybe.int.<=><0>
<=>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(x##0:wybe.int, y##0:wybe.int, ?tmp#6##0:wybe.bool) @int:87:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?tmp#5##0:wybe.bool) @int:83:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5



= > public {inline} (2 calls)
0: wybe.int.=<0>
=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:83:29


> > public {inline} (0 calls)
0: wybe.int.><0>
>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sgt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:89:29


>= > public {inline} (3 calls)
0: wybe.int.>=<0>
>=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:90:30


>> > public {inline} (1 calls)
0: wybe.int.>><0>
>>(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:65:27


>>= > public {inline} (0 calls)
0: wybe.int.>>=<0>
>>=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:65:27


decr > public {inline} (0 calls)
0: wybe.int.decr<0>
decr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:25:27


incr > public {inline} (0 calls)
0: wybe.int.incr<0>
incr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:16:27


logical_bitshift > public {inline} (1 calls)
0: wybe.int.logical_bitshift<0>
logical_bitshift(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:74:40
logical_bitshift > public {inline} (0 calls)
1: wybe.int.logical_bitshift<1>
logical_bitshift(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:74:40


max > public (0 calls)
0: wybe.int.max<0>
max(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:90:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:98:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:98:5



min > public (0 calls)
0: wybe.int.min<0>
min(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:88:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:97:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:97:5



power > public {inline} (0 calls)
0: wybe.int.power<0>
power(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c ipow(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:107:29


print > public {inline} (1 calls)
0: wybe.int.print<0>
print(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:119:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:119:30


println > public {inline} (0 calls)
0: wybe.int.println<0>
println(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @int:119:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.int.read<0>
read(?x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:123:30
    foreign c read_int(?x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:123:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:123:30


signum > public {inline} (0 calls)
0: wybe.int.signum<0>
signum(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c signum(~x##0:wybe.int, ?#result##0:wybe.int) @int:114:25


sqrt > public {inline} (0 calls)
0: wybe.int.sqrt<0>
sqrt(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c isqrt(~x##0:wybe.int, ?#result##0:wybe.int) @int:104:23


~= > public {inline} (0 calls)
0: wybe.int.~=<0>
~=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:84:30

LLVM code       : None

--------------------------------------------------
 Module wybe.io
  representation  : (not a type)
  public submods  : phantom -> wybe.phantom
  public resources: io: wybe.io.io
  public procs    : wybe.io.<0>
                    wybe.io.eof<0>
                    wybe.io.nl<0>
  imports         : use wybe.char
                    public use wybe.phantom
  resources       : io: fromList [(wybe.io.io,wybe.phantom = 0:phantom @io:13:27 @io:13:5)]
  procs           : 

module top-level code > public {inline,semipure} (0 calls)
0: wybe.io.<0>
()<{}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm store(0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:13:5


eof > public {inline} (0 calls)
0: wybe.io.eof<0>
eof(?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(-1:wybe.int, ?#result##0:wybe.char) @io:20:29


nl > public {inline} (0 calls)
0: wybe.io.nl<0>
nl()<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @io:17:31
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31

LLVM code       : None

--------------------------------------------------
 Module wybe.list(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.list.,,<0>
                    wybe.list.[]<0>
                    wybe.list.all<0>
                    wybe.list.any<0>
                    wybe.list.empty<0>
                    wybe.list.filter<0>
                    wybe.list.foldl<0>
                    wybe.list.foldr<0>
                    wybe.list.length<0>
                    wybe.list.list<0>
                    wybe.list.map<0>
                    wybe.list.map<1>
                    wybe.list.map<2>
                    wybe.list.print<0>
                    wybe.list.println<0>
                    wybe.list.reverse<0>
  imports         : use wybe.array
                    use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
                    use wybe.machine_word
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_(T) @list:20:10, y:_(T) @list:20:20, ?#result:_(T) @list:20:5):
    if {[|](?h @list:21:16, ?t @list:21:21, x @list:21:10)::

        ,,(t @list:21:32, y @list:21:37, ?tmp#2 @list:21:32)
        [|](h @list:21:28, tmp#2, ?tmp#1 @list:21:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(y @list:21:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:21:10, ?#result @list:20:5)


[] > public {test} (0 calls)
0: [](xs:_(T) @list:31:21, idx:int @list:31:30, ?#result:T @list:31:5):
    >=(idx @list:32:5, 0 @list:32:13)
    index1(xs @list:33:17, idx @list:33:21, ?tmp#0 @list:33:10)
    =(?x @list:33:6, tmp#0)
    foreign llvm move(x @list:31:43, ?#result @list:31:5)


all > public {test} (0 calls)
0: all(p:{test}(T) @list:61:20, xs:_(T) @list:61:33):
    foreign llvm move(xs @list:62:15, ?tmp#0)
    do {
        if {[|](?x @list:62:10, ?tmp#0, tmp#0)::

            p(x @list:63:11)
        else::
            break

        }
    }


any > public {test} (0 calls)
0: any(p:{test}(T) @list:69:20, xs:_(T) @list:69:33):
    [|](?x @list:70:7, ?xs @list:70:12, xs @list:70:18)
    (   p(x @list:71:8)
    | any(p @list:71:17, xs @list:71:20))


empty > public {test} (0 calls)
0: empty(xs:_(T) @list:15:22):
    if {[|](?tmp#0 @list:16:11, ?tmp#1 @list:16:15, xs @list:16:20)::

        fail
    else::
        pass

    }


filter > public (0 calls)
0: filter(p:{test}(T) @list:95:16, !xs:_(T) @list:95:30):
    [](?tmp#0 @list:96:12)
    =(?out @list:96:6, tmp#0)
    foreign llvm move(xs @list:97:15, ?tmp#1)
    do {
        if {[|](?x @list:97:10, ?tmp#1, tmp#1)::

            if {p(x @list:98:16)::

                [|](x @list:98:30, out @list:98:34, ?tmp#2 @list:98:29)
                =(?out @list:98:23, tmp#2)
            else::
                pass

            }
        else::
            break

        }
    }
    reverse(out @list:100:19, ?tmp#3 @list:100:11)
    =(?as @list:100:6, tmp#3)


foldl > public (0 calls)
0: foldl(f:(A, !B) @list:77:15, as:_(A) @list:77:26, !b:B @list:77:36):
    foreign llvm move(as @list:78:15, ?tmp#0)
    do {
        if {[|](?a @list:78:10, ?tmp#0, tmp#0)::

            f(a @list:79:11, !b @list:79:15)
        else::
            break

        }
    }


foldr > public (0 calls)
0: foldr(f:(A, !B) @list:86:15, as:_(A) @list:86:26, !b:B @list:86:36):
    if {[|](?a @list:87:12, ?as @list:87:17, as @list:87:23)::

        foldr(f @list:88:15, as @list:88:18, !b @list:88:23)
        f(a @list:89:11, !b @list:89:15)
    else::
        pass

    }


index1 > {test} (0 calls)
0: index1(xs:_(T) @list:148:19, idx:int @list:148:28, ?#result:T @list:148:1):
    [|](?x @list:149:7, ?xs @list:149:12, xs @list:149:18)
    (   =(idx @list:150:6, 0 @list:150:12)
    | (   -(idx @list:150:27, 1 @list:150:33, ?tmp#0 @list:150:27)
        & index1(xs @list:150:23, tmp#0, ?x @list:150:37)))
    foreign llvm move(x @list:148:41, ?#result @list:148:1)


length > public (0 calls)
0: length(x:_(T) @list:24:16, ?#result:int @list:24:5):
    length1(x @list:24:38, 0 @list:24:41, ?tmp#0 @list:24:30)
    foreign llvm move(tmp#0, ?#result @list:24:5)


length1 > (0 calls)
0: length1(x:_(T) @list:140:13, acc:int @list:140:21, ?#result:int @list:140:1):
    if {[|](?h @list:141:16, ?t @list:141:21, x @list:141:10)::

        +(acc @list:141:38, 1 @list:141:44, ?tmp#2 @list:141:38)
        length1(t @list:141:35, tmp#2, ?tmp#1 @list:141:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(acc @list:141:57, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:141:10, ?#result @list:140:1)


list > public (0 calls)
0: list(ar:array(T) @list:128:14, ?#result:_(T) @list:128:5):
    [](?tmp#0 @list:129:11)
    =(?ls @list:129:6, tmp#0)
    foreign llvm move(ar @list:130:15, ?tmp#1)
    do {
        if {[|](?x @list:130:10, ?tmp#1, tmp#1)::

            [|](x @list:131:16, ls @list:131:20, ?tmp#2 @list:131:15)
            =(?ls @list:131:10, tmp#2)
        else::
            break

        }
    }
    reverse(ls @list:133:13, ?ls @list:133:18)
    foreign llvm move(ls @list:128:34, ?#result @list:128:5)


map > public (0 calls)
0: map(f:{resource}(T) @list:41:13, xs:_(T) @list:41:30):
    foreign llvm move(xs @list:42:15, ?tmp#0)
    do {
        if {[|](?x @list:42:10, ?tmp#0, tmp#0)::

            !f(x @list:43:12)
        else::
            break

        }
    }
map > public (0 calls)
1: map(f:(A, ?B) @list:49:13, as:_(A) @list:49:24, ?#result:_(B) @list:49:5):
    if {[|](?a @list:50:12, ?as @list:50:17, as @list:50:23)::

        f(a @list:50:33, ?tmp#2 @list:50:31)
        map(f @list:50:42, as @list:50:45, ?tmp#3 @list:50:38)
        [|](tmp#2, tmp#3, ?tmp#1 @list:50:29)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:50:61)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:50:10, ?#result @list:49:5)
map > public (0 calls)
2: map(f:(A, B, ?C) @list:55:13, as:_(A) @list:55:27, bs:_(B) @list:55:36, ?#result:_(C) @list:55:5):
    if {(   [|](?a @list:56:12, ?as @list:56:17, as @list:56:23)
        & [|](?b @list:56:30, ?bs @list:56:35, bs @list:56:41))::

        f(a @list:56:51, b @list:56:54, ?tmp#2 @list:56:49)
        map(f @list:56:63, as @list:56:66, bs @list:56:70, ?tmp#3 @list:56:59)
        [|](tmp#2, tmp#3, ?tmp#1 @list:56:47)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:57:47)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:56:10, ?#result @list:55:5)


print > public (0 calls)
0: print(printer:{resource}(T) @list:108:15, xs:_(T) @list:108:38) use !io:
    !print('[' @list:109:12)
    if {[|](?x @list:110:12, ?xs @list:110:17, xs @list:110:23)::

        !printer(x @list:111:18)
        !print1(printer @list:112:17, xs @list:112:26)
    else::
        pass

    }
    !print(']' @list:114:12)


print1 > (0 calls)
0: print1(printer:{resource}(T) @list:154:12, xs:_(T) @list:154:35) use !io:
    if {[|](?x @list:155:12, ?xs @list:155:17, xs @list:155:23)::

        !print(',' @list:156:16)
        !printer(x @list:157:18)
        !print1(printer @list:158:17, xs @list:158:26)
    else::
        pass

    }


println > public (0 calls)
0: println(printer:{resource}(T) @list:119:17, xs:_(T) @list:119:40) use !io:
    !print(printer @list:120:12, xs @list:120:21)
    !nl


reverse > public (0 calls)
0: reverse(x:_(T) @list:27:17, ?#result:_(T) @list:27:5):
    [](?tmp#1 @list:27:44)
    reverse1(x @list:27:41, tmp#1, ?tmp#0 @list:27:32)
    foreign llvm move(tmp#0, ?#result @list:27:5)


reverse1 > (0 calls)
0: reverse1(x:_(T) @list:144:14, tail:_(T) @list:144:22, ?#result:_(T) @list:144:1):
    if {[|](?h @list:145:16, ?t @list:145:21, x @list:145:10)::

        [|](h @list:145:40, tail @list:145:44, ?tmp#2 @list:145:39)
        reverse1(t @list:145:36, tmp#2, ?tmp#1 @list:145:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(tail @list:145:61, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:145:10, ?#result @list:144:1)

LLVM code       : None

--------------------------------------------------
 Module wybe.machine_word
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.machine_word.word_size_bits<0>
                    wybe.machine_word.word_size_bytes<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

word_size_bits > public (0 calls)
0: word_size_bits(?#result:int @machine_word:12:5):
    word_size_bytes(?tmp#1 @machine_word:12:34)
    *(8 @machine_word:12:30, tmp#1, ?tmp#0 @machine_word:12:30)
    foreign llvm move(tmp#0, ?#result @machine_word:12:5)


word_size_bytes > public (0 calls)
0: word_size_bytes(?#result:int @machine_word:10:5):
    foreign llvm move(8 @machine_word:10:31, ?#result @machine_word:10:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.memory_management
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.memory_management.malloc_count<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

malloc_count > public {semipure} (0 calls)
0: malloc_count(?x:int @memory_management:11:34):
    foreign c {impure} malloc_count(?x @memory_management:12:38)

LLVM code       : None

--------------------------------------------------
 Module wybe.phantom
 modifiers       : {unique} 
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : 
  imports         : 
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.predicate
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.predicate.const<0>
                    wybe.predicate.id<0>
  imports         : 
  resources       : 
  procs           : 

const > public {inline} (0 calls)
0: wybe.predicate.const<0>
const(a##0:A <{}; {}; {0}>, [b##0:B <{}; {}; {1}>], ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:8:5


id > public {inline} (0 calls)
0: wybe.predicate.id<0>
id(a##0:A <{}; {}; {0}>, ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:6:5

LLVM code       : None

--------------------------------------------------
 Module wybe.range
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.range...<0>
                    wybe.range.[]<0>
                    wybe.range.[|]<0>
                    wybe.range.irange<0>
                    wybe.range.size<0>
                    wybe.range.xrange<0>
  imports         : use wybe.bool
                    use wybe.int
  resources       : 
  procs           : 

.. > public (0 calls)
0: ..(start:int @range:38:10, end:int @range:38:23, ?#result:_ @range:38:5):
    if {<=(start @range:39:27, end @range:39:37)::

        foreign llvm move(1 @range:39:44, ?tmp#1)
    else::
        foreign llvm move(-1 @range:39:56, ?tmp#1)

    }
    construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)
    foreign llvm move(tmp#0, ?#result @range:38:5)


[] > public {test} (0 calls)
0: [](r:_ @range:20:19, idx:int @range:20:24, ?value:int @range:20:34):
    <=(0 @range:21:6, idx @range:21:12)
    range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)
    *(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)
    +(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)
    =(?value @range:23:6, tmp#0)
    if {<=(0 @range:24:10, stride @range:24:16)::

        <(value @range:24:27, end @range:24:35)
    else::
        <(end @range:24:51, value @range:24:57)

    }


[|] > public {test} (0 calls)
0: [|](?value:int @range:12:23, ?rest:_ @range:12:35, current:_ @range:12:43):
    range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)
    ~=(value @range:14:6, end @range:14:16)
    +(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)
    range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)
    =(?rest @range:15:6, tmp#0)


construct > (0 calls)
0: construct(start:int @range:49:15, stride:int @range:49:26, end:int @range:49:38, ?#result:_ @range:49:1):
    -(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)
    %(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)
    =(?diff @range:50:6, tmp#0)
    if {<=(0 @range:51:19, stride @range:51:25)::

        if {=(diff @range:52:26, 0 @range:52:33)::

            max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
            -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
            max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
            foreign llvm move(tmp#5, ?tmp#3)

        }
        foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
    else::
        if {=(diff @range:55:26, 0 @range:55:33)::

            min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
            foreign llvm move(tmp#9, ?tmp#8)
        else::
            +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
            min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
            foreign llvm move(tmp#10, ?tmp#8)

        }
        foreign llvm move(tmp#8 @range:55:26, ?tmp#2)

    }
    =(?final @range:51:6, tmp#2 @range:51:19)
    range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)
    =(?r @range:58:6, tmp#12)
    foreign llvm move(r @range:49:51, ?#result @range:49:1)


irange > public (0 calls)
0: irange(start:int @range:32:16, stride:int @range:32:27, end:int @range:32:39, ?#result:_ @range:32:5):
    if {<(stride @range:33:41, 0 @range:33:50)::

        foreign llvm move(-1 @range:33:55, ?tmp#2)
    else::
        foreign llvm move(1 @range:33:68, ?tmp#2)

    }
    +(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)
    construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)
    foreign llvm move(tmp#0, ?#result @range:32:5)


size > public (0 calls)
0: size(r:_ @range:42:14, ?#result:int @range:42:5):
    range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)
    if {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
        & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
        & signum(tmp#3, ?tmp#2 @range:44:29)
        & ~=(tmp#1, tmp#2))::

        foreign llvm move(0 @range:44:52, ?tmp#0)
    else::
        if {<=(0 @range:45:10, stride @range:45:16)::

            -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
            -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
            /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
            +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
            foreign llvm move(tmp#5, ?tmp#4)
        else::
            -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
            -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
            -(stride @range:46:39, ?tmp#13 @range:46:38)
            /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
            +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
            foreign llvm move(tmp#9, ?tmp#4)

        }
        foreign llvm move(tmp#4 @range:45:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)


xrange > public (0 calls)
0: xrange(start:int @range:28:16, stride:int @range:28:27, end:int @range:28:39, ?#result:_ @range:28:5):
    construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)
    foreign llvm move(tmp#0, ?#result @range:28:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.string
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.string.,,<0>
                    wybe.string.<<0>
                    wybe.string.<=<0>
                    wybe.string.<=><0>
                    wybe.string.=<0>
                    wybe.string.><0>
                    wybe.string.>=<0>
                    wybe.string.[]<0>
                    wybe.string.[]<1>
                    wybe.string.[|]<0>
                    wybe.string.c_string<0>
                    wybe.string.length<0>
                    wybe.string.print<0>
                    wybe.string.println<0>
                    wybe.string.read<0>
                    wybe.string.string<0>
                    wybe.string.string<1>
                    wybe.string.~=<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.char
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
                    use wybe.range
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_ @string:64:10, y:_ @string:64:17, ?#result:_ @string:64:5):
    if {(   empty(?tmp#1 @string:65:14)
        & =(x @string:65:10, tmp#1))::

        foreign llvm move(y @string:65:23, ?tmp#0)
    else::
        if {(   empty(?tmp#3 @string:66:14)
            & =(y @string:66:10, tmp#3))::

            foreign llvm move(x @string:66:23, ?tmp#2)
        else::
            concat(x @string:67:25, y @string:67:28, ?tmp#4 @string:67:18)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:66:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:65:10, ?#result @string:64:5)


< > public (0 calls)
0: <(x:_ @string:119:10, y:_ @string:119:17, ?#result:bool @string:119:5):
    <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
    equal(?tmp#2 @string:119:44)
    <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
    foreign llvm move(tmp#0, ?#result @string:119:5)


<= > public (0 calls)
0: <=(x:_ @string:120:10, y:_ @string:120:18, ?#result:bool @string:120:5):
    <=>(x @string:120:31, y @string:120:39, ?tmp#1 @string:120:31)
    equal(?tmp#2 @string:120:46)
    <=(tmp#1, tmp#2, ?tmp#0 @string:120:30)
    foreign llvm move(tmp#0, ?#result @string:120:5)


<=> > public (0 calls)
0: <=>(x:_ @string:125:10, y:_ @string:125:20, ?#result:comparison @string:125:5):
    equal(?tmp#0 @string:126:10)
    =(?c @string:126:6, tmp#0)
    foreign llvm move(x @string:127:16, ?tmp#1)
    foreign llvm move(y @string:127:26, ?tmp#2)
    do {
        if {[|](?cx @string:127:10, ?tmp#1, tmp#1)::

            if {[|](?cy @string:127:20, ?tmp#2, tmp#2)::

                if {<(cx @string:128:14, cy @string:128:19)::

                    lesser(?tmp#3 @string:128:30)
                    =(?c @string:128:26, tmp#3)
                    break
                else::
                    if {>(cx @string:129:14, cy @string:129:19)::

                        greater(?tmp#4 @string:129:30)
                        =(?c @string:129:26, tmp#4)
                        break
                    else::
                        pass

                    }

                }
            else::
                break

            }
        else::
            break

        }
    }
    if {(   equal(?tmp#5 @string:132:14)
        & =(c @string:132:10, tmp#5))::

        length(x @string:133:22, ?tmp#6 @string:133:15)
        =(?lx @string:133:10, tmp#6)
        length(y @string:134:22, ?tmp#7 @string:134:15)
        =(?ly @string:134:10, tmp#7)
        if {<(lx @string:135:14, ly @string:135:19)::

            lesser(?tmp#8 @string:135:30)
            =(?c @string:135:26, tmp#8)
        else::
            if {>(lx @string:135:39, ly @string:135:44)::

                greater(?tmp#9 @string:135:55)
                =(?c @string:135:51, tmp#9)
            else::
                pass

            }

        }
    else::
        pass

    }
    foreign llvm move(c @string:125:38, ?#result @string:125:5)


= > public (0 calls)
0: =(x:_ @string:115:10, y:_ @string:115:17, ?#result:bool @string:115:5):
    <=>(x @string:115:30, y @string:115:38, ?tmp#1 @string:115:30)
    equal(?tmp#2 @string:115:44)
    =(tmp#1, tmp#2, ?tmp#0 @string:115:29)
    foreign llvm move(tmp#0, ?#result @string:115:5)


> > public (0 calls)
0: >(x:_ @string:121:10, y:_ @string:121:17, ?#result:bool @string:121:5):
    <=>(x @string:121:30, y @string:121:38, ?tmp#1 @string:121:30)
    equal(?tmp#2 @string:121:44)
    >(tmp#1, tmp#2, ?tmp#0 @string:121:29)
    foreign llvm move(tmp#0, ?#result @string:121:5)


>= > public (0 calls)
0: >=(x:_ @string:122:10, y:_ @string:122:18, ?#result:bool @string:122:5):
    <=>(x @string:122:31, y @string:122:39, ?tmp#1 @string:122:31)
    equal(?tmp#2 @string:122:46)
    >=(tmp#1, tmp#2, ?tmp#0 @string:122:30)
    foreign llvm move(tmp#0, ?#result @string:122:5)


[] > public {test} (0 calls)
0: [](s:_ @string:91:19, idx:int @string:91:24, ?c:char @string:91:34):
    if {buffer(?len @string:93:17, ?str @string:93:23, s @string:92:10)::

        <=(0 @string:94:14, idx @string:94:20)
        <(idx @string:95:14, len @string:95:20)
        unsafe_c_string_index(str @string:96:35, idx @string:96:40, ?c @string:96:46)
    else::
        if {concat(?left @string:97:17, ?right @string:97:24, s @string:92:10)::

            length(left @string:98:32, ?tmp#0 @string:98:25)
            =(?left_len @string:98:14, tmp#0)
            if {<(idx @string:99:18, left_len @string:99:24)::

                [](left @string:99:41, idx @string:99:46, ?tmp#1 @string:99:41)
                =(?c @string:99:37, tmp#1)
            else::
                -(idx @string:100:37, left_len @string:100:43, ?tmp#3 @string:100:37)
                [](right @string:100:31, tmp#3, ?tmp#2 @string:100:31)
                =(?c @string:100:27, tmp#2)

            }
        else::
            if {slice(?base @string:102:16, ?range @string:102:23, s @string:92:10)::

                [](range @string:102:43, idx @string:102:49, ?tmp#5 @string:102:43)
                [](base @string:102:38, tmp#5, ?tmp#4 @string:102:38)
                =(?c @string:102:34, tmp#4)
            else::
                if {singleton(?c @string:103:20, s @string:92:10)::

                    =(idx @string:103:27, 0 @string:103:33)
                else::
                    fail

                }

            }

        }

    }
[] > public (0 calls)
1: [](s:_ @string:109:12, r:range @string:109:17, ?#result:_ @string:109:5):
    slice(s @string:109:36, r @string:109:39, ?tmp#0 @string:109:30)
    foreign llvm move(tmp#0, ?#result @string:109:5)


[|] > public {test} (0 calls)
0: [|](?head:char @string:71:23, ?tail:_ @string:71:35, s:_ @string:71:43):
    if {buffer(?len @string:73:17, ?str @string:73:23, s @string:72:10)::

        [|](?head @string:74:15, ?str @string:74:23, str @string:74:30)
        if {=(len @string:75:26, 1 @string:75:32)::

            empty(?tmp#1 @string:75:37)
            foreign llvm move(tmp#1, ?tmp#0)
        else::
            -(len @string:75:60, 1 @string:75:66, ?tmp#3 @string:75:60)
            buffer(tmp#3, str @string:75:69, ?tmp#2 @string:75:53)
            foreign llvm move(tmp#2, ?tmp#0)

        }
        =(?tail @string:75:14, tmp#0 @string:75:26)
    else::
        if {concat(?left @string:76:17, ?right @string:76:24, s @string:72:10)::

            if {[|](?head @string:77:20, ?t @string:77:28, left @string:77:33)::

                concat(t @string:77:56, right @string:77:59, ?tmp#4 @string:77:49)
                =(?tail @string:77:42, tmp#4)
            else::
                [|](?head @string:78:28, ?tail @string:78:36, right @string:78:44)

            }
        else::
            if {slice(?base @string:80:16, ?range @string:80:23, s @string:72:10)::

                do {
                    [|](?idx @string:82:19, ?range @string:82:26, range @string:82:35)
                    if {(   [](base @string:83:30, idx @string:83:35, ?tmp#5 @string:83:30)
                        & =(?head @string:83:23, tmp#5))::

                        slice(base @string:83:57, range @string:83:63, ?tmp#6 @string:83:51)
                        =(?tail @string:83:44, tmp#6)
                        break
                    else::
                        pass

                    }
                }
            else::
                if {singleton(?head @string:85:20, s @string:72:10)::

                    empty(?tmp#7 @string:85:37)
                    =(?tail @string:85:30, tmp#7)
                else::
                    fail

                }

            }

        }

    }


c_string > public (0 calls)
0: c_string(s:_ @string:40:18, ?#result:c_string @string:40:5):
    if {buffer(?tmp#0 @string:41:21, ?str @string:41:25, s @string:41:10)::

        pass
    else::
        length(s @string:43:27, ?tmp#2 @string:43:20)
        +(tmp#2, 1 @string:43:32, ?tmp#1 @string:43:20)
        =(?len @string:43:14, tmp#1)
        foreign lpvm alloc(len @string:44:32, ?str @string:44:38)
        true(?tmp#3 @string:45:49)
        foreign lpvm mutate(str @string:45:33, ?str @string:45:39, len @string:45:44, tmp#3, len @string:45:55, 0 @string:45:60, '\NUL' @string:45:63)
        =(?offset @string:46:14, 0 @string:46:23)
        pack(s @string:47:18, !str @string:47:22, len @string:47:27, !offset @string:47:33)

    }
    foreign llvm move(str @string:40:34, ?#result @string:40:5)


fixed_range_size > (0 calls)
0: fixed_range_size(hi:int @string:184:22, r:range @string:184:30, ?sz:int @string:184:40):
    range(?start @string:185:16, ?stride @string:185:24, ?end @string:185:33, r @string:185:5)
    if {<=(0 @string:186:10, stride @string:186:16)::

        -(start @string:187:39, ?tmp#4 @string:187:38)
        /(tmp#4, stride @string:187:47, ?tmp#3 @string:187:38)
        *(tmp#3, stride @string:187:56, ?tmp#2 @string:187:38)
        +(start @string:187:30, tmp#2, ?tmp#1 @string:187:30)
        max(start @string:187:23, tmp#1, ?tmp#0 @string:187:19)
        =(?lo @string:187:14, tmp#0)
        min(hi @string:188:23, end @string:188:27, ?tmp#5 @string:188:19)
        =(?hi @string:188:14, tmp#5)
    else::
        max(-1 @string:190:23, end @string:190:27, ?tmp#6 @string:190:19)
        =(?lo @string:190:14, tmp#6)
        +(hi @string:191:30, stride @string:191:35, ?tmp#10 @string:191:30)
        -(start @string:191:45, hi @string:191:53, ?tmp#13 @string:191:45)
        -(tmp#13, 1 @string:191:58, ?tmp#12 @string:191:45)
        -(stride @string:191:64, ?tmp#14 @string:191:63)
        %(tmp#12, tmp#14, ?tmp#11 @string:191:44)
        +(tmp#10, tmp#11, ?tmp#9 @string:191:30)
        +(tmp#9, 1 @string:191:73, ?tmp#8 @string:191:30)
        min(start @string:191:23, tmp#8, ?tmp#7 @string:191:19)
        =(?hi @string:191:14, tmp#7)
        -(stride @string:192:24, ?tmp#15 @string:192:23)
        =(?stride @string:192:14, tmp#15)

    }
    if {<=(hi @string:194:16, lo @string:194:23)::

        foreign llvm move(0 @string:194:29, ?tmp#16)
    else::
        -(hi @string:194:42, lo @string:194:47, ?tmp#20 @string:194:42)
        -(tmp#20, 1 @string:194:52, ?tmp#19 @string:194:42)
        /(tmp#19, stride @string:194:57, ?tmp#18 @string:194:41)
        +(tmp#18, 1 @string:194:66, ?tmp#17 @string:194:41)
        foreign llvm move(tmp#17, ?tmp#16)

    }
    =(?sz @string:194:6, tmp#16 @string:194:16)


length > public (0 calls)
0: length(s:_ @string:52:16, ?#result:int @string:52:5):
    if {buffer(?len @string:53:22, ?tmp#1 @string:53:27, s @string:53:10)::

        foreign llvm move(len @string:53:33, ?tmp#0)
    else::
        if {concat(?left @string:54:22, ?right @string:54:29, s @string:54:10)::

            length(left @string:54:46, ?tmp#4 @string:54:39)
            length(right @string:54:61, ?tmp#5 @string:54:54)
            +(tmp#4, tmp#5, ?tmp#3 @string:54:39)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            if {slice(?base @string:55:21, ?range @string:55:28, s @string:55:10)::

                length(base @string:55:62, ?tmp#8 @string:55:55)
                fixed_range_size(tmp#8, range @string:55:69, ?tmp#7 @string:55:38)
                foreign llvm move(tmp#7, ?tmp#6)
            else::
                if {singleton(?tmp#10 @string:56:24, s @string:56:10)::

                    foreign llvm move(1 @string:56:30, ?tmp#9)
                else::
                    foreign llvm move(0 @string:57:18, ?tmp#9)

                }
                foreign llvm move(tmp#9 @string:56:10, ?tmp#6)

            }
            foreign llvm move(tmp#6 @string:55:10, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:54:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:53:10, ?#result @string:52:5)


pack > (0 calls)
0: pack(s:_ @string:160:10, !raw:c_string @string:160:16, size:int @string:160:30, !offset:int @string:160:41):
    if {buffer(?tmp#0 @string:162:16, ?str @string:162:20, s @string:161:10)::

        foreign llvm move(str @string:163:23, ?tmp#1)
        do {
            if {[|](?c @string:163:18, ?tmp#1, tmp#1)::

                true(?tmp#2 @string:164:56)
                foreign lpvm mutate(raw @string:164:37, ?raw @string:164:43, offset @string:164:48, tmp#2, size @string:164:62, 0 @string:164:68, c @string:164:71)
                incr(!offset @string:165:23)
            else::
                break

            }
        }
    else::
        if {concat(?left @string:167:17, ?right @string:167:24, s @string:161:10)::

            pack(left @string:168:18, !raw @string:168:25, size @string:168:30, !offset @string:168:37)
            pack(right @string:169:18, !raw @string:169:26, size @string:169:31, !offset @string:169:38)
            incr(!offset @string:170:19)
        else::
            if {slice(?tmp#3 @string:171:15, ?tmp#4 @string:171:18, s @string:161:10)::

                foreign llvm move(s @string:172:23, ?tmp#5)
                do {
                    if {[|](?c @string:172:18, ?tmp#5, tmp#5)::

                        true(?tmp#6 @string:173:56)
                        foreign lpvm mutate(raw @string:173:37, ?raw @string:173:43, offset @string:173:48, tmp#6, size @string:173:62, 0 @string:173:68, c @string:173:71)
                        incr(!offset @string:174:23)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:176:20, s @string:161:10)::

                    true(?tmp#7 @string:177:52)
                    foreign lpvm mutate(raw @string:177:33, ?raw @string:177:39, offset @string:177:44, tmp#7, size @string:177:58, 0 @string:177:64, c @string:177:67)
                    incr(!offset @string:178:19)
                else::
                    fail

                }

            }

        }

    }


print > public (0 calls)
0: print(x:_ @string:142:15) use !io:
    if {buffer(?tmp#0 @string:144:16, ?str @string:144:20, x @string:143:10)::

        !print(str @string:144:35)
    else::
        if {concat(?left @string:145:17, ?right @string:145:24, x @string:143:10)::

            !print(left @string:145:41)
            !print(right @string:145:55)
        else::
            if {slice(?tmp#1 @string:146:15, ?tmp#2 @string:146:18, x @string:143:10)::

                foreign llvm move(x @string:146:34, ?tmp#3)
                do {
                    if {[|](?c @string:146:29, ?tmp#3, tmp#3)::

                        !print(c @string:146:45)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:147:20, x @string:143:10)::

                    !print(c @string:147:33)
                else::
                    fail

                }

            }

        }

    }


println > public (0 calls)
0: println(x:_ @string:151:17) use !io:
    !print(x @string:151:39)
    !nl


read > public (0 calls)
0: read(?x:_ @string:153:15) use !io:
    !read(?str:c_string @string:153:37)
    string(str @string:153:64, ?tmp#0 @string:153:57)
    =(?x @string:153:53, tmp#0)


string > public (0 calls)
0: string(str:c_string @string:28:16, ?#result:_ @string:28:5):
    length(str @string:29:19, ?tmp#0 @string:29:12)
    =(?len @string:29:6, tmp#0)
    if {=(len @string:30:15, 0 @string:30:21)::

        empty(?tmp#2 @string:30:26)
        foreign llvm move(tmp#2, ?tmp#1)
    else::
        if {=(len @string:31:15, 1 @string:31:21)::

            foreign lpvm access(str @string:31:56, 0 @string:31:61, 1 @string:31:64, 0 @string:31:67, ?tmp#5 @string:31:36)
            singleton(tmp#5, ?tmp#4 @string:31:26)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            buffer(len @string:32:33, str @string:32:38, ?tmp#6 @string:32:26)
            foreign llvm move(tmp#6, ?tmp#3)

        }
        foreign llvm move(tmp#3 @string:31:15, ?tmp#1)

    }
    =(?s @string:30:6, tmp#1 @string:30:15)
    foreign llvm move(s @string:28:34, ?#result @string:28:5)
string > public (0 calls)
1: string(c:char @string:37:16, ?#result:_ @string:37:5):
    singleton(c @string:37:38, ?tmp#0 @string:37:28)
    foreign llvm move(tmp#0, ?#result @string:37:5)


~= > public (0 calls)
0: ~=(x:_ @string:116:10, y:_ @string:116:18, ?#result:bool @string:116:5):
    <=>(x @string:116:31, y @string:116:39, ?tmp#1 @string:116:31)
    equal(?tmp#2 @string:116:46)
    ~=(tmp#1, tmp#2, ?tmp#0 @string:116:30)
    foreign llvm move(tmp#0, ?#result @string:116:5)

LLVM code       : None

======================================================================
AFTER FLATTENING:
 Module wybe
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : 
  imports         : public use wybe.array
                    public use wybe.bool
                    public use wybe.c_string
                    public use wybe.char
                    public use wybe.comparison
                    public use wybe.control
                    public use wybe.count
                    public use wybe.float
                    public use wybe.int
                    public use wybe.io
                    public use wybe.list
                    public use wybe.machine_word
                    public use wybe.memory_management
                    public use wybe.phantom
                    public use wybe.predicate
                    public use wybe.range
                    public use wybe.string
  resources       : 
  submodules      : wybe.array, wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.control, wybe.count, wybe.float, wybe.int, wybe.io, wybe.list, wybe.machine_word, wybe.memory_management, wybe.phantom, wybe.predicate, wybe.range, wybe.string
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.array(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.array.[]<0>
                    wybe.array.[]<1>
                    wybe.array.[|]<0>
                    wybe.array.array<0>
                    wybe.array.array<1>
                    wybe.array.inbounds<0>
                    wybe.array.unsafe_get<0>
                    wybe.array.unsafe_update<0>
  imports         : public use wybe.array.raw_array
                    use wybe.bool
                    use wybe.int
                    use wybe.list
                    use wybe.machine_word
  resources       : 
  submodules      : wybe.array.raw_array
  procs           : 

[] > public {test} (0 calls)
0: [](a:_(T) @array:67:21, idx:int @array:67:29, ?#result:T @array:67:5):
    inbounds(a @array:68:14, idx @array:68:17)
    unsafe_get(a @array:69:10, idx @array:69:23, ?tmp#0 @array:69:10)
    =(?x @array:69:6, tmp#0)
    foreign llvm move(x @array:67:42, ?#result @array:67:5)
[] > public {test} (0 calls)
1: [](!a:_(T) @array:81:22, idx:int @array:81:30, x:T @array:81:39):
    inbounds(a @array:82:14, idx @array:82:17)
    unsafe_update(!a @array:83:20, idx @array:83:23, x @array:83:28)


[|] > public {test} (0 calls)
0: [|](?head:T @array:51:23, ?tail:_(T) @array:51:32, a:_(T) @array:51:43):
    array(?length @array:52:12, ?data @array:52:21, a @array:52:29)
    >(length @array:53:6, 0 @array:53:15)
    word_size_bytes(?tmp#0 @array:54:34)
    foreign lpvm access(data @array:54:25, 0 @array:54:31, tmp#0, 0 @array:54:51, ?head @array:54:55)
    word_size_bytes(?tmp#1 @array:55:28)
    foreign llvm add(data @array:55:22, tmp#1, ?data @array:55:46)
    -(length @array:56:19, 1 @array:56:28, ?tmp#3 @array:56:19)
    array(tmp#3, data @array:56:31, ?tmp#2 @array:56:13)
    =(?tail @array:56:6, tmp#2)


array > public (0 calls)
0: array(x:T @array:18:15, len:int @array:18:20, ?#result:_(T) @array:18:5):
    word_size_bytes(?tmp#1 @array:19:19)
    *(len @array:19:13, tmp#1, ?tmp#0 @array:19:13)
    =(?size @array:19:6, tmp#0)
    foreign lpvm alloc(size @array:20:24, ?data @array:20:31)
    =(?offset @array:21:6, 0 @array:21:15)
    do {
        if {<(offset @array:23:15, size @array:23:24)::

            pass
        else::
            break

        }
        foreign lpvm mutate(data @array:24:29, ?data @array:24:36, offset @array:24:42, 1 @array:24:50, size @array:24:53, 0 @array:24:59, x @array:24:62)
        word_size_bytes(?tmp#2 @array:25:21)
        +=(!offset @array:25:10, tmp#2)
    }
    array(len @array:27:17, data @array:27:22, ?tmp#3 @array:27:11)
    =(?ar @array:27:6, tmp#3)
    foreign llvm move(ar @array:18:36, ?#result @array:18:5)
array > public (0 calls)
1: array(ls:list(T) @array:34:15, ?#result:_(T) @array:34:5):
    length(ls @array:35:19, ?tmp#0 @array:35:12)
    =(?len @array:35:6, tmp#0)
    word_size_bytes(?tmp#2 @array:36:19)
    *(len @array:36:13, tmp#2, ?tmp#1 @array:36:13)
    =(?size @array:36:6, tmp#1)
    foreign lpvm alloc(size @array:37:24, ?data @array:37:31)
    =(?offset @array:38:6, 0 @array:38:15)
    foreign llvm move(ls @array:39:15, ?tmp#3)
    do {
        if {[|](?x @array:39:10, ?tmp#3, tmp#3)::

            foreign lpvm mutate(data @array:40:29, ?data @array:40:36, offset @array:40:42, 1 @array:40:50, size @array:40:53, 0 @array:40:59, x @array:40:62)
            word_size_bytes(?tmp#4 @array:41:21)
            +=(!offset @array:41:10, tmp#4)
        else::
            break

        }
    }
    array(len @array:43:17, data @array:43:22, ?tmp#5 @array:43:11)
    =(?ar @array:43:6, tmp#5)
    foreign llvm move(ar @array:34:34, ?#result @array:34:5)


inbounds > public {test,inline} (0 calls)
0: inbounds(a:_(T) @array:60:33, idx:int @array:60:41):
    <=(0 @array:61:6, idx @array:61:12)
    length(a @array:62:12, ?tmp#0 @array:62:12)
    <(idx @array:62:6, tmp#0)


unsafe_get > public {inline} (0 calls)
0: unsafe_get(a:_(T) @array:75:29, idx:int @array:75:37, ?#result:T @array:75:5):
    raw_data(a @array:76:25, ?tmp#0 @array:76:25)
    word_size_bytes(?tmp#2 @array:76:43)
    *(idx @array:76:37, tmp#2, ?tmp#1 @array:76:37)
    word_size_bytes(?tmp#3 @array:76:60)
    foreign lpvm access(tmp#0, tmp#1, tmp#3, 0 @array:76:77, ?x @array:76:81)
    foreign llvm move(x @array:75:50, ?#result @array:75:5)


unsafe_update > public {inline} (0 calls)
0: unsafe_update(!a:_(T) @array:89:33, idx:int @array:89:41, x:T @array:89:50):
    raw_data(a @array:90:25, ?tmp#0 @array:90:25)
    word_size_bytes(?tmp#2 @array:90:50)
    *(idx @array:90:44, tmp#2, ?tmp#1 @array:90:44)
    length(a @array:91:44, ?tmp#4 @array:91:44)
    word_size_bytes(?tmp#5 @array:91:55)
    *(tmp#4, tmp#5, ?tmp#3 @array:91:44)
    foreign lpvm mutate(tmp#0, ?data @array:90:38, tmp#1, 0 @array:90:67, tmp#3, 0 @array:91:72, x @array:91:75)
    raw_data(!a @array:92:6, data @array:92:19)

LLVM code       : None

--------------------------------------------------
 Module wybe.array.raw_array(T)
  representation  : address
  public submods  : 
  public resources: 
  public procs    : 
  imports         : use wybe
                    use wybe.array
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.bool
  representation  : 1 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.bool.&&<0>
                    wybe.bool.&=<0>
                    wybe.bool.=<0>
                    wybe.bool.^=<0>
                    wybe.bool.^^<0>
                    wybe.bool.false<0>
                    wybe.bool.print<0>
                    wybe.bool.println<0>
                    wybe.bool.succeed<0>
                    wybe.bool.true<0>
                    wybe.bool.|=<0>
                    wybe.bool.||<0>
                    wybe.bool.~<0>
                    wybe.bool.~=<0>
  imports         : use wybe.c_string
                    use wybe.io
  resources       : 
  procs           : 

&& > public {inline} (1 calls)
0: wybe.bool.&&<0>
&&(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:13:27


&= > public {inline} (0 calls)
0: wybe.bool.&=<0>
&=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:13:27


= > public {inline} (0 calls)
0: wybe.bool.=<0>
=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:37:26


^= > public {inline} (0 calls)
0: wybe.bool.^=<0>
^=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:25:27


^^ > public {inline} (1 calls)
0: wybe.bool.^^<0>
^^(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:25:27


false > public {inline} (0 calls)
0: wybe.bool.false<0>
false(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.bool, ?#result##0:wybe.bool)


print > public (1 calls)
0: wybe.bool.print<0>
print(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    case ~x##0:wybe.bool of
    0:
        wybe.c_string.print<0>(c"false":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #1 @bool:47:31

    1:
        wybe.c_string.print<0>(c"true":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:47:31



println > public {inline} (0 calls)
0: wybe.bool.println<0>
println(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.bool.print<0>(~x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:49:33
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#0##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~tmp#0##0:wybe.phantom, ?tmp#1##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#1##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


succeed > public {inline} (0 calls)
0: wybe.bool.succeed<0>
succeed()<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []


true > public {inline} (1 calls)
0: wybe.bool.true<0>
true(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.bool, ?#result##0:wybe.bool)


|= > public {inline} (0 calls)
0: wybe.bool.|=<0>
|=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:19:27


|| > public {inline} (1 calls)
0: wybe.bool.||<0>
||(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:19:27


~ > public {inline} (0 calls)
0: wybe.bool.~<0>
~(p##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, 1:wybe.bool, ?#result##0:wybe.bool) @bool:31:20


~= > public {inline} (0 calls)
0: wybe.bool.~=<0>
~=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:38:27

LLVM code       : None

--------------------------------------------------
 Module wybe.c_string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.c_string.<<0>
                    wybe.c_string.<=<0>
                    wybe.c_string.=<0>
                    wybe.c_string.><0>
                    wybe.c_string.>=<0>
                    wybe.c_string.[]<0>
                    wybe.c_string.[|]<0>
                    wybe.c_string.length<0>
                    wybe.c_string.print<0>
                    wybe.c_string.println<0>
                    wybe.c_string.read<0>
                    wybe.c_string.unsafe_c_string_index<0>
                    wybe.c_string.~=<0>
  imports         : use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.c_string.<<0>
<(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:12:29
    wybe.int.<<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:12:29


<= > public {inline} (0 calls)
0: wybe.c_string.<=<0>
<=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:13:30
    wybe.int.<=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:13:30


= > public {inline} (0 calls)
0: wybe.c_string.=<0>
=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:10:29
    wybe.int.=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:10:29


> > public {inline} (0 calls)
0: wybe.c_string.><0>
>(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:14:29
    wybe.int.><0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:14:29


>= > public {inline} (0 calls)
0: wybe.c_string.>=<0>
>=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:15:30
    wybe.int.>=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:15:30


[] > public (0 calls)
0: wybe.c_string.[]<0>
[](str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, idx##0:wybe.int, ?tmp#2##0:wybe.bool) #0 @c_string:27:6
    case ~tmp#2##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        foreign c strlen(str##0:wybe.c_string, ?tmp#0##0:wybe.int) @c_string:17:29
        wybe.int.<<0>(idx##0:wybe.int, ~tmp#0##0:wybe.int, ?tmp#3##0:wybe.bool) #2 @c_string:28:6
        case ~tmp#3##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




[|] > public (0 calls)
0: wybe.c_string.[|]<0>
[|](?head##0:wybe.char, ?tail##0:wybe.c_string, str##0:wybe.c_string, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(str##0:wybe.c_string, 0:wybe.int, 0:wybe.int, 0:wybe.int, ?head##0:wybe.char) @c_string:20:5
    foreign llvm icmp_ne(head##0:wybe.char, '\NUL':wybe.char, ?not_done##0:wybe.bool) @c_string:21:5
    foreign llvm icmp_eq(~not_done##0:wybe.bool, 1:wybe.bool, ?tmp#1##0:wybe.bool) @bool:37:26
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.c_string, ?tail##0:wybe.c_string)

    1:
        foreign llvm add(~str##0:wybe.c_string, 1:wybe.int, ?tail##0:wybe.c_string) @c_string:23:5
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



length > public {inline} (3 calls)
0: wybe.c_string.length<0>
length(str##0:wybe.c_string, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strlen(~str##0:wybe.c_string, ?#result##0:wybe.int) @c_string:17:29


print > public {inline} (1 calls)
0: wybe.c_string.print<0>
print(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:35:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:35:30


println > public {inline} (0 calls)
0: wybe.c_string.println<0>
println(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @c_string:35:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.c_string.read<0>
read(?x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:39:30
    foreign c read_line(?x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:39:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:39:30


unsafe_c_string_index > public {inline} (1 calls)
0: wybe.c_string.unsafe_c_string_index<0>
unsafe_c_string_index(str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7


~= > public {inline} (0 calls)
0: wybe.c_string.~=<0>
~=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:11:30
    wybe.int.~=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.char
  representation  : 8 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.char.<<0>
                    wybe.char.<=<0>
                    wybe.char.<=><0>
                    wybe.char.=<0>
                    wybe.char.><0>
                    wybe.char.>=<0>
                    wybe.char.chr<0>
                    wybe.char.ord<0>
                    wybe.char.print<0>
                    wybe.char.println<0>
                    wybe.char.read<0>
                    wybe.char.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (4 calls)
0: wybe.char.<<0>
<(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:17:29


<= > public {inline} (0 calls)
0: wybe.char.<=<0>
<=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:18:30


<=> > public (0 calls)
0: wybe.char.<=><0>
<=>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.char, y##0:wybe.char, ?tmp#6##0:wybe.bool) @char:17:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?tmp#5##0:wybe.bool) @char:13:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5



= > public {inline} (2 calls)
0: wybe.char.=<0>
=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:13:29


> > public {inline} (0 calls)
0: wybe.char.><0>
>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:19:29


>= > public {inline} (0 calls)
0: wybe.char.>=<0>
>=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:20:30


chr > public (0 calls)
0: wybe.char.chr<0>
chr(i##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, i##0:wybe.int, ?tmp#1##0:wybe.bool) #0 @char:33:60
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        wybe.int.<=<0>(i##0:wybe.int, 255:wybe.int, ?tmp#2##0:wybe.bool) #1 @char:33:70
        case ~tmp#2##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm cast(~i##0:wybe.int, ?#result##0:wybe.char) @char:33:31
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




ord > public {inline} (0 calls)
0: wybe.char.ord<0>
ord(c##0:wybe.char, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(~c##0:wybe.char, ?#result##0:wybe.int) @char:30:24


print > public {inline} (1 calls)
0: wybe.char.print<0>
print(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:37:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:37:30


println > public {inline} (0 calls)
0: wybe.char.println<0>
println(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @char:37:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.char.read<0>
read(?x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:41:30
    foreign c read_char(?x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:41:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:41:30


~= > public {inline} (0 calls)
0: wybe.char.~=<0>
~=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:14:30

LLVM code       : None

--------------------------------------------------
 Module wybe.comparison
  representation  : 2 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.comparison.<<0>
                    wybe.comparison.<=<0>
                    wybe.comparison.=<0>
                    wybe.comparison.><0>
                    wybe.comparison.>=<0>
                    wybe.comparison.equal<0>
                    wybe.comparison.greater<0>
                    wybe.comparison.lesser<0>
                    wybe.comparison.~=<0>
  imports         : use wybe.bool
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.comparison.<<0>
<(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:12:29


<= > public {inline} (0 calls)
0: wybe.comparison.<=<0>
<=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:13:30


= > public {inline} (0 calls)
0: wybe.comparison.=<0>
=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:10:29


> > public {inline} (0 calls)
0: wybe.comparison.><0>
>(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:14:29


>= > public {inline} (0 calls)
0: wybe.comparison.>=<0>
>=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:15:30


equal > public {inline} (0 calls)
0: wybe.comparison.equal<0>
equal(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison)


greater > public {inline} (0 calls)
0: wybe.comparison.greater<0>
greater(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison)


lesser > public {inline} (0 calls)
0: wybe.comparison.lesser<0>
lesser(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison)


~= > public {inline} (0 calls)
0: wybe.comparison.~=<0>
~=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.control
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.control.assert<0>
                    wybe.control.error<0>
                    wybe.control.error<1>
                    wybe.control.exit<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.int
                    use wybe.string
  resources       : 
  procs           : 

assert > public {semipure} (0 calls)
0: assert(condition:bool @control:26:27) use call_source_location:
    if {~(condition @control:27:11)::

        !error(c"assertion failed" @control:27:31)
    else::
        pass

    }


error > public {terminal,semipure} (0 calls)
0: error(message:string @control:17:35) use call_source_location:
    c_string(message @control:18:77, ?tmp#0 @control:18:68)
    foreign c {terminal,semipure} error_exit(call_source_location @control:18:46, tmp#0)
error > public {terminal,semipure} (0 calls)
1: error(message:c_string @control:21:35) use call_source_location:
    foreign c {terminal,semipure} error_exit(call_source_location @control:22:46, message @control:22:68)


exit > public {terminal,semipure} (0 calls)
0: exit(code:int @control:10:34):
    foreign c {terminal,semipure} exit(code @control:11:40)

LLVM code       : None

--------------------------------------------------
 Module wybe.count
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.count.%<0>
                    wybe.count.%=<0>
                    wybe.count.*<0>
                    wybe.count.*=<0>
                    wybe.count.+<0>
                    wybe.count.+<1>
                    wybe.count.+<2>
                    wybe.count.+=<0>
                    wybe.count.-<0>
                    wybe.count.-<1>
                    wybe.count.-<2>
                    wybe.count.-=<0>
                    wybe.count./<0>
                    wybe.count./=<0>
                    wybe.count.<<0>
                    wybe.count.<=<0>
                    wybe.count.<=><0>
                    wybe.count.=<0>
                    wybe.count.><0>
                    wybe.count.>=<0>
                    wybe.count.decr<0>
                    wybe.count.incr<0>
                    wybe.count.max<0>
                    wybe.count.min<0>
                    wybe.count.print<0>
                    wybe.count.println<0>
                    wybe.count.read<0>
                    wybe.count.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.count.%<0>
%(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:51:25


%= > public {inline} (0 calls)
0: wybe.count.%=<0>
%=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:51:25


* > public {inline} (1 calls)
0: wybe.count.*<0>
*(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:39:25


*= > public {inline} (0 calls)
0: wybe.count.*=<0>
*=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:39:25


+ > public {inline} (2 calls)
0: wybe.count.+<0>
+(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:15:25
+ > public (0 calls)
1: wybe.count.+<1>
+(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(y##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?x##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~y##0:wybe.count, ?x##0:wybe.count) @count:18:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

+ > public (0 calls)
2: wybe.count.+<2>
+(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?y##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:22:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



+= > public {inline} (0 calls)
0: wybe.count.+=<0>
+=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:15:25


- > public (6 calls)
0: wybe.count.-<0>
-(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?#result##0:wybe.count)

    1:
        foreign llvm sub(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:31:35
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

- > public {inline} (0 calls)
1: wybe.count.-<1>
-(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.count, ~z##0:wybe.count, ?x##0:wybe.count) @count:32:42
- > public {inline} (0 calls)
2: wybe.count.-<2>
-(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:33:42


-= > public (0 calls)
0: wybe.count.-=<0>
-=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, ~y##0:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:36:41
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:36:37
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



/ > public {inline} (1 calls)
0: wybe.count./<0>
/(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:45:25


/= > public {inline} (0 calls)
0: wybe.count./=<0>
/=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:45:25


< > public {inline} (4 calls)
0: wybe.count.<<0>
<(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:64:29


<= > public {inline} (3 calls)
0: wybe.count.<=<0>
<=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:65:30


<=> > public (0 calls)
0: wybe.count.<=><0>
<=>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.count, y##0:wybe.count, ?tmp#6##0:wybe.bool) @count:64:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?tmp#5##0:wybe.bool) @count:60:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5



= > public {inline} (2 calls)
0: wybe.count.=<0>
=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:60:29


> > public {inline} (0 calls)
0: wybe.count.><0>
>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:66:29


>= > public {inline} (12 calls)
0: wybe.count.>=<0>
>=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:67:30


decr > public (0 calls)
0: wybe.count.decr<0>
decr(x##0:wybe.count, ?x##1:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, 1:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:84:37
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:84:33
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



incr > public {inline} (0 calls)
0: wybe.count.incr<0>
incr(x##0:wybe.count, ?x##1:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, 1:wybe.count, ?x##1:wybe.count) @count:15:25


max > public (0 calls)
0: wybe.count.max<0>
max(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:75:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:75:5



min > public (0 calls)
0: wybe.count.min<0>
min(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:65:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:74:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:74:5



print > public {inline} (1 calls)
0: wybe.count.print<0>
print(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:88:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:88:30


println > public {inline} (0 calls)
0: wybe.count.println<0>
println(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @count:88:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.count.read<0>
read(?x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:92:30
    foreign c read_count(?x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:92:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:92:30


~= > public {inline} (0 calls)
0: wybe.count.~=<0>
~=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:61:30

LLVM code       : None

--------------------------------------------------
 Module wybe.float
  representation  : 64 bit float
  public submods  : 
  public resources: 
  public procs    : wybe.float.*<0>
                    wybe.float.**<0>
                    wybe.float.*=<0>
                    wybe.float.+<0>
                    wybe.float.+<1>
                    wybe.float.+<2>
                    wybe.float.+=<0>
                    wybe.float.-<0>
                    wybe.float.-<1>
                    wybe.float.-<2>
                    wybe.float.-<3>
                    wybe.float.-<4>
                    wybe.float.-=<0>
                    wybe.float./<0>
                    wybe.float./=<0>
                    wybe.float.<<0>
                    wybe.float.<=<0>
                    wybe.float.<=><0>
                    wybe.float.=<0>
                    wybe.float.><0>
                    wybe.float.>=<0>
                    wybe.float.abs<0>
                    wybe.float.ceil<0>
                    wybe.float.cos<0>
                    wybe.float.e<0>
                    wybe.float.exp<0>
                    wybe.float.floor<0>
                    wybe.float.iceil<0>
                    wybe.float.ifloor<0>
                    wybe.float.iround<0>
                    wybe.float.log<0>
                    wybe.float.log10<0>
                    wybe.float.log2<0>
                    wybe.float.max<0>
                    wybe.float.min<0>
                    wybe.float.pi<0>
                    wybe.float.power<0>
                    wybe.float.print<0>
                    wybe.float.println<0>
                    wybe.float.read<0>
                    wybe.float.round<0>
                    wybe.float.sin<0>
                    wybe.float.sqrt<0>
                    wybe.float.square<0>
                    wybe.float.tan<0>
                    wybe.float.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

* > public {inline} (1 calls)
0: wybe.float.*<0>
*(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:45:25


** > public {inline} (0 calls)
0: wybe.float.**<0>
**(x##0:wybe.float, n##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.pow.f64(~x##0:wybe.float, ~n##0:wybe.float, ?#result##0:wybe.float) @float:112:27


*= > public {inline} (0 calls)
0: wybe.float.*=<0>
*=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:45:25


+ > public {inline} (1 calls)
0: wybe.float.+<0>
+(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:23:27
+ > public {inline} (0 calls)
1: wybe.float.+<1>
+(?x##0:wybe.float, y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:24:43
+ > public {inline} (0 calls)
2: wybe.float.+<2>
+(x##0:wybe.float, ?y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~x##0:wybe.float, ?y##0:wybe.float) @float:25:43


+= > public {inline} (0 calls)
0: wybe.float.+=<0>
+=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:23:27


- > public {inline} (1 calls)
0: wybe.float.-<0>
-(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:32:27
- > public {inline} (0 calls)
1: wybe.float.-<1>
-(?x##0:wybe.float, y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~z##0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:33:43
- > public {inline} (0 calls)
2: wybe.float.-<2>
-(x##0:wybe.float, ?y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~x##0:wybe.float, ?y##0:wybe.float) @float:34:43
- > public {inline} (0 calls)
3: wybe.float.-<3>
-(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(0.0:wybe.float, ~x##0:wybe.float, ?#result##0:wybe.float) @float:38:21
- > public {inline} (0 calls)
4: wybe.float.-<4>
-(?x##0:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(0.0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:39:37


-= > public {inline} (0 calls)
0: wybe.float.-=<0>
-=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:32:27


/ > public {inline} (2 calls)
0: wybe.float./<0>
/(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fdiv(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:51:25


/= > public {inline} (0 calls)
0: wybe.float./=<0>
/=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fdiv(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:51:25


< > public {inline} (4 calls)
0: wybe.float.<<0>
<(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_slt(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:70:29


<= > public {inline} (0 calls)
0: wybe.float.<=<0>
<=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sle(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:71:30


<=> > public (0 calls)
0: wybe.float.<=><0>
<=>(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_slt(x##0:wybe.float, y##0:wybe.float, ?tmp#6##0:wybe.bool) @float:70:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm fcmp_eq(~x##0:wybe.float, ~y##0:wybe.float, ?tmp#5##0:wybe.bool) @float:66:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5



= > public {inline} (2 calls)
0: wybe.float.=<0>
=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_eq(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:66:29


> > public {inline} (0 calls)
0: wybe.float.><0>
>(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sgt(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:72:29


>= > public {inline} (0 calls)
0: wybe.float.>=<0>
>=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sge(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:73:30


abs > public {inline} (0 calls)
0: wybe.float.abs<0>
abs(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.fabs.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:60:22


ceil > public {inline} (1 calls)
0: wybe.float.ceil<0>
ceil(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.ceil.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:87:23


cos > public {inline} (0 calls)
0: wybe.float.cos<0>
cos(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.cos.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:116:22


e > public {inline} (0 calls)
0: wybe.float.e<0>
e(?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2.7182818284590455:wybe.float, ?#result##0:wybe.float) @float:16:5


exp > public {inline} (0 calls)
0: wybe.float.exp<0>
exp(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.exp.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:120:22


floor > public {inline} (1 calls)
0: wybe.float.floor<0>
floor(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.floor.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:90:24


iceil > public {inline} (0 calls)
0: wybe.float.iceil<0>
iceil(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.ceil.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:87:23
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:99:26


ifloor > public {inline} (0 calls)
0: wybe.float.ifloor<0>
ifloor(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.floor.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:90:24
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:102:27


iround > public {inline} (0 calls)
0: wybe.float.iround<0>
iround(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.round.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:93:24
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:96:27


log > public {inline} (0 calls)
0: wybe.float.log<0>
log(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:123:22


log10 > public {inline} (0 calls)
0: wybe.float.log10<0>
log10(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log10.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:126:24


log2 > public {inline} (0 calls)
0: wybe.float.log2<0>
log2(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log2.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:129:23


max > public {inline} (0 calls)
0: wybe.float.max<0>
max(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.maxnum.f64(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:81:27


min > public {inline} (0 calls)
0: wybe.float.min<0>
min(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.minnum.f64(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:80:27


pi > public {inline} (0 calls)
0: wybe.float.pi<0>
pi(?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(3.141592653589793:wybe.float, ?#result##0:wybe.float) @float:13:5


power > public {inline} (0 calls)
0: wybe.float.power<0>
power(x##0:wybe.float, n##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.pow.f64(~x##0:wybe.float, ~n##0:wybe.float, ?#result##0:wybe.float) @float:111:28


print > public {inline} (1 calls)
0: wybe.float.print<0>
print(x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @float:133:30
    foreign c print_float(~x##0:wybe.float, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @float:133:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @float:133:30


println > public {inline} (0 calls)
0: wybe.float.println<0>
println(x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @float:133:30
    foreign c print_float(~x##0:wybe.float, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @float:133:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.float.read<0>
read(?x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @float:137:30
    foreign c read_float(?x##0:wybe.float, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @float:137:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @float:137:30


round > public {inline} (1 calls)
0: wybe.float.round<0>
round(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.round.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:93:24


sin > public {inline} (0 calls)
0: wybe.float.sin<0>
sin(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sin.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:115:22


sqrt > public {inline} (0 calls)
0: wybe.float.sqrt<0>
sqrt(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sqrt.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:108:23


square > public {inline} (0 calls)
0: wybe.float.square<0>
square(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~x##0:wybe.float, ?#result##0:wybe.float) @float:57:25


tan > public {inline} (0 calls)
0: wybe.float.tan<0>
tan(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sin.f64(x##0:wybe.float, ?tmp#1##0:wybe.float) @float:117:22
    foreign c llvm.cos.f64(~x##0:wybe.float, ?tmp#2##0:wybe.float) @float:117:52
    foreign llvm fdiv(~tmp#1##0:wybe.float, ~tmp#2##0:wybe.float, ?#result##0:wybe.float) @float:51:25


~= > public {inline} (0 calls)
0: wybe.float.~=<0>
~=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_ne(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:67:30

LLVM code       : None

--------------------------------------------------
 Module wybe.int
  representation  : 64 bit signed
  public submods  : 
  public resources: 
  public procs    : wybe.int.%<0>
                    wybe.int.%=<0>
                    wybe.int.*<0>
                    wybe.int.*=<0>
                    wybe.int.+<0>
                    wybe.int.+<1>
                    wybe.int.+<2>
                    wybe.int.+=<0>
                    wybe.int.-<0>
                    wybe.int.-<1>
                    wybe.int.-<2>
                    wybe.int.-<3>
                    wybe.int.-<4>
                    wybe.int.-=<0>
                    wybe.int./<0>
                    wybe.int./=<0>
                    wybe.int.<<0>
                    wybe.int.<<<0>
                    wybe.int.<<=<0>
                    wybe.int.<=<0>
                    wybe.int.<=><0>
                    wybe.int.=<0>
                    wybe.int.><0>
                    wybe.int.>=<0>
                    wybe.int.>><0>
                    wybe.int.>>=<0>
                    wybe.int.decr<0>
                    wybe.int.incr<0>
                    wybe.int.logical_bitshift<0>
                    wybe.int.logical_bitshift<1>
                    wybe.int.max<0>
                    wybe.int.min<0>
                    wybe.int.power<0>
                    wybe.int.print<0>
                    wybe.int.println<0>
                    wybe.int.read<0>
                    wybe.int.signum<0>
                    wybe.int.sqrt<0>
                    wybe.int.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.int.%<0>
%(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:50:25


%= > public {inline} (0 calls)
0: wybe.int.%=<0>
%=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:50:25


* > public {inline} (1 calls)
0: wybe.int.*<0>
*(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:38:25


*= > public {inline} (0 calls)
0: wybe.int.*=<0>
*=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:38:25


+ > public {inline} (2 calls)
0: wybe.int.+<0>
+(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:16:27
+ > public {inline} (0 calls)
1: wybe.int.+<1>
+(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:17:43
+ > public {inline} (0 calls)
2: wybe.int.+<2>
+(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:18:43


+= > public {inline} (0 calls)
0: wybe.int.+=<0>
+=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:16:27


- > public {inline} (2 calls)
0: wybe.int.-<0>
-(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:25:27
- > public {inline} (0 calls)
1: wybe.int.-<1>
-(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.int, ~z##0:wybe.int, ?x##0:wybe.int) @int:26:43
- > public {inline} (0 calls)
2: wybe.int.-<2>
-(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:27:43
- > public {inline} (0 calls)
3: wybe.int.-<3>
-(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~x##0:wybe.int, ?#result##0:wybe.int) @int:31:21
- > public {inline} (0 calls)
4: wybe.int.-<4>
-(?x##0:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:32:37


-= > public {inline} (0 calls)
0: wybe.int.-=<0>
-=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:25:27


/ > public {inline} (1 calls)
0: wybe.int./<0>
/(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:44:25


/= > public {inline} (0 calls)
0: wybe.int./=<0>
/=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:44:25


< > public {inline} (4 calls)
0: wybe.int.<<0>
<(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:87:29


<< > public {inline} (1 calls)
0: wybe.int.<<<0>
<<(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:56:27


<<= > public {inline} (0 calls)
0: wybe.int.<<=<0>
<<=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:56:27


<= > public {inline} (3 calls)
0: wybe.int.<=<0>
<=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:88:30


<=> > public (0 calls)
0: wybe.int.<=><0>
<=>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(x##0:wybe.int, y##0:wybe.int, ?tmp#6##0:wybe.bool) @int:87:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?tmp#5##0:wybe.bool) @int:83:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5



= > public {inline} (2 calls)
0: wybe.int.=<0>
=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:83:29


> > public {inline} (0 calls)
0: wybe.int.><0>
>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sgt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:89:29


>= > public {inline} (3 calls)
0: wybe.int.>=<0>
>=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:90:30


>> > public {inline} (1 calls)
0: wybe.int.>><0>
>>(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:65:27


>>= > public {inline} (0 calls)
0: wybe.int.>>=<0>
>>=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:65:27


decr > public {inline} (0 calls)
0: wybe.int.decr<0>
decr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:25:27


incr > public {inline} (0 calls)
0: wybe.int.incr<0>
incr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:16:27


logical_bitshift > public {inline} (1 calls)
0: wybe.int.logical_bitshift<0>
logical_bitshift(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:74:40
logical_bitshift > public {inline} (0 calls)
1: wybe.int.logical_bitshift<1>
logical_bitshift(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:74:40


max > public (0 calls)
0: wybe.int.max<0>
max(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:90:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:98:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:98:5



min > public (0 calls)
0: wybe.int.min<0>
min(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:88:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:97:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:97:5



power > public {inline} (0 calls)
0: wybe.int.power<0>
power(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c ipow(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:107:29


print > public {inline} (1 calls)
0: wybe.int.print<0>
print(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:119:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:119:30


println > public {inline} (0 calls)
0: wybe.int.println<0>
println(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @int:119:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.int.read<0>
read(?x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:123:30
    foreign c read_int(?x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:123:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:123:30


signum > public {inline} (0 calls)
0: wybe.int.signum<0>
signum(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c signum(~x##0:wybe.int, ?#result##0:wybe.int) @int:114:25


sqrt > public {inline} (0 calls)
0: wybe.int.sqrt<0>
sqrt(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c isqrt(~x##0:wybe.int, ?#result##0:wybe.int) @int:104:23


~= > public {inline} (0 calls)
0: wybe.int.~=<0>
~=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:84:30

LLVM code       : None

--------------------------------------------------
 Module wybe.io
  representation  : (not a type)
  public submods  : phantom -> wybe.phantom
  public resources: io: wybe.io.io
  public procs    : wybe.io.<0>
                    wybe.io.eof<0>
                    wybe.io.nl<0>
  imports         : use wybe.char
                    public use wybe.phantom
  resources       : io: fromList [(wybe.io.io,wybe.phantom = 0:phantom @io:13:27 @io:13:5)]
  procs           : 

module top-level code > public {inline,semipure} (0 calls)
0: wybe.io.<0>
()<{}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm store(0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:13:5


eof > public {inline} (0 calls)
0: wybe.io.eof<0>
eof(?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(-1:wybe.int, ?#result##0:wybe.char) @io:20:29


nl > public {inline} (0 calls)
0: wybe.io.nl<0>
nl()<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @io:17:31
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31

LLVM code       : None

--------------------------------------------------
 Module wybe.list(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.list.,,<0>
                    wybe.list.[]<0>
                    wybe.list.all<0>
                    wybe.list.any<0>
                    wybe.list.empty<0>
                    wybe.list.filter<0>
                    wybe.list.foldl<0>
                    wybe.list.foldr<0>
                    wybe.list.length<0>
                    wybe.list.list<0>
                    wybe.list.map<0>
                    wybe.list.map<1>
                    wybe.list.map<2>
                    wybe.list.print<0>
                    wybe.list.println<0>
                    wybe.list.reverse<0>
  imports         : use wybe.array
                    use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
                    use wybe.machine_word
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_(T) @list:20:10, y:_(T) @list:20:20, ?#result:_(T) @list:20:5):
    if {[|](?h @list:21:16, ?t @list:21:21, x @list:21:10)::

        ,,(t @list:21:32, y @list:21:37, ?tmp#2 @list:21:32)
        [|](h @list:21:28, tmp#2, ?tmp#1 @list:21:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(y @list:21:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:21:10, ?#result @list:20:5)


[] > public {test} (0 calls)
0: [](xs:_(T) @list:31:21, idx:int @list:31:30, ?#result:T @list:31:5):
    >=(idx @list:32:5, 0 @list:32:13)
    index1(xs @list:33:17, idx @list:33:21, ?tmp#0 @list:33:10)
    =(?x @list:33:6, tmp#0)
    foreign llvm move(x @list:31:43, ?#result @list:31:5)


all > public {test} (0 calls)
0: all(p:{test}(T) @list:61:20, xs:_(T) @list:61:33):
    foreign llvm move(xs @list:62:15, ?tmp#0)
    do {
        if {[|](?x @list:62:10, ?tmp#0, tmp#0)::

            p(x @list:63:11)
        else::
            break

        }
    }


any > public {test} (0 calls)
0: any(p:{test}(T) @list:69:20, xs:_(T) @list:69:33):
    [|](?x @list:70:7, ?xs @list:70:12, xs @list:70:18)
    (   p(x @list:71:8)
    | any(p @list:71:17, xs @list:71:20))


empty > public {test} (0 calls)
0: empty(xs:_(T) @list:15:22):
    if {[|](?tmp#0 @list:16:11, ?tmp#1 @list:16:15, xs @list:16:20)::

        fail
    else::
        pass

    }


filter > public (0 calls)
0: filter(p:{test}(T) @list:95:16, !xs:_(T) @list:95:30):
    [](?tmp#0 @list:96:12)
    =(?out @list:96:6, tmp#0)
    foreign llvm move(xs @list:97:15, ?tmp#1)
    do {
        if {[|](?x @list:97:10, ?tmp#1, tmp#1)::

            if {p(x @list:98:16)::

                [|](x @list:98:30, out @list:98:34, ?tmp#2 @list:98:29)
                =(?out @list:98:23, tmp#2)
            else::
                pass

            }
        else::
            break

        }
    }
    reverse(out @list:100:19, ?tmp#3 @list:100:11)
    =(?as @list:100:6, tmp#3)


foldl > public (0 calls)
0: foldl(f:(A, !B) @list:77:15, as:_(A) @list:77:26, !b:B @list:77:36):
    foreign llvm move(as @list:78:15, ?tmp#0)
    do {
        if {[|](?a @list:78:10, ?tmp#0, tmp#0)::

            f(a @list:79:11, !b @list:79:15)
        else::
            break

        }
    }


foldr > public (0 calls)
0: foldr(f:(A, !B) @list:86:15, as:_(A) @list:86:26, !b:B @list:86:36):
    if {[|](?a @list:87:12, ?as @list:87:17, as @list:87:23)::

        foldr(f @list:88:15, as @list:88:18, !b @list:88:23)
        f(a @list:89:11, !b @list:89:15)
    else::
        pass

    }


index1 > {test} (0 calls)
0: index1(xs:_(T) @list:148:19, idx:int @list:148:28, ?#result:T @list:148:1):
    [|](?x @list:149:7, ?xs @list:149:12, xs @list:149:18)
    (   =(idx @list:150:6, 0 @list:150:12)
    | (   -(idx @list:150:27, 1 @list:150:33, ?tmp#0 @list:150:27)
        & index1(xs @list:150:23, tmp#0, ?x @list:150:37)))
    foreign llvm move(x @list:148:41, ?#result @list:148:1)


length > public (0 calls)
0: length(x:_(T) @list:24:16, ?#result:int @list:24:5):
    length1(x @list:24:38, 0 @list:24:41, ?tmp#0 @list:24:30)
    foreign llvm move(tmp#0, ?#result @list:24:5)


length1 > (0 calls)
0: length1(x:_(T) @list:140:13, acc:int @list:140:21, ?#result:int @list:140:1):
    if {[|](?h @list:141:16, ?t @list:141:21, x @list:141:10)::

        +(acc @list:141:38, 1 @list:141:44, ?tmp#2 @list:141:38)
        length1(t @list:141:35, tmp#2, ?tmp#1 @list:141:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(acc @list:141:57, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:141:10, ?#result @list:140:1)


list > public (0 calls)
0: list(ar:array(T) @list:128:14, ?#result:_(T) @list:128:5):
    [](?tmp#0 @list:129:11)
    =(?ls @list:129:6, tmp#0)
    foreign llvm move(ar @list:130:15, ?tmp#1)
    do {
        if {[|](?x @list:130:10, ?tmp#1, tmp#1)::

            [|](x @list:131:16, ls @list:131:20, ?tmp#2 @list:131:15)
            =(?ls @list:131:10, tmp#2)
        else::
            break

        }
    }
    reverse(ls @list:133:13, ?ls @list:133:18)
    foreign llvm move(ls @list:128:34, ?#result @list:128:5)


map > public (0 calls)
0: map(f:{resource}(T) @list:41:13, xs:_(T) @list:41:30):
    foreign llvm move(xs @list:42:15, ?tmp#0)
    do {
        if {[|](?x @list:42:10, ?tmp#0, tmp#0)::

            !f(x @list:43:12)
        else::
            break

        }
    }
map > public (0 calls)
1: map(f:(A, ?B) @list:49:13, as:_(A) @list:49:24, ?#result:_(B) @list:49:5):
    if {[|](?a @list:50:12, ?as @list:50:17, as @list:50:23)::

        f(a @list:50:33, ?tmp#2 @list:50:31)
        map(f @list:50:42, as @list:50:45, ?tmp#3 @list:50:38)
        [|](tmp#2, tmp#3, ?tmp#1 @list:50:29)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:50:61)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:50:10, ?#result @list:49:5)
map > public (0 calls)
2: map(f:(A, B, ?C) @list:55:13, as:_(A) @list:55:27, bs:_(B) @list:55:36, ?#result:_(C) @list:55:5):
    if {(   [|](?a @list:56:12, ?as @list:56:17, as @list:56:23)
        & [|](?b @list:56:30, ?bs @list:56:35, bs @list:56:41))::

        f(a @list:56:51, b @list:56:54, ?tmp#2 @list:56:49)
        map(f @list:56:63, as @list:56:66, bs @list:56:70, ?tmp#3 @list:56:59)
        [|](tmp#2, tmp#3, ?tmp#1 @list:56:47)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:57:47)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:56:10, ?#result @list:55:5)


print > public (0 calls)
0: print(printer:{resource}(T) @list:108:15, xs:_(T) @list:108:38) use !io:
    !print('[' @list:109:12)
    if {[|](?x @list:110:12, ?xs @list:110:17, xs @list:110:23)::

        !printer(x @list:111:18)
        !print1(printer @list:112:17, xs @list:112:26)
    else::
        pass

    }
    !print(']' @list:114:12)


print1 > (0 calls)
0: print1(printer:{resource}(T) @list:154:12, xs:_(T) @list:154:35) use !io:
    if {[|](?x @list:155:12, ?xs @list:155:17, xs @list:155:23)::

        !print(',' @list:156:16)
        !printer(x @list:157:18)
        !print1(printer @list:158:17, xs @list:158:26)
    else::
        pass

    }


println > public (0 calls)
0: println(printer:{resource}(T) @list:119:17, xs:_(T) @list:119:40) use !io:
    !print(printer @list:120:12, xs @list:120:21)
    !nl


reverse > public (0 calls)
0: reverse(x:_(T) @list:27:17, ?#result:_(T) @list:27:5):
    [](?tmp#1 @list:27:44)
    reverse1(x @list:27:41, tmp#1, ?tmp#0 @list:27:32)
    foreign llvm move(tmp#0, ?#result @list:27:5)


reverse1 > (0 calls)
0: reverse1(x:_(T) @list:144:14, tail:_(T) @list:144:22, ?#result:_(T) @list:144:1):
    if {[|](?h @list:145:16, ?t @list:145:21, x @list:145:10)::

        [|](h @list:145:40, tail @list:145:44, ?tmp#2 @list:145:39)
        reverse1(t @list:145:36, tmp#2, ?tmp#1 @list:145:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(tail @list:145:61, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:145:10, ?#result @list:144:1)

LLVM code       : None

--------------------------------------------------
 Module wybe.machine_word
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.machine_word.word_size_bits<0>
                    wybe.machine_word.word_size_bytes<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

word_size_bits > public (0 calls)
0: word_size_bits(?#result:int @machine_word:12:5):
    word_size_bytes(?tmp#1 @machine_word:12:34)
    *(8 @machine_word:12:30, tmp#1, ?tmp#0 @machine_word:12:30)
    foreign llvm move(tmp#0, ?#result @machine_word:12:5)


word_size_bytes > public (0 calls)
0: word_size_bytes(?#result:int @machine_word:10:5):
    foreign llvm move(8 @machine_word:10:31, ?#result @machine_word:10:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.memory_management
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.memory_management.malloc_count<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

malloc_count > public {semipure} (0 calls)
0: malloc_count(?x:int @memory_management:11:34):
    foreign c {impure} malloc_count(?x @memory_management:12:38)

LLVM code       : None

--------------------------------------------------
 Module wybe.phantom
 modifiers       : {unique} 
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : 
  imports         : 
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.predicate
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.predicate.const<0>
                    wybe.predicate.id<0>
  imports         : 
  resources       : 
  procs           : 

const > public {inline} (0 calls)
0: wybe.predicate.const<0>
const(a##0:A <{}; {}; {0}>, [b##0:B <{}; {}; {1}>], ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:8:5


id > public {inline} (0 calls)
0: wybe.predicate.id<0>
id(a##0:A <{}; {}; {0}>, ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:6:5

LLVM code       : None

--------------------------------------------------
 Module wybe.range
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.range...<0>
                    wybe.range.[]<0>
                    wybe.range.[|]<0>
                    wybe.range.irange<0>
                    wybe.range.size<0>
                    wybe.range.xrange<0>
  imports         : use wybe.bool
                    use wybe.int
  resources       : 
  procs           : 

.. > public (0 calls)
0: ..(start:int @range:38:10, end:int @range:38:23, ?#result:_ @range:38:5):
    if {<=(start @range:39:27, end @range:39:37)::

        foreign llvm move(1 @range:39:44, ?tmp#1)
    else::
        foreign llvm move(-1 @range:39:56, ?tmp#1)

    }
    construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)
    foreign llvm move(tmp#0, ?#result @range:38:5)


[] > public {test} (0 calls)
0: [](r:_ @range:20:19, idx:int @range:20:24, ?value:int @range:20:34):
    <=(0 @range:21:6, idx @range:21:12)
    range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)
    *(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)
    +(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)
    =(?value @range:23:6, tmp#0)
    if {<=(0 @range:24:10, stride @range:24:16)::

        <(value @range:24:27, end @range:24:35)
    else::
        <(end @range:24:51, value @range:24:57)

    }


[|] > public {test} (0 calls)
0: [|](?value:int @range:12:23, ?rest:_ @range:12:35, current:_ @range:12:43):
    range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)
    ~=(value @range:14:6, end @range:14:16)
    +(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)
    range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)
    =(?rest @range:15:6, tmp#0)


construct > (0 calls)
0: construct(start:int @range:49:15, stride:int @range:49:26, end:int @range:49:38, ?#result:_ @range:49:1):
    -(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)
    %(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)
    =(?diff @range:50:6, tmp#0)
    if {<=(0 @range:51:19, stride @range:51:25)::

        if {=(diff @range:52:26, 0 @range:52:33)::

            max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
            -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
            max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
            foreign llvm move(tmp#5, ?tmp#3)

        }
        foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
    else::
        if {=(diff @range:55:26, 0 @range:55:33)::

            min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
            foreign llvm move(tmp#9, ?tmp#8)
        else::
            +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
            min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
            foreign llvm move(tmp#10, ?tmp#8)

        }
        foreign llvm move(tmp#8 @range:55:26, ?tmp#2)

    }
    =(?final @range:51:6, tmp#2 @range:51:19)
    range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)
    =(?r @range:58:6, tmp#12)
    foreign llvm move(r @range:49:51, ?#result @range:49:1)


irange > public (0 calls)
0: irange(start:int @range:32:16, stride:int @range:32:27, end:int @range:32:39, ?#result:_ @range:32:5):
    if {<(stride @range:33:41, 0 @range:33:50)::

        foreign llvm move(-1 @range:33:55, ?tmp#2)
    else::
        foreign llvm move(1 @range:33:68, ?tmp#2)

    }
    +(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)
    construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)
    foreign llvm move(tmp#0, ?#result @range:32:5)


size > public (0 calls)
0: size(r:_ @range:42:14, ?#result:int @range:42:5):
    range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)
    if {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
        & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
        & signum(tmp#3, ?tmp#2 @range:44:29)
        & ~=(tmp#1, tmp#2))::

        foreign llvm move(0 @range:44:52, ?tmp#0)
    else::
        if {<=(0 @range:45:10, stride @range:45:16)::

            -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
            -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
            /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
            +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
            foreign llvm move(tmp#5, ?tmp#4)
        else::
            -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
            -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
            -(stride @range:46:39, ?tmp#13 @range:46:38)
            /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
            +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
            foreign llvm move(tmp#9, ?tmp#4)

        }
        foreign llvm move(tmp#4 @range:45:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)


xrange > public (0 calls)
0: xrange(start:int @range:28:16, stride:int @range:28:27, end:int @range:28:39, ?#result:_ @range:28:5):
    construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)
    foreign llvm move(tmp#0, ?#result @range:28:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.string
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.string.,,<0>
                    wybe.string.<<0>
                    wybe.string.<=<0>
                    wybe.string.<=><0>
                    wybe.string.=<0>
                    wybe.string.><0>
                    wybe.string.>=<0>
                    wybe.string.[]<0>
                    wybe.string.[]<1>
                    wybe.string.[|]<0>
                    wybe.string.c_string<0>
                    wybe.string.length<0>
                    wybe.string.print<0>
                    wybe.string.println<0>
                    wybe.string.read<0>
                    wybe.string.string<0>
                    wybe.string.string<1>
                    wybe.string.~=<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.char
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
                    use wybe.range
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_ @string:64:10, y:_ @string:64:17, ?#result:_ @string:64:5):
    if {(   empty(?tmp#1 @string:65:14)
        & =(x @string:65:10, tmp#1))::

        foreign llvm move(y @string:65:23, ?tmp#0)
    else::
        if {(   empty(?tmp#3 @string:66:14)
            & =(y @string:66:10, tmp#3))::

            foreign llvm move(x @string:66:23, ?tmp#2)
        else::
            concat(x @string:67:25, y @string:67:28, ?tmp#4 @string:67:18)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:66:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:65:10, ?#result @string:64:5)


< > public (0 calls)
0: <(x:_ @string:119:10, y:_ @string:119:17, ?#result:bool @string:119:5):
    <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
    equal(?tmp#2 @string:119:44)
    <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
    foreign llvm move(tmp#0, ?#result @string:119:5)


<= > public (0 calls)
0: <=(x:_ @string:120:10, y:_ @string:120:18, ?#result:bool @string:120:5):
    <=>(x @string:120:31, y @string:120:39, ?tmp#1 @string:120:31)
    equal(?tmp#2 @string:120:46)
    <=(tmp#1, tmp#2, ?tmp#0 @string:120:30)
    foreign llvm move(tmp#0, ?#result @string:120:5)


<=> > public (0 calls)
0: <=>(x:_ @string:125:10, y:_ @string:125:20, ?#result:comparison @string:125:5):
    equal(?tmp#0 @string:126:10)
    =(?c @string:126:6, tmp#0)
    foreign llvm move(x @string:127:16, ?tmp#1)
    foreign llvm move(y @string:127:26, ?tmp#2)
    do {
        if {[|](?cx @string:127:10, ?tmp#1, tmp#1)::

            if {[|](?cy @string:127:20, ?tmp#2, tmp#2)::

                if {<(cx @string:128:14, cy @string:128:19)::

                    lesser(?tmp#3 @string:128:30)
                    =(?c @string:128:26, tmp#3)
                    break
                else::
                    if {>(cx @string:129:14, cy @string:129:19)::

                        greater(?tmp#4 @string:129:30)
                        =(?c @string:129:26, tmp#4)
                        break
                    else::
                        pass

                    }

                }
            else::
                break

            }
        else::
            break

        }
    }
    if {(   equal(?tmp#5 @string:132:14)
        & =(c @string:132:10, tmp#5))::

        length(x @string:133:22, ?tmp#6 @string:133:15)
        =(?lx @string:133:10, tmp#6)
        length(y @string:134:22, ?tmp#7 @string:134:15)
        =(?ly @string:134:10, tmp#7)
        if {<(lx @string:135:14, ly @string:135:19)::

            lesser(?tmp#8 @string:135:30)
            =(?c @string:135:26, tmp#8)
        else::
            if {>(lx @string:135:39, ly @string:135:44)::

                greater(?tmp#9 @string:135:55)
                =(?c @string:135:51, tmp#9)
            else::
                pass

            }

        }
    else::
        pass

    }
    foreign llvm move(c @string:125:38, ?#result @string:125:5)


= > public (0 calls)
0: =(x:_ @string:115:10, y:_ @string:115:17, ?#result:bool @string:115:5):
    <=>(x @string:115:30, y @string:115:38, ?tmp#1 @string:115:30)
    equal(?tmp#2 @string:115:44)
    =(tmp#1, tmp#2, ?tmp#0 @string:115:29)
    foreign llvm move(tmp#0, ?#result @string:115:5)


> > public (0 calls)
0: >(x:_ @string:121:10, y:_ @string:121:17, ?#result:bool @string:121:5):
    <=>(x @string:121:30, y @string:121:38, ?tmp#1 @string:121:30)
    equal(?tmp#2 @string:121:44)
    >(tmp#1, tmp#2, ?tmp#0 @string:121:29)
    foreign llvm move(tmp#0, ?#result @string:121:5)


>= > public (0 calls)
0: >=(x:_ @string:122:10, y:_ @string:122:18, ?#result:bool @string:122:5):
    <=>(x @string:122:31, y @string:122:39, ?tmp#1 @string:122:31)
    equal(?tmp#2 @string:122:46)
    >=(tmp#1, tmp#2, ?tmp#0 @string:122:30)
    foreign llvm move(tmp#0, ?#result @string:122:5)


[] > public {test} (0 calls)
0: [](s:_ @string:91:19, idx:int @string:91:24, ?c:char @string:91:34):
    if {buffer(?len @string:93:17, ?str @string:93:23, s @string:92:10)::

        <=(0 @string:94:14, idx @string:94:20)
        <(idx @string:95:14, len @string:95:20)
        unsafe_c_string_index(str @string:96:35, idx @string:96:40, ?c @string:96:46)
    else::
        if {concat(?left @string:97:17, ?right @string:97:24, s @string:92:10)::

            length(left @string:98:32, ?tmp#0 @string:98:25)
            =(?left_len @string:98:14, tmp#0)
            if {<(idx @string:99:18, left_len @string:99:24)::

                [](left @string:99:41, idx @string:99:46, ?tmp#1 @string:99:41)
                =(?c @string:99:37, tmp#1)
            else::
                -(idx @string:100:37, left_len @string:100:43, ?tmp#3 @string:100:37)
                [](right @string:100:31, tmp#3, ?tmp#2 @string:100:31)
                =(?c @string:100:27, tmp#2)

            }
        else::
            if {slice(?base @string:102:16, ?range @string:102:23, s @string:92:10)::

                [](range @string:102:43, idx @string:102:49, ?tmp#5 @string:102:43)
                [](base @string:102:38, tmp#5, ?tmp#4 @string:102:38)
                =(?c @string:102:34, tmp#4)
            else::
                if {singleton(?c @string:103:20, s @string:92:10)::

                    =(idx @string:103:27, 0 @string:103:33)
                else::
                    fail

                }

            }

        }

    }
[] > public (0 calls)
1: [](s:_ @string:109:12, r:range @string:109:17, ?#result:_ @string:109:5):
    slice(s @string:109:36, r @string:109:39, ?tmp#0 @string:109:30)
    foreign llvm move(tmp#0, ?#result @string:109:5)


[|] > public {test} (0 calls)
0: [|](?head:char @string:71:23, ?tail:_ @string:71:35, s:_ @string:71:43):
    if {buffer(?len @string:73:17, ?str @string:73:23, s @string:72:10)::

        [|](?head @string:74:15, ?str @string:74:23, str @string:74:30)
        if {=(len @string:75:26, 1 @string:75:32)::

            empty(?tmp#1 @string:75:37)
            foreign llvm move(tmp#1, ?tmp#0)
        else::
            -(len @string:75:60, 1 @string:75:66, ?tmp#3 @string:75:60)
            buffer(tmp#3, str @string:75:69, ?tmp#2 @string:75:53)
            foreign llvm move(tmp#2, ?tmp#0)

        }
        =(?tail @string:75:14, tmp#0 @string:75:26)
    else::
        if {concat(?left @string:76:17, ?right @string:76:24, s @string:72:10)::

            if {[|](?head @string:77:20, ?t @string:77:28, left @string:77:33)::

                concat(t @string:77:56, right @string:77:59, ?tmp#4 @string:77:49)
                =(?tail @string:77:42, tmp#4)
            else::
                [|](?head @string:78:28, ?tail @string:78:36, right @string:78:44)

            }
        else::
            if {slice(?base @string:80:16, ?range @string:80:23, s @string:72:10)::

                do {
                    [|](?idx @string:82:19, ?range @string:82:26, range @string:82:35)
                    if {(   [](base @string:83:30, idx @string:83:35, ?tmp#5 @string:83:30)
                        & =(?head @string:83:23, tmp#5))::

                        slice(base @string:83:57, range @string:83:63, ?tmp#6 @string:83:51)
                        =(?tail @string:83:44, tmp#6)
                        break
                    else::
                        pass

                    }
                }
            else::
                if {singleton(?head @string:85:20, s @string:72:10)::

                    empty(?tmp#7 @string:85:37)
                    =(?tail @string:85:30, tmp#7)
                else::
                    fail

                }

            }

        }

    }


c_string > public (0 calls)
0: c_string(s:_ @string:40:18, ?#result:c_string @string:40:5):
    if {buffer(?tmp#0 @string:41:21, ?str @string:41:25, s @string:41:10)::

        pass
    else::
        length(s @string:43:27, ?tmp#2 @string:43:20)
        +(tmp#2, 1 @string:43:32, ?tmp#1 @string:43:20)
        =(?len @string:43:14, tmp#1)
        foreign lpvm alloc(len @string:44:32, ?str @string:44:38)
        true(?tmp#3 @string:45:49)
        foreign lpvm mutate(str @string:45:33, ?str @string:45:39, len @string:45:44, tmp#3, len @string:45:55, 0 @string:45:60, '\NUL' @string:45:63)
        =(?offset @string:46:14, 0 @string:46:23)
        pack(s @string:47:18, !str @string:47:22, len @string:47:27, !offset @string:47:33)

    }
    foreign llvm move(str @string:40:34, ?#result @string:40:5)


fixed_range_size > (0 calls)
0: fixed_range_size(hi:int @string:184:22, r:range @string:184:30, ?sz:int @string:184:40):
    range(?start @string:185:16, ?stride @string:185:24, ?end @string:185:33, r @string:185:5)
    if {<=(0 @string:186:10, stride @string:186:16)::

        -(start @string:187:39, ?tmp#4 @string:187:38)
        /(tmp#4, stride @string:187:47, ?tmp#3 @string:187:38)
        *(tmp#3, stride @string:187:56, ?tmp#2 @string:187:38)
        +(start @string:187:30, tmp#2, ?tmp#1 @string:187:30)
        max(start @string:187:23, tmp#1, ?tmp#0 @string:187:19)
        =(?lo @string:187:14, tmp#0)
        min(hi @string:188:23, end @string:188:27, ?tmp#5 @string:188:19)
        =(?hi @string:188:14, tmp#5)
    else::
        max(-1 @string:190:23, end @string:190:27, ?tmp#6 @string:190:19)
        =(?lo @string:190:14, tmp#6)
        +(hi @string:191:30, stride @string:191:35, ?tmp#10 @string:191:30)
        -(start @string:191:45, hi @string:191:53, ?tmp#13 @string:191:45)
        -(tmp#13, 1 @string:191:58, ?tmp#12 @string:191:45)
        -(stride @string:191:64, ?tmp#14 @string:191:63)
        %(tmp#12, tmp#14, ?tmp#11 @string:191:44)
        +(tmp#10, tmp#11, ?tmp#9 @string:191:30)
        +(tmp#9, 1 @string:191:73, ?tmp#8 @string:191:30)
        min(start @string:191:23, tmp#8, ?tmp#7 @string:191:19)
        =(?hi @string:191:14, tmp#7)
        -(stride @string:192:24, ?tmp#15 @string:192:23)
        =(?stride @string:192:14, tmp#15)

    }
    if {<=(hi @string:194:16, lo @string:194:23)::

        foreign llvm move(0 @string:194:29, ?tmp#16)
    else::
        -(hi @string:194:42, lo @string:194:47, ?tmp#20 @string:194:42)
        -(tmp#20, 1 @string:194:52, ?tmp#19 @string:194:42)
        /(tmp#19, stride @string:194:57, ?tmp#18 @string:194:41)
        +(tmp#18, 1 @string:194:66, ?tmp#17 @string:194:41)
        foreign llvm move(tmp#17, ?tmp#16)

    }
    =(?sz @string:194:6, tmp#16 @string:194:16)


length > public (0 calls)
0: length(s:_ @string:52:16, ?#result:int @string:52:5):
    if {buffer(?len @string:53:22, ?tmp#1 @string:53:27, s @string:53:10)::

        foreign llvm move(len @string:53:33, ?tmp#0)
    else::
        if {concat(?left @string:54:22, ?right @string:54:29, s @string:54:10)::

            length(left @string:54:46, ?tmp#4 @string:54:39)
            length(right @string:54:61, ?tmp#5 @string:54:54)
            +(tmp#4, tmp#5, ?tmp#3 @string:54:39)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            if {slice(?base @string:55:21, ?range @string:55:28, s @string:55:10)::

                length(base @string:55:62, ?tmp#8 @string:55:55)
                fixed_range_size(tmp#8, range @string:55:69, ?tmp#7 @string:55:38)
                foreign llvm move(tmp#7, ?tmp#6)
            else::
                if {singleton(?tmp#10 @string:56:24, s @string:56:10)::

                    foreign llvm move(1 @string:56:30, ?tmp#9)
                else::
                    foreign llvm move(0 @string:57:18, ?tmp#9)

                }
                foreign llvm move(tmp#9 @string:56:10, ?tmp#6)

            }
            foreign llvm move(tmp#6 @string:55:10, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:54:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:53:10, ?#result @string:52:5)


pack > (0 calls)
0: pack(s:_ @string:160:10, !raw:c_string @string:160:16, size:int @string:160:30, !offset:int @string:160:41):
    if {buffer(?tmp#0 @string:162:16, ?str @string:162:20, s @string:161:10)::

        foreign llvm move(str @string:163:23, ?tmp#1)
        do {
            if {[|](?c @string:163:18, ?tmp#1, tmp#1)::

                true(?tmp#2 @string:164:56)
                foreign lpvm mutate(raw @string:164:37, ?raw @string:164:43, offset @string:164:48, tmp#2, size @string:164:62, 0 @string:164:68, c @string:164:71)
                incr(!offset @string:165:23)
            else::
                break

            }
        }
    else::
        if {concat(?left @string:167:17, ?right @string:167:24, s @string:161:10)::

            pack(left @string:168:18, !raw @string:168:25, size @string:168:30, !offset @string:168:37)
            pack(right @string:169:18, !raw @string:169:26, size @string:169:31, !offset @string:169:38)
            incr(!offset @string:170:19)
        else::
            if {slice(?tmp#3 @string:171:15, ?tmp#4 @string:171:18, s @string:161:10)::

                foreign llvm move(s @string:172:23, ?tmp#5)
                do {
                    if {[|](?c @string:172:18, ?tmp#5, tmp#5)::

                        true(?tmp#6 @string:173:56)
                        foreign lpvm mutate(raw @string:173:37, ?raw @string:173:43, offset @string:173:48, tmp#6, size @string:173:62, 0 @string:173:68, c @string:173:71)
                        incr(!offset @string:174:23)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:176:20, s @string:161:10)::

                    true(?tmp#7 @string:177:52)
                    foreign lpvm mutate(raw @string:177:33, ?raw @string:177:39, offset @string:177:44, tmp#7, size @string:177:58, 0 @string:177:64, c @string:177:67)
                    incr(!offset @string:178:19)
                else::
                    fail

                }

            }

        }

    }


print > public (0 calls)
0: print(x:_ @string:142:15) use !io:
    if {buffer(?tmp#0 @string:144:16, ?str @string:144:20, x @string:143:10)::

        !print(str @string:144:35)
    else::
        if {concat(?left @string:145:17, ?right @string:145:24, x @string:143:10)::

            !print(left @string:145:41)
            !print(right @string:145:55)
        else::
            if {slice(?tmp#1 @string:146:15, ?tmp#2 @string:146:18, x @string:143:10)::

                foreign llvm move(x @string:146:34, ?tmp#3)
                do {
                    if {[|](?c @string:146:29, ?tmp#3, tmp#3)::

                        !print(c @string:146:45)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:147:20, x @string:143:10)::

                    !print(c @string:147:33)
                else::
                    fail

                }

            }

        }

    }


println > public (0 calls)
0: println(x:_ @string:151:17) use !io:
    !print(x @string:151:39)
    !nl


read > public (0 calls)
0: read(?x:_ @string:153:15) use !io:
    !read(?str:c_string @string:153:37)
    string(str @string:153:64, ?tmp#0 @string:153:57)
    =(?x @string:153:53, tmp#0)


string > public (0 calls)
0: string(str:c_string @string:28:16, ?#result:_ @string:28:5):
    length(str @string:29:19, ?tmp#0 @string:29:12)
    =(?len @string:29:6, tmp#0)
    if {=(len @string:30:15, 0 @string:30:21)::

        empty(?tmp#2 @string:30:26)
        foreign llvm move(tmp#2, ?tmp#1)
    else::
        if {=(len @string:31:15, 1 @string:31:21)::

            foreign lpvm access(str @string:31:56, 0 @string:31:61, 1 @string:31:64, 0 @string:31:67, ?tmp#5 @string:31:36)
            singleton(tmp#5, ?tmp#4 @string:31:26)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            buffer(len @string:32:33, str @string:32:38, ?tmp#6 @string:32:26)
            foreign llvm move(tmp#6, ?tmp#3)

        }
        foreign llvm move(tmp#3 @string:31:15, ?tmp#1)

    }
    =(?s @string:30:6, tmp#1 @string:30:15)
    foreign llvm move(s @string:28:34, ?#result @string:28:5)
string > public (0 calls)
1: string(c:char @string:37:16, ?#result:_ @string:37:5):
    singleton(c @string:37:38, ?tmp#0 @string:37:28)
    foreign llvm move(tmp#0, ?#result @string:37:5)


~= > public (0 calls)
0: ~=(x:_ @string:116:10, y:_ @string:116:18, ?#result:bool @string:116:5):
    <=>(x @string:116:31, y @string:116:39, ?tmp#1 @string:116:31)
    equal(?tmp#2 @string:116:46)
    ~=(tmp#1, tmp#2, ?tmp#0 @string:116:30)
    foreign llvm move(tmp#0, ?#result @string:116:5)

LLVM code       : None

Types: **** Validating parameter types in module wybe.machine_word
Types: Validating def of word_size_bits
Types: Checking type int of param ?#result:int
Types: Param is ?#result:wybe.int
Types: Validating def of word_size_bytes
Types: Checking type int of param ?#result:int
Types: Param is ?#result:wybe.int
Types: **** Re-exiting module wybe.machine_word
Types: **** Type checking modules wybe.machine_word
Types: **** Strongly connected components:
Types:     wybe.machine_word.word_size_bytes
Types:     wybe.machine_word.word_size_bits
Types: Type checking non-recursive proc wybe.machine_word.word_size_bytes
Types: ** Type checking decl of proc word_size_bytes
Types: found 1 definition(s)
Types: Type checking word_size_bytes
Types: ** Type checking word_size_bytes: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm move(8 @machine_word:10:31, ?#result @machine_word:10:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result"]
Types: Recording parameter types: ?#result:wybe.int
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign llvm move(8 @machine_word:10:31, ?#result @machine_word:10:5)}
Types: Unifying move argument types 8 @machine_word:10:31 and ?#result @machine_word:10:5
Types: Finding type of expr 8 @machine_word:10:31
Types:   Type = wybe.int
Types: Finding type of expr ?#result @machine_word:10:5
Types:   Type = wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.int}; {} (with no errors)
Types: Finding type of expr 8 @machine_word:10:31
Types:   Type = wybe.int
Types: Finding type of expr ?#result @machine_word:10:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc word_size_bytes
Types: bound vars: semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(8 @machine_word:10:31, ?#result @machine_word:10:5)
Types: Mode checking foreign call {foreign llvm move(8 @machine_word:10:31, ?#result @machine_word:10:5)}
Types:     with assigned semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check exp 8
Types: Mode check exp resulted in 8
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr 8 @machine_word:10:31
Types:   Type = wybe.int
Types: Finding type of expr ?#result @machine_word:10:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(8:wybe.int @machine_word:10:31, ?#result:wybe.int @machine_word:10:5)}
Types: Now assigned = semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'word_size_bytes'
Types: Mode checked body   : [{foreign llvm move(8:wybe.int @machine_word:10:31, ?#result:wybe.int @machine_word:10:5)} @machine_word:10:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of word_size_bytes:
Types: 
Types: word_size_bytes > public (0 calls)
Types: 4: word_size_bytes(?#result:wybe.int @machine_word:10:5):
Types:     foreign llvm move(8:wybe.int @machine_word:10:31, ?#result:wybe.int @machine_word:10:5)
Types: Type checking non-recursive proc wybe.machine_word.word_size_bits
Types: ** Type checking decl of proc word_size_bits
Types: found 1 definition(s)
Types: Type checking word_size_bits
Types: ** Type checking word_size_bits: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         word_size_bytes(?tmp#1 @machine_word:12:34)
Types:         *(8 @machine_word:12:30, tmp#1, ?tmp#0 @machine_word:12:30)
Types:         foreign llvm move(tmp#0, ?#result @machine_word:12:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","tmp#1"]
Types: Recording parameter types: ?#result:wybe.int
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {word_size_bytes(?tmp#1 @machine_word:12:34)}
Types: Recording casts in {*(8 @machine_word:12:30, tmp#1, ?tmp#0 @machine_word:12:30)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @machine_word:12:5)}
Types: Unifying move argument types tmp#0 and ?#result @machine_word:12:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @machine_word:12:5
Types:   Type = wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, tmp#0::0}; {0::wybe.int} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {word_size_bytes(?tmp#1 @machine_word:12:34)} @machine_word:12:34, typingInfos = [wybe.machine_word.word_size_bytes<0>(?wybe.int)]}
Types:     StmtTypings {typingStmt = {*(8 @machine_word:12:30, tmp#1, ?tmp#0 @machine_word:12:30)} @machine_word:12:30, typingInfos = [wybe.int.*<0>(wybe.int,wybe.int,?wybe.int)]}Typing {#result::wybe.int, tmp#0::0}; {0::wybe.int} (with no errors)
Types: Type checking call {word_size_bytes(?tmp#1 @machine_word:12:34)} @machine_word:12:34
Types: Candidate types:
Types:     wybe.machine_word.word_size_bytes<0>(?wybe.int)
Types: Finding type of expr ?tmp#1 @machine_word:12:34
Types:   Type = 1
Types: Actual types: [1]
Types: Matching types [1] with wybe.machine_word.word_size_bytes<0>(?wybe.int)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, tmp#0::0, tmp#1::1}; {0::wybe.int, 1::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, tmp#0::0, tmp#1::1}; {0::wybe.int, 1::wybe.int} (with no errors)
Types: Type checking call {*(8 @machine_word:12:30, tmp#1, ?tmp#0 @machine_word:12:30)} @machine_word:12:30
Types: Candidate types:
Types:     wybe.int.*<0>(wybe.int,wybe.int,?wybe.int)
Types: Finding type of expr 8 @machine_word:12:30
Types:   Type = wybe.int
Types: Finding type of expr tmp#1
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @machine_word:12:30
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.*<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, tmp#0::0, tmp#1::1}; {0::wybe.int, 1::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, tmp#0::0, tmp#1::1}; {0::wybe.int, 1::wybe.int} (with no errors)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @machine_word:12:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc word_size_bits
Types: bound vars: semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check stmt word_size_bytes(?tmp#1 @machine_word:12:34)
Types: Mode checking call   : {word_size_bytes(?tmp#1 @machine_word:12:34)}
Types:     with assigned    : semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr ?tmp#1 @machine_word:12:34
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int]
Types:     actual modes     : [(ParamOut,False,Nothing)]
Types: Matching types [wybe.int] with wybe.machine_word.word_size_bytes<0>(?wybe.int)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.machine_word.word_size_bytes<0>(?wybe.int),Typing {#result::wybe.int, tmp#0::0, tmp#1::1}; {0::wybe.int, 1::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.machine_word.word_size_bytes<0>(?wybe.int),Typing {#result::wybe.int, tmp#0::0, tmp#1::1}; {0::wybe.int, 1::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.machine_word.word_size_bytes<0>(?wybe.int),Typing {#result::wybe.int, tmp#0::0, tmp#1::1}; {0::wybe.int, 1::wybe.int} (with no errors))]
Types: Finding type of expr ?tmp#1 @machine_word:12:34
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.machine_word.<0>word_size_bytes(?tmp#1:wybe.int @machine_word:12:34)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.machine_word.<0>word_size_bytes(?tmp#1:wybe.int @machine_word:12:34)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'word_size_bits'
Types: Now assigned = semipure normal (total) computation binding {tmp#1}, break set = Everything, with resources {}
Types: Mode check stmt *(8 @machine_word:12:30, tmp#1, ?tmp#0 @machine_word:12:30)
Types: Mode checking call   : {*(8 @machine_word:12:30, tmp#1, ?tmp#0 @machine_word:12:30)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#1}, break set = Everything, with resources {}
Types: Mode check exp 8
Types: Mode check exp resulted in 8
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr 8 @machine_word:12:30
Types:   Type = wybe.int
Types: Finding type of expr tmp#1
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @machine_word:12:30
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.*<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.*<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, tmp#0::0, tmp#1::1}; {0::wybe.int, 1::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.*<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, tmp#0::0, tmp#1::1}; {0::wybe.int, 1::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.*<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, tmp#0::0, tmp#1::1}; {0::wybe.int, 1::wybe.int} (with no errors))]
Types: Finding type of expr 8 @machine_word:12:30
Types:   Type = wybe.int
Types: Finding type of expr tmp#1
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @machine_word:12:30
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>*(8:wybe.int @machine_word:12:30, tmp#1:wybe.int, ?tmp#0:wybe.int @machine_word:12:30)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"tmp#1"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>*(8:wybe.int @machine_word:12:30, tmp#1:wybe.int, ?tmp#0:wybe.int @machine_word:12:30)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'word_size_bits'
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @machine_word:12:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @machine_word:12:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @machine_word:12:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @machine_word:12:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'word_size_bits'
Types: Mode checked body   : [{wybe.machine_word.<0>word_size_bytes(?tmp#1:wybe.int @machine_word:12:34)} @machine_word:12:34,{wybe.int.<0>*(8:wybe.int @machine_word:12:30, tmp#1:wybe.int, ?tmp#0:wybe.int @machine_word:12:30)} @machine_word:12:30,{foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @machine_word:12:5)} @machine_word:12:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of word_size_bits:
Types: 
Types: word_size_bits > public (0 calls)
Types: 4: word_size_bits(?#result:wybe.int @machine_word:12:5):
Types:     wybe.machine_word.<0>word_size_bytes(?tmp#1:wybe.int @machine_word:12:34)
Types:     wybe.int.<0>*(8:wybe.int @machine_word:12:30, tmp#1:wybe.int, ?tmp#0:wybe.int @machine_word:12:30)
Types:     foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @machine_word:12:5)
======================================================================
AFTER TYPE CHECK:
 Module wybe
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : 
  imports         : public use wybe.array
                    public use wybe.bool
                    public use wybe.c_string
                    public use wybe.char
                    public use wybe.comparison
                    public use wybe.control
                    public use wybe.count
                    public use wybe.float
                    public use wybe.int
                    public use wybe.io
                    public use wybe.list
                    public use wybe.machine_word
                    public use wybe.memory_management
                    public use wybe.phantom
                    public use wybe.predicate
                    public use wybe.range
                    public use wybe.string
  resources       : 
  submodules      : wybe.array, wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.control, wybe.count, wybe.float, wybe.int, wybe.io, wybe.list, wybe.machine_word, wybe.memory_management, wybe.phantom, wybe.predicate, wybe.range, wybe.string
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.array(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.array.[]<0>
                    wybe.array.[]<1>
                    wybe.array.[|]<0>
                    wybe.array.array<0>
                    wybe.array.array<1>
                    wybe.array.inbounds<0>
                    wybe.array.unsafe_get<0>
                    wybe.array.unsafe_update<0>
  imports         : public use wybe.array.raw_array
                    use wybe.bool
                    use wybe.int
                    use wybe.list
                    use wybe.machine_word
  resources       : 
  submodules      : wybe.array.raw_array
  procs           : 

[] > public {test} (0 calls)
0: [](a:_(T) @array:67:21, idx:int @array:67:29, ?#result:T @array:67:5):
    inbounds(a @array:68:14, idx @array:68:17)
    unsafe_get(a @array:69:10, idx @array:69:23, ?tmp#0 @array:69:10)
    =(?x @array:69:6, tmp#0)
    foreign llvm move(x @array:67:42, ?#result @array:67:5)
[] > public {test} (0 calls)
1: [](!a:_(T) @array:81:22, idx:int @array:81:30, x:T @array:81:39):
    inbounds(a @array:82:14, idx @array:82:17)
    unsafe_update(!a @array:83:20, idx @array:83:23, x @array:83:28)


[|] > public {test} (0 calls)
0: [|](?head:T @array:51:23, ?tail:_(T) @array:51:32, a:_(T) @array:51:43):
    array(?length @array:52:12, ?data @array:52:21, a @array:52:29)
    >(length @array:53:6, 0 @array:53:15)
    word_size_bytes(?tmp#0 @array:54:34)
    foreign lpvm access(data @array:54:25, 0 @array:54:31, tmp#0, 0 @array:54:51, ?head @array:54:55)
    word_size_bytes(?tmp#1 @array:55:28)
    foreign llvm add(data @array:55:22, tmp#1, ?data @array:55:46)
    -(length @array:56:19, 1 @array:56:28, ?tmp#3 @array:56:19)
    array(tmp#3, data @array:56:31, ?tmp#2 @array:56:13)
    =(?tail @array:56:6, tmp#2)


array > public (0 calls)
0: array(x:T @array:18:15, len:int @array:18:20, ?#result:_(T) @array:18:5):
    word_size_bytes(?tmp#1 @array:19:19)
    *(len @array:19:13, tmp#1, ?tmp#0 @array:19:13)
    =(?size @array:19:6, tmp#0)
    foreign lpvm alloc(size @array:20:24, ?data @array:20:31)
    =(?offset @array:21:6, 0 @array:21:15)
    do {
        if {<(offset @array:23:15, size @array:23:24)::

            pass
        else::
            break

        }
        foreign lpvm mutate(data @array:24:29, ?data @array:24:36, offset @array:24:42, 1 @array:24:50, size @array:24:53, 0 @array:24:59, x @array:24:62)
        word_size_bytes(?tmp#2 @array:25:21)
        +=(!offset @array:25:10, tmp#2)
    }
    array(len @array:27:17, data @array:27:22, ?tmp#3 @array:27:11)
    =(?ar @array:27:6, tmp#3)
    foreign llvm move(ar @array:18:36, ?#result @array:18:5)
array > public (0 calls)
1: array(ls:list(T) @array:34:15, ?#result:_(T) @array:34:5):
    length(ls @array:35:19, ?tmp#0 @array:35:12)
    =(?len @array:35:6, tmp#0)
    word_size_bytes(?tmp#2 @array:36:19)
    *(len @array:36:13, tmp#2, ?tmp#1 @array:36:13)
    =(?size @array:36:6, tmp#1)
    foreign lpvm alloc(size @array:37:24, ?data @array:37:31)
    =(?offset @array:38:6, 0 @array:38:15)
    foreign llvm move(ls @array:39:15, ?tmp#3)
    do {
        if {[|](?x @array:39:10, ?tmp#3, tmp#3)::

            foreign lpvm mutate(data @array:40:29, ?data @array:40:36, offset @array:40:42, 1 @array:40:50, size @array:40:53, 0 @array:40:59, x @array:40:62)
            word_size_bytes(?tmp#4 @array:41:21)
            +=(!offset @array:41:10, tmp#4)
        else::
            break

        }
    }
    array(len @array:43:17, data @array:43:22, ?tmp#5 @array:43:11)
    =(?ar @array:43:6, tmp#5)
    foreign llvm move(ar @array:34:34, ?#result @array:34:5)


inbounds > public {test,inline} (0 calls)
0: inbounds(a:_(T) @array:60:33, idx:int @array:60:41):
    <=(0 @array:61:6, idx @array:61:12)
    length(a @array:62:12, ?tmp#0 @array:62:12)
    <(idx @array:62:6, tmp#0)


unsafe_get > public {inline} (0 calls)
0: unsafe_get(a:_(T) @array:75:29, idx:int @array:75:37, ?#result:T @array:75:5):
    raw_data(a @array:76:25, ?tmp#0 @array:76:25)
    word_size_bytes(?tmp#2 @array:76:43)
    *(idx @array:76:37, tmp#2, ?tmp#1 @array:76:37)
    word_size_bytes(?tmp#3 @array:76:60)
    foreign lpvm access(tmp#0, tmp#1, tmp#3, 0 @array:76:77, ?x @array:76:81)
    foreign llvm move(x @array:75:50, ?#result @array:75:5)


unsafe_update > public {inline} (0 calls)
0: unsafe_update(!a:_(T) @array:89:33, idx:int @array:89:41, x:T @array:89:50):
    raw_data(a @array:90:25, ?tmp#0 @array:90:25)
    word_size_bytes(?tmp#2 @array:90:50)
    *(idx @array:90:44, tmp#2, ?tmp#1 @array:90:44)
    length(a @array:91:44, ?tmp#4 @array:91:44)
    word_size_bytes(?tmp#5 @array:91:55)
    *(tmp#4, tmp#5, ?tmp#3 @array:91:44)
    foreign lpvm mutate(tmp#0, ?data @array:90:38, tmp#1, 0 @array:90:67, tmp#3, 0 @array:91:72, x @array:91:75)
    raw_data(!a @array:92:6, data @array:92:19)

LLVM code       : None

--------------------------------------------------
 Module wybe.array.raw_array(T)
  representation  : address
  public submods  : 
  public resources: 
  public procs    : 
  imports         : use wybe
                    use wybe.array
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.bool
  representation  : 1 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.bool.&&<0>
                    wybe.bool.&=<0>
                    wybe.bool.=<0>
                    wybe.bool.^=<0>
                    wybe.bool.^^<0>
                    wybe.bool.false<0>
                    wybe.bool.print<0>
                    wybe.bool.println<0>
                    wybe.bool.succeed<0>
                    wybe.bool.true<0>
                    wybe.bool.|=<0>
                    wybe.bool.||<0>
                    wybe.bool.~<0>
                    wybe.bool.~=<0>
  imports         : use wybe.c_string
                    use wybe.io
  resources       : 
  procs           : 

&& > public {inline} (1 calls)
0: wybe.bool.&&<0>
&&(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:13:27


&= > public {inline} (0 calls)
0: wybe.bool.&=<0>
&=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:13:27


= > public {inline} (0 calls)
0: wybe.bool.=<0>
=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:37:26


^= > public {inline} (0 calls)
0: wybe.bool.^=<0>
^=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:25:27


^^ > public {inline} (1 calls)
0: wybe.bool.^^<0>
^^(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:25:27


false > public {inline} (0 calls)
0: wybe.bool.false<0>
false(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.bool, ?#result##0:wybe.bool)


print > public (1 calls)
0: wybe.bool.print<0>
print(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    case ~x##0:wybe.bool of
    0:
        wybe.c_string.print<0>(c"false":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #1 @bool:47:31

    1:
        wybe.c_string.print<0>(c"true":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:47:31



println > public {inline} (0 calls)
0: wybe.bool.println<0>
println(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.bool.print<0>(~x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:49:33
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#0##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~tmp#0##0:wybe.phantom, ?tmp#1##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#1##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


succeed > public {inline} (0 calls)
0: wybe.bool.succeed<0>
succeed()<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []


true > public {inline} (1 calls)
0: wybe.bool.true<0>
true(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.bool, ?#result##0:wybe.bool)


|= > public {inline} (0 calls)
0: wybe.bool.|=<0>
|=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:19:27


|| > public {inline} (1 calls)
0: wybe.bool.||<0>
||(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:19:27


~ > public {inline} (0 calls)
0: wybe.bool.~<0>
~(p##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, 1:wybe.bool, ?#result##0:wybe.bool) @bool:31:20


~= > public {inline} (0 calls)
0: wybe.bool.~=<0>
~=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:38:27

LLVM code       : None

--------------------------------------------------
 Module wybe.c_string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.c_string.<<0>
                    wybe.c_string.<=<0>
                    wybe.c_string.=<0>
                    wybe.c_string.><0>
                    wybe.c_string.>=<0>
                    wybe.c_string.[]<0>
                    wybe.c_string.[|]<0>
                    wybe.c_string.length<0>
                    wybe.c_string.print<0>
                    wybe.c_string.println<0>
                    wybe.c_string.read<0>
                    wybe.c_string.unsafe_c_string_index<0>
                    wybe.c_string.~=<0>
  imports         : use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.c_string.<<0>
<(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:12:29
    wybe.int.<<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:12:29


<= > public {inline} (0 calls)
0: wybe.c_string.<=<0>
<=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:13:30
    wybe.int.<=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:13:30


= > public {inline} (0 calls)
0: wybe.c_string.=<0>
=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:10:29
    wybe.int.=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:10:29


> > public {inline} (0 calls)
0: wybe.c_string.><0>
>(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:14:29
    wybe.int.><0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:14:29


>= > public {inline} (0 calls)
0: wybe.c_string.>=<0>
>=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:15:30
    wybe.int.>=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:15:30


[] > public (0 calls)
0: wybe.c_string.[]<0>
[](str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, idx##0:wybe.int, ?tmp#2##0:wybe.bool) #0 @c_string:27:6
    case ~tmp#2##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        foreign c strlen(str##0:wybe.c_string, ?tmp#0##0:wybe.int) @c_string:17:29
        wybe.int.<<0>(idx##0:wybe.int, ~tmp#0##0:wybe.int, ?tmp#3##0:wybe.bool) #2 @c_string:28:6
        case ~tmp#3##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




[|] > public (0 calls)
0: wybe.c_string.[|]<0>
[|](?head##0:wybe.char, ?tail##0:wybe.c_string, str##0:wybe.c_string, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(str##0:wybe.c_string, 0:wybe.int, 0:wybe.int, 0:wybe.int, ?head##0:wybe.char) @c_string:20:5
    foreign llvm icmp_ne(head##0:wybe.char, '\NUL':wybe.char, ?not_done##0:wybe.bool) @c_string:21:5
    foreign llvm icmp_eq(~not_done##0:wybe.bool, 1:wybe.bool, ?tmp#1##0:wybe.bool) @bool:37:26
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.c_string, ?tail##0:wybe.c_string)

    1:
        foreign llvm add(~str##0:wybe.c_string, 1:wybe.int, ?tail##0:wybe.c_string) @c_string:23:5
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



length > public {inline} (3 calls)
0: wybe.c_string.length<0>
length(str##0:wybe.c_string, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strlen(~str##0:wybe.c_string, ?#result##0:wybe.int) @c_string:17:29


print > public {inline} (1 calls)
0: wybe.c_string.print<0>
print(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:35:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:35:30


println > public {inline} (0 calls)
0: wybe.c_string.println<0>
println(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @c_string:35:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.c_string.read<0>
read(?x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:39:30
    foreign c read_line(?x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:39:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:39:30


unsafe_c_string_index > public {inline} (1 calls)
0: wybe.c_string.unsafe_c_string_index<0>
unsafe_c_string_index(str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7


~= > public {inline} (0 calls)
0: wybe.c_string.~=<0>
~=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:11:30
    wybe.int.~=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.char
  representation  : 8 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.char.<<0>
                    wybe.char.<=<0>
                    wybe.char.<=><0>
                    wybe.char.=<0>
                    wybe.char.><0>
                    wybe.char.>=<0>
                    wybe.char.chr<0>
                    wybe.char.ord<0>
                    wybe.char.print<0>
                    wybe.char.println<0>
                    wybe.char.read<0>
                    wybe.char.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (4 calls)
0: wybe.char.<<0>
<(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:17:29


<= > public {inline} (0 calls)
0: wybe.char.<=<0>
<=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:18:30


<=> > public (0 calls)
0: wybe.char.<=><0>
<=>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.char, y##0:wybe.char, ?tmp#6##0:wybe.bool) @char:17:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?tmp#5##0:wybe.bool) @char:13:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5



= > public {inline} (2 calls)
0: wybe.char.=<0>
=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:13:29


> > public {inline} (0 calls)
0: wybe.char.><0>
>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:19:29


>= > public {inline} (0 calls)
0: wybe.char.>=<0>
>=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:20:30


chr > public (0 calls)
0: wybe.char.chr<0>
chr(i##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, i##0:wybe.int, ?tmp#1##0:wybe.bool) #0 @char:33:60
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        wybe.int.<=<0>(i##0:wybe.int, 255:wybe.int, ?tmp#2##0:wybe.bool) #1 @char:33:70
        case ~tmp#2##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm cast(~i##0:wybe.int, ?#result##0:wybe.char) @char:33:31
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




ord > public {inline} (0 calls)
0: wybe.char.ord<0>
ord(c##0:wybe.char, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(~c##0:wybe.char, ?#result##0:wybe.int) @char:30:24


print > public {inline} (1 calls)
0: wybe.char.print<0>
print(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:37:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:37:30


println > public {inline} (0 calls)
0: wybe.char.println<0>
println(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @char:37:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.char.read<0>
read(?x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:41:30
    foreign c read_char(?x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:41:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:41:30


~= > public {inline} (0 calls)
0: wybe.char.~=<0>
~=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:14:30

LLVM code       : None

--------------------------------------------------
 Module wybe.comparison
  representation  : 2 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.comparison.<<0>
                    wybe.comparison.<=<0>
                    wybe.comparison.=<0>
                    wybe.comparison.><0>
                    wybe.comparison.>=<0>
                    wybe.comparison.equal<0>
                    wybe.comparison.greater<0>
                    wybe.comparison.lesser<0>
                    wybe.comparison.~=<0>
  imports         : use wybe.bool
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.comparison.<<0>
<(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:12:29


<= > public {inline} (0 calls)
0: wybe.comparison.<=<0>
<=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:13:30


= > public {inline} (0 calls)
0: wybe.comparison.=<0>
=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:10:29


> > public {inline} (0 calls)
0: wybe.comparison.><0>
>(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:14:29


>= > public {inline} (0 calls)
0: wybe.comparison.>=<0>
>=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:15:30


equal > public {inline} (0 calls)
0: wybe.comparison.equal<0>
equal(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison)


greater > public {inline} (0 calls)
0: wybe.comparison.greater<0>
greater(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison)


lesser > public {inline} (0 calls)
0: wybe.comparison.lesser<0>
lesser(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison)


~= > public {inline} (0 calls)
0: wybe.comparison.~=<0>
~=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.control
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.control.assert<0>
                    wybe.control.error<0>
                    wybe.control.error<1>
                    wybe.control.exit<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.int
                    use wybe.string
  resources       : 
  procs           : 

assert > public {semipure} (0 calls)
0: assert(condition:bool @control:26:27) use call_source_location:
    if {~(condition @control:27:11)::

        !error(c"assertion failed" @control:27:31)
    else::
        pass

    }


error > public {terminal,semipure} (0 calls)
0: error(message:string @control:17:35) use call_source_location:
    c_string(message @control:18:77, ?tmp#0 @control:18:68)
    foreign c {terminal,semipure} error_exit(call_source_location @control:18:46, tmp#0)
error > public {terminal,semipure} (0 calls)
1: error(message:c_string @control:21:35) use call_source_location:
    foreign c {terminal,semipure} error_exit(call_source_location @control:22:46, message @control:22:68)


exit > public {terminal,semipure} (0 calls)
0: exit(code:int @control:10:34):
    foreign c {terminal,semipure} exit(code @control:11:40)

LLVM code       : None

--------------------------------------------------
 Module wybe.count
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.count.%<0>
                    wybe.count.%=<0>
                    wybe.count.*<0>
                    wybe.count.*=<0>
                    wybe.count.+<0>
                    wybe.count.+<1>
                    wybe.count.+<2>
                    wybe.count.+=<0>
                    wybe.count.-<0>
                    wybe.count.-<1>
                    wybe.count.-<2>
                    wybe.count.-=<0>
                    wybe.count./<0>
                    wybe.count./=<0>
                    wybe.count.<<0>
                    wybe.count.<=<0>
                    wybe.count.<=><0>
                    wybe.count.=<0>
                    wybe.count.><0>
                    wybe.count.>=<0>
                    wybe.count.decr<0>
                    wybe.count.incr<0>
                    wybe.count.max<0>
                    wybe.count.min<0>
                    wybe.count.print<0>
                    wybe.count.println<0>
                    wybe.count.read<0>
                    wybe.count.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.count.%<0>
%(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:51:25


%= > public {inline} (0 calls)
0: wybe.count.%=<0>
%=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:51:25


* > public {inline} (1 calls)
0: wybe.count.*<0>
*(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:39:25


*= > public {inline} (0 calls)
0: wybe.count.*=<0>
*=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:39:25


+ > public {inline} (2 calls)
0: wybe.count.+<0>
+(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:15:25
+ > public (0 calls)
1: wybe.count.+<1>
+(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(y##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?x##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~y##0:wybe.count, ?x##0:wybe.count) @count:18:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

+ > public (0 calls)
2: wybe.count.+<2>
+(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?y##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:22:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



+= > public {inline} (0 calls)
0: wybe.count.+=<0>
+=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:15:25


- > public (6 calls)
0: wybe.count.-<0>
-(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?#result##0:wybe.count)

    1:
        foreign llvm sub(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:31:35
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

- > public {inline} (0 calls)
1: wybe.count.-<1>
-(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.count, ~z##0:wybe.count, ?x##0:wybe.count) @count:32:42
- > public {inline} (0 calls)
2: wybe.count.-<2>
-(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:33:42


-= > public (0 calls)
0: wybe.count.-=<0>
-=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, ~y##0:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:36:41
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:36:37
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



/ > public {inline} (1 calls)
0: wybe.count./<0>
/(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:45:25


/= > public {inline} (0 calls)
0: wybe.count./=<0>
/=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:45:25


< > public {inline} (4 calls)
0: wybe.count.<<0>
<(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:64:29


<= > public {inline} (3 calls)
0: wybe.count.<=<0>
<=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:65:30


<=> > public (0 calls)
0: wybe.count.<=><0>
<=>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.count, y##0:wybe.count, ?tmp#6##0:wybe.bool) @count:64:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?tmp#5##0:wybe.bool) @count:60:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5



= > public {inline} (2 calls)
0: wybe.count.=<0>
=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:60:29


> > public {inline} (0 calls)
0: wybe.count.><0>
>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:66:29


>= > public {inline} (12 calls)
0: wybe.count.>=<0>
>=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:67:30


decr > public (0 calls)
0: wybe.count.decr<0>
decr(x##0:wybe.count, ?x##1:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, 1:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:84:37
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:84:33
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



incr > public {inline} (0 calls)
0: wybe.count.incr<0>
incr(x##0:wybe.count, ?x##1:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, 1:wybe.count, ?x##1:wybe.count) @count:15:25


max > public (0 calls)
0: wybe.count.max<0>
max(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:75:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:75:5



min > public (0 calls)
0: wybe.count.min<0>
min(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:65:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:74:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:74:5



print > public {inline} (1 calls)
0: wybe.count.print<0>
print(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:88:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:88:30


println > public {inline} (0 calls)
0: wybe.count.println<0>
println(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @count:88:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.count.read<0>
read(?x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:92:30
    foreign c read_count(?x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:92:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:92:30


~= > public {inline} (0 calls)
0: wybe.count.~=<0>
~=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:61:30

LLVM code       : None

--------------------------------------------------
 Module wybe.float
  representation  : 64 bit float
  public submods  : 
  public resources: 
  public procs    : wybe.float.*<0>
                    wybe.float.**<0>
                    wybe.float.*=<0>
                    wybe.float.+<0>
                    wybe.float.+<1>
                    wybe.float.+<2>
                    wybe.float.+=<0>
                    wybe.float.-<0>
                    wybe.float.-<1>
                    wybe.float.-<2>
                    wybe.float.-<3>
                    wybe.float.-<4>
                    wybe.float.-=<0>
                    wybe.float./<0>
                    wybe.float./=<0>
                    wybe.float.<<0>
                    wybe.float.<=<0>
                    wybe.float.<=><0>
                    wybe.float.=<0>
                    wybe.float.><0>
                    wybe.float.>=<0>
                    wybe.float.abs<0>
                    wybe.float.ceil<0>
                    wybe.float.cos<0>
                    wybe.float.e<0>
                    wybe.float.exp<0>
                    wybe.float.floor<0>
                    wybe.float.iceil<0>
                    wybe.float.ifloor<0>
                    wybe.float.iround<0>
                    wybe.float.log<0>
                    wybe.float.log10<0>
                    wybe.float.log2<0>
                    wybe.float.max<0>
                    wybe.float.min<0>
                    wybe.float.pi<0>
                    wybe.float.power<0>
                    wybe.float.print<0>
                    wybe.float.println<0>
                    wybe.float.read<0>
                    wybe.float.round<0>
                    wybe.float.sin<0>
                    wybe.float.sqrt<0>
                    wybe.float.square<0>
                    wybe.float.tan<0>
                    wybe.float.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

* > public {inline} (1 calls)
0: wybe.float.*<0>
*(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:45:25


** > public {inline} (0 calls)
0: wybe.float.**<0>
**(x##0:wybe.float, n##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.pow.f64(~x##0:wybe.float, ~n##0:wybe.float, ?#result##0:wybe.float) @float:112:27


*= > public {inline} (0 calls)
0: wybe.float.*=<0>
*=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:45:25


+ > public {inline} (1 calls)
0: wybe.float.+<0>
+(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:23:27
+ > public {inline} (0 calls)
1: wybe.float.+<1>
+(?x##0:wybe.float, y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:24:43
+ > public {inline} (0 calls)
2: wybe.float.+<2>
+(x##0:wybe.float, ?y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~x##0:wybe.float, ?y##0:wybe.float) @float:25:43


+= > public {inline} (0 calls)
0: wybe.float.+=<0>
+=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:23:27


- > public {inline} (1 calls)
0: wybe.float.-<0>
-(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:32:27
- > public {inline} (0 calls)
1: wybe.float.-<1>
-(?x##0:wybe.float, y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~z##0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:33:43
- > public {inline} (0 calls)
2: wybe.float.-<2>
-(x##0:wybe.float, ?y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~x##0:wybe.float, ?y##0:wybe.float) @float:34:43
- > public {inline} (0 calls)
3: wybe.float.-<3>
-(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(0.0:wybe.float, ~x##0:wybe.float, ?#result##0:wybe.float) @float:38:21
- > public {inline} (0 calls)
4: wybe.float.-<4>
-(?x##0:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(0.0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:39:37


-= > public {inline} (0 calls)
0: wybe.float.-=<0>
-=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:32:27


/ > public {inline} (2 calls)
0: wybe.float./<0>
/(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fdiv(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:51:25


/= > public {inline} (0 calls)
0: wybe.float./=<0>
/=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fdiv(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:51:25


< > public {inline} (4 calls)
0: wybe.float.<<0>
<(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_slt(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:70:29


<= > public {inline} (0 calls)
0: wybe.float.<=<0>
<=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sle(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:71:30


<=> > public (0 calls)
0: wybe.float.<=><0>
<=>(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_slt(x##0:wybe.float, y##0:wybe.float, ?tmp#6##0:wybe.bool) @float:70:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm fcmp_eq(~x##0:wybe.float, ~y##0:wybe.float, ?tmp#5##0:wybe.bool) @float:66:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5



= > public {inline} (2 calls)
0: wybe.float.=<0>
=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_eq(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:66:29


> > public {inline} (0 calls)
0: wybe.float.><0>
>(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sgt(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:72:29


>= > public {inline} (0 calls)
0: wybe.float.>=<0>
>=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sge(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:73:30


abs > public {inline} (0 calls)
0: wybe.float.abs<0>
abs(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.fabs.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:60:22


ceil > public {inline} (1 calls)
0: wybe.float.ceil<0>
ceil(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.ceil.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:87:23


cos > public {inline} (0 calls)
0: wybe.float.cos<0>
cos(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.cos.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:116:22


e > public {inline} (0 calls)
0: wybe.float.e<0>
e(?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2.7182818284590455:wybe.float, ?#result##0:wybe.float) @float:16:5


exp > public {inline} (0 calls)
0: wybe.float.exp<0>
exp(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.exp.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:120:22


floor > public {inline} (1 calls)
0: wybe.float.floor<0>
floor(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.floor.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:90:24


iceil > public {inline} (0 calls)
0: wybe.float.iceil<0>
iceil(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.ceil.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:87:23
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:99:26


ifloor > public {inline} (0 calls)
0: wybe.float.ifloor<0>
ifloor(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.floor.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:90:24
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:102:27


iround > public {inline} (0 calls)
0: wybe.float.iround<0>
iround(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.round.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:93:24
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:96:27


log > public {inline} (0 calls)
0: wybe.float.log<0>
log(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:123:22


log10 > public {inline} (0 calls)
0: wybe.float.log10<0>
log10(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log10.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:126:24


log2 > public {inline} (0 calls)
0: wybe.float.log2<0>
log2(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log2.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:129:23


max > public {inline} (0 calls)
0: wybe.float.max<0>
max(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.maxnum.f64(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:81:27


min > public {inline} (0 calls)
0: wybe.float.min<0>
min(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.minnum.f64(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:80:27


pi > public {inline} (0 calls)
0: wybe.float.pi<0>
pi(?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(3.141592653589793:wybe.float, ?#result##0:wybe.float) @float:13:5


power > public {inline} (0 calls)
0: wybe.float.power<0>
power(x##0:wybe.float, n##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.pow.f64(~x##0:wybe.float, ~n##0:wybe.float, ?#result##0:wybe.float) @float:111:28


print > public {inline} (1 calls)
0: wybe.float.print<0>
print(x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @float:133:30
    foreign c print_float(~x##0:wybe.float, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @float:133:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @float:133:30


println > public {inline} (0 calls)
0: wybe.float.println<0>
println(x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @float:133:30
    foreign c print_float(~x##0:wybe.float, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @float:133:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.float.read<0>
read(?x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @float:137:30
    foreign c read_float(?x##0:wybe.float, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @float:137:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @float:137:30


round > public {inline} (1 calls)
0: wybe.float.round<0>
round(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.round.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:93:24


sin > public {inline} (0 calls)
0: wybe.float.sin<0>
sin(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sin.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:115:22


sqrt > public {inline} (0 calls)
0: wybe.float.sqrt<0>
sqrt(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sqrt.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:108:23


square > public {inline} (0 calls)
0: wybe.float.square<0>
square(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~x##0:wybe.float, ?#result##0:wybe.float) @float:57:25


tan > public {inline} (0 calls)
0: wybe.float.tan<0>
tan(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sin.f64(x##0:wybe.float, ?tmp#1##0:wybe.float) @float:117:22
    foreign c llvm.cos.f64(~x##0:wybe.float, ?tmp#2##0:wybe.float) @float:117:52
    foreign llvm fdiv(~tmp#1##0:wybe.float, ~tmp#2##0:wybe.float, ?#result##0:wybe.float) @float:51:25


~= > public {inline} (0 calls)
0: wybe.float.~=<0>
~=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_ne(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:67:30

LLVM code       : None

--------------------------------------------------
 Module wybe.int
  representation  : 64 bit signed
  public submods  : 
  public resources: 
  public procs    : wybe.int.%<0>
                    wybe.int.%=<0>
                    wybe.int.*<0>
                    wybe.int.*=<0>
                    wybe.int.+<0>
                    wybe.int.+<1>
                    wybe.int.+<2>
                    wybe.int.+=<0>
                    wybe.int.-<0>
                    wybe.int.-<1>
                    wybe.int.-<2>
                    wybe.int.-<3>
                    wybe.int.-<4>
                    wybe.int.-=<0>
                    wybe.int./<0>
                    wybe.int./=<0>
                    wybe.int.<<0>
                    wybe.int.<<<0>
                    wybe.int.<<=<0>
                    wybe.int.<=<0>
                    wybe.int.<=><0>
                    wybe.int.=<0>
                    wybe.int.><0>
                    wybe.int.>=<0>
                    wybe.int.>><0>
                    wybe.int.>>=<0>
                    wybe.int.decr<0>
                    wybe.int.incr<0>
                    wybe.int.logical_bitshift<0>
                    wybe.int.logical_bitshift<1>
                    wybe.int.max<0>
                    wybe.int.min<0>
                    wybe.int.power<0>
                    wybe.int.print<0>
                    wybe.int.println<0>
                    wybe.int.read<0>
                    wybe.int.signum<0>
                    wybe.int.sqrt<0>
                    wybe.int.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.int.%<0>
%(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:50:25


%= > public {inline} (0 calls)
0: wybe.int.%=<0>
%=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:50:25


* > public {inline} (1 calls)
0: wybe.int.*<0>
*(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:38:25


*= > public {inline} (0 calls)
0: wybe.int.*=<0>
*=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:38:25


+ > public {inline} (2 calls)
0: wybe.int.+<0>
+(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:16:27
+ > public {inline} (0 calls)
1: wybe.int.+<1>
+(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:17:43
+ > public {inline} (0 calls)
2: wybe.int.+<2>
+(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:18:43


+= > public {inline} (0 calls)
0: wybe.int.+=<0>
+=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:16:27


- > public {inline} (2 calls)
0: wybe.int.-<0>
-(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:25:27
- > public {inline} (0 calls)
1: wybe.int.-<1>
-(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.int, ~z##0:wybe.int, ?x##0:wybe.int) @int:26:43
- > public {inline} (0 calls)
2: wybe.int.-<2>
-(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:27:43
- > public {inline} (0 calls)
3: wybe.int.-<3>
-(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~x##0:wybe.int, ?#result##0:wybe.int) @int:31:21
- > public {inline} (0 calls)
4: wybe.int.-<4>
-(?x##0:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:32:37


-= > public {inline} (0 calls)
0: wybe.int.-=<0>
-=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:25:27


/ > public {inline} (1 calls)
0: wybe.int./<0>
/(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:44:25


/= > public {inline} (0 calls)
0: wybe.int./=<0>
/=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:44:25


< > public {inline} (4 calls)
0: wybe.int.<<0>
<(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:87:29


<< > public {inline} (1 calls)
0: wybe.int.<<<0>
<<(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:56:27


<<= > public {inline} (0 calls)
0: wybe.int.<<=<0>
<<=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:56:27


<= > public {inline} (3 calls)
0: wybe.int.<=<0>
<=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:88:30


<=> > public (0 calls)
0: wybe.int.<=><0>
<=>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(x##0:wybe.int, y##0:wybe.int, ?tmp#6##0:wybe.bool) @int:87:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?tmp#5##0:wybe.bool) @int:83:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5



= > public {inline} (2 calls)
0: wybe.int.=<0>
=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:83:29


> > public {inline} (0 calls)
0: wybe.int.><0>
>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sgt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:89:29


>= > public {inline} (3 calls)
0: wybe.int.>=<0>
>=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:90:30


>> > public {inline} (1 calls)
0: wybe.int.>><0>
>>(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:65:27


>>= > public {inline} (0 calls)
0: wybe.int.>>=<0>
>>=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:65:27


decr > public {inline} (0 calls)
0: wybe.int.decr<0>
decr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:25:27


incr > public {inline} (0 calls)
0: wybe.int.incr<0>
incr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:16:27


logical_bitshift > public {inline} (1 calls)
0: wybe.int.logical_bitshift<0>
logical_bitshift(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:74:40
logical_bitshift > public {inline} (0 calls)
1: wybe.int.logical_bitshift<1>
logical_bitshift(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:74:40


max > public (0 calls)
0: wybe.int.max<0>
max(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:90:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:98:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:98:5



min > public (0 calls)
0: wybe.int.min<0>
min(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:88:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:97:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:97:5



power > public {inline} (0 calls)
0: wybe.int.power<0>
power(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c ipow(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:107:29


print > public {inline} (1 calls)
0: wybe.int.print<0>
print(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:119:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:119:30


println > public {inline} (0 calls)
0: wybe.int.println<0>
println(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @int:119:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.int.read<0>
read(?x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:123:30
    foreign c read_int(?x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:123:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:123:30


signum > public {inline} (0 calls)
0: wybe.int.signum<0>
signum(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c signum(~x##0:wybe.int, ?#result##0:wybe.int) @int:114:25


sqrt > public {inline} (0 calls)
0: wybe.int.sqrt<0>
sqrt(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c isqrt(~x##0:wybe.int, ?#result##0:wybe.int) @int:104:23


~= > public {inline} (0 calls)
0: wybe.int.~=<0>
~=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:84:30

LLVM code       : None

--------------------------------------------------
 Module wybe.io
  representation  : (not a type)
  public submods  : phantom -> wybe.phantom
  public resources: io: wybe.io.io
  public procs    : wybe.io.<0>
                    wybe.io.eof<0>
                    wybe.io.nl<0>
  imports         : use wybe.char
                    public use wybe.phantom
  resources       : io: fromList [(wybe.io.io,wybe.phantom = 0:phantom @io:13:27 @io:13:5)]
  procs           : 

module top-level code > public {inline,semipure} (0 calls)
0: wybe.io.<0>
()<{}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm store(0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:13:5


eof > public {inline} (0 calls)
0: wybe.io.eof<0>
eof(?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(-1:wybe.int, ?#result##0:wybe.char) @io:20:29


nl > public {inline} (0 calls)
0: wybe.io.nl<0>
nl()<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @io:17:31
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31

LLVM code       : None

--------------------------------------------------
 Module wybe.list(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.list.,,<0>
                    wybe.list.[]<0>
                    wybe.list.all<0>
                    wybe.list.any<0>
                    wybe.list.empty<0>
                    wybe.list.filter<0>
                    wybe.list.foldl<0>
                    wybe.list.foldr<0>
                    wybe.list.length<0>
                    wybe.list.list<0>
                    wybe.list.map<0>
                    wybe.list.map<1>
                    wybe.list.map<2>
                    wybe.list.print<0>
                    wybe.list.println<0>
                    wybe.list.reverse<0>
  imports         : use wybe.array
                    use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
                    use wybe.machine_word
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_(T) @list:20:10, y:_(T) @list:20:20, ?#result:_(T) @list:20:5):
    if {[|](?h @list:21:16, ?t @list:21:21, x @list:21:10)::

        ,,(t @list:21:32, y @list:21:37, ?tmp#2 @list:21:32)
        [|](h @list:21:28, tmp#2, ?tmp#1 @list:21:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(y @list:21:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:21:10, ?#result @list:20:5)


[] > public {test} (0 calls)
0: [](xs:_(T) @list:31:21, idx:int @list:31:30, ?#result:T @list:31:5):
    >=(idx @list:32:5, 0 @list:32:13)
    index1(xs @list:33:17, idx @list:33:21, ?tmp#0 @list:33:10)
    =(?x @list:33:6, tmp#0)
    foreign llvm move(x @list:31:43, ?#result @list:31:5)


all > public {test} (0 calls)
0: all(p:{test}(T) @list:61:20, xs:_(T) @list:61:33):
    foreign llvm move(xs @list:62:15, ?tmp#0)
    do {
        if {[|](?x @list:62:10, ?tmp#0, tmp#0)::

            p(x @list:63:11)
        else::
            break

        }
    }


any > public {test} (0 calls)
0: any(p:{test}(T) @list:69:20, xs:_(T) @list:69:33):
    [|](?x @list:70:7, ?xs @list:70:12, xs @list:70:18)
    (   p(x @list:71:8)
    | any(p @list:71:17, xs @list:71:20))


empty > public {test} (0 calls)
0: empty(xs:_(T) @list:15:22):
    if {[|](?tmp#0 @list:16:11, ?tmp#1 @list:16:15, xs @list:16:20)::

        fail
    else::
        pass

    }


filter > public (0 calls)
0: filter(p:{test}(T) @list:95:16, !xs:_(T) @list:95:30):
    [](?tmp#0 @list:96:12)
    =(?out @list:96:6, tmp#0)
    foreign llvm move(xs @list:97:15, ?tmp#1)
    do {
        if {[|](?x @list:97:10, ?tmp#1, tmp#1)::

            if {p(x @list:98:16)::

                [|](x @list:98:30, out @list:98:34, ?tmp#2 @list:98:29)
                =(?out @list:98:23, tmp#2)
            else::
                pass

            }
        else::
            break

        }
    }
    reverse(out @list:100:19, ?tmp#3 @list:100:11)
    =(?as @list:100:6, tmp#3)


foldl > public (0 calls)
0: foldl(f:(A, !B) @list:77:15, as:_(A) @list:77:26, !b:B @list:77:36):
    foreign llvm move(as @list:78:15, ?tmp#0)
    do {
        if {[|](?a @list:78:10, ?tmp#0, tmp#0)::

            f(a @list:79:11, !b @list:79:15)
        else::
            break

        }
    }


foldr > public (0 calls)
0: foldr(f:(A, !B) @list:86:15, as:_(A) @list:86:26, !b:B @list:86:36):
    if {[|](?a @list:87:12, ?as @list:87:17, as @list:87:23)::

        foldr(f @list:88:15, as @list:88:18, !b @list:88:23)
        f(a @list:89:11, !b @list:89:15)
    else::
        pass

    }


index1 > {test} (0 calls)
0: index1(xs:_(T) @list:148:19, idx:int @list:148:28, ?#result:T @list:148:1):
    [|](?x @list:149:7, ?xs @list:149:12, xs @list:149:18)
    (   =(idx @list:150:6, 0 @list:150:12)
    | (   -(idx @list:150:27, 1 @list:150:33, ?tmp#0 @list:150:27)
        & index1(xs @list:150:23, tmp#0, ?x @list:150:37)))
    foreign llvm move(x @list:148:41, ?#result @list:148:1)


length > public (0 calls)
0: length(x:_(T) @list:24:16, ?#result:int @list:24:5):
    length1(x @list:24:38, 0 @list:24:41, ?tmp#0 @list:24:30)
    foreign llvm move(tmp#0, ?#result @list:24:5)


length1 > (0 calls)
0: length1(x:_(T) @list:140:13, acc:int @list:140:21, ?#result:int @list:140:1):
    if {[|](?h @list:141:16, ?t @list:141:21, x @list:141:10)::

        +(acc @list:141:38, 1 @list:141:44, ?tmp#2 @list:141:38)
        length1(t @list:141:35, tmp#2, ?tmp#1 @list:141:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(acc @list:141:57, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:141:10, ?#result @list:140:1)


list > public (0 calls)
0: list(ar:array(T) @list:128:14, ?#result:_(T) @list:128:5):
    [](?tmp#0 @list:129:11)
    =(?ls @list:129:6, tmp#0)
    foreign llvm move(ar @list:130:15, ?tmp#1)
    do {
        if {[|](?x @list:130:10, ?tmp#1, tmp#1)::

            [|](x @list:131:16, ls @list:131:20, ?tmp#2 @list:131:15)
            =(?ls @list:131:10, tmp#2)
        else::
            break

        }
    }
    reverse(ls @list:133:13, ?ls @list:133:18)
    foreign llvm move(ls @list:128:34, ?#result @list:128:5)


map > public (0 calls)
0: map(f:{resource}(T) @list:41:13, xs:_(T) @list:41:30):
    foreign llvm move(xs @list:42:15, ?tmp#0)
    do {
        if {[|](?x @list:42:10, ?tmp#0, tmp#0)::

            !f(x @list:43:12)
        else::
            break

        }
    }
map > public (0 calls)
1: map(f:(A, ?B) @list:49:13, as:_(A) @list:49:24, ?#result:_(B) @list:49:5):
    if {[|](?a @list:50:12, ?as @list:50:17, as @list:50:23)::

        f(a @list:50:33, ?tmp#2 @list:50:31)
        map(f @list:50:42, as @list:50:45, ?tmp#3 @list:50:38)
        [|](tmp#2, tmp#3, ?tmp#1 @list:50:29)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:50:61)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:50:10, ?#result @list:49:5)
map > public (0 calls)
2: map(f:(A, B, ?C) @list:55:13, as:_(A) @list:55:27, bs:_(B) @list:55:36, ?#result:_(C) @list:55:5):
    if {(   [|](?a @list:56:12, ?as @list:56:17, as @list:56:23)
        & [|](?b @list:56:30, ?bs @list:56:35, bs @list:56:41))::

        f(a @list:56:51, b @list:56:54, ?tmp#2 @list:56:49)
        map(f @list:56:63, as @list:56:66, bs @list:56:70, ?tmp#3 @list:56:59)
        [|](tmp#2, tmp#3, ?tmp#1 @list:56:47)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:57:47)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:56:10, ?#result @list:55:5)


print > public (0 calls)
0: print(printer:{resource}(T) @list:108:15, xs:_(T) @list:108:38) use !io:
    !print('[' @list:109:12)
    if {[|](?x @list:110:12, ?xs @list:110:17, xs @list:110:23)::

        !printer(x @list:111:18)
        !print1(printer @list:112:17, xs @list:112:26)
    else::
        pass

    }
    !print(']' @list:114:12)


print1 > (0 calls)
0: print1(printer:{resource}(T) @list:154:12, xs:_(T) @list:154:35) use !io:
    if {[|](?x @list:155:12, ?xs @list:155:17, xs @list:155:23)::

        !print(',' @list:156:16)
        !printer(x @list:157:18)
        !print1(printer @list:158:17, xs @list:158:26)
    else::
        pass

    }


println > public (0 calls)
0: println(printer:{resource}(T) @list:119:17, xs:_(T) @list:119:40) use !io:
    !print(printer @list:120:12, xs @list:120:21)
    !nl


reverse > public (0 calls)
0: reverse(x:_(T) @list:27:17, ?#result:_(T) @list:27:5):
    [](?tmp#1 @list:27:44)
    reverse1(x @list:27:41, tmp#1, ?tmp#0 @list:27:32)
    foreign llvm move(tmp#0, ?#result @list:27:5)


reverse1 > (0 calls)
0: reverse1(x:_(T) @list:144:14, tail:_(T) @list:144:22, ?#result:_(T) @list:144:1):
    if {[|](?h @list:145:16, ?t @list:145:21, x @list:145:10)::

        [|](h @list:145:40, tail @list:145:44, ?tmp#2 @list:145:39)
        reverse1(t @list:145:36, tmp#2, ?tmp#1 @list:145:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(tail @list:145:61, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:145:10, ?#result @list:144:1)

LLVM code       : None

--------------------------------------------------
 Module wybe.machine_word
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.machine_word.word_size_bits<0>
                    wybe.machine_word.word_size_bytes<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

word_size_bits > public (0 calls)
0: word_size_bits(?#result:wybe.int @machine_word:12:5):
    wybe.machine_word.<0>word_size_bytes(?tmp#1:wybe.int @machine_word:12:34)
    wybe.int.<0>*(8:wybe.int @machine_word:12:30, tmp#1:wybe.int, ?tmp#0:wybe.int @machine_word:12:30)
    foreign llvm move(tmp#0:wybe.int, ?#result:wybe.int @machine_word:12:5)


word_size_bytes > public (0 calls)
0: word_size_bytes(?#result:wybe.int @machine_word:10:5):
    foreign llvm move(8:wybe.int @machine_word:10:31, ?#result:wybe.int @machine_word:10:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.memory_management
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.memory_management.malloc_count<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

malloc_count > public {semipure} (0 calls)
0: malloc_count(?x:int @memory_management:11:34):
    foreign c {impure} malloc_count(?x @memory_management:12:38)

LLVM code       : None

--------------------------------------------------
 Module wybe.phantom
 modifiers       : {unique} 
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : 
  imports         : 
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.predicate
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.predicate.const<0>
                    wybe.predicate.id<0>
  imports         : 
  resources       : 
  procs           : 

const > public {inline} (0 calls)
0: wybe.predicate.const<0>
const(a##0:A <{}; {}; {0}>, [b##0:B <{}; {}; {1}>], ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:8:5


id > public {inline} (0 calls)
0: wybe.predicate.id<0>
id(a##0:A <{}; {}; {0}>, ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:6:5

LLVM code       : None

--------------------------------------------------
 Module wybe.range
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.range...<0>
                    wybe.range.[]<0>
                    wybe.range.[|]<0>
                    wybe.range.irange<0>
                    wybe.range.size<0>
                    wybe.range.xrange<0>
  imports         : use wybe.bool
                    use wybe.int
  resources       : 
  procs           : 

.. > public (0 calls)
0: ..(start:int @range:38:10, end:int @range:38:23, ?#result:_ @range:38:5):
    if {<=(start @range:39:27, end @range:39:37)::

        foreign llvm move(1 @range:39:44, ?tmp#1)
    else::
        foreign llvm move(-1 @range:39:56, ?tmp#1)

    }
    construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)
    foreign llvm move(tmp#0, ?#result @range:38:5)


[] > public {test} (0 calls)
0: [](r:_ @range:20:19, idx:int @range:20:24, ?value:int @range:20:34):
    <=(0 @range:21:6, idx @range:21:12)
    range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)
    *(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)
    +(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)
    =(?value @range:23:6, tmp#0)
    if {<=(0 @range:24:10, stride @range:24:16)::

        <(value @range:24:27, end @range:24:35)
    else::
        <(end @range:24:51, value @range:24:57)

    }


[|] > public {test} (0 calls)
0: [|](?value:int @range:12:23, ?rest:_ @range:12:35, current:_ @range:12:43):
    range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)
    ~=(value @range:14:6, end @range:14:16)
    +(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)
    range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)
    =(?rest @range:15:6, tmp#0)


construct > (0 calls)
0: construct(start:int @range:49:15, stride:int @range:49:26, end:int @range:49:38, ?#result:_ @range:49:1):
    -(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)
    %(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)
    =(?diff @range:50:6, tmp#0)
    if {<=(0 @range:51:19, stride @range:51:25)::

        if {=(diff @range:52:26, 0 @range:52:33)::

            max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
            -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
            max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
            foreign llvm move(tmp#5, ?tmp#3)

        }
        foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
    else::
        if {=(diff @range:55:26, 0 @range:55:33)::

            min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
            foreign llvm move(tmp#9, ?tmp#8)
        else::
            +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
            min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
            foreign llvm move(tmp#10, ?tmp#8)

        }
        foreign llvm move(tmp#8 @range:55:26, ?tmp#2)

    }
    =(?final @range:51:6, tmp#2 @range:51:19)
    range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)
    =(?r @range:58:6, tmp#12)
    foreign llvm move(r @range:49:51, ?#result @range:49:1)


irange > public (0 calls)
0: irange(start:int @range:32:16, stride:int @range:32:27, end:int @range:32:39, ?#result:_ @range:32:5):
    if {<(stride @range:33:41, 0 @range:33:50)::

        foreign llvm move(-1 @range:33:55, ?tmp#2)
    else::
        foreign llvm move(1 @range:33:68, ?tmp#2)

    }
    +(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)
    construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)
    foreign llvm move(tmp#0, ?#result @range:32:5)


size > public (0 calls)
0: size(r:_ @range:42:14, ?#result:int @range:42:5):
    range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)
    if {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
        & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
        & signum(tmp#3, ?tmp#2 @range:44:29)
        & ~=(tmp#1, tmp#2))::

        foreign llvm move(0 @range:44:52, ?tmp#0)
    else::
        if {<=(0 @range:45:10, stride @range:45:16)::

            -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
            -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
            /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
            +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
            foreign llvm move(tmp#5, ?tmp#4)
        else::
            -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
            -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
            -(stride @range:46:39, ?tmp#13 @range:46:38)
            /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
            +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
            foreign llvm move(tmp#9, ?tmp#4)

        }
        foreign llvm move(tmp#4 @range:45:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)


xrange > public (0 calls)
0: xrange(start:int @range:28:16, stride:int @range:28:27, end:int @range:28:39, ?#result:_ @range:28:5):
    construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)
    foreign llvm move(tmp#0, ?#result @range:28:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.string
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.string.,,<0>
                    wybe.string.<<0>
                    wybe.string.<=<0>
                    wybe.string.<=><0>
                    wybe.string.=<0>
                    wybe.string.><0>
                    wybe.string.>=<0>
                    wybe.string.[]<0>
                    wybe.string.[]<1>
                    wybe.string.[|]<0>
                    wybe.string.c_string<0>
                    wybe.string.length<0>
                    wybe.string.print<0>
                    wybe.string.println<0>
                    wybe.string.read<0>
                    wybe.string.string<0>
                    wybe.string.string<1>
                    wybe.string.~=<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.char
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
                    use wybe.range
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_ @string:64:10, y:_ @string:64:17, ?#result:_ @string:64:5):
    if {(   empty(?tmp#1 @string:65:14)
        & =(x @string:65:10, tmp#1))::

        foreign llvm move(y @string:65:23, ?tmp#0)
    else::
        if {(   empty(?tmp#3 @string:66:14)
            & =(y @string:66:10, tmp#3))::

            foreign llvm move(x @string:66:23, ?tmp#2)
        else::
            concat(x @string:67:25, y @string:67:28, ?tmp#4 @string:67:18)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:66:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:65:10, ?#result @string:64:5)


< > public (0 calls)
0: <(x:_ @string:119:10, y:_ @string:119:17, ?#result:bool @string:119:5):
    <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
    equal(?tmp#2 @string:119:44)
    <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
    foreign llvm move(tmp#0, ?#result @string:119:5)


<= > public (0 calls)
0: <=(x:_ @string:120:10, y:_ @string:120:18, ?#result:bool @string:120:5):
    <=>(x @string:120:31, y @string:120:39, ?tmp#1 @string:120:31)
    equal(?tmp#2 @string:120:46)
    <=(tmp#1, tmp#2, ?tmp#0 @string:120:30)
    foreign llvm move(tmp#0, ?#result @string:120:5)


<=> > public (0 calls)
0: <=>(x:_ @string:125:10, y:_ @string:125:20, ?#result:comparison @string:125:5):
    equal(?tmp#0 @string:126:10)
    =(?c @string:126:6, tmp#0)
    foreign llvm move(x @string:127:16, ?tmp#1)
    foreign llvm move(y @string:127:26, ?tmp#2)
    do {
        if {[|](?cx @string:127:10, ?tmp#1, tmp#1)::

            if {[|](?cy @string:127:20, ?tmp#2, tmp#2)::

                if {<(cx @string:128:14, cy @string:128:19)::

                    lesser(?tmp#3 @string:128:30)
                    =(?c @string:128:26, tmp#3)
                    break
                else::
                    if {>(cx @string:129:14, cy @string:129:19)::

                        greater(?tmp#4 @string:129:30)
                        =(?c @string:129:26, tmp#4)
                        break
                    else::
                        pass

                    }

                }
            else::
                break

            }
        else::
            break

        }
    }
    if {(   equal(?tmp#5 @string:132:14)
        & =(c @string:132:10, tmp#5))::

        length(x @string:133:22, ?tmp#6 @string:133:15)
        =(?lx @string:133:10, tmp#6)
        length(y @string:134:22, ?tmp#7 @string:134:15)
        =(?ly @string:134:10, tmp#7)
        if {<(lx @string:135:14, ly @string:135:19)::

            lesser(?tmp#8 @string:135:30)
            =(?c @string:135:26, tmp#8)
        else::
            if {>(lx @string:135:39, ly @string:135:44)::

                greater(?tmp#9 @string:135:55)
                =(?c @string:135:51, tmp#9)
            else::
                pass

            }

        }
    else::
        pass

    }
    foreign llvm move(c @string:125:38, ?#result @string:125:5)


= > public (0 calls)
0: =(x:_ @string:115:10, y:_ @string:115:17, ?#result:bool @string:115:5):
    <=>(x @string:115:30, y @string:115:38, ?tmp#1 @string:115:30)
    equal(?tmp#2 @string:115:44)
    =(tmp#1, tmp#2, ?tmp#0 @string:115:29)
    foreign llvm move(tmp#0, ?#result @string:115:5)


> > public (0 calls)
0: >(x:_ @string:121:10, y:_ @string:121:17, ?#result:bool @string:121:5):
    <=>(x @string:121:30, y @string:121:38, ?tmp#1 @string:121:30)
    equal(?tmp#2 @string:121:44)
    >(tmp#1, tmp#2, ?tmp#0 @string:121:29)
    foreign llvm move(tmp#0, ?#result @string:121:5)


>= > public (0 calls)
0: >=(x:_ @string:122:10, y:_ @string:122:18, ?#result:bool @string:122:5):
    <=>(x @string:122:31, y @string:122:39, ?tmp#1 @string:122:31)
    equal(?tmp#2 @string:122:46)
    >=(tmp#1, tmp#2, ?tmp#0 @string:122:30)
    foreign llvm move(tmp#0, ?#result @string:122:5)


[] > public {test} (0 calls)
0: [](s:_ @string:91:19, idx:int @string:91:24, ?c:char @string:91:34):
    if {buffer(?len @string:93:17, ?str @string:93:23, s @string:92:10)::

        <=(0 @string:94:14, idx @string:94:20)
        <(idx @string:95:14, len @string:95:20)
        unsafe_c_string_index(str @string:96:35, idx @string:96:40, ?c @string:96:46)
    else::
        if {concat(?left @string:97:17, ?right @string:97:24, s @string:92:10)::

            length(left @string:98:32, ?tmp#0 @string:98:25)
            =(?left_len @string:98:14, tmp#0)
            if {<(idx @string:99:18, left_len @string:99:24)::

                [](left @string:99:41, idx @string:99:46, ?tmp#1 @string:99:41)
                =(?c @string:99:37, tmp#1)
            else::
                -(idx @string:100:37, left_len @string:100:43, ?tmp#3 @string:100:37)
                [](right @string:100:31, tmp#3, ?tmp#2 @string:100:31)
                =(?c @string:100:27, tmp#2)

            }
        else::
            if {slice(?base @string:102:16, ?range @string:102:23, s @string:92:10)::

                [](range @string:102:43, idx @string:102:49, ?tmp#5 @string:102:43)
                [](base @string:102:38, tmp#5, ?tmp#4 @string:102:38)
                =(?c @string:102:34, tmp#4)
            else::
                if {singleton(?c @string:103:20, s @string:92:10)::

                    =(idx @string:103:27, 0 @string:103:33)
                else::
                    fail

                }

            }

        }

    }
[] > public (0 calls)
1: [](s:_ @string:109:12, r:range @string:109:17, ?#result:_ @string:109:5):
    slice(s @string:109:36, r @string:109:39, ?tmp#0 @string:109:30)
    foreign llvm move(tmp#0, ?#result @string:109:5)


[|] > public {test} (0 calls)
0: [|](?head:char @string:71:23, ?tail:_ @string:71:35, s:_ @string:71:43):
    if {buffer(?len @string:73:17, ?str @string:73:23, s @string:72:10)::

        [|](?head @string:74:15, ?str @string:74:23, str @string:74:30)
        if {=(len @string:75:26, 1 @string:75:32)::

            empty(?tmp#1 @string:75:37)
            foreign llvm move(tmp#1, ?tmp#0)
        else::
            -(len @string:75:60, 1 @string:75:66, ?tmp#3 @string:75:60)
            buffer(tmp#3, str @string:75:69, ?tmp#2 @string:75:53)
            foreign llvm move(tmp#2, ?tmp#0)

        }
        =(?tail @string:75:14, tmp#0 @string:75:26)
    else::
        if {concat(?left @string:76:17, ?right @string:76:24, s @string:72:10)::

            if {[|](?head @string:77:20, ?t @string:77:28, left @string:77:33)::

                concat(t @string:77:56, right @string:77:59, ?tmp#4 @string:77:49)
                =(?tail @string:77:42, tmp#4)
            else::
                [|](?head @string:78:28, ?tail @string:78:36, right @string:78:44)

            }
        else::
            if {slice(?base @string:80:16, ?range @string:80:23, s @string:72:10)::

                do {
                    [|](?idx @string:82:19, ?range @string:82:26, range @string:82:35)
                    if {(   [](base @string:83:30, idx @string:83:35, ?tmp#5 @string:83:30)
                        & =(?head @string:83:23, tmp#5))::

                        slice(base @string:83:57, range @string:83:63, ?tmp#6 @string:83:51)
                        =(?tail @string:83:44, tmp#6)
                        break
                    else::
                        pass

                    }
                }
            else::
                if {singleton(?head @string:85:20, s @string:72:10)::

                    empty(?tmp#7 @string:85:37)
                    =(?tail @string:85:30, tmp#7)
                else::
                    fail

                }

            }

        }

    }


c_string > public (0 calls)
0: c_string(s:_ @string:40:18, ?#result:c_string @string:40:5):
    if {buffer(?tmp#0 @string:41:21, ?str @string:41:25, s @string:41:10)::

        pass
    else::
        length(s @string:43:27, ?tmp#2 @string:43:20)
        +(tmp#2, 1 @string:43:32, ?tmp#1 @string:43:20)
        =(?len @string:43:14, tmp#1)
        foreign lpvm alloc(len @string:44:32, ?str @string:44:38)
        true(?tmp#3 @string:45:49)
        foreign lpvm mutate(str @string:45:33, ?str @string:45:39, len @string:45:44, tmp#3, len @string:45:55, 0 @string:45:60, '\NUL' @string:45:63)
        =(?offset @string:46:14, 0 @string:46:23)
        pack(s @string:47:18, !str @string:47:22, len @string:47:27, !offset @string:47:33)

    }
    foreign llvm move(str @string:40:34, ?#result @string:40:5)


fixed_range_size > (0 calls)
0: fixed_range_size(hi:int @string:184:22, r:range @string:184:30, ?sz:int @string:184:40):
    range(?start @string:185:16, ?stride @string:185:24, ?end @string:185:33, r @string:185:5)
    if {<=(0 @string:186:10, stride @string:186:16)::

        -(start @string:187:39, ?tmp#4 @string:187:38)
        /(tmp#4, stride @string:187:47, ?tmp#3 @string:187:38)
        *(tmp#3, stride @string:187:56, ?tmp#2 @string:187:38)
        +(start @string:187:30, tmp#2, ?tmp#1 @string:187:30)
        max(start @string:187:23, tmp#1, ?tmp#0 @string:187:19)
        =(?lo @string:187:14, tmp#0)
        min(hi @string:188:23, end @string:188:27, ?tmp#5 @string:188:19)
        =(?hi @string:188:14, tmp#5)
    else::
        max(-1 @string:190:23, end @string:190:27, ?tmp#6 @string:190:19)
        =(?lo @string:190:14, tmp#6)
        +(hi @string:191:30, stride @string:191:35, ?tmp#10 @string:191:30)
        -(start @string:191:45, hi @string:191:53, ?tmp#13 @string:191:45)
        -(tmp#13, 1 @string:191:58, ?tmp#12 @string:191:45)
        -(stride @string:191:64, ?tmp#14 @string:191:63)
        %(tmp#12, tmp#14, ?tmp#11 @string:191:44)
        +(tmp#10, tmp#11, ?tmp#9 @string:191:30)
        +(tmp#9, 1 @string:191:73, ?tmp#8 @string:191:30)
        min(start @string:191:23, tmp#8, ?tmp#7 @string:191:19)
        =(?hi @string:191:14, tmp#7)
        -(stride @string:192:24, ?tmp#15 @string:192:23)
        =(?stride @string:192:14, tmp#15)

    }
    if {<=(hi @string:194:16, lo @string:194:23)::

        foreign llvm move(0 @string:194:29, ?tmp#16)
    else::
        -(hi @string:194:42, lo @string:194:47, ?tmp#20 @string:194:42)
        -(tmp#20, 1 @string:194:52, ?tmp#19 @string:194:42)
        /(tmp#19, stride @string:194:57, ?tmp#18 @string:194:41)
        +(tmp#18, 1 @string:194:66, ?tmp#17 @string:194:41)
        foreign llvm move(tmp#17, ?tmp#16)

    }
    =(?sz @string:194:6, tmp#16 @string:194:16)


length > public (0 calls)
0: length(s:_ @string:52:16, ?#result:int @string:52:5):
    if {buffer(?len @string:53:22, ?tmp#1 @string:53:27, s @string:53:10)::

        foreign llvm move(len @string:53:33, ?tmp#0)
    else::
        if {concat(?left @string:54:22, ?right @string:54:29, s @string:54:10)::

            length(left @string:54:46, ?tmp#4 @string:54:39)
            length(right @string:54:61, ?tmp#5 @string:54:54)
            +(tmp#4, tmp#5, ?tmp#3 @string:54:39)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            if {slice(?base @string:55:21, ?range @string:55:28, s @string:55:10)::

                length(base @string:55:62, ?tmp#8 @string:55:55)
                fixed_range_size(tmp#8, range @string:55:69, ?tmp#7 @string:55:38)
                foreign llvm move(tmp#7, ?tmp#6)
            else::
                if {singleton(?tmp#10 @string:56:24, s @string:56:10)::

                    foreign llvm move(1 @string:56:30, ?tmp#9)
                else::
                    foreign llvm move(0 @string:57:18, ?tmp#9)

                }
                foreign llvm move(tmp#9 @string:56:10, ?tmp#6)

            }
            foreign llvm move(tmp#6 @string:55:10, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:54:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:53:10, ?#result @string:52:5)


pack > (0 calls)
0: pack(s:_ @string:160:10, !raw:c_string @string:160:16, size:int @string:160:30, !offset:int @string:160:41):
    if {buffer(?tmp#0 @string:162:16, ?str @string:162:20, s @string:161:10)::

        foreign llvm move(str @string:163:23, ?tmp#1)
        do {
            if {[|](?c @string:163:18, ?tmp#1, tmp#1)::

                true(?tmp#2 @string:164:56)
                foreign lpvm mutate(raw @string:164:37, ?raw @string:164:43, offset @string:164:48, tmp#2, size @string:164:62, 0 @string:164:68, c @string:164:71)
                incr(!offset @string:165:23)
            else::
                break

            }
        }
    else::
        if {concat(?left @string:167:17, ?right @string:167:24, s @string:161:10)::

            pack(left @string:168:18, !raw @string:168:25, size @string:168:30, !offset @string:168:37)
            pack(right @string:169:18, !raw @string:169:26, size @string:169:31, !offset @string:169:38)
            incr(!offset @string:170:19)
        else::
            if {slice(?tmp#3 @string:171:15, ?tmp#4 @string:171:18, s @string:161:10)::

                foreign llvm move(s @string:172:23, ?tmp#5)
                do {
                    if {[|](?c @string:172:18, ?tmp#5, tmp#5)::

                        true(?tmp#6 @string:173:56)
                        foreign lpvm mutate(raw @string:173:37, ?raw @string:173:43, offset @string:173:48, tmp#6, size @string:173:62, 0 @string:173:68, c @string:173:71)
                        incr(!offset @string:174:23)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:176:20, s @string:161:10)::

                    true(?tmp#7 @string:177:52)
                    foreign lpvm mutate(raw @string:177:33, ?raw @string:177:39, offset @string:177:44, tmp#7, size @string:177:58, 0 @string:177:64, c @string:177:67)
                    incr(!offset @string:178:19)
                else::
                    fail

                }

            }

        }

    }


print > public (0 calls)
0: print(x:_ @string:142:15) use !io:
    if {buffer(?tmp#0 @string:144:16, ?str @string:144:20, x @string:143:10)::

        !print(str @string:144:35)
    else::
        if {concat(?left @string:145:17, ?right @string:145:24, x @string:143:10)::

            !print(left @string:145:41)
            !print(right @string:145:55)
        else::
            if {slice(?tmp#1 @string:146:15, ?tmp#2 @string:146:18, x @string:143:10)::

                foreign llvm move(x @string:146:34, ?tmp#3)
                do {
                    if {[|](?c @string:146:29, ?tmp#3, tmp#3)::

                        !print(c @string:146:45)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:147:20, x @string:143:10)::

                    !print(c @string:147:33)
                else::
                    fail

                }

            }

        }

    }


println > public (0 calls)
0: println(x:_ @string:151:17) use !io:
    !print(x @string:151:39)
    !nl


read > public (0 calls)
0: read(?x:_ @string:153:15) use !io:
    !read(?str:c_string @string:153:37)
    string(str @string:153:64, ?tmp#0 @string:153:57)
    =(?x @string:153:53, tmp#0)


string > public (0 calls)
0: string(str:c_string @string:28:16, ?#result:_ @string:28:5):
    length(str @string:29:19, ?tmp#0 @string:29:12)
    =(?len @string:29:6, tmp#0)
    if {=(len @string:30:15, 0 @string:30:21)::

        empty(?tmp#2 @string:30:26)
        foreign llvm move(tmp#2, ?tmp#1)
    else::
        if {=(len @string:31:15, 1 @string:31:21)::

            foreign lpvm access(str @string:31:56, 0 @string:31:61, 1 @string:31:64, 0 @string:31:67, ?tmp#5 @string:31:36)
            singleton(tmp#5, ?tmp#4 @string:31:26)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            buffer(len @string:32:33, str @string:32:38, ?tmp#6 @string:32:26)
            foreign llvm move(tmp#6, ?tmp#3)

        }
        foreign llvm move(tmp#3 @string:31:15, ?tmp#1)

    }
    =(?s @string:30:6, tmp#1 @string:30:15)
    foreign llvm move(s @string:28:34, ?#result @string:28:5)
string > public (0 calls)
1: string(c:char @string:37:16, ?#result:_ @string:37:5):
    singleton(c @string:37:38, ?tmp#0 @string:37:28)
    foreign llvm move(tmp#0, ?#result @string:37:5)


~= > public (0 calls)
0: ~=(x:_ @string:116:10, y:_ @string:116:18, ?#result:bool @string:116:5):
    <=>(x @string:116:31, y @string:116:39, ?tmp#1 @string:116:31)
    equal(?tmp#2 @string:116:46)
    ~=(tmp#1, tmp#2, ?tmp#0 @string:116:30)
    foreign llvm move(tmp#0, ?#result @string:116:5)

LLVM code       : None

======================================================================
AFTER FLATTENING:
 Module wybe
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : 
  imports         : public use wybe.array
                    public use wybe.bool
                    public use wybe.c_string
                    public use wybe.char
                    public use wybe.comparison
                    public use wybe.control
                    public use wybe.count
                    public use wybe.float
                    public use wybe.int
                    public use wybe.io
                    public use wybe.list
                    public use wybe.machine_word
                    public use wybe.memory_management
                    public use wybe.phantom
                    public use wybe.predicate
                    public use wybe.range
                    public use wybe.string
  resources       : 
  submodules      : wybe.array, wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.control, wybe.count, wybe.float, wybe.int, wybe.io, wybe.list, wybe.machine_word, wybe.memory_management, wybe.phantom, wybe.predicate, wybe.range, wybe.string
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.array(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.array.[]<0>
                    wybe.array.[]<1>
                    wybe.array.[|]<0>
                    wybe.array.array<0>
                    wybe.array.array<1>
                    wybe.array.inbounds<0>
                    wybe.array.unsafe_get<0>
                    wybe.array.unsafe_update<0>
  imports         : public use wybe.array.raw_array
                    use wybe.bool
                    use wybe.int
                    use wybe.list
                    use wybe.machine_word
  resources       : 
  submodules      : wybe.array.raw_array
  procs           : 

[] > public {test} (0 calls)
0: [](a:_(T) @array:67:21, idx:int @array:67:29, ?#result:T @array:67:5):
    inbounds(a @array:68:14, idx @array:68:17)
    unsafe_get(a @array:69:10, idx @array:69:23, ?tmp#0 @array:69:10)
    =(?x @array:69:6, tmp#0)
    foreign llvm move(x @array:67:42, ?#result @array:67:5)
[] > public {test} (0 calls)
1: [](!a:_(T) @array:81:22, idx:int @array:81:30, x:T @array:81:39):
    inbounds(a @array:82:14, idx @array:82:17)
    unsafe_update(!a @array:83:20, idx @array:83:23, x @array:83:28)


[|] > public {test} (0 calls)
0: [|](?head:T @array:51:23, ?tail:_(T) @array:51:32, a:_(T) @array:51:43):
    array(?length @array:52:12, ?data @array:52:21, a @array:52:29)
    >(length @array:53:6, 0 @array:53:15)
    word_size_bytes(?tmp#0 @array:54:34)
    foreign lpvm access(data @array:54:25, 0 @array:54:31, tmp#0, 0 @array:54:51, ?head @array:54:55)
    word_size_bytes(?tmp#1 @array:55:28)
    foreign llvm add(data @array:55:22, tmp#1, ?data @array:55:46)
    -(length @array:56:19, 1 @array:56:28, ?tmp#3 @array:56:19)
    array(tmp#3, data @array:56:31, ?tmp#2 @array:56:13)
    =(?tail @array:56:6, tmp#2)


array > public (0 calls)
0: array(x:T @array:18:15, len:int @array:18:20, ?#result:_(T) @array:18:5):
    word_size_bytes(?tmp#1 @array:19:19)
    *(len @array:19:13, tmp#1, ?tmp#0 @array:19:13)
    =(?size @array:19:6, tmp#0)
    foreign lpvm alloc(size @array:20:24, ?data @array:20:31)
    =(?offset @array:21:6, 0 @array:21:15)
    do {
        if {<(offset @array:23:15, size @array:23:24)::

            pass
        else::
            break

        }
        foreign lpvm mutate(data @array:24:29, ?data @array:24:36, offset @array:24:42, 1 @array:24:50, size @array:24:53, 0 @array:24:59, x @array:24:62)
        word_size_bytes(?tmp#2 @array:25:21)
        +=(!offset @array:25:10, tmp#2)
    }
    array(len @array:27:17, data @array:27:22, ?tmp#3 @array:27:11)
    =(?ar @array:27:6, tmp#3)
    foreign llvm move(ar @array:18:36, ?#result @array:18:5)
array > public (0 calls)
1: array(ls:list(T) @array:34:15, ?#result:_(T) @array:34:5):
    length(ls @array:35:19, ?tmp#0 @array:35:12)
    =(?len @array:35:6, tmp#0)
    word_size_bytes(?tmp#2 @array:36:19)
    *(len @array:36:13, tmp#2, ?tmp#1 @array:36:13)
    =(?size @array:36:6, tmp#1)
    foreign lpvm alloc(size @array:37:24, ?data @array:37:31)
    =(?offset @array:38:6, 0 @array:38:15)
    foreign llvm move(ls @array:39:15, ?tmp#3)
    do {
        if {[|](?x @array:39:10, ?tmp#3, tmp#3)::

            foreign lpvm mutate(data @array:40:29, ?data @array:40:36, offset @array:40:42, 1 @array:40:50, size @array:40:53, 0 @array:40:59, x @array:40:62)
            word_size_bytes(?tmp#4 @array:41:21)
            +=(!offset @array:41:10, tmp#4)
        else::
            break

        }
    }
    array(len @array:43:17, data @array:43:22, ?tmp#5 @array:43:11)
    =(?ar @array:43:6, tmp#5)
    foreign llvm move(ar @array:34:34, ?#result @array:34:5)


inbounds > public {test,inline} (0 calls)
0: inbounds(a:_(T) @array:60:33, idx:int @array:60:41):
    <=(0 @array:61:6, idx @array:61:12)
    length(a @array:62:12, ?tmp#0 @array:62:12)
    <(idx @array:62:6, tmp#0)


unsafe_get > public {inline} (0 calls)
0: unsafe_get(a:_(T) @array:75:29, idx:int @array:75:37, ?#result:T @array:75:5):
    raw_data(a @array:76:25, ?tmp#0 @array:76:25)
    word_size_bytes(?tmp#2 @array:76:43)
    *(idx @array:76:37, tmp#2, ?tmp#1 @array:76:37)
    word_size_bytes(?tmp#3 @array:76:60)
    foreign lpvm access(tmp#0, tmp#1, tmp#3, 0 @array:76:77, ?x @array:76:81)
    foreign llvm move(x @array:75:50, ?#result @array:75:5)


unsafe_update > public {inline} (0 calls)
0: unsafe_update(!a:_(T) @array:89:33, idx:int @array:89:41, x:T @array:89:50):
    raw_data(a @array:90:25, ?tmp#0 @array:90:25)
    word_size_bytes(?tmp#2 @array:90:50)
    *(idx @array:90:44, tmp#2, ?tmp#1 @array:90:44)
    length(a @array:91:44, ?tmp#4 @array:91:44)
    word_size_bytes(?tmp#5 @array:91:55)
    *(tmp#4, tmp#5, ?tmp#3 @array:91:44)
    foreign lpvm mutate(tmp#0, ?data @array:90:38, tmp#1, 0 @array:90:67, tmp#3, 0 @array:91:72, x @array:91:75)
    raw_data(!a @array:92:6, data @array:92:19)

LLVM code       : None

--------------------------------------------------
 Module wybe.array.raw_array(T)
  representation  : address
  public submods  : 
  public resources: 
  public procs    : 
  imports         : use wybe
                    use wybe.array
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.bool
  representation  : 1 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.bool.&&<0>
                    wybe.bool.&=<0>
                    wybe.bool.=<0>
                    wybe.bool.^=<0>
                    wybe.bool.^^<0>
                    wybe.bool.false<0>
                    wybe.bool.print<0>
                    wybe.bool.println<0>
                    wybe.bool.succeed<0>
                    wybe.bool.true<0>
                    wybe.bool.|=<0>
                    wybe.bool.||<0>
                    wybe.bool.~<0>
                    wybe.bool.~=<0>
  imports         : use wybe.c_string
                    use wybe.io
  resources       : 
  procs           : 

&& > public {inline} (1 calls)
0: wybe.bool.&&<0>
&&(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:13:27


&= > public {inline} (0 calls)
0: wybe.bool.&=<0>
&=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:13:27


= > public {inline} (0 calls)
0: wybe.bool.=<0>
=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:37:26


^= > public {inline} (0 calls)
0: wybe.bool.^=<0>
^=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:25:27


^^ > public {inline} (1 calls)
0: wybe.bool.^^<0>
^^(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:25:27


false > public {inline} (0 calls)
0: wybe.bool.false<0>
false(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.bool, ?#result##0:wybe.bool)


print > public (1 calls)
0: wybe.bool.print<0>
print(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    case ~x##0:wybe.bool of
    0:
        wybe.c_string.print<0>(c"false":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #1 @bool:47:31

    1:
        wybe.c_string.print<0>(c"true":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:47:31



println > public {inline} (0 calls)
0: wybe.bool.println<0>
println(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.bool.print<0>(~x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:49:33
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#0##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~tmp#0##0:wybe.phantom, ?tmp#1##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#1##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


succeed > public {inline} (0 calls)
0: wybe.bool.succeed<0>
succeed()<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []


true > public {inline} (1 calls)
0: wybe.bool.true<0>
true(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.bool, ?#result##0:wybe.bool)


|= > public {inline} (0 calls)
0: wybe.bool.|=<0>
|=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:19:27


|| > public {inline} (1 calls)
0: wybe.bool.||<0>
||(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:19:27


~ > public {inline} (0 calls)
0: wybe.bool.~<0>
~(p##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, 1:wybe.bool, ?#result##0:wybe.bool) @bool:31:20


~= > public {inline} (0 calls)
0: wybe.bool.~=<0>
~=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:38:27

LLVM code       : None

--------------------------------------------------
 Module wybe.c_string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.c_string.<<0>
                    wybe.c_string.<=<0>
                    wybe.c_string.=<0>
                    wybe.c_string.><0>
                    wybe.c_string.>=<0>
                    wybe.c_string.[]<0>
                    wybe.c_string.[|]<0>
                    wybe.c_string.length<0>
                    wybe.c_string.print<0>
                    wybe.c_string.println<0>
                    wybe.c_string.read<0>
                    wybe.c_string.unsafe_c_string_index<0>
                    wybe.c_string.~=<0>
  imports         : use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.c_string.<<0>
<(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:12:29
    wybe.int.<<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:12:29


<= > public {inline} (0 calls)
0: wybe.c_string.<=<0>
<=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:13:30
    wybe.int.<=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:13:30


= > public {inline} (0 calls)
0: wybe.c_string.=<0>
=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:10:29
    wybe.int.=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:10:29


> > public {inline} (0 calls)
0: wybe.c_string.><0>
>(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:14:29
    wybe.int.><0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:14:29


>= > public {inline} (0 calls)
0: wybe.c_string.>=<0>
>=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:15:30
    wybe.int.>=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:15:30


[] > public (0 calls)
0: wybe.c_string.[]<0>
[](str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, idx##0:wybe.int, ?tmp#2##0:wybe.bool) #0 @c_string:27:6
    case ~tmp#2##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        foreign c strlen(str##0:wybe.c_string, ?tmp#0##0:wybe.int) @c_string:17:29
        wybe.int.<<0>(idx##0:wybe.int, ~tmp#0##0:wybe.int, ?tmp#3##0:wybe.bool) #2 @c_string:28:6
        case ~tmp#3##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




[|] > public (0 calls)
0: wybe.c_string.[|]<0>
[|](?head##0:wybe.char, ?tail##0:wybe.c_string, str##0:wybe.c_string, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(str##0:wybe.c_string, 0:wybe.int, 0:wybe.int, 0:wybe.int, ?head##0:wybe.char) @c_string:20:5
    foreign llvm icmp_ne(head##0:wybe.char, '\NUL':wybe.char, ?not_done##0:wybe.bool) @c_string:21:5
    foreign llvm icmp_eq(~not_done##0:wybe.bool, 1:wybe.bool, ?tmp#1##0:wybe.bool) @bool:37:26
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.c_string, ?tail##0:wybe.c_string)

    1:
        foreign llvm add(~str##0:wybe.c_string, 1:wybe.int, ?tail##0:wybe.c_string) @c_string:23:5
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



length > public {inline} (3 calls)
0: wybe.c_string.length<0>
length(str##0:wybe.c_string, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strlen(~str##0:wybe.c_string, ?#result##0:wybe.int) @c_string:17:29


print > public {inline} (1 calls)
0: wybe.c_string.print<0>
print(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:35:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:35:30


println > public {inline} (0 calls)
0: wybe.c_string.println<0>
println(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @c_string:35:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.c_string.read<0>
read(?x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:39:30
    foreign c read_line(?x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:39:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:39:30


unsafe_c_string_index > public {inline} (1 calls)
0: wybe.c_string.unsafe_c_string_index<0>
unsafe_c_string_index(str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7


~= > public {inline} (0 calls)
0: wybe.c_string.~=<0>
~=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:11:30
    wybe.int.~=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.char
  representation  : 8 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.char.<<0>
                    wybe.char.<=<0>
                    wybe.char.<=><0>
                    wybe.char.=<0>
                    wybe.char.><0>
                    wybe.char.>=<0>
                    wybe.char.chr<0>
                    wybe.char.ord<0>
                    wybe.char.print<0>
                    wybe.char.println<0>
                    wybe.char.read<0>
                    wybe.char.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (4 calls)
0: wybe.char.<<0>
<(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:17:29


<= > public {inline} (0 calls)
0: wybe.char.<=<0>
<=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:18:30


<=> > public (0 calls)
0: wybe.char.<=><0>
<=>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.char, y##0:wybe.char, ?tmp#6##0:wybe.bool) @char:17:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?tmp#5##0:wybe.bool) @char:13:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5



= > public {inline} (2 calls)
0: wybe.char.=<0>
=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:13:29


> > public {inline} (0 calls)
0: wybe.char.><0>
>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:19:29


>= > public {inline} (0 calls)
0: wybe.char.>=<0>
>=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:20:30


chr > public (0 calls)
0: wybe.char.chr<0>
chr(i##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, i##0:wybe.int, ?tmp#1##0:wybe.bool) #0 @char:33:60
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        wybe.int.<=<0>(i##0:wybe.int, 255:wybe.int, ?tmp#2##0:wybe.bool) #1 @char:33:70
        case ~tmp#2##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm cast(~i##0:wybe.int, ?#result##0:wybe.char) @char:33:31
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




ord > public {inline} (0 calls)
0: wybe.char.ord<0>
ord(c##0:wybe.char, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(~c##0:wybe.char, ?#result##0:wybe.int) @char:30:24


print > public {inline} (1 calls)
0: wybe.char.print<0>
print(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:37:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:37:30


println > public {inline} (0 calls)
0: wybe.char.println<0>
println(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @char:37:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.char.read<0>
read(?x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:41:30
    foreign c read_char(?x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:41:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:41:30


~= > public {inline} (0 calls)
0: wybe.char.~=<0>
~=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:14:30

LLVM code       : None

--------------------------------------------------
 Module wybe.comparison
  representation  : 2 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.comparison.<<0>
                    wybe.comparison.<=<0>
                    wybe.comparison.=<0>
                    wybe.comparison.><0>
                    wybe.comparison.>=<0>
                    wybe.comparison.equal<0>
                    wybe.comparison.greater<0>
                    wybe.comparison.lesser<0>
                    wybe.comparison.~=<0>
  imports         : use wybe.bool
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.comparison.<<0>
<(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:12:29


<= > public {inline} (0 calls)
0: wybe.comparison.<=<0>
<=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:13:30


= > public {inline} (0 calls)
0: wybe.comparison.=<0>
=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:10:29


> > public {inline} (0 calls)
0: wybe.comparison.><0>
>(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:14:29


>= > public {inline} (0 calls)
0: wybe.comparison.>=<0>
>=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:15:30


equal > public {inline} (0 calls)
0: wybe.comparison.equal<0>
equal(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison)


greater > public {inline} (0 calls)
0: wybe.comparison.greater<0>
greater(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison)


lesser > public {inline} (0 calls)
0: wybe.comparison.lesser<0>
lesser(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison)


~= > public {inline} (0 calls)
0: wybe.comparison.~=<0>
~=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.control
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.control.assert<0>
                    wybe.control.error<0>
                    wybe.control.error<1>
                    wybe.control.exit<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.int
                    use wybe.string
  resources       : 
  procs           : 

assert > public {semipure} (0 calls)
0: assert(condition:bool @control:26:27) use call_source_location:
    if {~(condition @control:27:11)::

        !error(c"assertion failed" @control:27:31)
    else::
        pass

    }


error > public {terminal,semipure} (0 calls)
0: error(message:string @control:17:35) use call_source_location:
    c_string(message @control:18:77, ?tmp#0 @control:18:68)
    foreign c {terminal,semipure} error_exit(call_source_location @control:18:46, tmp#0)
error > public {terminal,semipure} (0 calls)
1: error(message:c_string @control:21:35) use call_source_location:
    foreign c {terminal,semipure} error_exit(call_source_location @control:22:46, message @control:22:68)


exit > public {terminal,semipure} (0 calls)
0: exit(code:int @control:10:34):
    foreign c {terminal,semipure} exit(code @control:11:40)

LLVM code       : None

--------------------------------------------------
 Module wybe.count
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.count.%<0>
                    wybe.count.%=<0>
                    wybe.count.*<0>
                    wybe.count.*=<0>
                    wybe.count.+<0>
                    wybe.count.+<1>
                    wybe.count.+<2>
                    wybe.count.+=<0>
                    wybe.count.-<0>
                    wybe.count.-<1>
                    wybe.count.-<2>
                    wybe.count.-=<0>
                    wybe.count./<0>
                    wybe.count./=<0>
                    wybe.count.<<0>
                    wybe.count.<=<0>
                    wybe.count.<=><0>
                    wybe.count.=<0>
                    wybe.count.><0>
                    wybe.count.>=<0>
                    wybe.count.decr<0>
                    wybe.count.incr<0>
                    wybe.count.max<0>
                    wybe.count.min<0>
                    wybe.count.print<0>
                    wybe.count.println<0>
                    wybe.count.read<0>
                    wybe.count.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.count.%<0>
%(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:51:25


%= > public {inline} (0 calls)
0: wybe.count.%=<0>
%=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:51:25


* > public {inline} (1 calls)
0: wybe.count.*<0>
*(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:39:25


*= > public {inline} (0 calls)
0: wybe.count.*=<0>
*=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:39:25


+ > public {inline} (2 calls)
0: wybe.count.+<0>
+(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:15:25
+ > public (0 calls)
1: wybe.count.+<1>
+(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(y##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?x##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~y##0:wybe.count, ?x##0:wybe.count) @count:18:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

+ > public (0 calls)
2: wybe.count.+<2>
+(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?y##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:22:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



+= > public {inline} (0 calls)
0: wybe.count.+=<0>
+=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:15:25


- > public (6 calls)
0: wybe.count.-<0>
-(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?#result##0:wybe.count)

    1:
        foreign llvm sub(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:31:35
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

- > public {inline} (0 calls)
1: wybe.count.-<1>
-(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.count, ~z##0:wybe.count, ?x##0:wybe.count) @count:32:42
- > public {inline} (0 calls)
2: wybe.count.-<2>
-(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:33:42


-= > public (0 calls)
0: wybe.count.-=<0>
-=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, ~y##0:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:36:41
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:36:37
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



/ > public {inline} (1 calls)
0: wybe.count./<0>
/(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:45:25


/= > public {inline} (0 calls)
0: wybe.count./=<0>
/=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:45:25


< > public {inline} (4 calls)
0: wybe.count.<<0>
<(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:64:29


<= > public {inline} (3 calls)
0: wybe.count.<=<0>
<=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:65:30


<=> > public (0 calls)
0: wybe.count.<=><0>
<=>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.count, y##0:wybe.count, ?tmp#6##0:wybe.bool) @count:64:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?tmp#5##0:wybe.bool) @count:60:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5



= > public {inline} (2 calls)
0: wybe.count.=<0>
=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:60:29


> > public {inline} (0 calls)
0: wybe.count.><0>
>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:66:29


>= > public {inline} (12 calls)
0: wybe.count.>=<0>
>=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:67:30


decr > public (0 calls)
0: wybe.count.decr<0>
decr(x##0:wybe.count, ?x##1:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, 1:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:84:37
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:84:33
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



incr > public {inline} (0 calls)
0: wybe.count.incr<0>
incr(x##0:wybe.count, ?x##1:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, 1:wybe.count, ?x##1:wybe.count) @count:15:25


max > public (0 calls)
0: wybe.count.max<0>
max(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:75:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:75:5



min > public (0 calls)
0: wybe.count.min<0>
min(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:65:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:74:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:74:5



print > public {inline} (1 calls)
0: wybe.count.print<0>
print(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:88:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:88:30


println > public {inline} (0 calls)
0: wybe.count.println<0>
println(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @count:88:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.count.read<0>
read(?x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:92:30
    foreign c read_count(?x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:92:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:92:30


~= > public {inline} (0 calls)
0: wybe.count.~=<0>
~=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:61:30

LLVM code       : None

--------------------------------------------------
 Module wybe.float
  representation  : 64 bit float
  public submods  : 
  public resources: 
  public procs    : wybe.float.*<0>
                    wybe.float.**<0>
                    wybe.float.*=<0>
                    wybe.float.+<0>
                    wybe.float.+<1>
                    wybe.float.+<2>
                    wybe.float.+=<0>
                    wybe.float.-<0>
                    wybe.float.-<1>
                    wybe.float.-<2>
                    wybe.float.-<3>
                    wybe.float.-<4>
                    wybe.float.-=<0>
                    wybe.float./<0>
                    wybe.float./=<0>
                    wybe.float.<<0>
                    wybe.float.<=<0>
                    wybe.float.<=><0>
                    wybe.float.=<0>
                    wybe.float.><0>
                    wybe.float.>=<0>
                    wybe.float.abs<0>
                    wybe.float.ceil<0>
                    wybe.float.cos<0>
                    wybe.float.e<0>
                    wybe.float.exp<0>
                    wybe.float.floor<0>
                    wybe.float.iceil<0>
                    wybe.float.ifloor<0>
                    wybe.float.iround<0>
                    wybe.float.log<0>
                    wybe.float.log10<0>
                    wybe.float.log2<0>
                    wybe.float.max<0>
                    wybe.float.min<0>
                    wybe.float.pi<0>
                    wybe.float.power<0>
                    wybe.float.print<0>
                    wybe.float.println<0>
                    wybe.float.read<0>
                    wybe.float.round<0>
                    wybe.float.sin<0>
                    wybe.float.sqrt<0>
                    wybe.float.square<0>
                    wybe.float.tan<0>
                    wybe.float.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

* > public {inline} (1 calls)
0: wybe.float.*<0>
*(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:45:25


** > public {inline} (0 calls)
0: wybe.float.**<0>
**(x##0:wybe.float, n##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.pow.f64(~x##0:wybe.float, ~n##0:wybe.float, ?#result##0:wybe.float) @float:112:27


*= > public {inline} (0 calls)
0: wybe.float.*=<0>
*=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:45:25


+ > public {inline} (1 calls)
0: wybe.float.+<0>
+(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:23:27
+ > public {inline} (0 calls)
1: wybe.float.+<1>
+(?x##0:wybe.float, y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:24:43
+ > public {inline} (0 calls)
2: wybe.float.+<2>
+(x##0:wybe.float, ?y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~x##0:wybe.float, ?y##0:wybe.float) @float:25:43


+= > public {inline} (0 calls)
0: wybe.float.+=<0>
+=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:23:27


- > public {inline} (1 calls)
0: wybe.float.-<0>
-(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:32:27
- > public {inline} (0 calls)
1: wybe.float.-<1>
-(?x##0:wybe.float, y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~z##0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:33:43
- > public {inline} (0 calls)
2: wybe.float.-<2>
-(x##0:wybe.float, ?y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~x##0:wybe.float, ?y##0:wybe.float) @float:34:43
- > public {inline} (0 calls)
3: wybe.float.-<3>
-(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(0.0:wybe.float, ~x##0:wybe.float, ?#result##0:wybe.float) @float:38:21
- > public {inline} (0 calls)
4: wybe.float.-<4>
-(?x##0:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(0.0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:39:37


-= > public {inline} (0 calls)
0: wybe.float.-=<0>
-=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:32:27


/ > public {inline} (2 calls)
0: wybe.float./<0>
/(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fdiv(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:51:25


/= > public {inline} (0 calls)
0: wybe.float./=<0>
/=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fdiv(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:51:25


< > public {inline} (4 calls)
0: wybe.float.<<0>
<(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_slt(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:70:29


<= > public {inline} (0 calls)
0: wybe.float.<=<0>
<=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sle(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:71:30


<=> > public (0 calls)
0: wybe.float.<=><0>
<=>(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_slt(x##0:wybe.float, y##0:wybe.float, ?tmp#6##0:wybe.bool) @float:70:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm fcmp_eq(~x##0:wybe.float, ~y##0:wybe.float, ?tmp#5##0:wybe.bool) @float:66:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5



= > public {inline} (2 calls)
0: wybe.float.=<0>
=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_eq(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:66:29


> > public {inline} (0 calls)
0: wybe.float.><0>
>(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sgt(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:72:29


>= > public {inline} (0 calls)
0: wybe.float.>=<0>
>=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sge(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:73:30


abs > public {inline} (0 calls)
0: wybe.float.abs<0>
abs(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.fabs.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:60:22


ceil > public {inline} (1 calls)
0: wybe.float.ceil<0>
ceil(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.ceil.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:87:23


cos > public {inline} (0 calls)
0: wybe.float.cos<0>
cos(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.cos.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:116:22


e > public {inline} (0 calls)
0: wybe.float.e<0>
e(?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2.7182818284590455:wybe.float, ?#result##0:wybe.float) @float:16:5


exp > public {inline} (0 calls)
0: wybe.float.exp<0>
exp(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.exp.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:120:22


floor > public {inline} (1 calls)
0: wybe.float.floor<0>
floor(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.floor.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:90:24


iceil > public {inline} (0 calls)
0: wybe.float.iceil<0>
iceil(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.ceil.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:87:23
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:99:26


ifloor > public {inline} (0 calls)
0: wybe.float.ifloor<0>
ifloor(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.floor.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:90:24
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:102:27


iround > public {inline} (0 calls)
0: wybe.float.iround<0>
iround(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.round.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:93:24
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:96:27


log > public {inline} (0 calls)
0: wybe.float.log<0>
log(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:123:22


log10 > public {inline} (0 calls)
0: wybe.float.log10<0>
log10(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log10.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:126:24


log2 > public {inline} (0 calls)
0: wybe.float.log2<0>
log2(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log2.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:129:23


max > public {inline} (0 calls)
0: wybe.float.max<0>
max(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.maxnum.f64(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:81:27


min > public {inline} (0 calls)
0: wybe.float.min<0>
min(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.minnum.f64(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:80:27


pi > public {inline} (0 calls)
0: wybe.float.pi<0>
pi(?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(3.141592653589793:wybe.float, ?#result##0:wybe.float) @float:13:5


power > public {inline} (0 calls)
0: wybe.float.power<0>
power(x##0:wybe.float, n##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.pow.f64(~x##0:wybe.float, ~n##0:wybe.float, ?#result##0:wybe.float) @float:111:28


print > public {inline} (1 calls)
0: wybe.float.print<0>
print(x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @float:133:30
    foreign c print_float(~x##0:wybe.float, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @float:133:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @float:133:30


println > public {inline} (0 calls)
0: wybe.float.println<0>
println(x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @float:133:30
    foreign c print_float(~x##0:wybe.float, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @float:133:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.float.read<0>
read(?x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @float:137:30
    foreign c read_float(?x##0:wybe.float, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @float:137:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @float:137:30


round > public {inline} (1 calls)
0: wybe.float.round<0>
round(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.round.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:93:24


sin > public {inline} (0 calls)
0: wybe.float.sin<0>
sin(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sin.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:115:22


sqrt > public {inline} (0 calls)
0: wybe.float.sqrt<0>
sqrt(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sqrt.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:108:23


square > public {inline} (0 calls)
0: wybe.float.square<0>
square(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~x##0:wybe.float, ?#result##0:wybe.float) @float:57:25


tan > public {inline} (0 calls)
0: wybe.float.tan<0>
tan(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sin.f64(x##0:wybe.float, ?tmp#1##0:wybe.float) @float:117:22
    foreign c llvm.cos.f64(~x##0:wybe.float, ?tmp#2##0:wybe.float) @float:117:52
    foreign llvm fdiv(~tmp#1##0:wybe.float, ~tmp#2##0:wybe.float, ?#result##0:wybe.float) @float:51:25


~= > public {inline} (0 calls)
0: wybe.float.~=<0>
~=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_ne(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:67:30

LLVM code       : None

--------------------------------------------------
 Module wybe.int
  representation  : 64 bit signed
  public submods  : 
  public resources: 
  public procs    : wybe.int.%<0>
                    wybe.int.%=<0>
                    wybe.int.*<0>
                    wybe.int.*=<0>
                    wybe.int.+<0>
                    wybe.int.+<1>
                    wybe.int.+<2>
                    wybe.int.+=<0>
                    wybe.int.-<0>
                    wybe.int.-<1>
                    wybe.int.-<2>
                    wybe.int.-<3>
                    wybe.int.-<4>
                    wybe.int.-=<0>
                    wybe.int./<0>
                    wybe.int./=<0>
                    wybe.int.<<0>
                    wybe.int.<<<0>
                    wybe.int.<<=<0>
                    wybe.int.<=<0>
                    wybe.int.<=><0>
                    wybe.int.=<0>
                    wybe.int.><0>
                    wybe.int.>=<0>
                    wybe.int.>><0>
                    wybe.int.>>=<0>
                    wybe.int.decr<0>
                    wybe.int.incr<0>
                    wybe.int.logical_bitshift<0>
                    wybe.int.logical_bitshift<1>
                    wybe.int.max<0>
                    wybe.int.min<0>
                    wybe.int.power<0>
                    wybe.int.print<0>
                    wybe.int.println<0>
                    wybe.int.read<0>
                    wybe.int.signum<0>
                    wybe.int.sqrt<0>
                    wybe.int.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.int.%<0>
%(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:50:25


%= > public {inline} (0 calls)
0: wybe.int.%=<0>
%=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:50:25


* > public {inline} (1 calls)
0: wybe.int.*<0>
*(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:38:25


*= > public {inline} (0 calls)
0: wybe.int.*=<0>
*=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:38:25


+ > public {inline} (2 calls)
0: wybe.int.+<0>
+(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:16:27
+ > public {inline} (0 calls)
1: wybe.int.+<1>
+(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:17:43
+ > public {inline} (0 calls)
2: wybe.int.+<2>
+(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:18:43


+= > public {inline} (0 calls)
0: wybe.int.+=<0>
+=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:16:27


- > public {inline} (2 calls)
0: wybe.int.-<0>
-(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:25:27
- > public {inline} (0 calls)
1: wybe.int.-<1>
-(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.int, ~z##0:wybe.int, ?x##0:wybe.int) @int:26:43
- > public {inline} (0 calls)
2: wybe.int.-<2>
-(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:27:43
- > public {inline} (0 calls)
3: wybe.int.-<3>
-(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~x##0:wybe.int, ?#result##0:wybe.int) @int:31:21
- > public {inline} (0 calls)
4: wybe.int.-<4>
-(?x##0:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:32:37


-= > public {inline} (0 calls)
0: wybe.int.-=<0>
-=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:25:27


/ > public {inline} (1 calls)
0: wybe.int./<0>
/(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:44:25


/= > public {inline} (0 calls)
0: wybe.int./=<0>
/=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:44:25


< > public {inline} (4 calls)
0: wybe.int.<<0>
<(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:87:29


<< > public {inline} (1 calls)
0: wybe.int.<<<0>
<<(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:56:27


<<= > public {inline} (0 calls)
0: wybe.int.<<=<0>
<<=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:56:27


<= > public {inline} (3 calls)
0: wybe.int.<=<0>
<=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:88:30


<=> > public (0 calls)
0: wybe.int.<=><0>
<=>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(x##0:wybe.int, y##0:wybe.int, ?tmp#6##0:wybe.bool) @int:87:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?tmp#5##0:wybe.bool) @int:83:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5



= > public {inline} (2 calls)
0: wybe.int.=<0>
=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:83:29


> > public {inline} (0 calls)
0: wybe.int.><0>
>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sgt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:89:29


>= > public {inline} (3 calls)
0: wybe.int.>=<0>
>=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:90:30


>> > public {inline} (1 calls)
0: wybe.int.>><0>
>>(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:65:27


>>= > public {inline} (0 calls)
0: wybe.int.>>=<0>
>>=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:65:27


decr > public {inline} (0 calls)
0: wybe.int.decr<0>
decr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:25:27


incr > public {inline} (0 calls)
0: wybe.int.incr<0>
incr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:16:27


logical_bitshift > public {inline} (1 calls)
0: wybe.int.logical_bitshift<0>
logical_bitshift(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:74:40
logical_bitshift > public {inline} (0 calls)
1: wybe.int.logical_bitshift<1>
logical_bitshift(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:74:40


max > public (0 calls)
0: wybe.int.max<0>
max(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:90:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:98:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:98:5



min > public (0 calls)
0: wybe.int.min<0>
min(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:88:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:97:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:97:5



power > public {inline} (0 calls)
0: wybe.int.power<0>
power(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c ipow(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:107:29


print > public {inline} (1 calls)
0: wybe.int.print<0>
print(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:119:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:119:30


println > public {inline} (0 calls)
0: wybe.int.println<0>
println(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @int:119:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.int.read<0>
read(?x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:123:30
    foreign c read_int(?x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:123:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:123:30


signum > public {inline} (0 calls)
0: wybe.int.signum<0>
signum(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c signum(~x##0:wybe.int, ?#result##0:wybe.int) @int:114:25


sqrt > public {inline} (0 calls)
0: wybe.int.sqrt<0>
sqrt(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c isqrt(~x##0:wybe.int, ?#result##0:wybe.int) @int:104:23


~= > public {inline} (0 calls)
0: wybe.int.~=<0>
~=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:84:30

LLVM code       : None

--------------------------------------------------
 Module wybe.io
  representation  : (not a type)
  public submods  : phantom -> wybe.phantom
  public resources: io: wybe.io.io
  public procs    : wybe.io.<0>
                    wybe.io.eof<0>
                    wybe.io.nl<0>
  imports         : use wybe.char
                    public use wybe.phantom
  resources       : io: fromList [(wybe.io.io,wybe.phantom = 0:phantom @io:13:27 @io:13:5)]
  procs           : 

module top-level code > public {inline,semipure} (0 calls)
0: wybe.io.<0>
()<{}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm store(0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:13:5


eof > public {inline} (0 calls)
0: wybe.io.eof<0>
eof(?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(-1:wybe.int, ?#result##0:wybe.char) @io:20:29


nl > public {inline} (0 calls)
0: wybe.io.nl<0>
nl()<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @io:17:31
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31

LLVM code       : None

--------------------------------------------------
 Module wybe.list(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.list.,,<0>
                    wybe.list.[]<0>
                    wybe.list.all<0>
                    wybe.list.any<0>
                    wybe.list.empty<0>
                    wybe.list.filter<0>
                    wybe.list.foldl<0>
                    wybe.list.foldr<0>
                    wybe.list.length<0>
                    wybe.list.list<0>
                    wybe.list.map<0>
                    wybe.list.map<1>
                    wybe.list.map<2>
                    wybe.list.print<0>
                    wybe.list.println<0>
                    wybe.list.reverse<0>
  imports         : use wybe.array
                    use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
                    use wybe.machine_word
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_(T) @list:20:10, y:_(T) @list:20:20, ?#result:_(T) @list:20:5):
    if {[|](?h @list:21:16, ?t @list:21:21, x @list:21:10)::

        ,,(t @list:21:32, y @list:21:37, ?tmp#2 @list:21:32)
        [|](h @list:21:28, tmp#2, ?tmp#1 @list:21:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(y @list:21:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:21:10, ?#result @list:20:5)


[] > public {test} (0 calls)
0: [](xs:_(T) @list:31:21, idx:int @list:31:30, ?#result:T @list:31:5):
    >=(idx @list:32:5, 0 @list:32:13)
    index1(xs @list:33:17, idx @list:33:21, ?tmp#0 @list:33:10)
    =(?x @list:33:6, tmp#0)
    foreign llvm move(x @list:31:43, ?#result @list:31:5)


all > public {test} (0 calls)
0: all(p:{test}(T) @list:61:20, xs:_(T) @list:61:33):
    foreign llvm move(xs @list:62:15, ?tmp#0)
    do {
        if {[|](?x @list:62:10, ?tmp#0, tmp#0)::

            p(x @list:63:11)
        else::
            break

        }
    }


any > public {test} (0 calls)
0: any(p:{test}(T) @list:69:20, xs:_(T) @list:69:33):
    [|](?x @list:70:7, ?xs @list:70:12, xs @list:70:18)
    (   p(x @list:71:8)
    | any(p @list:71:17, xs @list:71:20))


empty > public {test} (0 calls)
0: empty(xs:_(T) @list:15:22):
    if {[|](?tmp#0 @list:16:11, ?tmp#1 @list:16:15, xs @list:16:20)::

        fail
    else::
        pass

    }


filter > public (0 calls)
0: filter(p:{test}(T) @list:95:16, !xs:_(T) @list:95:30):
    [](?tmp#0 @list:96:12)
    =(?out @list:96:6, tmp#0)
    foreign llvm move(xs @list:97:15, ?tmp#1)
    do {
        if {[|](?x @list:97:10, ?tmp#1, tmp#1)::

            if {p(x @list:98:16)::

                [|](x @list:98:30, out @list:98:34, ?tmp#2 @list:98:29)
                =(?out @list:98:23, tmp#2)
            else::
                pass

            }
        else::
            break

        }
    }
    reverse(out @list:100:19, ?tmp#3 @list:100:11)
    =(?as @list:100:6, tmp#3)


foldl > public (0 calls)
0: foldl(f:(A, !B) @list:77:15, as:_(A) @list:77:26, !b:B @list:77:36):
    foreign llvm move(as @list:78:15, ?tmp#0)
    do {
        if {[|](?a @list:78:10, ?tmp#0, tmp#0)::

            f(a @list:79:11, !b @list:79:15)
        else::
            break

        }
    }


foldr > public (0 calls)
0: foldr(f:(A, !B) @list:86:15, as:_(A) @list:86:26, !b:B @list:86:36):
    if {[|](?a @list:87:12, ?as @list:87:17, as @list:87:23)::

        foldr(f @list:88:15, as @list:88:18, !b @list:88:23)
        f(a @list:89:11, !b @list:89:15)
    else::
        pass

    }


index1 > {test} (0 calls)
0: index1(xs:_(T) @list:148:19, idx:int @list:148:28, ?#result:T @list:148:1):
    [|](?x @list:149:7, ?xs @list:149:12, xs @list:149:18)
    (   =(idx @list:150:6, 0 @list:150:12)
    | (   -(idx @list:150:27, 1 @list:150:33, ?tmp#0 @list:150:27)
        & index1(xs @list:150:23, tmp#0, ?x @list:150:37)))
    foreign llvm move(x @list:148:41, ?#result @list:148:1)


length > public (0 calls)
0: length(x:_(T) @list:24:16, ?#result:int @list:24:5):
    length1(x @list:24:38, 0 @list:24:41, ?tmp#0 @list:24:30)
    foreign llvm move(tmp#0, ?#result @list:24:5)


length1 > (0 calls)
0: length1(x:_(T) @list:140:13, acc:int @list:140:21, ?#result:int @list:140:1):
    if {[|](?h @list:141:16, ?t @list:141:21, x @list:141:10)::

        +(acc @list:141:38, 1 @list:141:44, ?tmp#2 @list:141:38)
        length1(t @list:141:35, tmp#2, ?tmp#1 @list:141:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(acc @list:141:57, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:141:10, ?#result @list:140:1)


list > public (0 calls)
0: list(ar:array(T) @list:128:14, ?#result:_(T) @list:128:5):
    [](?tmp#0 @list:129:11)
    =(?ls @list:129:6, tmp#0)
    foreign llvm move(ar @list:130:15, ?tmp#1)
    do {
        if {[|](?x @list:130:10, ?tmp#1, tmp#1)::

            [|](x @list:131:16, ls @list:131:20, ?tmp#2 @list:131:15)
            =(?ls @list:131:10, tmp#2)
        else::
            break

        }
    }
    reverse(ls @list:133:13, ?ls @list:133:18)
    foreign llvm move(ls @list:128:34, ?#result @list:128:5)


map > public (0 calls)
0: map(f:{resource}(T) @list:41:13, xs:_(T) @list:41:30):
    foreign llvm move(xs @list:42:15, ?tmp#0)
    do {
        if {[|](?x @list:42:10, ?tmp#0, tmp#0)::

            !f(x @list:43:12)
        else::
            break

        }
    }
map > public (0 calls)
1: map(f:(A, ?B) @list:49:13, as:_(A) @list:49:24, ?#result:_(B) @list:49:5):
    if {[|](?a @list:50:12, ?as @list:50:17, as @list:50:23)::

        f(a @list:50:33, ?tmp#2 @list:50:31)
        map(f @list:50:42, as @list:50:45, ?tmp#3 @list:50:38)
        [|](tmp#2, tmp#3, ?tmp#1 @list:50:29)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:50:61)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:50:10, ?#result @list:49:5)
map > public (0 calls)
2: map(f:(A, B, ?C) @list:55:13, as:_(A) @list:55:27, bs:_(B) @list:55:36, ?#result:_(C) @list:55:5):
    if {(   [|](?a @list:56:12, ?as @list:56:17, as @list:56:23)
        & [|](?b @list:56:30, ?bs @list:56:35, bs @list:56:41))::

        f(a @list:56:51, b @list:56:54, ?tmp#2 @list:56:49)
        map(f @list:56:63, as @list:56:66, bs @list:56:70, ?tmp#3 @list:56:59)
        [|](tmp#2, tmp#3, ?tmp#1 @list:56:47)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:57:47)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:56:10, ?#result @list:55:5)


print > public (0 calls)
0: print(printer:{resource}(T) @list:108:15, xs:_(T) @list:108:38) use !io:
    !print('[' @list:109:12)
    if {[|](?x @list:110:12, ?xs @list:110:17, xs @list:110:23)::

        !printer(x @list:111:18)
        !print1(printer @list:112:17, xs @list:112:26)
    else::
        pass

    }
    !print(']' @list:114:12)


print1 > (0 calls)
0: print1(printer:{resource}(T) @list:154:12, xs:_(T) @list:154:35) use !io:
    if {[|](?x @list:155:12, ?xs @list:155:17, xs @list:155:23)::

        !print(',' @list:156:16)
        !printer(x @list:157:18)
        !print1(printer @list:158:17, xs @list:158:26)
    else::
        pass

    }


println > public (0 calls)
0: println(printer:{resource}(T) @list:119:17, xs:_(T) @list:119:40) use !io:
    !print(printer @list:120:12, xs @list:120:21)
    !nl


reverse > public (0 calls)
0: reverse(x:_(T) @list:27:17, ?#result:_(T) @list:27:5):
    [](?tmp#1 @list:27:44)
    reverse1(x @list:27:41, tmp#1, ?tmp#0 @list:27:32)
    foreign llvm move(tmp#0, ?#result @list:27:5)


reverse1 > (0 calls)
0: reverse1(x:_(T) @list:144:14, tail:_(T) @list:144:22, ?#result:_(T) @list:144:1):
    if {[|](?h @list:145:16, ?t @list:145:21, x @list:145:10)::

        [|](h @list:145:40, tail @list:145:44, ?tmp#2 @list:145:39)
        reverse1(t @list:145:36, tmp#2, ?tmp#1 @list:145:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(tail @list:145:61, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:145:10, ?#result @list:144:1)

LLVM code       : None

--------------------------------------------------
 Module wybe.machine_word
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.machine_word.word_size_bits<0>
                    wybe.machine_word.word_size_bytes<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

word_size_bits > public {inline} (0 calls)
0: wybe.machine_word.word_size_bits<0>
word_size_bits(?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(64:wybe.int, ?#result##0:wybe.int) @machine_word:12:5


word_size_bytes > public {inline} (1 calls)
0: wybe.machine_word.word_size_bytes<0>
word_size_bytes(?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(8:wybe.int, ?#result##0:wybe.int) @machine_word:10:5

LLVM code       : None

--------------------------------------------------
 Module wybe.memory_management
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.memory_management.<0>
                    wybe.memory_management.malloc_count<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

module top-level code > public {semipure} (0 calls)
0: ():
    foreign c {impure} gc_init


malloc_count > public {semipure} (0 calls)
0: malloc_count(?x:int @memory_management:11:34):
    foreign c {impure} malloc_count(?x @memory_management:12:38)

LLVM code       : None

--------------------------------------------------
 Module wybe.phantom
 modifiers       : {unique} 
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : 
  imports         : 
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.predicate
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.predicate.const<0>
                    wybe.predicate.id<0>
  imports         : 
  resources       : 
  procs           : 

const > public {inline} (0 calls)
0: wybe.predicate.const<0>
const(a##0:A <{}; {}; {0}>, [b##0:B <{}; {}; {1}>], ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:8:5


id > public {inline} (0 calls)
0: wybe.predicate.id<0>
id(a##0:A <{}; {}; {0}>, ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:6:5

LLVM code       : None

--------------------------------------------------
 Module wybe.range
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.range...<0>
                    wybe.range.[]<0>
                    wybe.range.[|]<0>
                    wybe.range.irange<0>
                    wybe.range.size<0>
                    wybe.range.xrange<0>
  imports         : use wybe.bool
                    use wybe.int
  resources       : 
  procs           : 

.. > public (0 calls)
0: ..(start:int @range:38:10, end:int @range:38:23, ?#result:_ @range:38:5):
    if {<=(start @range:39:27, end @range:39:37)::

        foreign llvm move(1 @range:39:44, ?tmp#1)
    else::
        foreign llvm move(-1 @range:39:56, ?tmp#1)

    }
    construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)
    foreign llvm move(tmp#0, ?#result @range:38:5)


[] > public {test} (0 calls)
0: [](r:_ @range:20:19, idx:int @range:20:24, ?value:int @range:20:34):
    <=(0 @range:21:6, idx @range:21:12)
    range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)
    *(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)
    +(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)
    =(?value @range:23:6, tmp#0)
    if {<=(0 @range:24:10, stride @range:24:16)::

        <(value @range:24:27, end @range:24:35)
    else::
        <(end @range:24:51, value @range:24:57)

    }


[|] > public {test} (0 calls)
0: [|](?value:int @range:12:23, ?rest:_ @range:12:35, current:_ @range:12:43):
    range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)
    ~=(value @range:14:6, end @range:14:16)
    +(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)
    range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)
    =(?rest @range:15:6, tmp#0)


construct > (0 calls)
0: construct(start:int @range:49:15, stride:int @range:49:26, end:int @range:49:38, ?#result:_ @range:49:1):
    -(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)
    %(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)
    =(?diff @range:50:6, tmp#0)
    if {<=(0 @range:51:19, stride @range:51:25)::

        if {=(diff @range:52:26, 0 @range:52:33)::

            max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
            -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
            max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
            foreign llvm move(tmp#5, ?tmp#3)

        }
        foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
    else::
        if {=(diff @range:55:26, 0 @range:55:33)::

            min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
            foreign llvm move(tmp#9, ?tmp#8)
        else::
            +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
            min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
            foreign llvm move(tmp#10, ?tmp#8)

        }
        foreign llvm move(tmp#8 @range:55:26, ?tmp#2)

    }
    =(?final @range:51:6, tmp#2 @range:51:19)
    range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)
    =(?r @range:58:6, tmp#12)
    foreign llvm move(r @range:49:51, ?#result @range:49:1)


irange > public (0 calls)
0: irange(start:int @range:32:16, stride:int @range:32:27, end:int @range:32:39, ?#result:_ @range:32:5):
    if {<(stride @range:33:41, 0 @range:33:50)::

        foreign llvm move(-1 @range:33:55, ?tmp#2)
    else::
        foreign llvm move(1 @range:33:68, ?tmp#2)

    }
    +(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)
    construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)
    foreign llvm move(tmp#0, ?#result @range:32:5)


size > public (0 calls)
0: size(r:_ @range:42:14, ?#result:int @range:42:5):
    range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)
    if {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
        & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
        & signum(tmp#3, ?tmp#2 @range:44:29)
        & ~=(tmp#1, tmp#2))::

        foreign llvm move(0 @range:44:52, ?tmp#0)
    else::
        if {<=(0 @range:45:10, stride @range:45:16)::

            -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
            -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
            /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
            +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
            foreign llvm move(tmp#5, ?tmp#4)
        else::
            -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
            -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
            -(stride @range:46:39, ?tmp#13 @range:46:38)
            /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
            +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
            foreign llvm move(tmp#9, ?tmp#4)

        }
        foreign llvm move(tmp#4 @range:45:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)


xrange > public (0 calls)
0: xrange(start:int @range:28:16, stride:int @range:28:27, end:int @range:28:39, ?#result:_ @range:28:5):
    construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)
    foreign llvm move(tmp#0, ?#result @range:28:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.string
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.string.,,<0>
                    wybe.string.<<0>
                    wybe.string.<=<0>
                    wybe.string.<=><0>
                    wybe.string.=<0>
                    wybe.string.><0>
                    wybe.string.>=<0>
                    wybe.string.[]<0>
                    wybe.string.[]<1>
                    wybe.string.[|]<0>
                    wybe.string.c_string<0>
                    wybe.string.length<0>
                    wybe.string.print<0>
                    wybe.string.println<0>
                    wybe.string.read<0>
                    wybe.string.string<0>
                    wybe.string.string<1>
                    wybe.string.~=<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.char
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
                    use wybe.range
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_ @string:64:10, y:_ @string:64:17, ?#result:_ @string:64:5):
    if {(   empty(?tmp#1 @string:65:14)
        & =(x @string:65:10, tmp#1))::

        foreign llvm move(y @string:65:23, ?tmp#0)
    else::
        if {(   empty(?tmp#3 @string:66:14)
            & =(y @string:66:10, tmp#3))::

            foreign llvm move(x @string:66:23, ?tmp#2)
        else::
            concat(x @string:67:25, y @string:67:28, ?tmp#4 @string:67:18)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:66:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:65:10, ?#result @string:64:5)


< > public (0 calls)
0: <(x:_ @string:119:10, y:_ @string:119:17, ?#result:bool @string:119:5):
    <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
    equal(?tmp#2 @string:119:44)
    <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
    foreign llvm move(tmp#0, ?#result @string:119:5)


<= > public (0 calls)
0: <=(x:_ @string:120:10, y:_ @string:120:18, ?#result:bool @string:120:5):
    <=>(x @string:120:31, y @string:120:39, ?tmp#1 @string:120:31)
    equal(?tmp#2 @string:120:46)
    <=(tmp#1, tmp#2, ?tmp#0 @string:120:30)
    foreign llvm move(tmp#0, ?#result @string:120:5)


<=> > public (0 calls)
0: <=>(x:_ @string:125:10, y:_ @string:125:20, ?#result:comparison @string:125:5):
    equal(?tmp#0 @string:126:10)
    =(?c @string:126:6, tmp#0)
    foreign llvm move(x @string:127:16, ?tmp#1)
    foreign llvm move(y @string:127:26, ?tmp#2)
    do {
        if {[|](?cx @string:127:10, ?tmp#1, tmp#1)::

            if {[|](?cy @string:127:20, ?tmp#2, tmp#2)::

                if {<(cx @string:128:14, cy @string:128:19)::

                    lesser(?tmp#3 @string:128:30)
                    =(?c @string:128:26, tmp#3)
                    break
                else::
                    if {>(cx @string:129:14, cy @string:129:19)::

                        greater(?tmp#4 @string:129:30)
                        =(?c @string:129:26, tmp#4)
                        break
                    else::
                        pass

                    }

                }
            else::
                break

            }
        else::
            break

        }
    }
    if {(   equal(?tmp#5 @string:132:14)
        & =(c @string:132:10, tmp#5))::

        length(x @string:133:22, ?tmp#6 @string:133:15)
        =(?lx @string:133:10, tmp#6)
        length(y @string:134:22, ?tmp#7 @string:134:15)
        =(?ly @string:134:10, tmp#7)
        if {<(lx @string:135:14, ly @string:135:19)::

            lesser(?tmp#8 @string:135:30)
            =(?c @string:135:26, tmp#8)
        else::
            if {>(lx @string:135:39, ly @string:135:44)::

                greater(?tmp#9 @string:135:55)
                =(?c @string:135:51, tmp#9)
            else::
                pass

            }

        }
    else::
        pass

    }
    foreign llvm move(c @string:125:38, ?#result @string:125:5)


= > public (0 calls)
0: =(x:_ @string:115:10, y:_ @string:115:17, ?#result:bool @string:115:5):
    <=>(x @string:115:30, y @string:115:38, ?tmp#1 @string:115:30)
    equal(?tmp#2 @string:115:44)
    =(tmp#1, tmp#2, ?tmp#0 @string:115:29)
    foreign llvm move(tmp#0, ?#result @string:115:5)


> > public (0 calls)
0: >(x:_ @string:121:10, y:_ @string:121:17, ?#result:bool @string:121:5):
    <=>(x @string:121:30, y @string:121:38, ?tmp#1 @string:121:30)
    equal(?tmp#2 @string:121:44)
    >(tmp#1, tmp#2, ?tmp#0 @string:121:29)
    foreign llvm move(tmp#0, ?#result @string:121:5)


>= > public (0 calls)
0: >=(x:_ @string:122:10, y:_ @string:122:18, ?#result:bool @string:122:5):
    <=>(x @string:122:31, y @string:122:39, ?tmp#1 @string:122:31)
    equal(?tmp#2 @string:122:46)
    >=(tmp#1, tmp#2, ?tmp#0 @string:122:30)
    foreign llvm move(tmp#0, ?#result @string:122:5)


[] > public {test} (0 calls)
0: [](s:_ @string:91:19, idx:int @string:91:24, ?c:char @string:91:34):
    if {buffer(?len @string:93:17, ?str @string:93:23, s @string:92:10)::

        <=(0 @string:94:14, idx @string:94:20)
        <(idx @string:95:14, len @string:95:20)
        unsafe_c_string_index(str @string:96:35, idx @string:96:40, ?c @string:96:46)
    else::
        if {concat(?left @string:97:17, ?right @string:97:24, s @string:92:10)::

            length(left @string:98:32, ?tmp#0 @string:98:25)
            =(?left_len @string:98:14, tmp#0)
            if {<(idx @string:99:18, left_len @string:99:24)::

                [](left @string:99:41, idx @string:99:46, ?tmp#1 @string:99:41)
                =(?c @string:99:37, tmp#1)
            else::
                -(idx @string:100:37, left_len @string:100:43, ?tmp#3 @string:100:37)
                [](right @string:100:31, tmp#3, ?tmp#2 @string:100:31)
                =(?c @string:100:27, tmp#2)

            }
        else::
            if {slice(?base @string:102:16, ?range @string:102:23, s @string:92:10)::

                [](range @string:102:43, idx @string:102:49, ?tmp#5 @string:102:43)
                [](base @string:102:38, tmp#5, ?tmp#4 @string:102:38)
                =(?c @string:102:34, tmp#4)
            else::
                if {singleton(?c @string:103:20, s @string:92:10)::

                    =(idx @string:103:27, 0 @string:103:33)
                else::
                    fail

                }

            }

        }

    }
[] > public (0 calls)
1: [](s:_ @string:109:12, r:range @string:109:17, ?#result:_ @string:109:5):
    slice(s @string:109:36, r @string:109:39, ?tmp#0 @string:109:30)
    foreign llvm move(tmp#0, ?#result @string:109:5)


[|] > public {test} (0 calls)
0: [|](?head:char @string:71:23, ?tail:_ @string:71:35, s:_ @string:71:43):
    if {buffer(?len @string:73:17, ?str @string:73:23, s @string:72:10)::

        [|](?head @string:74:15, ?str @string:74:23, str @string:74:30)
        if {=(len @string:75:26, 1 @string:75:32)::

            empty(?tmp#1 @string:75:37)
            foreign llvm move(tmp#1, ?tmp#0)
        else::
            -(len @string:75:60, 1 @string:75:66, ?tmp#3 @string:75:60)
            buffer(tmp#3, str @string:75:69, ?tmp#2 @string:75:53)
            foreign llvm move(tmp#2, ?tmp#0)

        }
        =(?tail @string:75:14, tmp#0 @string:75:26)
    else::
        if {concat(?left @string:76:17, ?right @string:76:24, s @string:72:10)::

            if {[|](?head @string:77:20, ?t @string:77:28, left @string:77:33)::

                concat(t @string:77:56, right @string:77:59, ?tmp#4 @string:77:49)
                =(?tail @string:77:42, tmp#4)
            else::
                [|](?head @string:78:28, ?tail @string:78:36, right @string:78:44)

            }
        else::
            if {slice(?base @string:80:16, ?range @string:80:23, s @string:72:10)::

                do {
                    [|](?idx @string:82:19, ?range @string:82:26, range @string:82:35)
                    if {(   [](base @string:83:30, idx @string:83:35, ?tmp#5 @string:83:30)
                        & =(?head @string:83:23, tmp#5))::

                        slice(base @string:83:57, range @string:83:63, ?tmp#6 @string:83:51)
                        =(?tail @string:83:44, tmp#6)
                        break
                    else::
                        pass

                    }
                }
            else::
                if {singleton(?head @string:85:20, s @string:72:10)::

                    empty(?tmp#7 @string:85:37)
                    =(?tail @string:85:30, tmp#7)
                else::
                    fail

                }

            }

        }

    }


c_string > public (0 calls)
0: c_string(s:_ @string:40:18, ?#result:c_string @string:40:5):
    if {buffer(?tmp#0 @string:41:21, ?str @string:41:25, s @string:41:10)::

        pass
    else::
        length(s @string:43:27, ?tmp#2 @string:43:20)
        +(tmp#2, 1 @string:43:32, ?tmp#1 @string:43:20)
        =(?len @string:43:14, tmp#1)
        foreign lpvm alloc(len @string:44:32, ?str @string:44:38)
        true(?tmp#3 @string:45:49)
        foreign lpvm mutate(str @string:45:33, ?str @string:45:39, len @string:45:44, tmp#3, len @string:45:55, 0 @string:45:60, '\NUL' @string:45:63)
        =(?offset @string:46:14, 0 @string:46:23)
        pack(s @string:47:18, !str @string:47:22, len @string:47:27, !offset @string:47:33)

    }
    foreign llvm move(str @string:40:34, ?#result @string:40:5)


fixed_range_size > (0 calls)
0: fixed_range_size(hi:int @string:184:22, r:range @string:184:30, ?sz:int @string:184:40):
    range(?start @string:185:16, ?stride @string:185:24, ?end @string:185:33, r @string:185:5)
    if {<=(0 @string:186:10, stride @string:186:16)::

        -(start @string:187:39, ?tmp#4 @string:187:38)
        /(tmp#4, stride @string:187:47, ?tmp#3 @string:187:38)
        *(tmp#3, stride @string:187:56, ?tmp#2 @string:187:38)
        +(start @string:187:30, tmp#2, ?tmp#1 @string:187:30)
        max(start @string:187:23, tmp#1, ?tmp#0 @string:187:19)
        =(?lo @string:187:14, tmp#0)
        min(hi @string:188:23, end @string:188:27, ?tmp#5 @string:188:19)
        =(?hi @string:188:14, tmp#5)
    else::
        max(-1 @string:190:23, end @string:190:27, ?tmp#6 @string:190:19)
        =(?lo @string:190:14, tmp#6)
        +(hi @string:191:30, stride @string:191:35, ?tmp#10 @string:191:30)
        -(start @string:191:45, hi @string:191:53, ?tmp#13 @string:191:45)
        -(tmp#13, 1 @string:191:58, ?tmp#12 @string:191:45)
        -(stride @string:191:64, ?tmp#14 @string:191:63)
        %(tmp#12, tmp#14, ?tmp#11 @string:191:44)
        +(tmp#10, tmp#11, ?tmp#9 @string:191:30)
        +(tmp#9, 1 @string:191:73, ?tmp#8 @string:191:30)
        min(start @string:191:23, tmp#8, ?tmp#7 @string:191:19)
        =(?hi @string:191:14, tmp#7)
        -(stride @string:192:24, ?tmp#15 @string:192:23)
        =(?stride @string:192:14, tmp#15)

    }
    if {<=(hi @string:194:16, lo @string:194:23)::

        foreign llvm move(0 @string:194:29, ?tmp#16)
    else::
        -(hi @string:194:42, lo @string:194:47, ?tmp#20 @string:194:42)
        -(tmp#20, 1 @string:194:52, ?tmp#19 @string:194:42)
        /(tmp#19, stride @string:194:57, ?tmp#18 @string:194:41)
        +(tmp#18, 1 @string:194:66, ?tmp#17 @string:194:41)
        foreign llvm move(tmp#17, ?tmp#16)

    }
    =(?sz @string:194:6, tmp#16 @string:194:16)


length > public (0 calls)
0: length(s:_ @string:52:16, ?#result:int @string:52:5):
    if {buffer(?len @string:53:22, ?tmp#1 @string:53:27, s @string:53:10)::

        foreign llvm move(len @string:53:33, ?tmp#0)
    else::
        if {concat(?left @string:54:22, ?right @string:54:29, s @string:54:10)::

            length(left @string:54:46, ?tmp#4 @string:54:39)
            length(right @string:54:61, ?tmp#5 @string:54:54)
            +(tmp#4, tmp#5, ?tmp#3 @string:54:39)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            if {slice(?base @string:55:21, ?range @string:55:28, s @string:55:10)::

                length(base @string:55:62, ?tmp#8 @string:55:55)
                fixed_range_size(tmp#8, range @string:55:69, ?tmp#7 @string:55:38)
                foreign llvm move(tmp#7, ?tmp#6)
            else::
                if {singleton(?tmp#10 @string:56:24, s @string:56:10)::

                    foreign llvm move(1 @string:56:30, ?tmp#9)
                else::
                    foreign llvm move(0 @string:57:18, ?tmp#9)

                }
                foreign llvm move(tmp#9 @string:56:10, ?tmp#6)

            }
            foreign llvm move(tmp#6 @string:55:10, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:54:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:53:10, ?#result @string:52:5)


pack > (0 calls)
0: pack(s:_ @string:160:10, !raw:c_string @string:160:16, size:int @string:160:30, !offset:int @string:160:41):
    if {buffer(?tmp#0 @string:162:16, ?str @string:162:20, s @string:161:10)::

        foreign llvm move(str @string:163:23, ?tmp#1)
        do {
            if {[|](?c @string:163:18, ?tmp#1, tmp#1)::

                true(?tmp#2 @string:164:56)
                foreign lpvm mutate(raw @string:164:37, ?raw @string:164:43, offset @string:164:48, tmp#2, size @string:164:62, 0 @string:164:68, c @string:164:71)
                incr(!offset @string:165:23)
            else::
                break

            }
        }
    else::
        if {concat(?left @string:167:17, ?right @string:167:24, s @string:161:10)::

            pack(left @string:168:18, !raw @string:168:25, size @string:168:30, !offset @string:168:37)
            pack(right @string:169:18, !raw @string:169:26, size @string:169:31, !offset @string:169:38)
            incr(!offset @string:170:19)
        else::
            if {slice(?tmp#3 @string:171:15, ?tmp#4 @string:171:18, s @string:161:10)::

                foreign llvm move(s @string:172:23, ?tmp#5)
                do {
                    if {[|](?c @string:172:18, ?tmp#5, tmp#5)::

                        true(?tmp#6 @string:173:56)
                        foreign lpvm mutate(raw @string:173:37, ?raw @string:173:43, offset @string:173:48, tmp#6, size @string:173:62, 0 @string:173:68, c @string:173:71)
                        incr(!offset @string:174:23)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:176:20, s @string:161:10)::

                    true(?tmp#7 @string:177:52)
                    foreign lpvm mutate(raw @string:177:33, ?raw @string:177:39, offset @string:177:44, tmp#7, size @string:177:58, 0 @string:177:64, c @string:177:67)
                    incr(!offset @string:178:19)
                else::
                    fail

                }

            }

        }

    }


print > public (0 calls)
0: print(x:_ @string:142:15) use !io:
    if {buffer(?tmp#0 @string:144:16, ?str @string:144:20, x @string:143:10)::

        !print(str @string:144:35)
    else::
        if {concat(?left @string:145:17, ?right @string:145:24, x @string:143:10)::

            !print(left @string:145:41)
            !print(right @string:145:55)
        else::
            if {slice(?tmp#1 @string:146:15, ?tmp#2 @string:146:18, x @string:143:10)::

                foreign llvm move(x @string:146:34, ?tmp#3)
                do {
                    if {[|](?c @string:146:29, ?tmp#3, tmp#3)::

                        !print(c @string:146:45)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:147:20, x @string:143:10)::

                    !print(c @string:147:33)
                else::
                    fail

                }

            }

        }

    }


println > public (0 calls)
0: println(x:_ @string:151:17) use !io:
    !print(x @string:151:39)
    !nl


read > public (0 calls)
0: read(?x:_ @string:153:15) use !io:
    !read(?str:c_string @string:153:37)
    string(str @string:153:64, ?tmp#0 @string:153:57)
    =(?x @string:153:53, tmp#0)


string > public (0 calls)
0: string(str:c_string @string:28:16, ?#result:_ @string:28:5):
    length(str @string:29:19, ?tmp#0 @string:29:12)
    =(?len @string:29:6, tmp#0)
    if {=(len @string:30:15, 0 @string:30:21)::

        empty(?tmp#2 @string:30:26)
        foreign llvm move(tmp#2, ?tmp#1)
    else::
        if {=(len @string:31:15, 1 @string:31:21)::

            foreign lpvm access(str @string:31:56, 0 @string:31:61, 1 @string:31:64, 0 @string:31:67, ?tmp#5 @string:31:36)
            singleton(tmp#5, ?tmp#4 @string:31:26)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            buffer(len @string:32:33, str @string:32:38, ?tmp#6 @string:32:26)
            foreign llvm move(tmp#6, ?tmp#3)

        }
        foreign llvm move(tmp#3 @string:31:15, ?tmp#1)

    }
    =(?s @string:30:6, tmp#1 @string:30:15)
    foreign llvm move(s @string:28:34, ?#result @string:28:5)
string > public (0 calls)
1: string(c:char @string:37:16, ?#result:_ @string:37:5):
    singleton(c @string:37:38, ?tmp#0 @string:37:28)
    foreign llvm move(tmp#0, ?#result @string:37:5)


~= > public (0 calls)
0: ~=(x:_ @string:116:10, y:_ @string:116:18, ?#result:bool @string:116:5):
    <=>(x @string:116:31, y @string:116:39, ?tmp#1 @string:116:31)
    equal(?tmp#2 @string:116:46)
    ~=(tmp#1, tmp#2, ?tmp#0 @string:116:30)
    foreign llvm move(tmp#0, ?#result @string:116:5)

LLVM code       : None

Types: **** Validating parameter types in module wybe.memory_management
Types: Validating def of 
Types: Validating def of malloc_count
Types: Checking type int of param ?x:int
Types: Param is ?x:wybe.int
Types: **** Re-exiting module wybe.memory_management
Types: **** Type checking modules wybe.memory_management
Types: **** Strongly connected components:
Types:     wybe.memory_management.malloc_count
Types:     wybe.memory_management.
Types: Type checking non-recursive proc wybe.memory_management.malloc_count
Types: ** Type checking decl of proc malloc_count
Types: found 1 definition(s)
Types: Type checking malloc_count
Types: ** Type checking malloc_count: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c {impure} malloc_count(?x @memory_management:12:38)
Types:    and defaults: 
Types:    with assigned vars: fromList ["x"]
Types: Recording parameter types: ?x:wybe.int
Types:     type of 'x' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable x type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign c {impure} malloc_count(?x @memory_management:12:38)}
Types: *** Before calls Typing {x::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   Typing {x::wybe.int}; {} (with no errors)
Types: Finding type of expr ?x @memory_management:12:38
Types:   Type = wybe.int
Types: Type checking foreign c call malloc_count impure(64 bit signed)
Types: Now mode checking proc malloc_count
Types: bound vars: impure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check stmt foreign c {impure} malloc_count(?x @memory_management:12:38)
Types: Mode checking foreign call {foreign c {impure} malloc_count(?x @memory_management:12:38)}
Types:     with assigned impure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check exp ?x
Types: Mode check exp resulted in ?x
Types: Finding type of expr ?x @memory_management:12:38
Types:   Type = wybe.int
Types:     types and modes = [?wybe.int]
Types: New instr = {foreign c {impure} malloc_count(?x:wybe.int @memory_management:12:38)}
Types: Now assigned = impure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'malloc_count'
Types: Mode checked body   : [{foreign c {impure} malloc_count(?x:wybe.int @memory_management:12:38)} @memory_management:12:5]
Types: Vars defined by body: impure normal (total) computation binding {x}, break set = Everything, with resources {}
Types: Output parameters   : x
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of malloc_count:
Types: 
Types: malloc_count > public {semipure} (0 calls)
Types: 4: malloc_count(?x:wybe.int @memory_management:11:34):
Types:     foreign c {impure} malloc_count(?x:wybe.int @memory_management:12:38)
Types: Type checking non-recursive proc wybe.memory_management.
Types: ** Type checking decl of proc 
Types: found 1 definition(s)
Types: Type checking module top-level code
Types: ** Type checking module top-level code: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign c {impure} gc_init
Types:    and defaults: 
Types:    with assigned vars: fromList []
Types: Recording parameter types: 
Types: Recording resource types: 
Types: Recording casts in {foreign c {impure} gc_init}
Types: *** Before calls Typing {}; {} (with no errors)
Types:   With calls:
Types:   Typing {}; {} (with no errors)
Types: Type checking foreign c call gc_init impure()
Types: Now mode checking proc 
Types: bound vars: impure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check stmt foreign c {impure} gc_init
Types: Mode checking foreign call {foreign c {impure} gc_init}
Types:     with assigned impure normal (total) computation binding {}, break set = Everything, with resources {}
Types:     types and modes = []
Types: New instr = {foreign c {impure} gc_init}
Types: Now assigned = impure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check end of Det proc ''
Types: Mode checked body   : [{foreign c {impure} gc_init} @memory_management:15:1]
Types: Vars defined by body: impure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Output parameters   : 
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of :
Types: 
Types: module top-level code > public {semipure} (0 calls)
Types: 4: ():
Types:     foreign c {impure} gc_init
======================================================================
AFTER TYPE CHECK:
 Module wybe
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : 
  imports         : public use wybe.array
                    public use wybe.bool
                    public use wybe.c_string
                    public use wybe.char
                    public use wybe.comparison
                    public use wybe.control
                    public use wybe.count
                    public use wybe.float
                    public use wybe.int
                    public use wybe.io
                    public use wybe.list
                    public use wybe.machine_word
                    public use wybe.memory_management
                    public use wybe.phantom
                    public use wybe.predicate
                    public use wybe.range
                    public use wybe.string
  resources       : 
  submodules      : wybe.array, wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.control, wybe.count, wybe.float, wybe.int, wybe.io, wybe.list, wybe.machine_word, wybe.memory_management, wybe.phantom, wybe.predicate, wybe.range, wybe.string
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.array(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.array.[]<0>
                    wybe.array.[]<1>
                    wybe.array.[|]<0>
                    wybe.array.array<0>
                    wybe.array.array<1>
                    wybe.array.inbounds<0>
                    wybe.array.unsafe_get<0>
                    wybe.array.unsafe_update<0>
  imports         : public use wybe.array.raw_array
                    use wybe.bool
                    use wybe.int
                    use wybe.list
                    use wybe.machine_word
  resources       : 
  submodules      : wybe.array.raw_array
  procs           : 

[] > public {test} (0 calls)
0: [](a:_(T) @array:67:21, idx:int @array:67:29, ?#result:T @array:67:5):
    inbounds(a @array:68:14, idx @array:68:17)
    unsafe_get(a @array:69:10, idx @array:69:23, ?tmp#0 @array:69:10)
    =(?x @array:69:6, tmp#0)
    foreign llvm move(x @array:67:42, ?#result @array:67:5)
[] > public {test} (0 calls)
1: [](!a:_(T) @array:81:22, idx:int @array:81:30, x:T @array:81:39):
    inbounds(a @array:82:14, idx @array:82:17)
    unsafe_update(!a @array:83:20, idx @array:83:23, x @array:83:28)


[|] > public {test} (0 calls)
0: [|](?head:T @array:51:23, ?tail:_(T) @array:51:32, a:_(T) @array:51:43):
    array(?length @array:52:12, ?data @array:52:21, a @array:52:29)
    >(length @array:53:6, 0 @array:53:15)
    word_size_bytes(?tmp#0 @array:54:34)
    foreign lpvm access(data @array:54:25, 0 @array:54:31, tmp#0, 0 @array:54:51, ?head @array:54:55)
    word_size_bytes(?tmp#1 @array:55:28)
    foreign llvm add(data @array:55:22, tmp#1, ?data @array:55:46)
    -(length @array:56:19, 1 @array:56:28, ?tmp#3 @array:56:19)
    array(tmp#3, data @array:56:31, ?tmp#2 @array:56:13)
    =(?tail @array:56:6, tmp#2)


array > public (0 calls)
0: array(x:T @array:18:15, len:int @array:18:20, ?#result:_(T) @array:18:5):
    word_size_bytes(?tmp#1 @array:19:19)
    *(len @array:19:13, tmp#1, ?tmp#0 @array:19:13)
    =(?size @array:19:6, tmp#0)
    foreign lpvm alloc(size @array:20:24, ?data @array:20:31)
    =(?offset @array:21:6, 0 @array:21:15)
    do {
        if {<(offset @array:23:15, size @array:23:24)::

            pass
        else::
            break

        }
        foreign lpvm mutate(data @array:24:29, ?data @array:24:36, offset @array:24:42, 1 @array:24:50, size @array:24:53, 0 @array:24:59, x @array:24:62)
        word_size_bytes(?tmp#2 @array:25:21)
        +=(!offset @array:25:10, tmp#2)
    }
    array(len @array:27:17, data @array:27:22, ?tmp#3 @array:27:11)
    =(?ar @array:27:6, tmp#3)
    foreign llvm move(ar @array:18:36, ?#result @array:18:5)
array > public (0 calls)
1: array(ls:list(T) @array:34:15, ?#result:_(T) @array:34:5):
    length(ls @array:35:19, ?tmp#0 @array:35:12)
    =(?len @array:35:6, tmp#0)
    word_size_bytes(?tmp#2 @array:36:19)
    *(len @array:36:13, tmp#2, ?tmp#1 @array:36:13)
    =(?size @array:36:6, tmp#1)
    foreign lpvm alloc(size @array:37:24, ?data @array:37:31)
    =(?offset @array:38:6, 0 @array:38:15)
    foreign llvm move(ls @array:39:15, ?tmp#3)
    do {
        if {[|](?x @array:39:10, ?tmp#3, tmp#3)::

            foreign lpvm mutate(data @array:40:29, ?data @array:40:36, offset @array:40:42, 1 @array:40:50, size @array:40:53, 0 @array:40:59, x @array:40:62)
            word_size_bytes(?tmp#4 @array:41:21)
            +=(!offset @array:41:10, tmp#4)
        else::
            break

        }
    }
    array(len @array:43:17, data @array:43:22, ?tmp#5 @array:43:11)
    =(?ar @array:43:6, tmp#5)
    foreign llvm move(ar @array:34:34, ?#result @array:34:5)


inbounds > public {test,inline} (0 calls)
0: inbounds(a:_(T) @array:60:33, idx:int @array:60:41):
    <=(0 @array:61:6, idx @array:61:12)
    length(a @array:62:12, ?tmp#0 @array:62:12)
    <(idx @array:62:6, tmp#0)


unsafe_get > public {inline} (0 calls)
0: unsafe_get(a:_(T) @array:75:29, idx:int @array:75:37, ?#result:T @array:75:5):
    raw_data(a @array:76:25, ?tmp#0 @array:76:25)
    word_size_bytes(?tmp#2 @array:76:43)
    *(idx @array:76:37, tmp#2, ?tmp#1 @array:76:37)
    word_size_bytes(?tmp#3 @array:76:60)
    foreign lpvm access(tmp#0, tmp#1, tmp#3, 0 @array:76:77, ?x @array:76:81)
    foreign llvm move(x @array:75:50, ?#result @array:75:5)


unsafe_update > public {inline} (0 calls)
0: unsafe_update(!a:_(T) @array:89:33, idx:int @array:89:41, x:T @array:89:50):
    raw_data(a @array:90:25, ?tmp#0 @array:90:25)
    word_size_bytes(?tmp#2 @array:90:50)
    *(idx @array:90:44, tmp#2, ?tmp#1 @array:90:44)
    length(a @array:91:44, ?tmp#4 @array:91:44)
    word_size_bytes(?tmp#5 @array:91:55)
    *(tmp#4, tmp#5, ?tmp#3 @array:91:44)
    foreign lpvm mutate(tmp#0, ?data @array:90:38, tmp#1, 0 @array:90:67, tmp#3, 0 @array:91:72, x @array:91:75)
    raw_data(!a @array:92:6, data @array:92:19)

LLVM code       : None

--------------------------------------------------
 Module wybe.array.raw_array(T)
  representation  : address
  public submods  : 
  public resources: 
  public procs    : 
  imports         : use wybe
                    use wybe.array
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.bool
  representation  : 1 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.bool.&&<0>
                    wybe.bool.&=<0>
                    wybe.bool.=<0>
                    wybe.bool.^=<0>
                    wybe.bool.^^<0>
                    wybe.bool.false<0>
                    wybe.bool.print<0>
                    wybe.bool.println<0>
                    wybe.bool.succeed<0>
                    wybe.bool.true<0>
                    wybe.bool.|=<0>
                    wybe.bool.||<0>
                    wybe.bool.~<0>
                    wybe.bool.~=<0>
  imports         : use wybe.c_string
                    use wybe.io
  resources       : 
  procs           : 

&& > public {inline} (1 calls)
0: wybe.bool.&&<0>
&&(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:13:27


&= > public {inline} (0 calls)
0: wybe.bool.&=<0>
&=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:13:27


= > public {inline} (0 calls)
0: wybe.bool.=<0>
=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:37:26


^= > public {inline} (0 calls)
0: wybe.bool.^=<0>
^=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:25:27


^^ > public {inline} (1 calls)
0: wybe.bool.^^<0>
^^(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:25:27


false > public {inline} (0 calls)
0: wybe.bool.false<0>
false(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.bool, ?#result##0:wybe.bool)


print > public (1 calls)
0: wybe.bool.print<0>
print(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    case ~x##0:wybe.bool of
    0:
        wybe.c_string.print<0>(c"false":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #1 @bool:47:31

    1:
        wybe.c_string.print<0>(c"true":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:47:31



println > public {inline} (0 calls)
0: wybe.bool.println<0>
println(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.bool.print<0>(~x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:49:33
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#0##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~tmp#0##0:wybe.phantom, ?tmp#1##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#1##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


succeed > public {inline} (0 calls)
0: wybe.bool.succeed<0>
succeed()<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []


true > public {inline} (1 calls)
0: wybe.bool.true<0>
true(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.bool, ?#result##0:wybe.bool)


|= > public {inline} (0 calls)
0: wybe.bool.|=<0>
|=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:19:27


|| > public {inline} (1 calls)
0: wybe.bool.||<0>
||(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:19:27


~ > public {inline} (0 calls)
0: wybe.bool.~<0>
~(p##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, 1:wybe.bool, ?#result##0:wybe.bool) @bool:31:20


~= > public {inline} (0 calls)
0: wybe.bool.~=<0>
~=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:38:27

LLVM code       : None

--------------------------------------------------
 Module wybe.c_string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.c_string.<<0>
                    wybe.c_string.<=<0>
                    wybe.c_string.=<0>
                    wybe.c_string.><0>
                    wybe.c_string.>=<0>
                    wybe.c_string.[]<0>
                    wybe.c_string.[|]<0>
                    wybe.c_string.length<0>
                    wybe.c_string.print<0>
                    wybe.c_string.println<0>
                    wybe.c_string.read<0>
                    wybe.c_string.unsafe_c_string_index<0>
                    wybe.c_string.~=<0>
  imports         : use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.c_string.<<0>
<(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:12:29
    wybe.int.<<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:12:29


<= > public {inline} (0 calls)
0: wybe.c_string.<=<0>
<=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:13:30
    wybe.int.<=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:13:30


= > public {inline} (0 calls)
0: wybe.c_string.=<0>
=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:10:29
    wybe.int.=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:10:29


> > public {inline} (0 calls)
0: wybe.c_string.><0>
>(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:14:29
    wybe.int.><0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:14:29


>= > public {inline} (0 calls)
0: wybe.c_string.>=<0>
>=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:15:30
    wybe.int.>=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:15:30


[] > public (0 calls)
0: wybe.c_string.[]<0>
[](str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, idx##0:wybe.int, ?tmp#2##0:wybe.bool) #0 @c_string:27:6
    case ~tmp#2##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        foreign c strlen(str##0:wybe.c_string, ?tmp#0##0:wybe.int) @c_string:17:29
        wybe.int.<<0>(idx##0:wybe.int, ~tmp#0##0:wybe.int, ?tmp#3##0:wybe.bool) #2 @c_string:28:6
        case ~tmp#3##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




[|] > public (0 calls)
0: wybe.c_string.[|]<0>
[|](?head##0:wybe.char, ?tail##0:wybe.c_string, str##0:wybe.c_string, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(str##0:wybe.c_string, 0:wybe.int, 0:wybe.int, 0:wybe.int, ?head##0:wybe.char) @c_string:20:5
    foreign llvm icmp_ne(head##0:wybe.char, '\NUL':wybe.char, ?not_done##0:wybe.bool) @c_string:21:5
    foreign llvm icmp_eq(~not_done##0:wybe.bool, 1:wybe.bool, ?tmp#1##0:wybe.bool) @bool:37:26
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.c_string, ?tail##0:wybe.c_string)

    1:
        foreign llvm add(~str##0:wybe.c_string, 1:wybe.int, ?tail##0:wybe.c_string) @c_string:23:5
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



length > public {inline} (3 calls)
0: wybe.c_string.length<0>
length(str##0:wybe.c_string, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strlen(~str##0:wybe.c_string, ?#result##0:wybe.int) @c_string:17:29


print > public {inline} (1 calls)
0: wybe.c_string.print<0>
print(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:35:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:35:30


println > public {inline} (0 calls)
0: wybe.c_string.println<0>
println(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @c_string:35:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.c_string.read<0>
read(?x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:39:30
    foreign c read_line(?x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:39:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:39:30


unsafe_c_string_index > public {inline} (1 calls)
0: wybe.c_string.unsafe_c_string_index<0>
unsafe_c_string_index(str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7


~= > public {inline} (0 calls)
0: wybe.c_string.~=<0>
~=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:11:30
    wybe.int.~=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.char
  representation  : 8 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.char.<<0>
                    wybe.char.<=<0>
                    wybe.char.<=><0>
                    wybe.char.=<0>
                    wybe.char.><0>
                    wybe.char.>=<0>
                    wybe.char.chr<0>
                    wybe.char.ord<0>
                    wybe.char.print<0>
                    wybe.char.println<0>
                    wybe.char.read<0>
                    wybe.char.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (4 calls)
0: wybe.char.<<0>
<(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:17:29


<= > public {inline} (0 calls)
0: wybe.char.<=<0>
<=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:18:30


<=> > public (0 calls)
0: wybe.char.<=><0>
<=>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.char, y##0:wybe.char, ?tmp#6##0:wybe.bool) @char:17:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?tmp#5##0:wybe.bool) @char:13:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5



= > public {inline} (2 calls)
0: wybe.char.=<0>
=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:13:29


> > public {inline} (0 calls)
0: wybe.char.><0>
>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:19:29


>= > public {inline} (0 calls)
0: wybe.char.>=<0>
>=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:20:30


chr > public (0 calls)
0: wybe.char.chr<0>
chr(i##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, i##0:wybe.int, ?tmp#1##0:wybe.bool) #0 @char:33:60
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        wybe.int.<=<0>(i##0:wybe.int, 255:wybe.int, ?tmp#2##0:wybe.bool) #1 @char:33:70
        case ~tmp#2##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm cast(~i##0:wybe.int, ?#result##0:wybe.char) @char:33:31
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




ord > public {inline} (0 calls)
0: wybe.char.ord<0>
ord(c##0:wybe.char, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(~c##0:wybe.char, ?#result##0:wybe.int) @char:30:24


print > public {inline} (1 calls)
0: wybe.char.print<0>
print(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:37:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:37:30


println > public {inline} (0 calls)
0: wybe.char.println<0>
println(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @char:37:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.char.read<0>
read(?x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:41:30
    foreign c read_char(?x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:41:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:41:30


~= > public {inline} (0 calls)
0: wybe.char.~=<0>
~=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:14:30

LLVM code       : None

--------------------------------------------------
 Module wybe.comparison
  representation  : 2 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.comparison.<<0>
                    wybe.comparison.<=<0>
                    wybe.comparison.=<0>
                    wybe.comparison.><0>
                    wybe.comparison.>=<0>
                    wybe.comparison.equal<0>
                    wybe.comparison.greater<0>
                    wybe.comparison.lesser<0>
                    wybe.comparison.~=<0>
  imports         : use wybe.bool
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.comparison.<<0>
<(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:12:29


<= > public {inline} (0 calls)
0: wybe.comparison.<=<0>
<=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:13:30


= > public {inline} (0 calls)
0: wybe.comparison.=<0>
=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:10:29


> > public {inline} (0 calls)
0: wybe.comparison.><0>
>(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:14:29


>= > public {inline} (0 calls)
0: wybe.comparison.>=<0>
>=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:15:30


equal > public {inline} (0 calls)
0: wybe.comparison.equal<0>
equal(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison)


greater > public {inline} (0 calls)
0: wybe.comparison.greater<0>
greater(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison)


lesser > public {inline} (0 calls)
0: wybe.comparison.lesser<0>
lesser(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison)


~= > public {inline} (0 calls)
0: wybe.comparison.~=<0>
~=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.control
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.control.assert<0>
                    wybe.control.error<0>
                    wybe.control.error<1>
                    wybe.control.exit<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.int
                    use wybe.string
  resources       : 
  procs           : 

assert > public {semipure} (0 calls)
0: assert(condition:bool @control:26:27) use call_source_location:
    if {~(condition @control:27:11)::

        !error(c"assertion failed" @control:27:31)
    else::
        pass

    }


error > public {terminal,semipure} (0 calls)
0: error(message:string @control:17:35) use call_source_location:
    c_string(message @control:18:77, ?tmp#0 @control:18:68)
    foreign c {terminal,semipure} error_exit(call_source_location @control:18:46, tmp#0)
error > public {terminal,semipure} (0 calls)
1: error(message:c_string @control:21:35) use call_source_location:
    foreign c {terminal,semipure} error_exit(call_source_location @control:22:46, message @control:22:68)


exit > public {terminal,semipure} (0 calls)
0: exit(code:int @control:10:34):
    foreign c {terminal,semipure} exit(code @control:11:40)

LLVM code       : None

--------------------------------------------------
 Module wybe.count
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.count.%<0>
                    wybe.count.%=<0>
                    wybe.count.*<0>
                    wybe.count.*=<0>
                    wybe.count.+<0>
                    wybe.count.+<1>
                    wybe.count.+<2>
                    wybe.count.+=<0>
                    wybe.count.-<0>
                    wybe.count.-<1>
                    wybe.count.-<2>
                    wybe.count.-=<0>
                    wybe.count./<0>
                    wybe.count./=<0>
                    wybe.count.<<0>
                    wybe.count.<=<0>
                    wybe.count.<=><0>
                    wybe.count.=<0>
                    wybe.count.><0>
                    wybe.count.>=<0>
                    wybe.count.decr<0>
                    wybe.count.incr<0>
                    wybe.count.max<0>
                    wybe.count.min<0>
                    wybe.count.print<0>
                    wybe.count.println<0>
                    wybe.count.read<0>
                    wybe.count.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.count.%<0>
%(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:51:25


%= > public {inline} (0 calls)
0: wybe.count.%=<0>
%=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:51:25


* > public {inline} (1 calls)
0: wybe.count.*<0>
*(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:39:25


*= > public {inline} (0 calls)
0: wybe.count.*=<0>
*=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:39:25


+ > public {inline} (2 calls)
0: wybe.count.+<0>
+(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:15:25
+ > public (0 calls)
1: wybe.count.+<1>
+(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(y##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?x##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~y##0:wybe.count, ?x##0:wybe.count) @count:18:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

+ > public (0 calls)
2: wybe.count.+<2>
+(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?y##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:22:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



+= > public {inline} (0 calls)
0: wybe.count.+=<0>
+=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:15:25


- > public (6 calls)
0: wybe.count.-<0>
-(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?#result##0:wybe.count)

    1:
        foreign llvm sub(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:31:35
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

- > public {inline} (0 calls)
1: wybe.count.-<1>
-(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.count, ~z##0:wybe.count, ?x##0:wybe.count) @count:32:42
- > public {inline} (0 calls)
2: wybe.count.-<2>
-(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:33:42


-= > public (0 calls)
0: wybe.count.-=<0>
-=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, ~y##0:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:36:41
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:36:37
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



/ > public {inline} (1 calls)
0: wybe.count./<0>
/(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:45:25


/= > public {inline} (0 calls)
0: wybe.count./=<0>
/=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:45:25


< > public {inline} (4 calls)
0: wybe.count.<<0>
<(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:64:29


<= > public {inline} (3 calls)
0: wybe.count.<=<0>
<=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:65:30


<=> > public (0 calls)
0: wybe.count.<=><0>
<=>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.count, y##0:wybe.count, ?tmp#6##0:wybe.bool) @count:64:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?tmp#5##0:wybe.bool) @count:60:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5



= > public {inline} (2 calls)
0: wybe.count.=<0>
=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:60:29


> > public {inline} (0 calls)
0: wybe.count.><0>
>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:66:29


>= > public {inline} (12 calls)
0: wybe.count.>=<0>
>=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:67:30


decr > public (0 calls)
0: wybe.count.decr<0>
decr(x##0:wybe.count, ?x##1:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, 1:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:84:37
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:84:33
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



incr > public {inline} (0 calls)
0: wybe.count.incr<0>
incr(x##0:wybe.count, ?x##1:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, 1:wybe.count, ?x##1:wybe.count) @count:15:25


max > public (0 calls)
0: wybe.count.max<0>
max(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:75:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:75:5



min > public (0 calls)
0: wybe.count.min<0>
min(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:65:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:74:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:74:5



print > public {inline} (1 calls)
0: wybe.count.print<0>
print(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:88:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:88:30


println > public {inline} (0 calls)
0: wybe.count.println<0>
println(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @count:88:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.count.read<0>
read(?x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:92:30
    foreign c read_count(?x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:92:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:92:30


~= > public {inline} (0 calls)
0: wybe.count.~=<0>
~=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:61:30

LLVM code       : None

--------------------------------------------------
 Module wybe.float
  representation  : 64 bit float
  public submods  : 
  public resources: 
  public procs    : wybe.float.*<0>
                    wybe.float.**<0>
                    wybe.float.*=<0>
                    wybe.float.+<0>
                    wybe.float.+<1>
                    wybe.float.+<2>
                    wybe.float.+=<0>
                    wybe.float.-<0>
                    wybe.float.-<1>
                    wybe.float.-<2>
                    wybe.float.-<3>
                    wybe.float.-<4>
                    wybe.float.-=<0>
                    wybe.float./<0>
                    wybe.float./=<0>
                    wybe.float.<<0>
                    wybe.float.<=<0>
                    wybe.float.<=><0>
                    wybe.float.=<0>
                    wybe.float.><0>
                    wybe.float.>=<0>
                    wybe.float.abs<0>
                    wybe.float.ceil<0>
                    wybe.float.cos<0>
                    wybe.float.e<0>
                    wybe.float.exp<0>
                    wybe.float.floor<0>
                    wybe.float.iceil<0>
                    wybe.float.ifloor<0>
                    wybe.float.iround<0>
                    wybe.float.log<0>
                    wybe.float.log10<0>
                    wybe.float.log2<0>
                    wybe.float.max<0>
                    wybe.float.min<0>
                    wybe.float.pi<0>
                    wybe.float.power<0>
                    wybe.float.print<0>
                    wybe.float.println<0>
                    wybe.float.read<0>
                    wybe.float.round<0>
                    wybe.float.sin<0>
                    wybe.float.sqrt<0>
                    wybe.float.square<0>
                    wybe.float.tan<0>
                    wybe.float.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

* > public {inline} (1 calls)
0: wybe.float.*<0>
*(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:45:25


** > public {inline} (0 calls)
0: wybe.float.**<0>
**(x##0:wybe.float, n##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.pow.f64(~x##0:wybe.float, ~n##0:wybe.float, ?#result##0:wybe.float) @float:112:27


*= > public {inline} (0 calls)
0: wybe.float.*=<0>
*=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:45:25


+ > public {inline} (1 calls)
0: wybe.float.+<0>
+(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:23:27
+ > public {inline} (0 calls)
1: wybe.float.+<1>
+(?x##0:wybe.float, y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:24:43
+ > public {inline} (0 calls)
2: wybe.float.+<2>
+(x##0:wybe.float, ?y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~x##0:wybe.float, ?y##0:wybe.float) @float:25:43


+= > public {inline} (0 calls)
0: wybe.float.+=<0>
+=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:23:27


- > public {inline} (1 calls)
0: wybe.float.-<0>
-(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:32:27
- > public {inline} (0 calls)
1: wybe.float.-<1>
-(?x##0:wybe.float, y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~z##0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:33:43
- > public {inline} (0 calls)
2: wybe.float.-<2>
-(x##0:wybe.float, ?y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~x##0:wybe.float, ?y##0:wybe.float) @float:34:43
- > public {inline} (0 calls)
3: wybe.float.-<3>
-(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(0.0:wybe.float, ~x##0:wybe.float, ?#result##0:wybe.float) @float:38:21
- > public {inline} (0 calls)
4: wybe.float.-<4>
-(?x##0:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(0.0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:39:37


-= > public {inline} (0 calls)
0: wybe.float.-=<0>
-=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:32:27


/ > public {inline} (2 calls)
0: wybe.float./<0>
/(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fdiv(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:51:25


/= > public {inline} (0 calls)
0: wybe.float./=<0>
/=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fdiv(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:51:25


< > public {inline} (4 calls)
0: wybe.float.<<0>
<(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_slt(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:70:29


<= > public {inline} (0 calls)
0: wybe.float.<=<0>
<=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sle(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:71:30


<=> > public (0 calls)
0: wybe.float.<=><0>
<=>(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_slt(x##0:wybe.float, y##0:wybe.float, ?tmp#6##0:wybe.bool) @float:70:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm fcmp_eq(~x##0:wybe.float, ~y##0:wybe.float, ?tmp#5##0:wybe.bool) @float:66:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5



= > public {inline} (2 calls)
0: wybe.float.=<0>
=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_eq(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:66:29


> > public {inline} (0 calls)
0: wybe.float.><0>
>(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sgt(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:72:29


>= > public {inline} (0 calls)
0: wybe.float.>=<0>
>=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sge(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:73:30


abs > public {inline} (0 calls)
0: wybe.float.abs<0>
abs(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.fabs.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:60:22


ceil > public {inline} (1 calls)
0: wybe.float.ceil<0>
ceil(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.ceil.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:87:23


cos > public {inline} (0 calls)
0: wybe.float.cos<0>
cos(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.cos.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:116:22


e > public {inline} (0 calls)
0: wybe.float.e<0>
e(?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2.7182818284590455:wybe.float, ?#result##0:wybe.float) @float:16:5


exp > public {inline} (0 calls)
0: wybe.float.exp<0>
exp(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.exp.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:120:22


floor > public {inline} (1 calls)
0: wybe.float.floor<0>
floor(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.floor.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:90:24


iceil > public {inline} (0 calls)
0: wybe.float.iceil<0>
iceil(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.ceil.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:87:23
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:99:26


ifloor > public {inline} (0 calls)
0: wybe.float.ifloor<0>
ifloor(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.floor.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:90:24
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:102:27


iround > public {inline} (0 calls)
0: wybe.float.iround<0>
iround(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.round.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:93:24
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:96:27


log > public {inline} (0 calls)
0: wybe.float.log<0>
log(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:123:22


log10 > public {inline} (0 calls)
0: wybe.float.log10<0>
log10(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log10.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:126:24


log2 > public {inline} (0 calls)
0: wybe.float.log2<0>
log2(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log2.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:129:23


max > public {inline} (0 calls)
0: wybe.float.max<0>
max(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.maxnum.f64(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:81:27


min > public {inline} (0 calls)
0: wybe.float.min<0>
min(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.minnum.f64(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:80:27


pi > public {inline} (0 calls)
0: wybe.float.pi<0>
pi(?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(3.141592653589793:wybe.float, ?#result##0:wybe.float) @float:13:5


power > public {inline} (0 calls)
0: wybe.float.power<0>
power(x##0:wybe.float, n##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.pow.f64(~x##0:wybe.float, ~n##0:wybe.float, ?#result##0:wybe.float) @float:111:28


print > public {inline} (1 calls)
0: wybe.float.print<0>
print(x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @float:133:30
    foreign c print_float(~x##0:wybe.float, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @float:133:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @float:133:30


println > public {inline} (0 calls)
0: wybe.float.println<0>
println(x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @float:133:30
    foreign c print_float(~x##0:wybe.float, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @float:133:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.float.read<0>
read(?x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @float:137:30
    foreign c read_float(?x##0:wybe.float, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @float:137:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @float:137:30


round > public {inline} (1 calls)
0: wybe.float.round<0>
round(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.round.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:93:24


sin > public {inline} (0 calls)
0: wybe.float.sin<0>
sin(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sin.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:115:22


sqrt > public {inline} (0 calls)
0: wybe.float.sqrt<0>
sqrt(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sqrt.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:108:23


square > public {inline} (0 calls)
0: wybe.float.square<0>
square(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~x##0:wybe.float, ?#result##0:wybe.float) @float:57:25


tan > public {inline} (0 calls)
0: wybe.float.tan<0>
tan(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sin.f64(x##0:wybe.float, ?tmp#1##0:wybe.float) @float:117:22
    foreign c llvm.cos.f64(~x##0:wybe.float, ?tmp#2##0:wybe.float) @float:117:52
    foreign llvm fdiv(~tmp#1##0:wybe.float, ~tmp#2##0:wybe.float, ?#result##0:wybe.float) @float:51:25


~= > public {inline} (0 calls)
0: wybe.float.~=<0>
~=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_ne(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:67:30

LLVM code       : None

--------------------------------------------------
 Module wybe.int
  representation  : 64 bit signed
  public submods  : 
  public resources: 
  public procs    : wybe.int.%<0>
                    wybe.int.%=<0>
                    wybe.int.*<0>
                    wybe.int.*=<0>
                    wybe.int.+<0>
                    wybe.int.+<1>
                    wybe.int.+<2>
                    wybe.int.+=<0>
                    wybe.int.-<0>
                    wybe.int.-<1>
                    wybe.int.-<2>
                    wybe.int.-<3>
                    wybe.int.-<4>
                    wybe.int.-=<0>
                    wybe.int./<0>
                    wybe.int./=<0>
                    wybe.int.<<0>
                    wybe.int.<<<0>
                    wybe.int.<<=<0>
                    wybe.int.<=<0>
                    wybe.int.<=><0>
                    wybe.int.=<0>
                    wybe.int.><0>
                    wybe.int.>=<0>
                    wybe.int.>><0>
                    wybe.int.>>=<0>
                    wybe.int.decr<0>
                    wybe.int.incr<0>
                    wybe.int.logical_bitshift<0>
                    wybe.int.logical_bitshift<1>
                    wybe.int.max<0>
                    wybe.int.min<0>
                    wybe.int.power<0>
                    wybe.int.print<0>
                    wybe.int.println<0>
                    wybe.int.read<0>
                    wybe.int.signum<0>
                    wybe.int.sqrt<0>
                    wybe.int.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.int.%<0>
%(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:50:25


%= > public {inline} (0 calls)
0: wybe.int.%=<0>
%=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:50:25


* > public {inline} (1 calls)
0: wybe.int.*<0>
*(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:38:25


*= > public {inline} (0 calls)
0: wybe.int.*=<0>
*=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:38:25


+ > public {inline} (2 calls)
0: wybe.int.+<0>
+(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:16:27
+ > public {inline} (0 calls)
1: wybe.int.+<1>
+(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:17:43
+ > public {inline} (0 calls)
2: wybe.int.+<2>
+(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:18:43


+= > public {inline} (0 calls)
0: wybe.int.+=<0>
+=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:16:27


- > public {inline} (2 calls)
0: wybe.int.-<0>
-(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:25:27
- > public {inline} (0 calls)
1: wybe.int.-<1>
-(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.int, ~z##0:wybe.int, ?x##0:wybe.int) @int:26:43
- > public {inline} (0 calls)
2: wybe.int.-<2>
-(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:27:43
- > public {inline} (0 calls)
3: wybe.int.-<3>
-(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~x##0:wybe.int, ?#result##0:wybe.int) @int:31:21
- > public {inline} (0 calls)
4: wybe.int.-<4>
-(?x##0:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:32:37


-= > public {inline} (0 calls)
0: wybe.int.-=<0>
-=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:25:27


/ > public {inline} (1 calls)
0: wybe.int./<0>
/(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:44:25


/= > public {inline} (0 calls)
0: wybe.int./=<0>
/=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:44:25


< > public {inline} (4 calls)
0: wybe.int.<<0>
<(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:87:29


<< > public {inline} (1 calls)
0: wybe.int.<<<0>
<<(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:56:27


<<= > public {inline} (0 calls)
0: wybe.int.<<=<0>
<<=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:56:27


<= > public {inline} (3 calls)
0: wybe.int.<=<0>
<=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:88:30


<=> > public (0 calls)
0: wybe.int.<=><0>
<=>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(x##0:wybe.int, y##0:wybe.int, ?tmp#6##0:wybe.bool) @int:87:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?tmp#5##0:wybe.bool) @int:83:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5



= > public {inline} (2 calls)
0: wybe.int.=<0>
=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:83:29


> > public {inline} (0 calls)
0: wybe.int.><0>
>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sgt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:89:29


>= > public {inline} (3 calls)
0: wybe.int.>=<0>
>=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:90:30


>> > public {inline} (1 calls)
0: wybe.int.>><0>
>>(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:65:27


>>= > public {inline} (0 calls)
0: wybe.int.>>=<0>
>>=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:65:27


decr > public {inline} (0 calls)
0: wybe.int.decr<0>
decr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:25:27


incr > public {inline} (0 calls)
0: wybe.int.incr<0>
incr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:16:27


logical_bitshift > public {inline} (1 calls)
0: wybe.int.logical_bitshift<0>
logical_bitshift(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:74:40
logical_bitshift > public {inline} (0 calls)
1: wybe.int.logical_bitshift<1>
logical_bitshift(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:74:40


max > public (0 calls)
0: wybe.int.max<0>
max(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:90:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:98:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:98:5



min > public (0 calls)
0: wybe.int.min<0>
min(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:88:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:97:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:97:5



power > public {inline} (0 calls)
0: wybe.int.power<0>
power(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c ipow(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:107:29


print > public {inline} (1 calls)
0: wybe.int.print<0>
print(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:119:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:119:30


println > public {inline} (0 calls)
0: wybe.int.println<0>
println(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @int:119:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.int.read<0>
read(?x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:123:30
    foreign c read_int(?x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:123:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:123:30


signum > public {inline} (0 calls)
0: wybe.int.signum<0>
signum(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c signum(~x##0:wybe.int, ?#result##0:wybe.int) @int:114:25


sqrt > public {inline} (0 calls)
0: wybe.int.sqrt<0>
sqrt(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c isqrt(~x##0:wybe.int, ?#result##0:wybe.int) @int:104:23


~= > public {inline} (0 calls)
0: wybe.int.~=<0>
~=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:84:30

LLVM code       : None

--------------------------------------------------
 Module wybe.io
  representation  : (not a type)
  public submods  : phantom -> wybe.phantom
  public resources: io: wybe.io.io
  public procs    : wybe.io.<0>
                    wybe.io.eof<0>
                    wybe.io.nl<0>
  imports         : use wybe.char
                    public use wybe.phantom
  resources       : io: fromList [(wybe.io.io,wybe.phantom = 0:phantom @io:13:27 @io:13:5)]
  procs           : 

module top-level code > public {inline,semipure} (0 calls)
0: wybe.io.<0>
()<{}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm store(0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:13:5


eof > public {inline} (0 calls)
0: wybe.io.eof<0>
eof(?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(-1:wybe.int, ?#result##0:wybe.char) @io:20:29


nl > public {inline} (0 calls)
0: wybe.io.nl<0>
nl()<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @io:17:31
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31

LLVM code       : None

--------------------------------------------------
 Module wybe.list(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.list.,,<0>
                    wybe.list.[]<0>
                    wybe.list.all<0>
                    wybe.list.any<0>
                    wybe.list.empty<0>
                    wybe.list.filter<0>
                    wybe.list.foldl<0>
                    wybe.list.foldr<0>
                    wybe.list.length<0>
                    wybe.list.list<0>
                    wybe.list.map<0>
                    wybe.list.map<1>
                    wybe.list.map<2>
                    wybe.list.print<0>
                    wybe.list.println<0>
                    wybe.list.reverse<0>
  imports         : use wybe.array
                    use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
                    use wybe.machine_word
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_(T) @list:20:10, y:_(T) @list:20:20, ?#result:_(T) @list:20:5):
    if {[|](?h @list:21:16, ?t @list:21:21, x @list:21:10)::

        ,,(t @list:21:32, y @list:21:37, ?tmp#2 @list:21:32)
        [|](h @list:21:28, tmp#2, ?tmp#1 @list:21:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(y @list:21:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:21:10, ?#result @list:20:5)


[] > public {test} (0 calls)
0: [](xs:_(T) @list:31:21, idx:int @list:31:30, ?#result:T @list:31:5):
    >=(idx @list:32:5, 0 @list:32:13)
    index1(xs @list:33:17, idx @list:33:21, ?tmp#0 @list:33:10)
    =(?x @list:33:6, tmp#0)
    foreign llvm move(x @list:31:43, ?#result @list:31:5)


all > public {test} (0 calls)
0: all(p:{test}(T) @list:61:20, xs:_(T) @list:61:33):
    foreign llvm move(xs @list:62:15, ?tmp#0)
    do {
        if {[|](?x @list:62:10, ?tmp#0, tmp#0)::

            p(x @list:63:11)
        else::
            break

        }
    }


any > public {test} (0 calls)
0: any(p:{test}(T) @list:69:20, xs:_(T) @list:69:33):
    [|](?x @list:70:7, ?xs @list:70:12, xs @list:70:18)
    (   p(x @list:71:8)
    | any(p @list:71:17, xs @list:71:20))


empty > public {test} (0 calls)
0: empty(xs:_(T) @list:15:22):
    if {[|](?tmp#0 @list:16:11, ?tmp#1 @list:16:15, xs @list:16:20)::

        fail
    else::
        pass

    }


filter > public (0 calls)
0: filter(p:{test}(T) @list:95:16, !xs:_(T) @list:95:30):
    [](?tmp#0 @list:96:12)
    =(?out @list:96:6, tmp#0)
    foreign llvm move(xs @list:97:15, ?tmp#1)
    do {
        if {[|](?x @list:97:10, ?tmp#1, tmp#1)::

            if {p(x @list:98:16)::

                [|](x @list:98:30, out @list:98:34, ?tmp#2 @list:98:29)
                =(?out @list:98:23, tmp#2)
            else::
                pass

            }
        else::
            break

        }
    }
    reverse(out @list:100:19, ?tmp#3 @list:100:11)
    =(?as @list:100:6, tmp#3)


foldl > public (0 calls)
0: foldl(f:(A, !B) @list:77:15, as:_(A) @list:77:26, !b:B @list:77:36):
    foreign llvm move(as @list:78:15, ?tmp#0)
    do {
        if {[|](?a @list:78:10, ?tmp#0, tmp#0)::

            f(a @list:79:11, !b @list:79:15)
        else::
            break

        }
    }


foldr > public (0 calls)
0: foldr(f:(A, !B) @list:86:15, as:_(A) @list:86:26, !b:B @list:86:36):
    if {[|](?a @list:87:12, ?as @list:87:17, as @list:87:23)::

        foldr(f @list:88:15, as @list:88:18, !b @list:88:23)
        f(a @list:89:11, !b @list:89:15)
    else::
        pass

    }


index1 > {test} (0 calls)
0: index1(xs:_(T) @list:148:19, idx:int @list:148:28, ?#result:T @list:148:1):
    [|](?x @list:149:7, ?xs @list:149:12, xs @list:149:18)
    (   =(idx @list:150:6, 0 @list:150:12)
    | (   -(idx @list:150:27, 1 @list:150:33, ?tmp#0 @list:150:27)
        & index1(xs @list:150:23, tmp#0, ?x @list:150:37)))
    foreign llvm move(x @list:148:41, ?#result @list:148:1)


length > public (0 calls)
0: length(x:_(T) @list:24:16, ?#result:int @list:24:5):
    length1(x @list:24:38, 0 @list:24:41, ?tmp#0 @list:24:30)
    foreign llvm move(tmp#0, ?#result @list:24:5)


length1 > (0 calls)
0: length1(x:_(T) @list:140:13, acc:int @list:140:21, ?#result:int @list:140:1):
    if {[|](?h @list:141:16, ?t @list:141:21, x @list:141:10)::

        +(acc @list:141:38, 1 @list:141:44, ?tmp#2 @list:141:38)
        length1(t @list:141:35, tmp#2, ?tmp#1 @list:141:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(acc @list:141:57, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:141:10, ?#result @list:140:1)


list > public (0 calls)
0: list(ar:array(T) @list:128:14, ?#result:_(T) @list:128:5):
    [](?tmp#0 @list:129:11)
    =(?ls @list:129:6, tmp#0)
    foreign llvm move(ar @list:130:15, ?tmp#1)
    do {
        if {[|](?x @list:130:10, ?tmp#1, tmp#1)::

            [|](x @list:131:16, ls @list:131:20, ?tmp#2 @list:131:15)
            =(?ls @list:131:10, tmp#2)
        else::
            break

        }
    }
    reverse(ls @list:133:13, ?ls @list:133:18)
    foreign llvm move(ls @list:128:34, ?#result @list:128:5)


map > public (0 calls)
0: map(f:{resource}(T) @list:41:13, xs:_(T) @list:41:30):
    foreign llvm move(xs @list:42:15, ?tmp#0)
    do {
        if {[|](?x @list:42:10, ?tmp#0, tmp#0)::

            !f(x @list:43:12)
        else::
            break

        }
    }
map > public (0 calls)
1: map(f:(A, ?B) @list:49:13, as:_(A) @list:49:24, ?#result:_(B) @list:49:5):
    if {[|](?a @list:50:12, ?as @list:50:17, as @list:50:23)::

        f(a @list:50:33, ?tmp#2 @list:50:31)
        map(f @list:50:42, as @list:50:45, ?tmp#3 @list:50:38)
        [|](tmp#2, tmp#3, ?tmp#1 @list:50:29)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:50:61)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:50:10, ?#result @list:49:5)
map > public (0 calls)
2: map(f:(A, B, ?C) @list:55:13, as:_(A) @list:55:27, bs:_(B) @list:55:36, ?#result:_(C) @list:55:5):
    if {(   [|](?a @list:56:12, ?as @list:56:17, as @list:56:23)
        & [|](?b @list:56:30, ?bs @list:56:35, bs @list:56:41))::

        f(a @list:56:51, b @list:56:54, ?tmp#2 @list:56:49)
        map(f @list:56:63, as @list:56:66, bs @list:56:70, ?tmp#3 @list:56:59)
        [|](tmp#2, tmp#3, ?tmp#1 @list:56:47)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:57:47)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:56:10, ?#result @list:55:5)


print > public (0 calls)
0: print(printer:{resource}(T) @list:108:15, xs:_(T) @list:108:38) use !io:
    !print('[' @list:109:12)
    if {[|](?x @list:110:12, ?xs @list:110:17, xs @list:110:23)::

        !printer(x @list:111:18)
        !print1(printer @list:112:17, xs @list:112:26)
    else::
        pass

    }
    !print(']' @list:114:12)


print1 > (0 calls)
0: print1(printer:{resource}(T) @list:154:12, xs:_(T) @list:154:35) use !io:
    if {[|](?x @list:155:12, ?xs @list:155:17, xs @list:155:23)::

        !print(',' @list:156:16)
        !printer(x @list:157:18)
        !print1(printer @list:158:17, xs @list:158:26)
    else::
        pass

    }


println > public (0 calls)
0: println(printer:{resource}(T) @list:119:17, xs:_(T) @list:119:40) use !io:
    !print(printer @list:120:12, xs @list:120:21)
    !nl


reverse > public (0 calls)
0: reverse(x:_(T) @list:27:17, ?#result:_(T) @list:27:5):
    [](?tmp#1 @list:27:44)
    reverse1(x @list:27:41, tmp#1, ?tmp#0 @list:27:32)
    foreign llvm move(tmp#0, ?#result @list:27:5)


reverse1 > (0 calls)
0: reverse1(x:_(T) @list:144:14, tail:_(T) @list:144:22, ?#result:_(T) @list:144:1):
    if {[|](?h @list:145:16, ?t @list:145:21, x @list:145:10)::

        [|](h @list:145:40, tail @list:145:44, ?tmp#2 @list:145:39)
        reverse1(t @list:145:36, tmp#2, ?tmp#1 @list:145:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(tail @list:145:61, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:145:10, ?#result @list:144:1)

LLVM code       : None

--------------------------------------------------
 Module wybe.machine_word
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.machine_word.word_size_bits<0>
                    wybe.machine_word.word_size_bytes<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

word_size_bits > public {inline} (0 calls)
0: wybe.machine_word.word_size_bits<0>
word_size_bits(?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(64:wybe.int, ?#result##0:wybe.int) @machine_word:12:5


word_size_bytes > public {inline} (1 calls)
0: wybe.machine_word.word_size_bytes<0>
word_size_bytes(?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(8:wybe.int, ?#result##0:wybe.int) @machine_word:10:5

LLVM code       : None

--------------------------------------------------
 Module wybe.memory_management
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.memory_management.<0>
                    wybe.memory_management.malloc_count<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

module top-level code > public {semipure} (0 calls)
0: ():
    foreign c {impure} gc_init


malloc_count > public {semipure} (0 calls)
0: malloc_count(?x:wybe.int @memory_management:11:34):
    foreign c {impure} malloc_count(?x:wybe.int @memory_management:12:38)

LLVM code       : None

--------------------------------------------------
 Module wybe.phantom
 modifiers       : {unique} 
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : 
  imports         : 
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.predicate
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.predicate.const<0>
                    wybe.predicate.id<0>
  imports         : 
  resources       : 
  procs           : 

const > public {inline} (0 calls)
0: wybe.predicate.const<0>
const(a##0:A <{}; {}; {0}>, [b##0:B <{}; {}; {1}>], ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:8:5


id > public {inline} (0 calls)
0: wybe.predicate.id<0>
id(a##0:A <{}; {}; {0}>, ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:6:5

LLVM code       : None

--------------------------------------------------
 Module wybe.range
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.range...<0>
                    wybe.range.[]<0>
                    wybe.range.[|]<0>
                    wybe.range.irange<0>
                    wybe.range.size<0>
                    wybe.range.xrange<0>
  imports         : use wybe.bool
                    use wybe.int
  resources       : 
  procs           : 

.. > public (0 calls)
0: ..(start:int @range:38:10, end:int @range:38:23, ?#result:_ @range:38:5):
    if {<=(start @range:39:27, end @range:39:37)::

        foreign llvm move(1 @range:39:44, ?tmp#1)
    else::
        foreign llvm move(-1 @range:39:56, ?tmp#1)

    }
    construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)
    foreign llvm move(tmp#0, ?#result @range:38:5)


[] > public {test} (0 calls)
0: [](r:_ @range:20:19, idx:int @range:20:24, ?value:int @range:20:34):
    <=(0 @range:21:6, idx @range:21:12)
    range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)
    *(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)
    +(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)
    =(?value @range:23:6, tmp#0)
    if {<=(0 @range:24:10, stride @range:24:16)::

        <(value @range:24:27, end @range:24:35)
    else::
        <(end @range:24:51, value @range:24:57)

    }


[|] > public {test} (0 calls)
0: [|](?value:int @range:12:23, ?rest:_ @range:12:35, current:_ @range:12:43):
    range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)
    ~=(value @range:14:6, end @range:14:16)
    +(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)
    range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)
    =(?rest @range:15:6, tmp#0)


construct > (0 calls)
0: construct(start:int @range:49:15, stride:int @range:49:26, end:int @range:49:38, ?#result:_ @range:49:1):
    -(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)
    %(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)
    =(?diff @range:50:6, tmp#0)
    if {<=(0 @range:51:19, stride @range:51:25)::

        if {=(diff @range:52:26, 0 @range:52:33)::

            max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
            -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
            max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
            foreign llvm move(tmp#5, ?tmp#3)

        }
        foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
    else::
        if {=(diff @range:55:26, 0 @range:55:33)::

            min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
            foreign llvm move(tmp#9, ?tmp#8)
        else::
            +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
            min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
            foreign llvm move(tmp#10, ?tmp#8)

        }
        foreign llvm move(tmp#8 @range:55:26, ?tmp#2)

    }
    =(?final @range:51:6, tmp#2 @range:51:19)
    range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)
    =(?r @range:58:6, tmp#12)
    foreign llvm move(r @range:49:51, ?#result @range:49:1)


irange > public (0 calls)
0: irange(start:int @range:32:16, stride:int @range:32:27, end:int @range:32:39, ?#result:_ @range:32:5):
    if {<(stride @range:33:41, 0 @range:33:50)::

        foreign llvm move(-1 @range:33:55, ?tmp#2)
    else::
        foreign llvm move(1 @range:33:68, ?tmp#2)

    }
    +(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)
    construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)
    foreign llvm move(tmp#0, ?#result @range:32:5)


size > public (0 calls)
0: size(r:_ @range:42:14, ?#result:int @range:42:5):
    range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)
    if {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
        & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
        & signum(tmp#3, ?tmp#2 @range:44:29)
        & ~=(tmp#1, tmp#2))::

        foreign llvm move(0 @range:44:52, ?tmp#0)
    else::
        if {<=(0 @range:45:10, stride @range:45:16)::

            -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
            -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
            /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
            +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
            foreign llvm move(tmp#5, ?tmp#4)
        else::
            -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
            -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
            -(stride @range:46:39, ?tmp#13 @range:46:38)
            /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
            +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
            foreign llvm move(tmp#9, ?tmp#4)

        }
        foreign llvm move(tmp#4 @range:45:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)


xrange > public (0 calls)
0: xrange(start:int @range:28:16, stride:int @range:28:27, end:int @range:28:39, ?#result:_ @range:28:5):
    construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)
    foreign llvm move(tmp#0, ?#result @range:28:5)

LLVM code       : None

--------------------------------------------------
 Module wybe.string
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.string.,,<0>
                    wybe.string.<<0>
                    wybe.string.<=<0>
                    wybe.string.<=><0>
                    wybe.string.=<0>
                    wybe.string.><0>
                    wybe.string.>=<0>
                    wybe.string.[]<0>
                    wybe.string.[]<1>
                    wybe.string.[|]<0>
                    wybe.string.c_string<0>
                    wybe.string.length<0>
                    wybe.string.print<0>
                    wybe.string.println<0>
                    wybe.string.read<0>
                    wybe.string.string<0>
                    wybe.string.string<1>
                    wybe.string.~=<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.char
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
                    use wybe.range
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_ @string:64:10, y:_ @string:64:17, ?#result:_ @string:64:5):
    if {(   empty(?tmp#1 @string:65:14)
        & =(x @string:65:10, tmp#1))::

        foreign llvm move(y @string:65:23, ?tmp#0)
    else::
        if {(   empty(?tmp#3 @string:66:14)
            & =(y @string:66:10, tmp#3))::

            foreign llvm move(x @string:66:23, ?tmp#2)
        else::
            concat(x @string:67:25, y @string:67:28, ?tmp#4 @string:67:18)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:66:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:65:10, ?#result @string:64:5)


< > public (0 calls)
0: <(x:_ @string:119:10, y:_ @string:119:17, ?#result:bool @string:119:5):
    <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
    equal(?tmp#2 @string:119:44)
    <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
    foreign llvm move(tmp#0, ?#result @string:119:5)


<= > public (0 calls)
0: <=(x:_ @string:120:10, y:_ @string:120:18, ?#result:bool @string:120:5):
    <=>(x @string:120:31, y @string:120:39, ?tmp#1 @string:120:31)
    equal(?tmp#2 @string:120:46)
    <=(tmp#1, tmp#2, ?tmp#0 @string:120:30)
    foreign llvm move(tmp#0, ?#result @string:120:5)


<=> > public (0 calls)
0: <=>(x:_ @string:125:10, y:_ @string:125:20, ?#result:comparison @string:125:5):
    equal(?tmp#0 @string:126:10)
    =(?c @string:126:6, tmp#0)
    foreign llvm move(x @string:127:16, ?tmp#1)
    foreign llvm move(y @string:127:26, ?tmp#2)
    do {
        if {[|](?cx @string:127:10, ?tmp#1, tmp#1)::

            if {[|](?cy @string:127:20, ?tmp#2, tmp#2)::

                if {<(cx @string:128:14, cy @string:128:19)::

                    lesser(?tmp#3 @string:128:30)
                    =(?c @string:128:26, tmp#3)
                    break
                else::
                    if {>(cx @string:129:14, cy @string:129:19)::

                        greater(?tmp#4 @string:129:30)
                        =(?c @string:129:26, tmp#4)
                        break
                    else::
                        pass

                    }

                }
            else::
                break

            }
        else::
            break

        }
    }
    if {(   equal(?tmp#5 @string:132:14)
        & =(c @string:132:10, tmp#5))::

        length(x @string:133:22, ?tmp#6 @string:133:15)
        =(?lx @string:133:10, tmp#6)
        length(y @string:134:22, ?tmp#7 @string:134:15)
        =(?ly @string:134:10, tmp#7)
        if {<(lx @string:135:14, ly @string:135:19)::

            lesser(?tmp#8 @string:135:30)
            =(?c @string:135:26, tmp#8)
        else::
            if {>(lx @string:135:39, ly @string:135:44)::

                greater(?tmp#9 @string:135:55)
                =(?c @string:135:51, tmp#9)
            else::
                pass

            }

        }
    else::
        pass

    }
    foreign llvm move(c @string:125:38, ?#result @string:125:5)


= > public (0 calls)
0: =(x:_ @string:115:10, y:_ @string:115:17, ?#result:bool @string:115:5):
    <=>(x @string:115:30, y @string:115:38, ?tmp#1 @string:115:30)
    equal(?tmp#2 @string:115:44)
    =(tmp#1, tmp#2, ?tmp#0 @string:115:29)
    foreign llvm move(tmp#0, ?#result @string:115:5)


> > public (0 calls)
0: >(x:_ @string:121:10, y:_ @string:121:17, ?#result:bool @string:121:5):
    <=>(x @string:121:30, y @string:121:38, ?tmp#1 @string:121:30)
    equal(?tmp#2 @string:121:44)
    >(tmp#1, tmp#2, ?tmp#0 @string:121:29)
    foreign llvm move(tmp#0, ?#result @string:121:5)


>= > public (0 calls)
0: >=(x:_ @string:122:10, y:_ @string:122:18, ?#result:bool @string:122:5):
    <=>(x @string:122:31, y @string:122:39, ?tmp#1 @string:122:31)
    equal(?tmp#2 @string:122:46)
    >=(tmp#1, tmp#2, ?tmp#0 @string:122:30)
    foreign llvm move(tmp#0, ?#result @string:122:5)


[] > public {test} (0 calls)
0: [](s:_ @string:91:19, idx:int @string:91:24, ?c:char @string:91:34):
    if {buffer(?len @string:93:17, ?str @string:93:23, s @string:92:10)::

        <=(0 @string:94:14, idx @string:94:20)
        <(idx @string:95:14, len @string:95:20)
        unsafe_c_string_index(str @string:96:35, idx @string:96:40, ?c @string:96:46)
    else::
        if {concat(?left @string:97:17, ?right @string:97:24, s @string:92:10)::

            length(left @string:98:32, ?tmp#0 @string:98:25)
            =(?left_len @string:98:14, tmp#0)
            if {<(idx @string:99:18, left_len @string:99:24)::

                [](left @string:99:41, idx @string:99:46, ?tmp#1 @string:99:41)
                =(?c @string:99:37, tmp#1)
            else::
                -(idx @string:100:37, left_len @string:100:43, ?tmp#3 @string:100:37)
                [](right @string:100:31, tmp#3, ?tmp#2 @string:100:31)
                =(?c @string:100:27, tmp#2)

            }
        else::
            if {slice(?base @string:102:16, ?range @string:102:23, s @string:92:10)::

                [](range @string:102:43, idx @string:102:49, ?tmp#5 @string:102:43)
                [](base @string:102:38, tmp#5, ?tmp#4 @string:102:38)
                =(?c @string:102:34, tmp#4)
            else::
                if {singleton(?c @string:103:20, s @string:92:10)::

                    =(idx @string:103:27, 0 @string:103:33)
                else::
                    fail

                }

            }

        }

    }
[] > public (0 calls)
1: [](s:_ @string:109:12, r:range @string:109:17, ?#result:_ @string:109:5):
    slice(s @string:109:36, r @string:109:39, ?tmp#0 @string:109:30)
    foreign llvm move(tmp#0, ?#result @string:109:5)


[|] > public {test} (0 calls)
0: [|](?head:char @string:71:23, ?tail:_ @string:71:35, s:_ @string:71:43):
    if {buffer(?len @string:73:17, ?str @string:73:23, s @string:72:10)::

        [|](?head @string:74:15, ?str @string:74:23, str @string:74:30)
        if {=(len @string:75:26, 1 @string:75:32)::

            empty(?tmp#1 @string:75:37)
            foreign llvm move(tmp#1, ?tmp#0)
        else::
            -(len @string:75:60, 1 @string:75:66, ?tmp#3 @string:75:60)
            buffer(tmp#3, str @string:75:69, ?tmp#2 @string:75:53)
            foreign llvm move(tmp#2, ?tmp#0)

        }
        =(?tail @string:75:14, tmp#0 @string:75:26)
    else::
        if {concat(?left @string:76:17, ?right @string:76:24, s @string:72:10)::

            if {[|](?head @string:77:20, ?t @string:77:28, left @string:77:33)::

                concat(t @string:77:56, right @string:77:59, ?tmp#4 @string:77:49)
                =(?tail @string:77:42, tmp#4)
            else::
                [|](?head @string:78:28, ?tail @string:78:36, right @string:78:44)

            }
        else::
            if {slice(?base @string:80:16, ?range @string:80:23, s @string:72:10)::

                do {
                    [|](?idx @string:82:19, ?range @string:82:26, range @string:82:35)
                    if {(   [](base @string:83:30, idx @string:83:35, ?tmp#5 @string:83:30)
                        & =(?head @string:83:23, tmp#5))::

                        slice(base @string:83:57, range @string:83:63, ?tmp#6 @string:83:51)
                        =(?tail @string:83:44, tmp#6)
                        break
                    else::
                        pass

                    }
                }
            else::
                if {singleton(?head @string:85:20, s @string:72:10)::

                    empty(?tmp#7 @string:85:37)
                    =(?tail @string:85:30, tmp#7)
                else::
                    fail

                }

            }

        }

    }


c_string > public (0 calls)
0: c_string(s:_ @string:40:18, ?#result:c_string @string:40:5):
    if {buffer(?tmp#0 @string:41:21, ?str @string:41:25, s @string:41:10)::

        pass
    else::
        length(s @string:43:27, ?tmp#2 @string:43:20)
        +(tmp#2, 1 @string:43:32, ?tmp#1 @string:43:20)
        =(?len @string:43:14, tmp#1)
        foreign lpvm alloc(len @string:44:32, ?str @string:44:38)
        true(?tmp#3 @string:45:49)
        foreign lpvm mutate(str @string:45:33, ?str @string:45:39, len @string:45:44, tmp#3, len @string:45:55, 0 @string:45:60, '\NUL' @string:45:63)
        =(?offset @string:46:14, 0 @string:46:23)
        pack(s @string:47:18, !str @string:47:22, len @string:47:27, !offset @string:47:33)

    }
    foreign llvm move(str @string:40:34, ?#result @string:40:5)


fixed_range_size > (0 calls)
0: fixed_range_size(hi:int @string:184:22, r:range @string:184:30, ?sz:int @string:184:40):
    range(?start @string:185:16, ?stride @string:185:24, ?end @string:185:33, r @string:185:5)
    if {<=(0 @string:186:10, stride @string:186:16)::

        -(start @string:187:39, ?tmp#4 @string:187:38)
        /(tmp#4, stride @string:187:47, ?tmp#3 @string:187:38)
        *(tmp#3, stride @string:187:56, ?tmp#2 @string:187:38)
        +(start @string:187:30, tmp#2, ?tmp#1 @string:187:30)
        max(start @string:187:23, tmp#1, ?tmp#0 @string:187:19)
        =(?lo @string:187:14, tmp#0)
        min(hi @string:188:23, end @string:188:27, ?tmp#5 @string:188:19)
        =(?hi @string:188:14, tmp#5)
    else::
        max(-1 @string:190:23, end @string:190:27, ?tmp#6 @string:190:19)
        =(?lo @string:190:14, tmp#6)
        +(hi @string:191:30, stride @string:191:35, ?tmp#10 @string:191:30)
        -(start @string:191:45, hi @string:191:53, ?tmp#13 @string:191:45)
        -(tmp#13, 1 @string:191:58, ?tmp#12 @string:191:45)
        -(stride @string:191:64, ?tmp#14 @string:191:63)
        %(tmp#12, tmp#14, ?tmp#11 @string:191:44)
        +(tmp#10, tmp#11, ?tmp#9 @string:191:30)
        +(tmp#9, 1 @string:191:73, ?tmp#8 @string:191:30)
        min(start @string:191:23, tmp#8, ?tmp#7 @string:191:19)
        =(?hi @string:191:14, tmp#7)
        -(stride @string:192:24, ?tmp#15 @string:192:23)
        =(?stride @string:192:14, tmp#15)

    }
    if {<=(hi @string:194:16, lo @string:194:23)::

        foreign llvm move(0 @string:194:29, ?tmp#16)
    else::
        -(hi @string:194:42, lo @string:194:47, ?tmp#20 @string:194:42)
        -(tmp#20, 1 @string:194:52, ?tmp#19 @string:194:42)
        /(tmp#19, stride @string:194:57, ?tmp#18 @string:194:41)
        +(tmp#18, 1 @string:194:66, ?tmp#17 @string:194:41)
        foreign llvm move(tmp#17, ?tmp#16)

    }
    =(?sz @string:194:6, tmp#16 @string:194:16)


length > public (0 calls)
0: length(s:_ @string:52:16, ?#result:int @string:52:5):
    if {buffer(?len @string:53:22, ?tmp#1 @string:53:27, s @string:53:10)::

        foreign llvm move(len @string:53:33, ?tmp#0)
    else::
        if {concat(?left @string:54:22, ?right @string:54:29, s @string:54:10)::

            length(left @string:54:46, ?tmp#4 @string:54:39)
            length(right @string:54:61, ?tmp#5 @string:54:54)
            +(tmp#4, tmp#5, ?tmp#3 @string:54:39)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            if {slice(?base @string:55:21, ?range @string:55:28, s @string:55:10)::

                length(base @string:55:62, ?tmp#8 @string:55:55)
                fixed_range_size(tmp#8, range @string:55:69, ?tmp#7 @string:55:38)
                foreign llvm move(tmp#7, ?tmp#6)
            else::
                if {singleton(?tmp#10 @string:56:24, s @string:56:10)::

                    foreign llvm move(1 @string:56:30, ?tmp#9)
                else::
                    foreign llvm move(0 @string:57:18, ?tmp#9)

                }
                foreign llvm move(tmp#9 @string:56:10, ?tmp#6)

            }
            foreign llvm move(tmp#6 @string:55:10, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:54:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:53:10, ?#result @string:52:5)


pack > (0 calls)
0: pack(s:_ @string:160:10, !raw:c_string @string:160:16, size:int @string:160:30, !offset:int @string:160:41):
    if {buffer(?tmp#0 @string:162:16, ?str @string:162:20, s @string:161:10)::

        foreign llvm move(str @string:163:23, ?tmp#1)
        do {
            if {[|](?c @string:163:18, ?tmp#1, tmp#1)::

                true(?tmp#2 @string:164:56)
                foreign lpvm mutate(raw @string:164:37, ?raw @string:164:43, offset @string:164:48, tmp#2, size @string:164:62, 0 @string:164:68, c @string:164:71)
                incr(!offset @string:165:23)
            else::
                break

            }
        }
    else::
        if {concat(?left @string:167:17, ?right @string:167:24, s @string:161:10)::

            pack(left @string:168:18, !raw @string:168:25, size @string:168:30, !offset @string:168:37)
            pack(right @string:169:18, !raw @string:169:26, size @string:169:31, !offset @string:169:38)
            incr(!offset @string:170:19)
        else::
            if {slice(?tmp#3 @string:171:15, ?tmp#4 @string:171:18, s @string:161:10)::

                foreign llvm move(s @string:172:23, ?tmp#5)
                do {
                    if {[|](?c @string:172:18, ?tmp#5, tmp#5)::

                        true(?tmp#6 @string:173:56)
                        foreign lpvm mutate(raw @string:173:37, ?raw @string:173:43, offset @string:173:48, tmp#6, size @string:173:62, 0 @string:173:68, c @string:173:71)
                        incr(!offset @string:174:23)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:176:20, s @string:161:10)::

                    true(?tmp#7 @string:177:52)
                    foreign lpvm mutate(raw @string:177:33, ?raw @string:177:39, offset @string:177:44, tmp#7, size @string:177:58, 0 @string:177:64, c @string:177:67)
                    incr(!offset @string:178:19)
                else::
                    fail

                }

            }

        }

    }


print > public (0 calls)
0: print(x:_ @string:142:15) use !io:
    if {buffer(?tmp#0 @string:144:16, ?str @string:144:20, x @string:143:10)::

        !print(str @string:144:35)
    else::
        if {concat(?left @string:145:17, ?right @string:145:24, x @string:143:10)::

            !print(left @string:145:41)
            !print(right @string:145:55)
        else::
            if {slice(?tmp#1 @string:146:15, ?tmp#2 @string:146:18, x @string:143:10)::

                foreign llvm move(x @string:146:34, ?tmp#3)
                do {
                    if {[|](?c @string:146:29, ?tmp#3, tmp#3)::

                        !print(c @string:146:45)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:147:20, x @string:143:10)::

                    !print(c @string:147:33)
                else::
                    fail

                }

            }

        }

    }


println > public (0 calls)
0: println(x:_ @string:151:17) use !io:
    !print(x @string:151:39)
    !nl


read > public (0 calls)
0: read(?x:_ @string:153:15) use !io:
    !read(?str:c_string @string:153:37)
    string(str @string:153:64, ?tmp#0 @string:153:57)
    =(?x @string:153:53, tmp#0)


string > public (0 calls)
0: string(str:c_string @string:28:16, ?#result:_ @string:28:5):
    length(str @string:29:19, ?tmp#0 @string:29:12)
    =(?len @string:29:6, tmp#0)
    if {=(len @string:30:15, 0 @string:30:21)::

        empty(?tmp#2 @string:30:26)
        foreign llvm move(tmp#2, ?tmp#1)
    else::
        if {=(len @string:31:15, 1 @string:31:21)::

            foreign lpvm access(str @string:31:56, 0 @string:31:61, 1 @string:31:64, 0 @string:31:67, ?tmp#5 @string:31:36)
            singleton(tmp#5, ?tmp#4 @string:31:26)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            buffer(len @string:32:33, str @string:32:38, ?tmp#6 @string:32:26)
            foreign llvm move(tmp#6, ?tmp#3)

        }
        foreign llvm move(tmp#3 @string:31:15, ?tmp#1)

    }
    =(?s @string:30:6, tmp#1 @string:30:15)
    foreign llvm move(s @string:28:34, ?#result @string:28:5)
string > public (0 calls)
1: string(c:char @string:37:16, ?#result:_ @string:37:5):
    singleton(c @string:37:38, ?tmp#0 @string:37:28)
    foreign llvm move(tmp#0, ?#result @string:37:5)


~= > public (0 calls)
0: ~=(x:_ @string:116:10, y:_ @string:116:18, ?#result:bool @string:116:5):
    <=>(x @string:116:31, y @string:116:39, ?tmp#1 @string:116:31)
    equal(?tmp#2 @string:116:46)
    ~=(tmp#1, tmp#2, ?tmp#0 @string:116:30)
    foreign llvm move(tmp#0, ?#result @string:116:5)

LLVM code       : None

======================================================================
AFTER FLATTENING:
 Module wybe
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : 
  imports         : public use wybe.array
                    public use wybe.bool
                    public use wybe.c_string
                    public use wybe.char
                    public use wybe.comparison
                    public use wybe.control
                    public use wybe.count
                    public use wybe.float
                    public use wybe.int
                    public use wybe.io
                    public use wybe.list
                    public use wybe.machine_word
                    public use wybe.memory_management
                    public use wybe.phantom
                    public use wybe.predicate
                    public use wybe.range
                    public use wybe.string
  resources       : 
  submodules      : wybe.array, wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.control, wybe.count, wybe.float, wybe.int, wybe.io, wybe.list, wybe.machine_word, wybe.memory_management, wybe.phantom, wybe.predicate, wybe.range, wybe.string
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.array(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.array.[]<0>
                    wybe.array.[]<1>
                    wybe.array.[|]<0>
                    wybe.array.array<0>
                    wybe.array.array<1>
                    wybe.array.inbounds<0>
                    wybe.array.unsafe_get<0>
                    wybe.array.unsafe_update<0>
  imports         : public use wybe.array.raw_array
                    use wybe.bool
                    use wybe.int
                    use wybe.list
                    use wybe.machine_word
  resources       : 
  submodules      : wybe.array.raw_array
  procs           : 

[] > public {test} (0 calls)
0: [](a:_(T) @array:67:21, idx:int @array:67:29, ?#result:T @array:67:5):
    inbounds(a @array:68:14, idx @array:68:17)
    unsafe_get(a @array:69:10, idx @array:69:23, ?tmp#0 @array:69:10)
    =(?x @array:69:6, tmp#0)
    foreign llvm move(x @array:67:42, ?#result @array:67:5)
[] > public {test} (0 calls)
1: [](!a:_(T) @array:81:22, idx:int @array:81:30, x:T @array:81:39):
    inbounds(a @array:82:14, idx @array:82:17)
    unsafe_update(!a @array:83:20, idx @array:83:23, x @array:83:28)


[|] > public {test} (0 calls)
0: [|](?head:T @array:51:23, ?tail:_(T) @array:51:32, a:_(T) @array:51:43):
    array(?length @array:52:12, ?data @array:52:21, a @array:52:29)
    >(length @array:53:6, 0 @array:53:15)
    word_size_bytes(?tmp#0 @array:54:34)
    foreign lpvm access(data @array:54:25, 0 @array:54:31, tmp#0, 0 @array:54:51, ?head @array:54:55)
    word_size_bytes(?tmp#1 @array:55:28)
    foreign llvm add(data @array:55:22, tmp#1, ?data @array:55:46)
    -(length @array:56:19, 1 @array:56:28, ?tmp#3 @array:56:19)
    array(tmp#3, data @array:56:31, ?tmp#2 @array:56:13)
    =(?tail @array:56:6, tmp#2)


array > public (0 calls)
0: array(x:T @array:18:15, len:int @array:18:20, ?#result:_(T) @array:18:5):
    word_size_bytes(?tmp#1 @array:19:19)
    *(len @array:19:13, tmp#1, ?tmp#0 @array:19:13)
    =(?size @array:19:6, tmp#0)
    foreign lpvm alloc(size @array:20:24, ?data @array:20:31)
    =(?offset @array:21:6, 0 @array:21:15)
    do {
        if {<(offset @array:23:15, size @array:23:24)::

            pass
        else::
            break

        }
        foreign lpvm mutate(data @array:24:29, ?data @array:24:36, offset @array:24:42, 1 @array:24:50, size @array:24:53, 0 @array:24:59, x @array:24:62)
        word_size_bytes(?tmp#2 @array:25:21)
        +=(!offset @array:25:10, tmp#2)
    }
    array(len @array:27:17, data @array:27:22, ?tmp#3 @array:27:11)
    =(?ar @array:27:6, tmp#3)
    foreign llvm move(ar @array:18:36, ?#result @array:18:5)
array > public (0 calls)
1: array(ls:list(T) @array:34:15, ?#result:_(T) @array:34:5):
    length(ls @array:35:19, ?tmp#0 @array:35:12)
    =(?len @array:35:6, tmp#0)
    word_size_bytes(?tmp#2 @array:36:19)
    *(len @array:36:13, tmp#2, ?tmp#1 @array:36:13)
    =(?size @array:36:6, tmp#1)
    foreign lpvm alloc(size @array:37:24, ?data @array:37:31)
    =(?offset @array:38:6, 0 @array:38:15)
    foreign llvm move(ls @array:39:15, ?tmp#3)
    do {
        if {[|](?x @array:39:10, ?tmp#3, tmp#3)::

            foreign lpvm mutate(data @array:40:29, ?data @array:40:36, offset @array:40:42, 1 @array:40:50, size @array:40:53, 0 @array:40:59, x @array:40:62)
            word_size_bytes(?tmp#4 @array:41:21)
            +=(!offset @array:41:10, tmp#4)
        else::
            break

        }
    }
    array(len @array:43:17, data @array:43:22, ?tmp#5 @array:43:11)
    =(?ar @array:43:6, tmp#5)
    foreign llvm move(ar @array:34:34, ?#result @array:34:5)


inbounds > public {test,inline} (0 calls)
0: inbounds(a:_(T) @array:60:33, idx:int @array:60:41):
    <=(0 @array:61:6, idx @array:61:12)
    length(a @array:62:12, ?tmp#0 @array:62:12)
    <(idx @array:62:6, tmp#0)


unsafe_get > public {inline} (0 calls)
0: unsafe_get(a:_(T) @array:75:29, idx:int @array:75:37, ?#result:T @array:75:5):
    raw_data(a @array:76:25, ?tmp#0 @array:76:25)
    word_size_bytes(?tmp#2 @array:76:43)
    *(idx @array:76:37, tmp#2, ?tmp#1 @array:76:37)
    word_size_bytes(?tmp#3 @array:76:60)
    foreign lpvm access(tmp#0, tmp#1, tmp#3, 0 @array:76:77, ?x @array:76:81)
    foreign llvm move(x @array:75:50, ?#result @array:75:5)


unsafe_update > public {inline} (0 calls)
0: unsafe_update(!a:_(T) @array:89:33, idx:int @array:89:41, x:T @array:89:50):
    raw_data(a @array:90:25, ?tmp#0 @array:90:25)
    word_size_bytes(?tmp#2 @array:90:50)
    *(idx @array:90:44, tmp#2, ?tmp#1 @array:90:44)
    length(a @array:91:44, ?tmp#4 @array:91:44)
    word_size_bytes(?tmp#5 @array:91:55)
    *(tmp#4, tmp#5, ?tmp#3 @array:91:44)
    foreign lpvm mutate(tmp#0, ?data @array:90:38, tmp#1, 0 @array:90:67, tmp#3, 0 @array:91:72, x @array:91:75)
    raw_data(!a @array:92:6, data @array:92:19)

LLVM code       : None

--------------------------------------------------
 Module wybe.array.raw_array(T)
  representation  : address
  public submods  : 
  public resources: 
  public procs    : 
  imports         : use wybe
                    use wybe.array
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.bool
  representation  : 1 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.bool.&&<0>
                    wybe.bool.&=<0>
                    wybe.bool.=<0>
                    wybe.bool.^=<0>
                    wybe.bool.^^<0>
                    wybe.bool.false<0>
                    wybe.bool.print<0>
                    wybe.bool.println<0>
                    wybe.bool.succeed<0>
                    wybe.bool.true<0>
                    wybe.bool.|=<0>
                    wybe.bool.||<0>
                    wybe.bool.~<0>
                    wybe.bool.~=<0>
  imports         : use wybe.c_string
                    use wybe.io
  resources       : 
  procs           : 

&& > public {inline} (1 calls)
0: wybe.bool.&&<0>
&&(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:13:27


&= > public {inline} (0 calls)
0: wybe.bool.&=<0>
&=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:13:27


= > public {inline} (0 calls)
0: wybe.bool.=<0>
=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:37:26


^= > public {inline} (0 calls)
0: wybe.bool.^=<0>
^=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:25:27


^^ > public {inline} (1 calls)
0: wybe.bool.^^<0>
^^(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:25:27


false > public {inline} (0 calls)
0: wybe.bool.false<0>
false(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.bool, ?#result##0:wybe.bool)


print > public (1 calls)
0: wybe.bool.print<0>
print(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    case ~x##0:wybe.bool of
    0:
        wybe.c_string.print<0>(c"false":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #1 @bool:47:31

    1:
        wybe.c_string.print<0>(c"true":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:47:31



println > public {inline} (0 calls)
0: wybe.bool.println<0>
println(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.bool.print<0>(~x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:49:33
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#0##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~tmp#0##0:wybe.phantom, ?tmp#1##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#1##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


succeed > public {inline} (0 calls)
0: wybe.bool.succeed<0>
succeed()<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []


true > public {inline} (1 calls)
0: wybe.bool.true<0>
true(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.bool, ?#result##0:wybe.bool)


|= > public {inline} (0 calls)
0: wybe.bool.|=<0>
|=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:19:27


|| > public {inline} (1 calls)
0: wybe.bool.||<0>
||(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:19:27


~ > public {inline} (0 calls)
0: wybe.bool.~<0>
~(p##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, 1:wybe.bool, ?#result##0:wybe.bool) @bool:31:20


~= > public {inline} (0 calls)
0: wybe.bool.~=<0>
~=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:38:27

LLVM code       : None

--------------------------------------------------
 Module wybe.c_string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.c_string.<<0>
                    wybe.c_string.<=<0>
                    wybe.c_string.=<0>
                    wybe.c_string.><0>
                    wybe.c_string.>=<0>
                    wybe.c_string.[]<0>
                    wybe.c_string.[|]<0>
                    wybe.c_string.length<0>
                    wybe.c_string.print<0>
                    wybe.c_string.println<0>
                    wybe.c_string.read<0>
                    wybe.c_string.unsafe_c_string_index<0>
                    wybe.c_string.~=<0>
  imports         : use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.c_string.<<0>
<(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:12:29
    wybe.int.<<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:12:29


<= > public {inline} (0 calls)
0: wybe.c_string.<=<0>
<=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:13:30
    wybe.int.<=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:13:30


= > public {inline} (0 calls)
0: wybe.c_string.=<0>
=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:10:29
    wybe.int.=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:10:29


> > public {inline} (0 calls)
0: wybe.c_string.><0>
>(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:14:29
    wybe.int.><0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:14:29


>= > public {inline} (0 calls)
0: wybe.c_string.>=<0>
>=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:15:30
    wybe.int.>=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:15:30


[] > public (0 calls)
0: wybe.c_string.[]<0>
[](str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, idx##0:wybe.int, ?tmp#2##0:wybe.bool) #0 @c_string:27:6
    case ~tmp#2##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        foreign c strlen(str##0:wybe.c_string, ?tmp#0##0:wybe.int) @c_string:17:29
        wybe.int.<<0>(idx##0:wybe.int, ~tmp#0##0:wybe.int, ?tmp#3##0:wybe.bool) #2 @c_string:28:6
        case ~tmp#3##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




[|] > public (0 calls)
0: wybe.c_string.[|]<0>
[|](?head##0:wybe.char, ?tail##0:wybe.c_string, str##0:wybe.c_string, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(str##0:wybe.c_string, 0:wybe.int, 0:wybe.int, 0:wybe.int, ?head##0:wybe.char) @c_string:20:5
    foreign llvm icmp_ne(head##0:wybe.char, '\NUL':wybe.char, ?not_done##0:wybe.bool) @c_string:21:5
    foreign llvm icmp_eq(~not_done##0:wybe.bool, 1:wybe.bool, ?tmp#1##0:wybe.bool) @bool:37:26
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.c_string, ?tail##0:wybe.c_string)

    1:
        foreign llvm add(~str##0:wybe.c_string, 1:wybe.int, ?tail##0:wybe.c_string) @c_string:23:5
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



length > public {inline} (3 calls)
0: wybe.c_string.length<0>
length(str##0:wybe.c_string, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strlen(~str##0:wybe.c_string, ?#result##0:wybe.int) @c_string:17:29


print > public {inline} (1 calls)
0: wybe.c_string.print<0>
print(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:35:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:35:30


println > public {inline} (0 calls)
0: wybe.c_string.println<0>
println(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @c_string:35:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.c_string.read<0>
read(?x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:39:30
    foreign c read_line(?x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:39:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:39:30


unsafe_c_string_index > public {inline} (1 calls)
0: wybe.c_string.unsafe_c_string_index<0>
unsafe_c_string_index(str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7


~= > public {inline} (0 calls)
0: wybe.c_string.~=<0>
~=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:11:30
    wybe.int.~=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.char
  representation  : 8 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.char.<<0>
                    wybe.char.<=<0>
                    wybe.char.<=><0>
                    wybe.char.=<0>
                    wybe.char.><0>
                    wybe.char.>=<0>
                    wybe.char.chr<0>
                    wybe.char.ord<0>
                    wybe.char.print<0>
                    wybe.char.println<0>
                    wybe.char.read<0>
                    wybe.char.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (4 calls)
0: wybe.char.<<0>
<(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:17:29


<= > public {inline} (0 calls)
0: wybe.char.<=<0>
<=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:18:30


<=> > public (0 calls)
0: wybe.char.<=><0>
<=>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.char, y##0:wybe.char, ?tmp#6##0:wybe.bool) @char:17:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?tmp#5##0:wybe.bool) @char:13:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5



= > public {inline} (2 calls)
0: wybe.char.=<0>
=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:13:29


> > public {inline} (0 calls)
0: wybe.char.><0>
>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:19:29


>= > public {inline} (0 calls)
0: wybe.char.>=<0>
>=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:20:30


chr > public (0 calls)
0: wybe.char.chr<0>
chr(i##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, i##0:wybe.int, ?tmp#1##0:wybe.bool) #0 @char:33:60
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        wybe.int.<=<0>(i##0:wybe.int, 255:wybe.int, ?tmp#2##0:wybe.bool) #1 @char:33:70
        case ~tmp#2##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm cast(~i##0:wybe.int, ?#result##0:wybe.char) @char:33:31
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




ord > public {inline} (0 calls)
0: wybe.char.ord<0>
ord(c##0:wybe.char, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(~c##0:wybe.char, ?#result##0:wybe.int) @char:30:24


print > public {inline} (1 calls)
0: wybe.char.print<0>
print(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:37:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:37:30


println > public {inline} (0 calls)
0: wybe.char.println<0>
println(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @char:37:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.char.read<0>
read(?x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:41:30
    foreign c read_char(?x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:41:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:41:30


~= > public {inline} (0 calls)
0: wybe.char.~=<0>
~=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:14:30

LLVM code       : None

--------------------------------------------------
 Module wybe.comparison
  representation  : 2 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.comparison.<<0>
                    wybe.comparison.<=<0>
                    wybe.comparison.=<0>
                    wybe.comparison.><0>
                    wybe.comparison.>=<0>
                    wybe.comparison.equal<0>
                    wybe.comparison.greater<0>
                    wybe.comparison.lesser<0>
                    wybe.comparison.~=<0>
  imports         : use wybe.bool
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.comparison.<<0>
<(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:12:29


<= > public {inline} (0 calls)
0: wybe.comparison.<=<0>
<=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:13:30


= > public {inline} (0 calls)
0: wybe.comparison.=<0>
=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:10:29


> > public {inline} (0 calls)
0: wybe.comparison.><0>
>(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:14:29


>= > public {inline} (0 calls)
0: wybe.comparison.>=<0>
>=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:15:30


equal > public {inline} (0 calls)
0: wybe.comparison.equal<0>
equal(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison)


greater > public {inline} (0 calls)
0: wybe.comparison.greater<0>
greater(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison)


lesser > public {inline} (0 calls)
0: wybe.comparison.lesser<0>
lesser(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison)


~= > public {inline} (0 calls)
0: wybe.comparison.~=<0>
~=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.control
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.control.assert<0>
                    wybe.control.error<0>
                    wybe.control.error<1>
                    wybe.control.exit<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.int
                    use wybe.string
  resources       : 
  procs           : 

assert > public {semipure} (0 calls)
0: assert(condition:bool @control:26:27) use call_source_location:
    if {~(condition @control:27:11)::

        !error(c"assertion failed" @control:27:31)
    else::
        pass

    }


error > public {terminal,semipure} (0 calls)
0: error(message:string @control:17:35) use call_source_location:
    c_string(message @control:18:77, ?tmp#0 @control:18:68)
    foreign c {terminal,semipure} error_exit(call_source_location @control:18:46, tmp#0)
error > public {terminal,semipure} (0 calls)
1: error(message:c_string @control:21:35) use call_source_location:
    foreign c {terminal,semipure} error_exit(call_source_location @control:22:46, message @control:22:68)


exit > public {terminal,semipure} (0 calls)
0: exit(code:int @control:10:34):
    foreign c {terminal,semipure} exit(code @control:11:40)

LLVM code       : None

--------------------------------------------------
 Module wybe.count
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.count.%<0>
                    wybe.count.%=<0>
                    wybe.count.*<0>
                    wybe.count.*=<0>
                    wybe.count.+<0>
                    wybe.count.+<1>
                    wybe.count.+<2>
                    wybe.count.+=<0>
                    wybe.count.-<0>
                    wybe.count.-<1>
                    wybe.count.-<2>
                    wybe.count.-=<0>
                    wybe.count./<0>
                    wybe.count./=<0>
                    wybe.count.<<0>
                    wybe.count.<=<0>
                    wybe.count.<=><0>
                    wybe.count.=<0>
                    wybe.count.><0>
                    wybe.count.>=<0>
                    wybe.count.decr<0>
                    wybe.count.incr<0>
                    wybe.count.max<0>
                    wybe.count.min<0>
                    wybe.count.print<0>
                    wybe.count.println<0>
                    wybe.count.read<0>
                    wybe.count.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.count.%<0>
%(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:51:25


%= > public {inline} (0 calls)
0: wybe.count.%=<0>
%=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:51:25


* > public {inline} (1 calls)
0: wybe.count.*<0>
*(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:39:25


*= > public {inline} (0 calls)
0: wybe.count.*=<0>
*=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:39:25


+ > public {inline} (2 calls)
0: wybe.count.+<0>
+(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:15:25
+ > public (0 calls)
1: wybe.count.+<1>
+(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(y##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?x##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~y##0:wybe.count, ?x##0:wybe.count) @count:18:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

+ > public (0 calls)
2: wybe.count.+<2>
+(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?y##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:22:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



+= > public {inline} (0 calls)
0: wybe.count.+=<0>
+=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:15:25


- > public (6 calls)
0: wybe.count.-<0>
-(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?#result##0:wybe.count)

    1:
        foreign llvm sub(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:31:35
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

- > public {inline} (0 calls)
1: wybe.count.-<1>
-(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.count, ~z##0:wybe.count, ?x##0:wybe.count) @count:32:42
- > public {inline} (0 calls)
2: wybe.count.-<2>
-(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:33:42


-= > public (0 calls)
0: wybe.count.-=<0>
-=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, ~y##0:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:36:41
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:36:37
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



/ > public {inline} (1 calls)
0: wybe.count./<0>
/(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:45:25


/= > public {inline} (0 calls)
0: wybe.count./=<0>
/=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:45:25


< > public {inline} (4 calls)
0: wybe.count.<<0>
<(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:64:29


<= > public {inline} (3 calls)
0: wybe.count.<=<0>
<=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:65:30


<=> > public (0 calls)
0: wybe.count.<=><0>
<=>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.count, y##0:wybe.count, ?tmp#6##0:wybe.bool) @count:64:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?tmp#5##0:wybe.bool) @count:60:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5



= > public {inline} (2 calls)
0: wybe.count.=<0>
=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:60:29


> > public {inline} (0 calls)
0: wybe.count.><0>
>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:66:29


>= > public {inline} (12 calls)
0: wybe.count.>=<0>
>=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:67:30


decr > public (0 calls)
0: wybe.count.decr<0>
decr(x##0:wybe.count, ?x##1:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, 1:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:84:37
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:84:33
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



incr > public {inline} (0 calls)
0: wybe.count.incr<0>
incr(x##0:wybe.count, ?x##1:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, 1:wybe.count, ?x##1:wybe.count) @count:15:25


max > public (0 calls)
0: wybe.count.max<0>
max(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:75:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:75:5



min > public (0 calls)
0: wybe.count.min<0>
min(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:65:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:74:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:74:5



print > public {inline} (1 calls)
0: wybe.count.print<0>
print(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:88:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:88:30


println > public {inline} (0 calls)
0: wybe.count.println<0>
println(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @count:88:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.count.read<0>
read(?x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:92:30
    foreign c read_count(?x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:92:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:92:30


~= > public {inline} (0 calls)
0: wybe.count.~=<0>
~=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:61:30

LLVM code       : None

--------------------------------------------------
 Module wybe.float
  representation  : 64 bit float
  public submods  : 
  public resources: 
  public procs    : wybe.float.*<0>
                    wybe.float.**<0>
                    wybe.float.*=<0>
                    wybe.float.+<0>
                    wybe.float.+<1>
                    wybe.float.+<2>
                    wybe.float.+=<0>
                    wybe.float.-<0>
                    wybe.float.-<1>
                    wybe.float.-<2>
                    wybe.float.-<3>
                    wybe.float.-<4>
                    wybe.float.-=<0>
                    wybe.float./<0>
                    wybe.float./=<0>
                    wybe.float.<<0>
                    wybe.float.<=<0>
                    wybe.float.<=><0>
                    wybe.float.=<0>
                    wybe.float.><0>
                    wybe.float.>=<0>
                    wybe.float.abs<0>
                    wybe.float.ceil<0>
                    wybe.float.cos<0>
                    wybe.float.e<0>
                    wybe.float.exp<0>
                    wybe.float.floor<0>
                    wybe.float.iceil<0>
                    wybe.float.ifloor<0>
                    wybe.float.iround<0>
                    wybe.float.log<0>
                    wybe.float.log10<0>
                    wybe.float.log2<0>
                    wybe.float.max<0>
                    wybe.float.min<0>
                    wybe.float.pi<0>
                    wybe.float.power<0>
                    wybe.float.print<0>
                    wybe.float.println<0>
                    wybe.float.read<0>
                    wybe.float.round<0>
                    wybe.float.sin<0>
                    wybe.float.sqrt<0>
                    wybe.float.square<0>
                    wybe.float.tan<0>
                    wybe.float.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

* > public {inline} (1 calls)
0: wybe.float.*<0>
*(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:45:25


** > public {inline} (0 calls)
0: wybe.float.**<0>
**(x##0:wybe.float, n##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.pow.f64(~x##0:wybe.float, ~n##0:wybe.float, ?#result##0:wybe.float) @float:112:27


*= > public {inline} (0 calls)
0: wybe.float.*=<0>
*=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:45:25


+ > public {inline} (1 calls)
0: wybe.float.+<0>
+(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:23:27
+ > public {inline} (0 calls)
1: wybe.float.+<1>
+(?x##0:wybe.float, y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:24:43
+ > public {inline} (0 calls)
2: wybe.float.+<2>
+(x##0:wybe.float, ?y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~x##0:wybe.float, ?y##0:wybe.float) @float:25:43


+= > public {inline} (0 calls)
0: wybe.float.+=<0>
+=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:23:27


- > public {inline} (1 calls)
0: wybe.float.-<0>
-(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:32:27
- > public {inline} (0 calls)
1: wybe.float.-<1>
-(?x##0:wybe.float, y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~z##0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:33:43
- > public {inline} (0 calls)
2: wybe.float.-<2>
-(x##0:wybe.float, ?y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~x##0:wybe.float, ?y##0:wybe.float) @float:34:43
- > public {inline} (0 calls)
3: wybe.float.-<3>
-(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(0.0:wybe.float, ~x##0:wybe.float, ?#result##0:wybe.float) @float:38:21
- > public {inline} (0 calls)
4: wybe.float.-<4>
-(?x##0:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(0.0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:39:37


-= > public {inline} (0 calls)
0: wybe.float.-=<0>
-=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:32:27


/ > public {inline} (2 calls)
0: wybe.float./<0>
/(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fdiv(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:51:25


/= > public {inline} (0 calls)
0: wybe.float./=<0>
/=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fdiv(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:51:25


< > public {inline} (4 calls)
0: wybe.float.<<0>
<(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_slt(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:70:29


<= > public {inline} (0 calls)
0: wybe.float.<=<0>
<=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sle(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:71:30


<=> > public (0 calls)
0: wybe.float.<=><0>
<=>(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_slt(x##0:wybe.float, y##0:wybe.float, ?tmp#6##0:wybe.bool) @float:70:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm fcmp_eq(~x##0:wybe.float, ~y##0:wybe.float, ?tmp#5##0:wybe.bool) @float:66:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5



= > public {inline} (2 calls)
0: wybe.float.=<0>
=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_eq(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:66:29


> > public {inline} (0 calls)
0: wybe.float.><0>
>(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sgt(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:72:29


>= > public {inline} (0 calls)
0: wybe.float.>=<0>
>=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sge(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:73:30


abs > public {inline} (0 calls)
0: wybe.float.abs<0>
abs(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.fabs.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:60:22


ceil > public {inline} (1 calls)
0: wybe.float.ceil<0>
ceil(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.ceil.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:87:23


cos > public {inline} (0 calls)
0: wybe.float.cos<0>
cos(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.cos.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:116:22


e > public {inline} (0 calls)
0: wybe.float.e<0>
e(?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2.7182818284590455:wybe.float, ?#result##0:wybe.float) @float:16:5


exp > public {inline} (0 calls)
0: wybe.float.exp<0>
exp(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.exp.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:120:22


floor > public {inline} (1 calls)
0: wybe.float.floor<0>
floor(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.floor.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:90:24


iceil > public {inline} (0 calls)
0: wybe.float.iceil<0>
iceil(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.ceil.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:87:23
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:99:26


ifloor > public {inline} (0 calls)
0: wybe.float.ifloor<0>
ifloor(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.floor.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:90:24
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:102:27


iround > public {inline} (0 calls)
0: wybe.float.iround<0>
iround(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.round.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:93:24
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:96:27


log > public {inline} (0 calls)
0: wybe.float.log<0>
log(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:123:22


log10 > public {inline} (0 calls)
0: wybe.float.log10<0>
log10(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log10.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:126:24


log2 > public {inline} (0 calls)
0: wybe.float.log2<0>
log2(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log2.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:129:23


max > public {inline} (0 calls)
0: wybe.float.max<0>
max(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.maxnum.f64(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:81:27


min > public {inline} (0 calls)
0: wybe.float.min<0>
min(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.minnum.f64(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:80:27


pi > public {inline} (0 calls)
0: wybe.float.pi<0>
pi(?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(3.141592653589793:wybe.float, ?#result##0:wybe.float) @float:13:5


power > public {inline} (0 calls)
0: wybe.float.power<0>
power(x##0:wybe.float, n##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.pow.f64(~x##0:wybe.float, ~n##0:wybe.float, ?#result##0:wybe.float) @float:111:28


print > public {inline} (1 calls)
0: wybe.float.print<0>
print(x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @float:133:30
    foreign c print_float(~x##0:wybe.float, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @float:133:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @float:133:30


println > public {inline} (0 calls)
0: wybe.float.println<0>
println(x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @float:133:30
    foreign c print_float(~x##0:wybe.float, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @float:133:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.float.read<0>
read(?x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @float:137:30
    foreign c read_float(?x##0:wybe.float, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @float:137:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @float:137:30


round > public {inline} (1 calls)
0: wybe.float.round<0>
round(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.round.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:93:24


sin > public {inline} (0 calls)
0: wybe.float.sin<0>
sin(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sin.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:115:22


sqrt > public {inline} (0 calls)
0: wybe.float.sqrt<0>
sqrt(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sqrt.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:108:23


square > public {inline} (0 calls)
0: wybe.float.square<0>
square(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~x##0:wybe.float, ?#result##0:wybe.float) @float:57:25


tan > public {inline} (0 calls)
0: wybe.float.tan<0>
tan(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sin.f64(x##0:wybe.float, ?tmp#1##0:wybe.float) @float:117:22
    foreign c llvm.cos.f64(~x##0:wybe.float, ?tmp#2##0:wybe.float) @float:117:52
    foreign llvm fdiv(~tmp#1##0:wybe.float, ~tmp#2##0:wybe.float, ?#result##0:wybe.float) @float:51:25


~= > public {inline} (0 calls)
0: wybe.float.~=<0>
~=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_ne(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:67:30

LLVM code       : None

--------------------------------------------------
 Module wybe.int
  representation  : 64 bit signed
  public submods  : 
  public resources: 
  public procs    : wybe.int.%<0>
                    wybe.int.%=<0>
                    wybe.int.*<0>
                    wybe.int.*=<0>
                    wybe.int.+<0>
                    wybe.int.+<1>
                    wybe.int.+<2>
                    wybe.int.+=<0>
                    wybe.int.-<0>
                    wybe.int.-<1>
                    wybe.int.-<2>
                    wybe.int.-<3>
                    wybe.int.-<4>
                    wybe.int.-=<0>
                    wybe.int./<0>
                    wybe.int./=<0>
                    wybe.int.<<0>
                    wybe.int.<<<0>
                    wybe.int.<<=<0>
                    wybe.int.<=<0>
                    wybe.int.<=><0>
                    wybe.int.=<0>
                    wybe.int.><0>
                    wybe.int.>=<0>
                    wybe.int.>><0>
                    wybe.int.>>=<0>
                    wybe.int.decr<0>
                    wybe.int.incr<0>
                    wybe.int.logical_bitshift<0>
                    wybe.int.logical_bitshift<1>
                    wybe.int.max<0>
                    wybe.int.min<0>
                    wybe.int.power<0>
                    wybe.int.print<0>
                    wybe.int.println<0>
                    wybe.int.read<0>
                    wybe.int.signum<0>
                    wybe.int.sqrt<0>
                    wybe.int.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.int.%<0>
%(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:50:25


%= > public {inline} (0 calls)
0: wybe.int.%=<0>
%=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:50:25


* > public {inline} (1 calls)
0: wybe.int.*<0>
*(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:38:25


*= > public {inline} (0 calls)
0: wybe.int.*=<0>
*=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:38:25


+ > public {inline} (2 calls)
0: wybe.int.+<0>
+(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:16:27
+ > public {inline} (0 calls)
1: wybe.int.+<1>
+(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:17:43
+ > public {inline} (0 calls)
2: wybe.int.+<2>
+(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:18:43


+= > public {inline} (0 calls)
0: wybe.int.+=<0>
+=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:16:27


- > public {inline} (2 calls)
0: wybe.int.-<0>
-(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:25:27
- > public {inline} (0 calls)
1: wybe.int.-<1>
-(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.int, ~z##0:wybe.int, ?x##0:wybe.int) @int:26:43
- > public {inline} (0 calls)
2: wybe.int.-<2>
-(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:27:43
- > public {inline} (0 calls)
3: wybe.int.-<3>
-(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~x##0:wybe.int, ?#result##0:wybe.int) @int:31:21
- > public {inline} (0 calls)
4: wybe.int.-<4>
-(?x##0:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:32:37


-= > public {inline} (0 calls)
0: wybe.int.-=<0>
-=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:25:27


/ > public {inline} (1 calls)
0: wybe.int./<0>
/(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:44:25


/= > public {inline} (0 calls)
0: wybe.int./=<0>
/=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:44:25


< > public {inline} (4 calls)
0: wybe.int.<<0>
<(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:87:29


<< > public {inline} (1 calls)
0: wybe.int.<<<0>
<<(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:56:27


<<= > public {inline} (0 calls)
0: wybe.int.<<=<0>
<<=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:56:27


<= > public {inline} (3 calls)
0: wybe.int.<=<0>
<=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:88:30


<=> > public (0 calls)
0: wybe.int.<=><0>
<=>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(x##0:wybe.int, y##0:wybe.int, ?tmp#6##0:wybe.bool) @int:87:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?tmp#5##0:wybe.bool) @int:83:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5



= > public {inline} (2 calls)
0: wybe.int.=<0>
=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:83:29


> > public {inline} (0 calls)
0: wybe.int.><0>
>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sgt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:89:29


>= > public {inline} (3 calls)
0: wybe.int.>=<0>
>=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:90:30


>> > public {inline} (1 calls)
0: wybe.int.>><0>
>>(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:65:27


>>= > public {inline} (0 calls)
0: wybe.int.>>=<0>
>>=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:65:27


decr > public {inline} (0 calls)
0: wybe.int.decr<0>
decr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:25:27


incr > public {inline} (0 calls)
0: wybe.int.incr<0>
incr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:16:27


logical_bitshift > public {inline} (1 calls)
0: wybe.int.logical_bitshift<0>
logical_bitshift(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:74:40
logical_bitshift > public {inline} (0 calls)
1: wybe.int.logical_bitshift<1>
logical_bitshift(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:74:40


max > public (0 calls)
0: wybe.int.max<0>
max(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:90:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:98:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:98:5



min > public (0 calls)
0: wybe.int.min<0>
min(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:88:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:97:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:97:5



power > public {inline} (0 calls)
0: wybe.int.power<0>
power(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c ipow(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:107:29


print > public {inline} (1 calls)
0: wybe.int.print<0>
print(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:119:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:119:30


println > public {inline} (0 calls)
0: wybe.int.println<0>
println(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @int:119:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.int.read<0>
read(?x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:123:30
    foreign c read_int(?x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:123:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:123:30


signum > public {inline} (0 calls)
0: wybe.int.signum<0>
signum(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c signum(~x##0:wybe.int, ?#result##0:wybe.int) @int:114:25


sqrt > public {inline} (0 calls)
0: wybe.int.sqrt<0>
sqrt(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c isqrt(~x##0:wybe.int, ?#result##0:wybe.int) @int:104:23


~= > public {inline} (0 calls)
0: wybe.int.~=<0>
~=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:84:30

LLVM code       : None

--------------------------------------------------
 Module wybe.io
  representation  : (not a type)
  public submods  : phantom -> wybe.phantom
  public resources: io: wybe.io.io
  public procs    : wybe.io.<0>
                    wybe.io.eof<0>
                    wybe.io.nl<0>
  imports         : use wybe.char
                    public use wybe.phantom
  resources       : io: fromList [(wybe.io.io,wybe.phantom = 0:phantom @io:13:27 @io:13:5)]
  procs           : 

module top-level code > public {inline,semipure} (0 calls)
0: wybe.io.<0>
()<{}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm store(0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:13:5


eof > public {inline} (0 calls)
0: wybe.io.eof<0>
eof(?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(-1:wybe.int, ?#result##0:wybe.char) @io:20:29


nl > public {inline} (0 calls)
0: wybe.io.nl<0>
nl()<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @io:17:31
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31

LLVM code       : None

--------------------------------------------------
 Module wybe.list(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.list.,,<0>
                    wybe.list.[]<0>
                    wybe.list.all<0>
                    wybe.list.any<0>
                    wybe.list.empty<0>
                    wybe.list.filter<0>
                    wybe.list.foldl<0>
                    wybe.list.foldr<0>
                    wybe.list.length<0>
                    wybe.list.list<0>
                    wybe.list.map<0>
                    wybe.list.map<1>
                    wybe.list.map<2>
                    wybe.list.print<0>
                    wybe.list.println<0>
                    wybe.list.reverse<0>
  imports         : use wybe.array
                    use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
                    use wybe.machine_word
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_(T) @list:20:10, y:_(T) @list:20:20, ?#result:_(T) @list:20:5):
    if {[|](?h @list:21:16, ?t @list:21:21, x @list:21:10)::

        ,,(t @list:21:32, y @list:21:37, ?tmp#2 @list:21:32)
        [|](h @list:21:28, tmp#2, ?tmp#1 @list:21:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(y @list:21:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:21:10, ?#result @list:20:5)


[] > public {test} (0 calls)
0: [](xs:_(T) @list:31:21, idx:int @list:31:30, ?#result:T @list:31:5):
    >=(idx @list:32:5, 0 @list:32:13)
    index1(xs @list:33:17, idx @list:33:21, ?tmp#0 @list:33:10)
    =(?x @list:33:6, tmp#0)
    foreign llvm move(x @list:31:43, ?#result @list:31:5)


all > public {test} (0 calls)
0: all(p:{test}(T) @list:61:20, xs:_(T) @list:61:33):
    foreign llvm move(xs @list:62:15, ?tmp#0)
    do {
        if {[|](?x @list:62:10, ?tmp#0, tmp#0)::

            p(x @list:63:11)
        else::
            break

        }
    }


any > public {test} (0 calls)
0: any(p:{test}(T) @list:69:20, xs:_(T) @list:69:33):
    [|](?x @list:70:7, ?xs @list:70:12, xs @list:70:18)
    (   p(x @list:71:8)
    | any(p @list:71:17, xs @list:71:20))


empty > public {test} (0 calls)
0: empty(xs:_(T) @list:15:22):
    if {[|](?tmp#0 @list:16:11, ?tmp#1 @list:16:15, xs @list:16:20)::

        fail
    else::
        pass

    }


filter > public (0 calls)
0: filter(p:{test}(T) @list:95:16, !xs:_(T) @list:95:30):
    [](?tmp#0 @list:96:12)
    =(?out @list:96:6, tmp#0)
    foreign llvm move(xs @list:97:15, ?tmp#1)
    do {
        if {[|](?x @list:97:10, ?tmp#1, tmp#1)::

            if {p(x @list:98:16)::

                [|](x @list:98:30, out @list:98:34, ?tmp#2 @list:98:29)
                =(?out @list:98:23, tmp#2)
            else::
                pass

            }
        else::
            break

        }
    }
    reverse(out @list:100:19, ?tmp#3 @list:100:11)
    =(?as @list:100:6, tmp#3)


foldl > public (0 calls)
0: foldl(f:(A, !B) @list:77:15, as:_(A) @list:77:26, !b:B @list:77:36):
    foreign llvm move(as @list:78:15, ?tmp#0)
    do {
        if {[|](?a @list:78:10, ?tmp#0, tmp#0)::

            f(a @list:79:11, !b @list:79:15)
        else::
            break

        }
    }


foldr > public (0 calls)
0: foldr(f:(A, !B) @list:86:15, as:_(A) @list:86:26, !b:B @list:86:36):
    if {[|](?a @list:87:12, ?as @list:87:17, as @list:87:23)::

        foldr(f @list:88:15, as @list:88:18, !b @list:88:23)
        f(a @list:89:11, !b @list:89:15)
    else::
        pass

    }


index1 > {test} (0 calls)
0: index1(xs:_(T) @list:148:19, idx:int @list:148:28, ?#result:T @list:148:1):
    [|](?x @list:149:7, ?xs @list:149:12, xs @list:149:18)
    (   =(idx @list:150:6, 0 @list:150:12)
    | (   -(idx @list:150:27, 1 @list:150:33, ?tmp#0 @list:150:27)
        & index1(xs @list:150:23, tmp#0, ?x @list:150:37)))
    foreign llvm move(x @list:148:41, ?#result @list:148:1)


length > public (0 calls)
0: length(x:_(T) @list:24:16, ?#result:int @list:24:5):
    length1(x @list:24:38, 0 @list:24:41, ?tmp#0 @list:24:30)
    foreign llvm move(tmp#0, ?#result @list:24:5)


length1 > (0 calls)
0: length1(x:_(T) @list:140:13, acc:int @list:140:21, ?#result:int @list:140:1):
    if {[|](?h @list:141:16, ?t @list:141:21, x @list:141:10)::

        +(acc @list:141:38, 1 @list:141:44, ?tmp#2 @list:141:38)
        length1(t @list:141:35, tmp#2, ?tmp#1 @list:141:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(acc @list:141:57, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:141:10, ?#result @list:140:1)


list > public (0 calls)
0: list(ar:array(T) @list:128:14, ?#result:_(T) @list:128:5):
    [](?tmp#0 @list:129:11)
    =(?ls @list:129:6, tmp#0)
    foreign llvm move(ar @list:130:15, ?tmp#1)
    do {
        if {[|](?x @list:130:10, ?tmp#1, tmp#1)::

            [|](x @list:131:16, ls @list:131:20, ?tmp#2 @list:131:15)
            =(?ls @list:131:10, tmp#2)
        else::
            break

        }
    }
    reverse(ls @list:133:13, ?ls @list:133:18)
    foreign llvm move(ls @list:128:34, ?#result @list:128:5)


map > public (0 calls)
0: map(f:{resource}(T) @list:41:13, xs:_(T) @list:41:30):
    foreign llvm move(xs @list:42:15, ?tmp#0)
    do {
        if {[|](?x @list:42:10, ?tmp#0, tmp#0)::

            !f(x @list:43:12)
        else::
            break

        }
    }
map > public (0 calls)
1: map(f:(A, ?B) @list:49:13, as:_(A) @list:49:24, ?#result:_(B) @list:49:5):
    if {[|](?a @list:50:12, ?as @list:50:17, as @list:50:23)::

        f(a @list:50:33, ?tmp#2 @list:50:31)
        map(f @list:50:42, as @list:50:45, ?tmp#3 @list:50:38)
        [|](tmp#2, tmp#3, ?tmp#1 @list:50:29)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:50:61)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:50:10, ?#result @list:49:5)
map > public (0 calls)
2: map(f:(A, B, ?C) @list:55:13, as:_(A) @list:55:27, bs:_(B) @list:55:36, ?#result:_(C) @list:55:5):
    if {(   [|](?a @list:56:12, ?as @list:56:17, as @list:56:23)
        & [|](?b @list:56:30, ?bs @list:56:35, bs @list:56:41))::

        f(a @list:56:51, b @list:56:54, ?tmp#2 @list:56:49)
        map(f @list:56:63, as @list:56:66, bs @list:56:70, ?tmp#3 @list:56:59)
        [|](tmp#2, tmp#3, ?tmp#1 @list:56:47)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:57:47)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:56:10, ?#result @list:55:5)


print > public (0 calls)
0: print(printer:{resource}(T) @list:108:15, xs:_(T) @list:108:38) use !io:
    !print('[' @list:109:12)
    if {[|](?x @list:110:12, ?xs @list:110:17, xs @list:110:23)::

        !printer(x @list:111:18)
        !print1(printer @list:112:17, xs @list:112:26)
    else::
        pass

    }
    !print(']' @list:114:12)


print1 > (0 calls)
0: print1(printer:{resource}(T) @list:154:12, xs:_(T) @list:154:35) use !io:
    if {[|](?x @list:155:12, ?xs @list:155:17, xs @list:155:23)::

        !print(',' @list:156:16)
        !printer(x @list:157:18)
        !print1(printer @list:158:17, xs @list:158:26)
    else::
        pass

    }


println > public (0 calls)
0: println(printer:{resource}(T) @list:119:17, xs:_(T) @list:119:40) use !io:
    !print(printer @list:120:12, xs @list:120:21)
    !nl


reverse > public (0 calls)
0: reverse(x:_(T) @list:27:17, ?#result:_(T) @list:27:5):
    [](?tmp#1 @list:27:44)
    reverse1(x @list:27:41, tmp#1, ?tmp#0 @list:27:32)
    foreign llvm move(tmp#0, ?#result @list:27:5)


reverse1 > (0 calls)
0: reverse1(x:_(T) @list:144:14, tail:_(T) @list:144:22, ?#result:_(T) @list:144:1):
    if {[|](?h @list:145:16, ?t @list:145:21, x @list:145:10)::

        [|](h @list:145:40, tail @list:145:44, ?tmp#2 @list:145:39)
        reverse1(t @list:145:36, tmp#2, ?tmp#1 @list:145:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(tail @list:145:61, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:145:10, ?#result @list:144:1)

LLVM code       : None

--------------------------------------------------
 Module wybe.machine_word
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.machine_word.word_size_bits<0>
                    wybe.machine_word.word_size_bytes<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

word_size_bits > public {inline} (0 calls)
0: wybe.machine_word.word_size_bits<0>
word_size_bits(?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(64:wybe.int, ?#result##0:wybe.int) @machine_word:12:5


word_size_bytes > public {inline} (1 calls)
0: wybe.machine_word.word_size_bytes<0>
word_size_bytes(?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(8:wybe.int, ?#result##0:wybe.int) @machine_word:10:5

LLVM code       : None

--------------------------------------------------
 Module wybe.memory_management
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.memory_management.<0>
                    wybe.memory_management.malloc_count<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

module top-level code > public {inline,semipure} (0 calls)
0: wybe.memory_management.<0>
()<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c {impure} gc_init @memory_management:15:1


malloc_count > public {inline,semipure} (0 calls)
0: wybe.memory_management.malloc_count<0>
malloc_count(?x##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c {impure} malloc_count(?x##0:wybe.int) @memory_management:12:5

LLVM code       : None

--------------------------------------------------
 Module wybe.phantom
 modifiers       : {unique} 
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : 
  imports         : 
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.predicate
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.predicate.const<0>
                    wybe.predicate.id<0>
  imports         : 
  resources       : 
  procs           : 

const > public {inline} (0 calls)
0: wybe.predicate.const<0>
const(a##0:A <{}; {}; {0}>, [b##0:B <{}; {}; {1}>], ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:8:5


id > public {inline} (0 calls)
0: wybe.predicate.id<0>
id(a##0:A <{}; {}; {0}>, ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:6:5

LLVM code       : None

--------------------------------------------------
 Module wybe.range
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.range...<0>
                    wybe.range.=<0>
                    wybe.range.[]<0>
                    wybe.range.[|]<0>
                    wybe.range.end<0>
                    wybe.range.end<1>
                    wybe.range.irange<0>
                    wybe.range.range<0>
                    wybe.range.range<1>
                    wybe.range.size<0>
                    wybe.range.start<0>
                    wybe.range.start<1>
                    wybe.range.stride<0>
                    wybe.range.stride<1>
                    wybe.range.xrange<0>
                    wybe.range.~=<0>
  imports         : use wybe.bool
                    use wybe.int
  resources       : 
  procs           : 

.. > public (0 calls)
0: ..(start:int @range:38:10, end:int @range:38:23, ?#result:_ @range:38:5):
    if {<=(start @range:39:27, end @range:39:37)::

        foreign llvm move(1 @range:39:44, ?tmp#1)
    else::
        foreign llvm move(-1 @range:39:56, ?tmp#1)

    }
    construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)
    foreign llvm move(tmp#0, ?#result @range:38:5)


= > public {test,inline} (0 calls)
0: =(#left:_, #right:_):
    if {(   foreign llvm icmp_uge(#left:!wybe.int, 0, ?tmp#0:!wybe.bool)
        & testbool tmp#0:!wybe.bool)::

        (   range(?#left#start, ?#left#stride, ?#left#end, #left)
        & range(?#right#start, ?#right#stride, ?#right#end, #right)
        & =(#left#start, #right#start)
        & =(#left#stride, #right#stride)
        & =(#left#end, #right#end))
    else::
        fail

    }


[] > public {test} (0 calls)
0: [](r:_ @range:20:19, idx:int @range:20:24, ?value:int @range:20:34):
    <=(0 @range:21:6, idx @range:21:12)
    range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)
    *(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)
    +(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)
    =(?value @range:23:6, tmp#0)
    if {<=(0 @range:24:10, stride @range:24:16)::

        <(value @range:24:27, end @range:24:35)
    else::
        <(end @range:24:51, value @range:24:57)

    }


[|] > public {test} (0 calls)
0: [|](?value:int @range:12:23, ?rest:_ @range:12:35, current:_ @range:12:43):
    range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)
    ~=(value @range:14:6, end @range:14:16)
    +(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)
    range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)
    =(?rest @range:15:6, tmp#0)


construct > (0 calls)
0: construct(start:int @range:49:15, stride:int @range:49:26, end:int @range:49:38, ?#result:_ @range:49:1):
    -(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)
    %(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)
    =(?diff @range:50:6, tmp#0)
    if {<=(0 @range:51:19, stride @range:51:25)::

        if {=(diff @range:52:26, 0 @range:52:33)::

            max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
            -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
            max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
            foreign llvm move(tmp#5, ?tmp#3)

        }
        foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
    else::
        if {=(diff @range:55:26, 0 @range:55:33)::

            min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
            foreign llvm move(tmp#9, ?tmp#8)
        else::
            +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
            min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
            foreign llvm move(tmp#10, ?tmp#8)

        }
        foreign llvm move(tmp#8 @range:55:26, ?tmp#2)

    }
    =(?final @range:51:6, tmp#2 @range:51:19)
    range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)
    =(?r @range:58:6, tmp#12)
    foreign llvm move(r @range:49:51, ?#result @range:49:1)


end > public {inline} (0 calls)
0: end(#rec:_ @range:8:46, ?#result:int @range:8:46):
    foreign lpvm access(#rec:_ @range:8:46, 16, 24, 0, ?#result:int @range:8:46)
end > public {inline} (0 calls)
1: end(!#rec:_ @range:8:46, #field:int @range:8:46):
    foreign lpvm {noalias} mutate(#rec:_ @range:8:46, ?#rec:_ @range:8:46, 16, 0, 24, 0, #field)


irange > public (0 calls)
0: irange(start:int @range:32:16, stride:int @range:32:27, end:int @range:32:39, ?#result:_ @range:32:5):
    if {<(stride @range:33:41, 0 @range:33:50)::

        foreign llvm move(-1 @range:33:55, ?tmp#2)
    else::
        foreign llvm move(1 @range:33:68, ?tmp#2)

    }
    +(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)
    construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)
    foreign llvm move(tmp#0, ?#result @range:32:5)


range > public {inline} (0 calls)
0: range(start:int @range:8:23, stride:int @range:8:34, end:int @range:8:46, ?#result:_ @range:8:17):
    foreign lpvm alloc(24, ?#rec:_ @range:8:17)
    foreign lpvm mutate(#rec:_ @range:8:17, ?#rec:_ @range:8:17, 0, 1, 24, 0, start:int @range:8:23)
    foreign lpvm mutate(#rec:_ @range:8:17, ?#rec:_ @range:8:17, 8, 1, 24, 0, stride:int @range:8:34)
    foreign lpvm mutate(#rec:_ @range:8:17, ?#rec:_ @range:8:17, 16, 1, 24, 0, end:int @range:8:46)
    foreign llvm or(#rec:_ @range:8:17, 0, ?#result:_ @range:8:17)
range > public {inline} (0 calls)
1: range(?start:int @range:8:23, ?stride:int @range:8:34, ?end:int @range:8:46, #result:_ @range:8:17):
    pass
    foreign lpvm access(#result:_ @range:8:17, 0, 24, 0, ?start:int @range:8:23)
    foreign lpvm access(#result:_ @range:8:17, 8, 24, 0, ?stride:int @range:8:34)
    foreign lpvm access(#result:_ @range:8:17, 16, 24, 0, ?end:int @range:8:46)


size > public (0 calls)
0: size(r:_ @range:42:14, ?#result:int @range:42:5):
    range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)
    if {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
        & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
        & signum(tmp#3, ?tmp#2 @range:44:29)
        & ~=(tmp#1, tmp#2))::

        foreign llvm move(0 @range:44:52, ?tmp#0)
    else::
        if {<=(0 @range:45:10, stride @range:45:16)::

            -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
            -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
            /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
            +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
            foreign llvm move(tmp#5, ?tmp#4)
        else::
            -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
            -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
            -(stride @range:46:39, ?tmp#13 @range:46:38)
            /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
            +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
            foreign llvm move(tmp#9, ?tmp#4)

        }
        foreign llvm move(tmp#4 @range:45:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)


start > public {inline} (0 calls)
0: start(#rec:_ @range:8:23, ?#result:int @range:8:23):
    foreign lpvm access(#rec:_ @range:8:23, 0, 24, 0, ?#result:int @range:8:23)
start > public {inline} (0 calls)
1: start(!#rec:_ @range:8:23, #field:int @range:8:23):
    foreign lpvm {noalias} mutate(#rec:_ @range:8:23, ?#rec:_ @range:8:23, 0, 0, 24, 0, #field)


stride > public {inline} (0 calls)
0: stride(#rec:_ @range:8:34, ?#result:int @range:8:34):
    foreign lpvm access(#rec:_ @range:8:34, 8, 24, 0, ?#result:int @range:8:34)
stride > public {inline} (0 calls)
1: stride(!#rec:_ @range:8:34, #field:int @range:8:34):
    foreign lpvm {noalias} mutate(#rec:_ @range:8:34, ?#rec:_ @range:8:34, 8, 0, 24, 0, #field)


xrange > public (0 calls)
0: xrange(start:int @range:28:16, stride:int @range:28:27, end:int @range:28:39, ?#result:_ @range:28:5):
    construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)
    foreign llvm move(tmp#0, ?#result @range:28:5)


~= > public {test,inline} (0 calls)
0: ~=(#left:_, #right:_):
    ~(=(#left:_, #right:_))

LLVM code       : None

--------------------------------------------------
 Module wybe.string
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.string.,,<0>
                    wybe.string.<<0>
                    wybe.string.<=<0>
                    wybe.string.<=><0>
                    wybe.string.=<0>
                    wybe.string.><0>
                    wybe.string.>=<0>
                    wybe.string.[]<0>
                    wybe.string.[]<1>
                    wybe.string.[|]<0>
                    wybe.string.c_string<0>
                    wybe.string.length<0>
                    wybe.string.print<0>
                    wybe.string.println<0>
                    wybe.string.read<0>
                    wybe.string.string<0>
                    wybe.string.string<1>
                    wybe.string.~=<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.char
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
                    use wybe.range
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_ @string:64:10, y:_ @string:64:17, ?#result:_ @string:64:5):
    if {(   empty(?tmp#1 @string:65:14)
        & =(x @string:65:10, tmp#1))::

        foreign llvm move(y @string:65:23, ?tmp#0)
    else::
        if {(   empty(?tmp#3 @string:66:14)
            & =(y @string:66:10, tmp#3))::

            foreign llvm move(x @string:66:23, ?tmp#2)
        else::
            concat(x @string:67:25, y @string:67:28, ?tmp#4 @string:67:18)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:66:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:65:10, ?#result @string:64:5)


< > public (0 calls)
0: <(x:_ @string:119:10, y:_ @string:119:17, ?#result:bool @string:119:5):
    <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
    equal(?tmp#2 @string:119:44)
    <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
    foreign llvm move(tmp#0, ?#result @string:119:5)


<= > public (0 calls)
0: <=(x:_ @string:120:10, y:_ @string:120:18, ?#result:bool @string:120:5):
    <=>(x @string:120:31, y @string:120:39, ?tmp#1 @string:120:31)
    equal(?tmp#2 @string:120:46)
    <=(tmp#1, tmp#2, ?tmp#0 @string:120:30)
    foreign llvm move(tmp#0, ?#result @string:120:5)


<=> > public (0 calls)
0: <=>(x:_ @string:125:10, y:_ @string:125:20, ?#result:comparison @string:125:5):
    equal(?tmp#0 @string:126:10)
    =(?c @string:126:6, tmp#0)
    foreign llvm move(x @string:127:16, ?tmp#1)
    foreign llvm move(y @string:127:26, ?tmp#2)
    do {
        if {[|](?cx @string:127:10, ?tmp#1, tmp#1)::

            if {[|](?cy @string:127:20, ?tmp#2, tmp#2)::

                if {<(cx @string:128:14, cy @string:128:19)::

                    lesser(?tmp#3 @string:128:30)
                    =(?c @string:128:26, tmp#3)
                    break
                else::
                    if {>(cx @string:129:14, cy @string:129:19)::

                        greater(?tmp#4 @string:129:30)
                        =(?c @string:129:26, tmp#4)
                        break
                    else::
                        pass

                    }

                }
            else::
                break

            }
        else::
            break

        }
    }
    if {(   equal(?tmp#5 @string:132:14)
        & =(c @string:132:10, tmp#5))::

        length(x @string:133:22, ?tmp#6 @string:133:15)
        =(?lx @string:133:10, tmp#6)
        length(y @string:134:22, ?tmp#7 @string:134:15)
        =(?ly @string:134:10, tmp#7)
        if {<(lx @string:135:14, ly @string:135:19)::

            lesser(?tmp#8 @string:135:30)
            =(?c @string:135:26, tmp#8)
        else::
            if {>(lx @string:135:39, ly @string:135:44)::

                greater(?tmp#9 @string:135:55)
                =(?c @string:135:51, tmp#9)
            else::
                pass

            }

        }
    else::
        pass

    }
    foreign llvm move(c @string:125:38, ?#result @string:125:5)


= > public (0 calls)
0: =(x:_ @string:115:10, y:_ @string:115:17, ?#result:bool @string:115:5):
    <=>(x @string:115:30, y @string:115:38, ?tmp#1 @string:115:30)
    equal(?tmp#2 @string:115:44)
    =(tmp#1, tmp#2, ?tmp#0 @string:115:29)
    foreign llvm move(tmp#0, ?#result @string:115:5)


> > public (0 calls)
0: >(x:_ @string:121:10, y:_ @string:121:17, ?#result:bool @string:121:5):
    <=>(x @string:121:30, y @string:121:38, ?tmp#1 @string:121:30)
    equal(?tmp#2 @string:121:44)
    >(tmp#1, tmp#2, ?tmp#0 @string:121:29)
    foreign llvm move(tmp#0, ?#result @string:121:5)


>= > public (0 calls)
0: >=(x:_ @string:122:10, y:_ @string:122:18, ?#result:bool @string:122:5):
    <=>(x @string:122:31, y @string:122:39, ?tmp#1 @string:122:31)
    equal(?tmp#2 @string:122:46)
    >=(tmp#1, tmp#2, ?tmp#0 @string:122:30)
    foreign llvm move(tmp#0, ?#result @string:122:5)


[] > public {test} (0 calls)
0: [](s:_ @string:91:19, idx:int @string:91:24, ?c:char @string:91:34):
    if {buffer(?len @string:93:17, ?str @string:93:23, s @string:92:10)::

        <=(0 @string:94:14, idx @string:94:20)
        <(idx @string:95:14, len @string:95:20)
        unsafe_c_string_index(str @string:96:35, idx @string:96:40, ?c @string:96:46)
    else::
        if {concat(?left @string:97:17, ?right @string:97:24, s @string:92:10)::

            length(left @string:98:32, ?tmp#0 @string:98:25)
            =(?left_len @string:98:14, tmp#0)
            if {<(idx @string:99:18, left_len @string:99:24)::

                [](left @string:99:41, idx @string:99:46, ?tmp#1 @string:99:41)
                =(?c @string:99:37, tmp#1)
            else::
                -(idx @string:100:37, left_len @string:100:43, ?tmp#3 @string:100:37)
                [](right @string:100:31, tmp#3, ?tmp#2 @string:100:31)
                =(?c @string:100:27, tmp#2)

            }
        else::
            if {slice(?base @string:102:16, ?range @string:102:23, s @string:92:10)::

                [](range @string:102:43, idx @string:102:49, ?tmp#5 @string:102:43)
                [](base @string:102:38, tmp#5, ?tmp#4 @string:102:38)
                =(?c @string:102:34, tmp#4)
            else::
                if {singleton(?c @string:103:20, s @string:92:10)::

                    =(idx @string:103:27, 0 @string:103:33)
                else::
                    fail

                }

            }

        }

    }
[] > public (0 calls)
1: [](s:_ @string:109:12, r:range @string:109:17, ?#result:_ @string:109:5):
    slice(s @string:109:36, r @string:109:39, ?tmp#0 @string:109:30)
    foreign llvm move(tmp#0, ?#result @string:109:5)


[|] > public {test} (0 calls)
0: [|](?head:char @string:71:23, ?tail:_ @string:71:35, s:_ @string:71:43):
    if {buffer(?len @string:73:17, ?str @string:73:23, s @string:72:10)::

        [|](?head @string:74:15, ?str @string:74:23, str @string:74:30)
        if {=(len @string:75:26, 1 @string:75:32)::

            empty(?tmp#1 @string:75:37)
            foreign llvm move(tmp#1, ?tmp#0)
        else::
            -(len @string:75:60, 1 @string:75:66, ?tmp#3 @string:75:60)
            buffer(tmp#3, str @string:75:69, ?tmp#2 @string:75:53)
            foreign llvm move(tmp#2, ?tmp#0)

        }
        =(?tail @string:75:14, tmp#0 @string:75:26)
    else::
        if {concat(?left @string:76:17, ?right @string:76:24, s @string:72:10)::

            if {[|](?head @string:77:20, ?t @string:77:28, left @string:77:33)::

                concat(t @string:77:56, right @string:77:59, ?tmp#4 @string:77:49)
                =(?tail @string:77:42, tmp#4)
            else::
                [|](?head @string:78:28, ?tail @string:78:36, right @string:78:44)

            }
        else::
            if {slice(?base @string:80:16, ?range @string:80:23, s @string:72:10)::

                do {
                    [|](?idx @string:82:19, ?range @string:82:26, range @string:82:35)
                    if {(   [](base @string:83:30, idx @string:83:35, ?tmp#5 @string:83:30)
                        & =(?head @string:83:23, tmp#5))::

                        slice(base @string:83:57, range @string:83:63, ?tmp#6 @string:83:51)
                        =(?tail @string:83:44, tmp#6)
                        break
                    else::
                        pass

                    }
                }
            else::
                if {singleton(?head @string:85:20, s @string:72:10)::

                    empty(?tmp#7 @string:85:37)
                    =(?tail @string:85:30, tmp#7)
                else::
                    fail

                }

            }

        }

    }


c_string > public (0 calls)
0: c_string(s:_ @string:40:18, ?#result:c_string @string:40:5):
    if {buffer(?tmp#0 @string:41:21, ?str @string:41:25, s @string:41:10)::

        pass
    else::
        length(s @string:43:27, ?tmp#2 @string:43:20)
        +(tmp#2, 1 @string:43:32, ?tmp#1 @string:43:20)
        =(?len @string:43:14, tmp#1)
        foreign lpvm alloc(len @string:44:32, ?str @string:44:38)
        true(?tmp#3 @string:45:49)
        foreign lpvm mutate(str @string:45:33, ?str @string:45:39, len @string:45:44, tmp#3, len @string:45:55, 0 @string:45:60, '\NUL' @string:45:63)
        =(?offset @string:46:14, 0 @string:46:23)
        pack(s @string:47:18, !str @string:47:22, len @string:47:27, !offset @string:47:33)

    }
    foreign llvm move(str @string:40:34, ?#result @string:40:5)


fixed_range_size > (0 calls)
0: fixed_range_size(hi:int @string:184:22, r:range @string:184:30, ?sz:int @string:184:40):
    range(?start @string:185:16, ?stride @string:185:24, ?end @string:185:33, r @string:185:5)
    if {<=(0 @string:186:10, stride @string:186:16)::

        -(start @string:187:39, ?tmp#4 @string:187:38)
        /(tmp#4, stride @string:187:47, ?tmp#3 @string:187:38)
        *(tmp#3, stride @string:187:56, ?tmp#2 @string:187:38)
        +(start @string:187:30, tmp#2, ?tmp#1 @string:187:30)
        max(start @string:187:23, tmp#1, ?tmp#0 @string:187:19)
        =(?lo @string:187:14, tmp#0)
        min(hi @string:188:23, end @string:188:27, ?tmp#5 @string:188:19)
        =(?hi @string:188:14, tmp#5)
    else::
        max(-1 @string:190:23, end @string:190:27, ?tmp#6 @string:190:19)
        =(?lo @string:190:14, tmp#6)
        +(hi @string:191:30, stride @string:191:35, ?tmp#10 @string:191:30)
        -(start @string:191:45, hi @string:191:53, ?tmp#13 @string:191:45)
        -(tmp#13, 1 @string:191:58, ?tmp#12 @string:191:45)
        -(stride @string:191:64, ?tmp#14 @string:191:63)
        %(tmp#12, tmp#14, ?tmp#11 @string:191:44)
        +(tmp#10, tmp#11, ?tmp#9 @string:191:30)
        +(tmp#9, 1 @string:191:73, ?tmp#8 @string:191:30)
        min(start @string:191:23, tmp#8, ?tmp#7 @string:191:19)
        =(?hi @string:191:14, tmp#7)
        -(stride @string:192:24, ?tmp#15 @string:192:23)
        =(?stride @string:192:14, tmp#15)

    }
    if {<=(hi @string:194:16, lo @string:194:23)::

        foreign llvm move(0 @string:194:29, ?tmp#16)
    else::
        -(hi @string:194:42, lo @string:194:47, ?tmp#20 @string:194:42)
        -(tmp#20, 1 @string:194:52, ?tmp#19 @string:194:42)
        /(tmp#19, stride @string:194:57, ?tmp#18 @string:194:41)
        +(tmp#18, 1 @string:194:66, ?tmp#17 @string:194:41)
        foreign llvm move(tmp#17, ?tmp#16)

    }
    =(?sz @string:194:6, tmp#16 @string:194:16)


length > public (0 calls)
0: length(s:_ @string:52:16, ?#result:int @string:52:5):
    if {buffer(?len @string:53:22, ?tmp#1 @string:53:27, s @string:53:10)::

        foreign llvm move(len @string:53:33, ?tmp#0)
    else::
        if {concat(?left @string:54:22, ?right @string:54:29, s @string:54:10)::

            length(left @string:54:46, ?tmp#4 @string:54:39)
            length(right @string:54:61, ?tmp#5 @string:54:54)
            +(tmp#4, tmp#5, ?tmp#3 @string:54:39)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            if {slice(?base @string:55:21, ?range @string:55:28, s @string:55:10)::

                length(base @string:55:62, ?tmp#8 @string:55:55)
                fixed_range_size(tmp#8, range @string:55:69, ?tmp#7 @string:55:38)
                foreign llvm move(tmp#7, ?tmp#6)
            else::
                if {singleton(?tmp#10 @string:56:24, s @string:56:10)::

                    foreign llvm move(1 @string:56:30, ?tmp#9)
                else::
                    foreign llvm move(0 @string:57:18, ?tmp#9)

                }
                foreign llvm move(tmp#9 @string:56:10, ?tmp#6)

            }
            foreign llvm move(tmp#6 @string:55:10, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:54:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:53:10, ?#result @string:52:5)


pack > (0 calls)
0: pack(s:_ @string:160:10, !raw:c_string @string:160:16, size:int @string:160:30, !offset:int @string:160:41):
    if {buffer(?tmp#0 @string:162:16, ?str @string:162:20, s @string:161:10)::

        foreign llvm move(str @string:163:23, ?tmp#1)
        do {
            if {[|](?c @string:163:18, ?tmp#1, tmp#1)::

                true(?tmp#2 @string:164:56)
                foreign lpvm mutate(raw @string:164:37, ?raw @string:164:43, offset @string:164:48, tmp#2, size @string:164:62, 0 @string:164:68, c @string:164:71)
                incr(!offset @string:165:23)
            else::
                break

            }
        }
    else::
        if {concat(?left @string:167:17, ?right @string:167:24, s @string:161:10)::

            pack(left @string:168:18, !raw @string:168:25, size @string:168:30, !offset @string:168:37)
            pack(right @string:169:18, !raw @string:169:26, size @string:169:31, !offset @string:169:38)
            incr(!offset @string:170:19)
        else::
            if {slice(?tmp#3 @string:171:15, ?tmp#4 @string:171:18, s @string:161:10)::

                foreign llvm move(s @string:172:23, ?tmp#5)
                do {
                    if {[|](?c @string:172:18, ?tmp#5, tmp#5)::

                        true(?tmp#6 @string:173:56)
                        foreign lpvm mutate(raw @string:173:37, ?raw @string:173:43, offset @string:173:48, tmp#6, size @string:173:62, 0 @string:173:68, c @string:173:71)
                        incr(!offset @string:174:23)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:176:20, s @string:161:10)::

                    true(?tmp#7 @string:177:52)
                    foreign lpvm mutate(raw @string:177:33, ?raw @string:177:39, offset @string:177:44, tmp#7, size @string:177:58, 0 @string:177:64, c @string:177:67)
                    incr(!offset @string:178:19)
                else::
                    fail

                }

            }

        }

    }


print > public (0 calls)
0: print(x:_ @string:142:15) use !io:
    if {buffer(?tmp#0 @string:144:16, ?str @string:144:20, x @string:143:10)::

        !print(str @string:144:35)
    else::
        if {concat(?left @string:145:17, ?right @string:145:24, x @string:143:10)::

            !print(left @string:145:41)
            !print(right @string:145:55)
        else::
            if {slice(?tmp#1 @string:146:15, ?tmp#2 @string:146:18, x @string:143:10)::

                foreign llvm move(x @string:146:34, ?tmp#3)
                do {
                    if {[|](?c @string:146:29, ?tmp#3, tmp#3)::

                        !print(c @string:146:45)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:147:20, x @string:143:10)::

                    !print(c @string:147:33)
                else::
                    fail

                }

            }

        }

    }


println > public (0 calls)
0: println(x:_ @string:151:17) use !io:
    !print(x @string:151:39)
    !nl


read > public (0 calls)
0: read(?x:_ @string:153:15) use !io:
    !read(?str:c_string @string:153:37)
    string(str @string:153:64, ?tmp#0 @string:153:57)
    =(?x @string:153:53, tmp#0)


string > public (0 calls)
0: string(str:c_string @string:28:16, ?#result:_ @string:28:5):
    length(str @string:29:19, ?tmp#0 @string:29:12)
    =(?len @string:29:6, tmp#0)
    if {=(len @string:30:15, 0 @string:30:21)::

        empty(?tmp#2 @string:30:26)
        foreign llvm move(tmp#2, ?tmp#1)
    else::
        if {=(len @string:31:15, 1 @string:31:21)::

            foreign lpvm access(str @string:31:56, 0 @string:31:61, 1 @string:31:64, 0 @string:31:67, ?tmp#5 @string:31:36)
            singleton(tmp#5, ?tmp#4 @string:31:26)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            buffer(len @string:32:33, str @string:32:38, ?tmp#6 @string:32:26)
            foreign llvm move(tmp#6, ?tmp#3)

        }
        foreign llvm move(tmp#3 @string:31:15, ?tmp#1)

    }
    =(?s @string:30:6, tmp#1 @string:30:15)
    foreign llvm move(s @string:28:34, ?#result @string:28:5)
string > public (0 calls)
1: string(c:char @string:37:16, ?#result:_ @string:37:5):
    singleton(c @string:37:38, ?tmp#0 @string:37:28)
    foreign llvm move(tmp#0, ?#result @string:37:5)


~= > public (0 calls)
0: ~=(x:_ @string:116:10, y:_ @string:116:18, ?#result:bool @string:116:5):
    <=>(x @string:116:31, y @string:116:39, ?tmp#1 @string:116:31)
    equal(?tmp#2 @string:116:46)
    ~=(tmp#1, tmp#2, ?tmp#0 @string:116:30)
    foreign llvm move(tmp#0, ?#result @string:116:5)

LLVM code       : None

Types: **** Validating parameter types in module wybe.range
Types: Validating def of ..
Types: Checking type int of param start:int
Types: Param is start:wybe.int
Types: Checking type int of param end:int
Types: Param is end:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.range
Types: Validating def of =
Types: Checking type _ of param #left:_
Types: Param is #left:wybe.range
Types: Checking type _ of param #right:_
Types: Param is #right:wybe.range
Types: Validating def of []
Types: Checking type _ of param r:_
Types: Param is r:wybe.range
Types: Checking type int of param idx:int
Types: Param is idx:wybe.int
Types: Checking type int of param ?value:int
Types: Param is ?value:wybe.int
Types: Validating def of [|]
Types: Checking type int of param ?value:int
Types: Param is ?value:wybe.int
Types: Checking type _ of param ?rest:_
Types: Param is ?rest:wybe.range
Types: Checking type _ of param current:_
Types: Param is current:wybe.range
Types: Validating def of construct
Types: Checking type int of param start:int
Types: Param is start:wybe.int
Types: Checking type int of param stride:int
Types: Param is stride:wybe.int
Types: Checking type int of param end:int
Types: Param is end:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.range
Types: Validating def of end
Types: Checking type _ of param #rec:_
Types: Param is #rec:wybe.range
Types: Checking type int of param ?#result:int
Types: Param is ?#result:wybe.int
Types: Validating def of end
Types: Checking type _ of param !#rec:_
Types: Param is !#rec:wybe.range
Types: Checking type int of param #field:int
Types: Param is #field:wybe.int
Types: Validating def of irange
Types: Checking type int of param start:int
Types: Param is start:wybe.int
Types: Checking type int of param stride:int
Types: Param is stride:wybe.int
Types: Checking type int of param end:int
Types: Param is end:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.range
Types: Validating def of range
Types: Checking type int of param start:int
Types: Param is start:wybe.int
Types: Checking type int of param stride:int
Types: Param is stride:wybe.int
Types: Checking type int of param end:int
Types: Param is end:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.range
Types: Validating def of range
Types: Checking type int of param ?start:int
Types: Param is ?start:wybe.int
Types: Checking type int of param ?stride:int
Types: Param is ?stride:wybe.int
Types: Checking type int of param ?end:int
Types: Param is ?end:wybe.int
Types: Checking type _ of param #result:_
Types: Param is #result:wybe.range
Types: Validating def of size
Types: Checking type _ of param r:_
Types: Param is r:wybe.range
Types: Checking type int of param ?#result:int
Types: Param is ?#result:wybe.int
Types: Validating def of start
Types: Checking type _ of param #rec:_
Types: Param is #rec:wybe.range
Types: Checking type int of param ?#result:int
Types: Param is ?#result:wybe.int
Types: Validating def of start
Types: Checking type _ of param !#rec:_
Types: Param is !#rec:wybe.range
Types: Checking type int of param #field:int
Types: Param is #field:wybe.int
Types: Validating def of stride
Types: Checking type _ of param #rec:_
Types: Param is #rec:wybe.range
Types: Checking type int of param ?#result:int
Types: Param is ?#result:wybe.int
Types: Validating def of stride
Types: Checking type _ of param !#rec:_
Types: Param is !#rec:wybe.range
Types: Checking type int of param #field:int
Types: Param is #field:wybe.int
Types: Validating def of xrange
Types: Checking type int of param start:int
Types: Param is start:wybe.int
Types: Checking type int of param stride:int
Types: Param is stride:wybe.int
Types: Checking type int of param end:int
Types: Param is end:wybe.int
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.range
Types: Validating def of ~=
Types: Checking type _ of param #left:_
Types: Param is #left:wybe.range
Types: Checking type _ of param #right:_
Types: Param is #right:wybe.range
Types: **** Re-exiting module wybe.range
Types: **** Type checking modules wybe.range
Types: **** Strongly connected components:
Types:     wybe.range.stride
Types:     wybe.range.start
Types:     wybe.range.range
Types:     wybe.range.end
Types:     wybe.range.=
Types:     wybe.range.[]
Types:     wybe.range.construct
Types:     wybe.range.irange
Types:     wybe.range.xrange
Types:     wybe.range.~=
Types:     wybe.range.[|]
Types:     wybe.range.size
Types:     wybe.range...
Types: Type checking non-recursive proc wybe.range.stride
Types: ** Type checking decl of proc stride
Types: found 2 definition(s)
Types: Type checking stride
Types: ** Type checking stride: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm access(#rec:_ @range:8:34, 8, 24, 0, ?#result:int @range:8:34)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#rec","#result"]
Types: Recording parameter types: #rec:wybe.range, ?#result:wybe.int
Types:     type of '#rec' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm access(#rec:_ @range:8:34, 8, 24, 0, ?#result:int @range:8:34)}
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: *** Before calls Typing {#rec::wybe.range, #result::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   Typing {#rec::wybe.range, #result::wybe.int}; {} (with no errors)
Types: Finding type of expr #rec:_ @range:8:34
Types:   Type = wybe.range
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?#result:int @range:8:34
Types:   Type = wybe.int
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed)
Types: Now mode checking proc stride
Types: bound vars: semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#rec:_ @range:8:34, 8, 24, 0, ?#result:int @range:8:34)
Types: Mode checking foreign call {foreign lpvm access(#rec:_ @range:8:34, 8, 24, 0, ?#result:int @range:8:34)}
Types:     with assigned semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp 8
Types: Mode check exp resulted in 8
Types: Mode check exp 24
Types: Mode check exp resulted in 24
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?#result:int
Types: Mode check exp resulted in ?#result:int
Types: Finding type of expr #rec:_ @range:8:34
Types:   Type = wybe.range
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?#result:int @range:8:34
Types:   Type = wybe.int
Types:     types and modes = [wybe.range,wybe.int,wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign lpvm access(#rec:wybe.range @range:8:34, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?#result:wybe.int @range:8:34)}
Types: Now assigned = semipure normal (total) computation binding {#rec, #result}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'stride'
Types: Mode checked body   : [{foreign lpvm access(#rec:wybe.range @range:8:34, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?#result:wybe.int @range:8:34)} @range:8:34]
Types: Vars defined by body: semipure normal (total) computation binding {#rec, #result}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking stride
Types: ** Type checking stride: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm {noalias} mutate(#rec:_ @range:8:34, ?#rec:_ @range:8:34, 8, 0, 24, 0, #field)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#field","#rec"]
Types: Recording parameter types: !#rec:wybe.range, #field:wybe.int
Types:     type of '#rec' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types:     type of '#field' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #field type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm {noalias} mutate(#rec:_ @range:8:34, ?#rec:_ @range:8:34, 8, 0, 24, 0, #field)}
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types: *** Before calls Typing {#field::wybe.int, #rec::wybe.range}; {} (with no errors)
Types:   With calls:
Types:   Typing {#field::wybe.int, #rec::wybe.range}; {} (with no errors)
Types: Finding type of expr #rec:_ @range:8:34
Types:   Type = wybe.range
Types: Finding type of expr ?#rec:_ @range:8:34
Types:   Type = wybe.range
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.int
Types: Type checking foreign lpvm call mutate noalias(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed)
Types: Now mode checking proc stride
Types: bound vars: semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm {noalias} mutate(#rec:_ @range:8:34, ?#rec:_ @range:8:34, 8, 0, 24, 0, #field)
Types: Mode checking foreign call {foreign lpvm {noalias} mutate(#rec:_ @range:8:34, ?#rec:_ @range:8:34, 8, 0, 24, 0, #field)}
Types:     with assigned semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp 8
Types: Mode check exp resulted in 8
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 24
Types: Mode check exp resulted in 24
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp #field
Types: Mode check exp resulted in #field
Types: Finding type of expr #rec:_ @range:8:34
Types:   Type = wybe.range
Types: Finding type of expr ?#rec:_ @range:8:34
Types:   Type = wybe.range
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.int
Types:     types and modes = [wybe.range,?wybe.range,wybe.int,wybe.int,wybe.int,wybe.int,wybe.int]
Types: New instr = {foreign lpvm {noalias} mutate(#rec:wybe.range @range:8:34, ?#rec:wybe.range @range:8:34, 8:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, #field:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'stride'
Types: Mode checked body   : [{foreign lpvm {noalias} mutate(#rec:wybe.range @range:8:34, ?#rec:wybe.range @range:8:34, 8:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, #field:wybe.int)} @range:8:34]
Types: Vars defined by body: semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Output parameters   : #rec
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of stride:
Types: 
Types: stride > public {inline} (0 calls)
Types: 4: stride(#rec:wybe.range @range:8:34, ?#result:wybe.int @range:8:34):
Types:     foreign lpvm access(#rec:wybe.range @range:8:34, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?#result:wybe.int @range:8:34)
Types: 
Types: stride > public {inline} (0 calls)
Types: 4: stride(!#rec:wybe.range @range:8:34, #field:wybe.int @range:8:34):
Types:     foreign lpvm {noalias} mutate(#rec:wybe.range @range:8:34, ?#rec:wybe.range @range:8:34, 8:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, #field:wybe.int)
Types: Type checking non-recursive proc wybe.range.start
Types: ** Type checking decl of proc start
Types: found 2 definition(s)
Types: Type checking start
Types: ** Type checking start: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm access(#rec:_ @range:8:23, 0, 24, 0, ?#result:int @range:8:23)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#rec","#result"]
Types: Recording parameter types: #rec:wybe.range, ?#result:wybe.int
Types:     type of '#rec' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm access(#rec:_ @range:8:23, 0, 24, 0, ?#result:int @range:8:23)}
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: *** Before calls Typing {#rec::wybe.range, #result::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   Typing {#rec::wybe.range, #result::wybe.int}; {} (with no errors)
Types: Finding type of expr #rec:_ @range:8:23
Types:   Type = wybe.range
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?#result:int @range:8:23
Types:   Type = wybe.int
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed)
Types: Now mode checking proc start
Types: bound vars: semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#rec:_ @range:8:23, 0, 24, 0, ?#result:int @range:8:23)
Types: Mode checking foreign call {foreign lpvm access(#rec:_ @range:8:23, 0, 24, 0, ?#result:int @range:8:23)}
Types:     with assigned semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 24
Types: Mode check exp resulted in 24
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?#result:int
Types: Mode check exp resulted in ?#result:int
Types: Finding type of expr #rec:_ @range:8:23
Types:   Type = wybe.range
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?#result:int @range:8:23
Types:   Type = wybe.int
Types:     types and modes = [wybe.range,wybe.int,wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign lpvm access(#rec:wybe.range @range:8:23, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?#result:wybe.int @range:8:23)}
Types: Now assigned = semipure normal (total) computation binding {#rec, #result}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'start'
Types: Mode checked body   : [{foreign lpvm access(#rec:wybe.range @range:8:23, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?#result:wybe.int @range:8:23)} @range:8:23]
Types: Vars defined by body: semipure normal (total) computation binding {#rec, #result}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking start
Types: ** Type checking start: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm {noalias} mutate(#rec:_ @range:8:23, ?#rec:_ @range:8:23, 0, 0, 24, 0, #field)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#field","#rec"]
Types: Recording parameter types: !#rec:wybe.range, #field:wybe.int
Types:     type of '#rec' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types:     type of '#field' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #field type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm {noalias} mutate(#rec:_ @range:8:23, ?#rec:_ @range:8:23, 0, 0, 24, 0, #field)}
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types: *** Before calls Typing {#field::wybe.int, #rec::wybe.range}; {} (with no errors)
Types:   With calls:
Types:   Typing {#field::wybe.int, #rec::wybe.range}; {} (with no errors)
Types: Finding type of expr #rec:_ @range:8:23
Types:   Type = wybe.range
Types: Finding type of expr ?#rec:_ @range:8:23
Types:   Type = wybe.range
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.int
Types: Type checking foreign lpvm call mutate noalias(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed)
Types: Now mode checking proc start
Types: bound vars: semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm {noalias} mutate(#rec:_ @range:8:23, ?#rec:_ @range:8:23, 0, 0, 24, 0, #field)
Types: Mode checking foreign call {foreign lpvm {noalias} mutate(#rec:_ @range:8:23, ?#rec:_ @range:8:23, 0, 0, 24, 0, #field)}
Types:     with assigned semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 24
Types: Mode check exp resulted in 24
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp #field
Types: Mode check exp resulted in #field
Types: Finding type of expr #rec:_ @range:8:23
Types:   Type = wybe.range
Types: Finding type of expr ?#rec:_ @range:8:23
Types:   Type = wybe.range
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.int
Types:     types and modes = [wybe.range,?wybe.range,wybe.int,wybe.int,wybe.int,wybe.int,wybe.int]
Types: New instr = {foreign lpvm {noalias} mutate(#rec:wybe.range @range:8:23, ?#rec:wybe.range @range:8:23, 0:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, #field:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'start'
Types: Mode checked body   : [{foreign lpvm {noalias} mutate(#rec:wybe.range @range:8:23, ?#rec:wybe.range @range:8:23, 0:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, #field:wybe.int)} @range:8:23]
Types: Vars defined by body: semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Output parameters   : #rec
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of start:
Types: 
Types: start > public {inline} (0 calls)
Types: 4: start(#rec:wybe.range @range:8:23, ?#result:wybe.int @range:8:23):
Types:     foreign lpvm access(#rec:wybe.range @range:8:23, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?#result:wybe.int @range:8:23)
Types: 
Types: start > public {inline} (0 calls)
Types: 4: start(!#rec:wybe.range @range:8:23, #field:wybe.int @range:8:23):
Types:     foreign lpvm {noalias} mutate(#rec:wybe.range @range:8:23, ?#rec:wybe.range @range:8:23, 0:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, #field:wybe.int)
Types: Type checking non-recursive proc wybe.range.range
Types: ** Type checking decl of proc range
Types: found 2 definition(s)
Types: Type checking range
Types: ** Type checking range: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm alloc(24, ?#rec:_ @range:8:17)
Types:         foreign lpvm mutate(#rec:_ @range:8:17, ?#rec:_ @range:8:17, 0, 1, 24, 0, start:int @range:8:23)
Types:         foreign lpvm mutate(#rec:_ @range:8:17, ?#rec:_ @range:8:17, 8, 1, 24, 0, stride:int @range:8:34)
Types:         foreign lpvm mutate(#rec:_ @range:8:17, ?#rec:_ @range:8:17, 16, 1, 24, 0, end:int @range:8:46)
Types:         foreign llvm or(#rec:_ @range:8:17, 0, ?#result:_ @range:8:17)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#rec","#result","end","start","stride"]
Types: Recording parameter types: start:wybe.int, stride:wybe.int, end:wybe.int, ?#result:wybe.range
Types:     type of 'start' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable start type constrained to wybe.int
Types:     type of 'stride' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable stride type constrained to wybe.int
Types:     type of 'end' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable end type constrained to wybe.int
Types:     type of '#result' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #result type constrained to wybe.range
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm alloc(24, ?#rec:_ @range:8:17)}
Types: Unifying types _ (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types: Recording casts in {foreign lpvm mutate(#rec:_ @range:8:17, ?#rec:_ @range:8:17, 0, 1, 24, 0, start:int @range:8:23)}
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable start type constrained to wybe.int
Types: Recording casts in {foreign lpvm mutate(#rec:_ @range:8:17, ?#rec:_ @range:8:17, 8, 1, 24, 0, stride:int @range:8:34)}
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable stride type constrained to wybe.int
Types: Recording casts in {foreign lpvm mutate(#rec:_ @range:8:17, ?#rec:_ @range:8:17, 16, 1, 24, 0, end:int @range:8:46)}
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable end type constrained to wybe.int
Types: Recording casts in {foreign llvm or(#rec:_ @range:8:17, 0, ?#result:_ @range:8:17)}
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #result type constrained to wybe.range
Types: *** Before calls Typing {#rec::wybe.range, #result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   Typing {#rec::wybe.range, #result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int}; {} (with no errors)
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr ?#rec:_ @range:8:17
Types:   Type = wybe.range
Types: Type checking foreign lpvm call alloc(64 bit signed, address)
Types: Finding type of expr #rec:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr ?#rec:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr start:int @range:8:23
Types:   Type = wybe.int
Types: Type checking foreign lpvm call mutate(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr #rec:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr ?#rec:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr stride:int @range:8:34
Types:   Type = wybe.int
Types: Type checking foreign lpvm call mutate(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr #rec:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr ?#rec:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr end:int @range:8:46
Types:   Type = wybe.int
Types: Type checking foreign lpvm call mutate(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr #rec:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?#result:_ @range:8:17
Types:   Type = wybe.range
Types: Type checking foreign llvm call or(address, 64 bit signed, address)
Types: Now mode checking proc range
Types: bound vars: semipure normal (total) computation binding {end, start, stride}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm alloc(24, ?#rec:_ @range:8:17)
Types: Mode checking foreign call {foreign lpvm alloc(24, ?#rec:_ @range:8:17)}
Types:     with assigned semipure normal (total) computation binding {end, start, stride}, break set = Everything, with resources {}
Types: Mode check exp 24
Types: Mode check exp resulted in 24
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr ?#rec:_ @range:8:17
Types:   Type = wybe.range
Types:     types and modes = [wybe.int,?wybe.range]
Types: New instr = {foreign lpvm alloc(24:wybe.int, ?#rec:wybe.range @range:8:17)}
Types: Now assigned = semipure normal (total) computation binding {#rec, end, start, stride}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm mutate(#rec:_ @range:8:17, ?#rec:_ @range:8:17, 0, 1, 24, 0, start:int @range:8:23)
Types: Mode checking foreign call {foreign lpvm mutate(#rec:_ @range:8:17, ?#rec:_ @range:8:17, 0, 1, 24, 0, start:int @range:8:23)}
Types:     with assigned semipure normal (total) computation binding {#rec, end, start, stride}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp 24
Types: Mode check exp resulted in 24
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp start:int
Types: Mode check exp resulted in start:int
Types: Finding type of expr #rec:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr ?#rec:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr start:int @range:8:23
Types:   Type = wybe.int
Types:     types and modes = [wybe.range,?wybe.range,wybe.int,wybe.int,wybe.int,wybe.int,wybe.int]
Types: New instr = {foreign lpvm mutate(#rec:wybe.range @range:8:17, ?#rec:wybe.range @range:8:17, 0:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, start:wybe.int @range:8:23)}
Types: Now assigned = semipure normal (total) computation binding {#rec, end, start, stride}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm mutate(#rec:_ @range:8:17, ?#rec:_ @range:8:17, 8, 1, 24, 0, stride:int @range:8:34)
Types: Mode checking foreign call {foreign lpvm mutate(#rec:_ @range:8:17, ?#rec:_ @range:8:17, 8, 1, 24, 0, stride:int @range:8:34)}
Types:     with assigned semipure normal (total) computation binding {#rec, end, start, stride}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp 8
Types: Mode check exp resulted in 8
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp 24
Types: Mode check exp resulted in 24
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp stride:int
Types: Mode check exp resulted in stride:int
Types: Finding type of expr #rec:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr ?#rec:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr stride:int @range:8:34
Types:   Type = wybe.int
Types:     types and modes = [wybe.range,?wybe.range,wybe.int,wybe.int,wybe.int,wybe.int,wybe.int]
Types: New instr = {foreign lpvm mutate(#rec:wybe.range @range:8:17, ?#rec:wybe.range @range:8:17, 8:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, stride:wybe.int @range:8:34)}
Types: Now assigned = semipure normal (total) computation binding {#rec, end, start, stride}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm mutate(#rec:_ @range:8:17, ?#rec:_ @range:8:17, 16, 1, 24, 0, end:int @range:8:46)
Types: Mode checking foreign call {foreign lpvm mutate(#rec:_ @range:8:17, ?#rec:_ @range:8:17, 16, 1, 24, 0, end:int @range:8:46)}
Types:     with assigned semipure normal (total) computation binding {#rec, end, start, stride}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp 24
Types: Mode check exp resulted in 24
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp end:int
Types: Mode check exp resulted in end:int
Types: Finding type of expr #rec:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr ?#rec:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr end:int @range:8:46
Types:   Type = wybe.int
Types:     types and modes = [wybe.range,?wybe.range,wybe.int,wybe.int,wybe.int,wybe.int,wybe.int]
Types: New instr = {foreign lpvm mutate(#rec:wybe.range @range:8:17, ?#rec:wybe.range @range:8:17, 16:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, end:wybe.int @range:8:46)}
Types: Now assigned = semipure normal (total) computation binding {#rec, end, start, stride}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm or(#rec:_ @range:8:17, 0, ?#result:_ @range:8:17)
Types: Mode checking foreign call {foreign llvm or(#rec:_ @range:8:17, 0, ?#result:_ @range:8:17)}
Types:     with assigned semipure normal (total) computation binding {#rec, end, start, stride}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?#result:_
Types: Mode check exp resulted in ?#result:_
Types: Finding type of expr #rec:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?#result:_ @range:8:17
Types:   Type = wybe.range
Types:     types and modes = [wybe.range,wybe.int,?wybe.range]
Types: New instr = {foreign llvm or(#rec:wybe.range @range:8:17, 0:wybe.int, ?#result:wybe.range @range:8:17)}
Types: Now assigned = semipure normal (total) computation binding {#rec, #result, end, start, stride}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'range'
Types: Mode checked body   : [{foreign lpvm alloc(24:wybe.int, ?#rec:wybe.range @range:8:17)} @range:8:17,{foreign lpvm mutate(#rec:wybe.range @range:8:17, ?#rec:wybe.range @range:8:17, 0:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, start:wybe.int @range:8:23)} @range:8:17,{foreign lpvm mutate(#rec:wybe.range @range:8:17, ?#rec:wybe.range @range:8:17, 8:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, stride:wybe.int @range:8:34)} @range:8:17,{foreign lpvm mutate(#rec:wybe.range @range:8:17, ?#rec:wybe.range @range:8:17, 16:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, end:wybe.int @range:8:46)} @range:8:17,{foreign llvm or(#rec:wybe.range @range:8:17, 0:wybe.int, ?#result:wybe.range @range:8:17)} @range:8:17]
Types: Vars defined by body: semipure normal (total) computation binding {#rec, #result, end, start, stride}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking range
Types: ** Type checking range: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm access(#result:_ @range:8:17, 0, 24, 0, ?start:int @range:8:23)
Types:         foreign lpvm access(#result:_ @range:8:17, 8, 24, 0, ?stride:int @range:8:34)
Types:         foreign lpvm access(#result:_ @range:8:17, 16, 24, 0, ?end:int @range:8:46)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","end","start","stride"]
Types: Recording parameter types: ?start:wybe.int, ?stride:wybe.int, ?end:wybe.int, #result:wybe.range
Types:     type of 'start' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable start type constrained to wybe.int
Types:     type of 'stride' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable stride type constrained to wybe.int
Types:     type of 'end' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable end type constrained to wybe.int
Types:     type of '#result' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #result type constrained to wybe.range
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm access(#result:_ @range:8:17, 0, 24, 0, ?start:int @range:8:23)}
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #result type constrained to wybe.range
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable start type constrained to wybe.int
Types: Recording casts in {foreign lpvm access(#result:_ @range:8:17, 8, 24, 0, ?stride:int @range:8:34)}
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #result type constrained to wybe.range
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable stride type constrained to wybe.int
Types: Recording casts in {foreign lpvm access(#result:_ @range:8:17, 16, 24, 0, ?end:int @range:8:46)}
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #result type constrained to wybe.range
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable end type constrained to wybe.int
Types: *** Before calls Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int}; {} (with no errors)
Types: Finding type of expr #result:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?start:int @range:8:23
Types:   Type = wybe.int
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr #result:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?stride:int @range:8:34
Types:   Type = wybe.int
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr #result:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?end:int @range:8:46
Types:   Type = wybe.int
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed)
Types: Now mode checking proc range
Types: bound vars: semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check stmt pass
Types: Mode checking Nop
Types: Now assigned = semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#result:_ @range:8:17, 0, 24, 0, ?start:int @range:8:23)
Types: Mode checking foreign call {foreign lpvm access(#result:_ @range:8:17, 0, 24, 0, ?start:int @range:8:23)}
Types:     with assigned semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check exp #result:_
Types: Mode check exp resulted in #result:_
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 24
Types: Mode check exp resulted in 24
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?start:int
Types: Mode check exp resulted in ?start:int
Types: Finding type of expr #result:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?start:int @range:8:23
Types:   Type = wybe.int
Types:     types and modes = [wybe.range,wybe.int,wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign lpvm access(#result:wybe.range @range:8:17, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?start:wybe.int @range:8:23)}
Types: Now assigned = semipure normal (total) computation binding {#result, start}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#result:_ @range:8:17, 8, 24, 0, ?stride:int @range:8:34)
Types: Mode checking foreign call {foreign lpvm access(#result:_ @range:8:17, 8, 24, 0, ?stride:int @range:8:34)}
Types:     with assigned semipure normal (total) computation binding {#result, start}, break set = Everything, with resources {}
Types: Mode check exp #result:_
Types: Mode check exp resulted in #result:_
Types: Mode check exp 8
Types: Mode check exp resulted in 8
Types: Mode check exp 24
Types: Mode check exp resulted in 24
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?stride:int
Types: Mode check exp resulted in ?stride:int
Types: Finding type of expr #result:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?stride:int @range:8:34
Types:   Type = wybe.int
Types:     types and modes = [wybe.range,wybe.int,wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign lpvm access(#result:wybe.range @range:8:17, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?stride:wybe.int @range:8:34)}
Types: Now assigned = semipure normal (total) computation binding {#result, start, stride}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#result:_ @range:8:17, 16, 24, 0, ?end:int @range:8:46)
Types: Mode checking foreign call {foreign lpvm access(#result:_ @range:8:17, 16, 24, 0, ?end:int @range:8:46)}
Types:     with assigned semipure normal (total) computation binding {#result, start, stride}, break set = Everything, with resources {}
Types: Mode check exp #result:_
Types: Mode check exp resulted in #result:_
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 24
Types: Mode check exp resulted in 24
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?end:int
Types: Mode check exp resulted in ?end:int
Types: Finding type of expr #result:_ @range:8:17
Types:   Type = wybe.range
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?end:int @range:8:46
Types:   Type = wybe.int
Types:     types and modes = [wybe.range,wybe.int,wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign lpvm access(#result:wybe.range @range:8:17, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?end:wybe.int @range:8:46)}
Types: Now assigned = semipure normal (total) computation binding {#result, end, start, stride}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'range'
Types: Mode checked body   : [{pass},{foreign lpvm access(#result:wybe.range @range:8:17, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?start:wybe.int @range:8:23)} @range:8:17,{foreign lpvm access(#result:wybe.range @range:8:17, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?stride:wybe.int @range:8:34)} @range:8:17,{foreign lpvm access(#result:wybe.range @range:8:17, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?end:wybe.int @range:8:46)} @range:8:17]
Types: Vars defined by body: semipure normal (total) computation binding {#result, end, start, stride}, break set = Everything, with resources {}
Types: Output parameters   : end, start, stride
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of range:
Types: 
Types: range > public {inline} (0 calls)
Types: 4: range(start:wybe.int @range:8:23, stride:wybe.int @range:8:34, end:wybe.int @range:8:46, ?#result:wybe.range @range:8:17):
Types:     foreign lpvm alloc(24:wybe.int, ?#rec:wybe.range @range:8:17)
Types:     foreign lpvm mutate(#rec:wybe.range @range:8:17, ?#rec:wybe.range @range:8:17, 0:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, start:wybe.int @range:8:23)
Types:     foreign lpvm mutate(#rec:wybe.range @range:8:17, ?#rec:wybe.range @range:8:17, 8:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, stride:wybe.int @range:8:34)
Types:     foreign lpvm mutate(#rec:wybe.range @range:8:17, ?#rec:wybe.range @range:8:17, 16:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, end:wybe.int @range:8:46)
Types:     foreign llvm or(#rec:wybe.range @range:8:17, 0:wybe.int, ?#result:wybe.range @range:8:17)
Types: 
Types: range > public {inline} (0 calls)
Types: 4: range(?start:wybe.int @range:8:23, ?stride:wybe.int @range:8:34, ?end:wybe.int @range:8:46, #result:wybe.range @range:8:17):
Types:     pass
Types:     foreign lpvm access(#result:wybe.range @range:8:17, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?start:wybe.int @range:8:23)
Types:     foreign lpvm access(#result:wybe.range @range:8:17, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?stride:wybe.int @range:8:34)
Types:     foreign lpvm access(#result:wybe.range @range:8:17, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?end:wybe.int @range:8:46)
Types: Type checking non-recursive proc wybe.range.end
Types: ** Type checking decl of proc end
Types: found 2 definition(s)
Types: Type checking end
Types: ** Type checking end: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm access(#rec:_ @range:8:46, 16, 24, 0, ?#result:int @range:8:46)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#rec","#result"]
Types: Recording parameter types: #rec:wybe.range, ?#result:wybe.int
Types:     type of '#rec' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm access(#rec:_ @range:8:46, 16, 24, 0, ?#result:int @range:8:46)}
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: *** Before calls Typing {#rec::wybe.range, #result::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   Typing {#rec::wybe.range, #result::wybe.int}; {} (with no errors)
Types: Finding type of expr #rec:_ @range:8:46
Types:   Type = wybe.range
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?#result:int @range:8:46
Types:   Type = wybe.int
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed)
Types: Now mode checking proc end
Types: bound vars: semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#rec:_ @range:8:46, 16, 24, 0, ?#result:int @range:8:46)
Types: Mode checking foreign call {foreign lpvm access(#rec:_ @range:8:46, 16, 24, 0, ?#result:int @range:8:46)}
Types:     with assigned semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 24
Types: Mode check exp resulted in 24
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?#result:int
Types: Mode check exp resulted in ?#result:int
Types: Finding type of expr #rec:_ @range:8:46
Types:   Type = wybe.range
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?#result:int @range:8:46
Types:   Type = wybe.int
Types:     types and modes = [wybe.range,wybe.int,wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign lpvm access(#rec:wybe.range @range:8:46, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?#result:wybe.int @range:8:46)}
Types: Now assigned = semipure normal (total) computation binding {#rec, #result}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'end'
Types: Mode checked body   : [{foreign lpvm access(#rec:wybe.range @range:8:46, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?#result:wybe.int @range:8:46)} @range:8:46]
Types: Vars defined by body: semipure normal (total) computation binding {#rec, #result}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking end
Types: ** Type checking end: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm {noalias} mutate(#rec:_ @range:8:46, ?#rec:_ @range:8:46, 16, 0, 24, 0, #field)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#field","#rec"]
Types: Recording parameter types: !#rec:wybe.range, #field:wybe.int
Types:     type of '#rec' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types:     type of '#field' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #field type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm {noalias} mutate(#rec:_ @range:8:46, ?#rec:_ @range:8:46, 16, 0, 24, 0, #field)}
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #rec type constrained to wybe.range
Types: *** Before calls Typing {#field::wybe.int, #rec::wybe.range}; {} (with no errors)
Types:   With calls:
Types:   Typing {#field::wybe.int, #rec::wybe.range}; {} (with no errors)
Types: Finding type of expr #rec:_ @range:8:46
Types:   Type = wybe.range
Types: Finding type of expr ?#rec:_ @range:8:46
Types:   Type = wybe.range
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.int
Types: Type checking foreign lpvm call mutate noalias(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed)
Types: Now mode checking proc end
Types: bound vars: semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm {noalias} mutate(#rec:_ @range:8:46, ?#rec:_ @range:8:46, 16, 0, 24, 0, #field)
Types: Mode checking foreign call {foreign lpvm {noalias} mutate(#rec:_ @range:8:46, ?#rec:_ @range:8:46, 16, 0, 24, 0, #field)}
Types:     with assigned semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 24
Types: Mode check exp resulted in 24
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp #field
Types: Mode check exp resulted in #field
Types: Finding type of expr #rec:_ @range:8:46
Types:   Type = wybe.range
Types: Finding type of expr ?#rec:_ @range:8:46
Types:   Type = wybe.range
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 24
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.int
Types:     types and modes = [wybe.range,?wybe.range,wybe.int,wybe.int,wybe.int,wybe.int,wybe.int]
Types: New instr = {foreign lpvm {noalias} mutate(#rec:wybe.range @range:8:46, ?#rec:wybe.range @range:8:46, 16:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, #field:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'end'
Types: Mode checked body   : [{foreign lpvm {noalias} mutate(#rec:wybe.range @range:8:46, ?#rec:wybe.range @range:8:46, 16:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, #field:wybe.int)} @range:8:46]
Types: Vars defined by body: semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Output parameters   : #rec
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of end:
Types: 
Types: end > public {inline} (0 calls)
Types: 4: end(#rec:wybe.range @range:8:46, ?#result:wybe.int @range:8:46):
Types:     foreign lpvm access(#rec:wybe.range @range:8:46, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?#result:wybe.int @range:8:46)
Types: 
Types: end > public {inline} (0 calls)
Types: 4: end(!#rec:wybe.range @range:8:46, #field:wybe.int @range:8:46):
Types:     foreign lpvm {noalias} mutate(#rec:wybe.range @range:8:46, ?#rec:wybe.range @range:8:46, 16:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, #field:wybe.int)
Types: **** Type checking recursive procs wybe.range.=
Types: ** Type checking decl of proc =
Types: found 1 definition(s)
Types: Type checking =
Types: ** Type checking =: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#left:!wybe.int, 0, ?tmp#0:!wybe.bool)
Types:         range(?#left#start, ?#left#stride, ?#left#end, #left)
Types:         range(?#right#start, ?#right#stride, ?#right#end, #right)
Types:         =(#left#start, #right#start)
Types:         =(#left#stride, #right#stride)
Types:         =(#left#end, #right#end)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#left","#left#end","#left#start","#left#stride","#right","#right#end","#right#start","#right#stride","tmp#0"]
Types: Recording parameter types: #left:wybe.range, #right:wybe.range
Types:     type of '#left' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #left type constrained to wybe.range
Types:     type of '#right' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #right type constrained to wybe.range
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#left:!wybe.int, 0, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #left type constrained to wybe.range
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {range(?#left#start, ?#left#stride, ?#left#end, #left)}
Types: Recording casts in {range(?#right#start, ?#right#stride, ?#right#end, #right)}
Types: Recording casts in {=(#left#start, #right#start)}
Types: Recording casts in {=(#left#stride, #right#stride)}
Types: Recording casts in {=(#left#end, #right#end)}
Types: *** Before calls Typing {#left::wybe.range, #right::wybe.range, tmp#0::any}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {range(?#left#start, ?#left#stride, ?#left#end, #left)}, typingInfos = [wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)]}
Types:     StmtTypings {typingStmt = {range(?#right#start, ?#right#stride, ?#right#end, #right)}, typingInfos = [wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)]}
Types:     StmtTypings {typingStmt = {=(#left#start, #right#start)}, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),{test} wybe.range.=<0>(wybe.range,wybe.range)]}
Types:     StmtTypings {typingStmt = {=(#left#stride, #right#stride)}, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),{test} wybe.range.=<0>(wybe.range,wybe.range)]}
Types:     StmtTypings {typingStmt = {=(#left#end, #right#end)}, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),{test} wybe.range.=<0>(wybe.range,wybe.range)]}Typing {#left::wybe.range, #right::wybe.range, tmp#0::any}; {} (with no errors)
Types: Type checking call {range(?#left#start, ?#left#stride, ?#left#end, #left)}
Types: Candidate types:
Types:     wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types:     wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Finding type of expr ?#left#start
Types:   Type = 0
Types: Finding type of expr ?#left#stride
Types:   Type = 1
Types: Finding type of expr ?#left#end
Types:   Type = 2
Types: Finding type of expr #left
Types:   Type = wybe.range
Types: Actual types: [0,1,2,wybe.range]
Types: Matching types [0,1,2,wybe.range] with wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 2 is bound to Nothing
Types: Unifying types 2 (-> 2) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Matching types [0,1,2,wybe.range] with wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 2 is bound to Nothing
Types: Unifying types 2 (-> 2) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Valid types = [Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, tmp#0::any}; {0::wybe.int, 1::wybe.int, 2::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, tmp#0::any}; {0::wybe.int, 1::wybe.int, 2::wybe.int} (with no errors)
Types: Type checking call {range(?#right#start, ?#right#stride, ?#right#end, #right)}
Types: Candidate types:
Types:     wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types:     wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Finding type of expr ?#right#start
Types:   Type = 3
Types: Finding type of expr ?#right#stride
Types:   Type = 4
Types: Finding type of expr ?#right#end
Types:   Type = 5
Types: Finding type of expr #right
Types:   Type = wybe.range
Types: Actual types: [3,4,5,wybe.range]
Types: Matching types [3,4,5,wybe.range] with wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Type variable 3 is bound to Nothing
Types: Unifying types 3 (-> 3) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 4 is bound to Nothing
Types: Unifying types 4 (-> 4) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 5 is bound to Nothing
Types: Unifying types 5 (-> 5) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Matching types [3,4,5,wybe.range] with wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Type variable 3 is bound to Nothing
Types: Unifying types 3 (-> 3) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 4 is bound to Nothing
Types: Unifying types 4 (-> 4) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 5 is bound to Nothing
Types: Unifying types 5 (-> 5) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Valid types = [Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::any}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::any}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors)
Types: Type checking call {=(#left#start, #right#start)}
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types:     {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Finding type of expr #left#start
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr #right#start
Types: Type variable 3 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::any}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::any}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors)
Types: Type checking call {=(#left#stride, #right#stride)}
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types:     {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Finding type of expr #left#stride
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr #right#stride
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::any}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::any}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors)
Types: Type checking call {=(#left#end, #right#end)}
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types:     {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Finding type of expr #left#end
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr #right#end
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::any}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::any}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors)
Types: Finding type of expr #left:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Now mode checking proc =
Types: bound vars: semipure normal (total) computation binding {#left, #right}, break set = Everything, with resources {}
Types: Mode check stmt if {(   foreign llvm icmp_uge(#left:!wybe.int, 0, ?tmp#0:!wybe.bool)
Types:                     & testbool tmp#0:!wybe.bool)::
Types: 
Types:                     (   range(?#left#start, ?#left#stride, ?#left#end, #left)
Types:                     & range(?#right#start, ?#right#stride, ?#right#end, #right)
Types:                     & =(#left#start, #right#start)
Types:                     & =(#left#stride, #right#stride)
Types:                     & =(#left#end, #right#end))
Types:                 else::
Types:                     fail
Types: 
Types:                 }
Types: Mode checking conditional {if {(   foreign llvm icmp_uge(#left:!wybe.int, 0, ?tmp#0:!wybe.bool)
Types:         & testbool tmp#0:!wybe.bool)::
Types: 
Types:         (   range(?#left#start, ?#left#stride, ?#left#end, #left)
Types:         & range(?#right#start, ?#right#stride, ?#right#end, #right)
Types:         & =(#left#start, #right#start)
Types:         & =(#left#stride, #right#stride)
Types:         & =(#left#end, #right#end))
Types:     else::
Types:         fail
Types: 
Types:     }}
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#left:!wybe.int, 0, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#left:!wybe.int, 0, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#left:!wybe.int, 0, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#left, #right}, break set = Everything, with resources {}
Types: Mode check exp #left:!wybe.int
Types: Mode check exp resulted in #left:!wybe.int
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #left:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#left:!wybe.int, 0:wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#left, #right, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#left, #right, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc '='
Types: Assigned by test: semipure test computation binding {#left, #right, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt (   range(?#left#start, ?#left#stride, ?#left#end, #left)
Types:                 & range(?#right#start, ?#right#stride, ?#right#end, #right)
Types:                 & =(#left#start, #right#start)
Types:                 & =(#left#stride, #right#stride)
Types:                 & =(#left#end, #right#end))
Types: Mode checking conjunction {(   range(?#left#start, ?#left#stride, ?#left#end, #left)
Types:     & range(?#right#start, ?#right#stride, ?#right#end, #right)
Types:     & =(#left#start, #right#start)
Types:     & =(#left#stride, #right#stride)
Types:     & =(#left#end, #right#end))}
Types: Mode check stmt range(?#left#start, ?#left#stride, ?#left#end, #left)
Types: Mode checking call   : {range(?#left#start, ?#left#stride, ?#left#end, #left)}
Types:     with assigned    : semipure normal (total) computation binding {#left, #right, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp ?#left#start
Types: Mode check exp resulted in ?#left#start
Types: Mode check exp ?#left#stride
Types: Mode check exp resulted in ?#left#stride
Types: Mode check exp ?#left#end
Types: Mode check exp resulted in ?#left#end
Types: Mode check exp #left
Types: Mode check exp resulted in #left
Types: Finding type of expr ?#left#start
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#left#stride
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#left#end
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr #left
Types:   Type = wybe.range
Types:     actual types     : [wybe.int,wybe.int,wybe.int,wybe.range]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamOut,False,Nothing),(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Type-correct modes   : [(wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::6}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors)),(wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range),Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::6}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range),Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::6}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range),Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::6}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors))]
Types: Finding type of expr ?#left#start
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#left#stride
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#left#end
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr #left
Types:   Type = wybe.range
Types: Finalising call    :  {wybe.range.<1>range(?#left#start:wybe.int, ?#left#stride:wybe.int, ?#left#end:wybe.int, #left:wybe.range)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"#left", "#right", "tmp#0"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.range.<1>range(?#left#start:wybe.int, ?#left#stride:wybe.int, ?#left#end:wybe.int, #left:wybe.range)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '='
Types: Now assigned = semipure normal (total) computation binding {#left, #left#end, #left#start, #left#stride, #right, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt range(?#right#start, ?#right#stride, ?#right#end, #right)
Types: Mode checking call   : {range(?#right#start, ?#right#stride, ?#right#end, #right)}
Types:     with assigned    : semipure normal (total) computation binding {#left, #left#end, #left#start, #left#stride, #right, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp ?#right#start
Types: Mode check exp resulted in ?#right#start
Types: Mode check exp ?#right#stride
Types: Mode check exp resulted in ?#right#stride
Types: Mode check exp ?#right#end
Types: Mode check exp resulted in ?#right#end
Types: Mode check exp #right
Types: Mode check exp resulted in #right
Types: Finding type of expr ?#right#start
Types: Type variable 3 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#right#stride
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#right#end
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr #right
Types:   Type = wybe.range
Types:     actual types     : [wybe.int,wybe.int,wybe.int,wybe.range]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamOut,False,Nothing),(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Type-correct modes   : [(wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::6}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors)),(wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range),Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::6}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range),Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::6}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range),Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::6}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors))]
Types: Finding type of expr ?#right#start
Types: Type variable 3 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#right#stride
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#right#end
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr #right
Types:   Type = wybe.range
Types: Finalising call    :  {wybe.range.<1>range(?#right#start:wybe.int, ?#right#stride:wybe.int, ?#right#end:wybe.int, #right:wybe.range)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"#left", "#left#end", "#left#start", "#left#stride", "#right", "tmp#0"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.range.<1>range(?#right#start:wybe.int, ?#right#stride:wybe.int, ?#right#end:wybe.int, #right:wybe.range)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '='
Types: Now assigned = semipure normal (total) computation binding {#left, #left#end, #left#start, #left#stride, #right, #right#end, #right#start, #right#stride, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt =(#left#start, #right#start)
Types: Mode checking call   : {=(#left#start, #right#start)}
Types:     with assigned    : semipure normal (total) computation binding {#left, #left#end, #left#start, #left#stride, #right, #right#end, #right#start, #right#stride, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #left#start
Types: Mode check exp resulted in #left#start
Types: Mode check exp #right#start
Types: Mode check exp resulted in #right#start
Types: Finding type of expr #left#start
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr #right#start
Types: Type variable 3 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::6}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::6}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::6}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors))]
Types: Finding type of expr #left#start
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr #right#start
Types: Type variable 3 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>=(#left#start:wybe.int, #right#start:wybe.int)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"#left", "#left#end", "#left#start", "#left#stride", "#right", "#right#end", "#right#start", "#right#stride", "tmp#0"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>=(#left#start:wybe.int, #right#start:wybe.int)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '='
Types: Now assigned = semipure test computation binding {#left, #left#end, #left#start, #left#stride, #right, #right#end, #right#start, #right#stride, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt =(#left#stride, #right#stride)
Types: Mode checking call   : {=(#left#stride, #right#stride)}
Types:     with assigned    : semipure test computation binding {#left, #left#end, #left#start, #left#stride, #right, #right#end, #right#start, #right#stride, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #left#stride
Types: Mode check exp resulted in #left#stride
Types: Mode check exp #right#stride
Types: Mode check exp resulted in #right#stride
Types: Finding type of expr #left#stride
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr #right#stride
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::6}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::6}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::6}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors))]
Types: Finding type of expr #left#stride
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr #right#stride
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>=(#left#stride:wybe.int, #right#stride:wybe.int)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"#left", "#left#end", "#left#start", "#left#stride", "#right", "#right#end", "#right#start", "#right#stride", "tmp#0"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>=(#left#stride:wybe.int, #right#stride:wybe.int)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '='
Types: Now assigned = semipure test computation binding {#left, #left#end, #left#start, #left#stride, #right, #right#end, #right#start, #right#stride, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt =(#left#end, #right#end)
Types: Mode checking call   : {=(#left#end, #right#end)}
Types:     with assigned    : semipure test computation binding {#left, #left#end, #left#start, #left#stride, #right, #right#end, #right#start, #right#stride, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #left#end
Types: Mode check exp resulted in #left#end
Types: Mode check exp #right#end
Types: Mode check exp resulted in #right#end
Types: Finding type of expr #left#end
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr #right#end
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::6}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::6}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#left::wybe.range, #left#end::2, #left#start::0, #left#stride::1, #right::wybe.range, #right#end::5, #right#start::3, #right#stride::4, tmp#0::6}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int, 5::wybe.int} (with no errors))]
Types: Finding type of expr #left#end
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr #right#end
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>=(#left#end:wybe.int, #right#end:wybe.int)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"#left", "#left#end", "#left#start", "#left#stride", "#right", "#right#end", "#right#start", "#right#stride", "tmp#0"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>=(#left#end:wybe.int, #right#end:wybe.int)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '='
Types: Now assigned = semipure test computation binding {#left, #left#end, #left#start, #left#stride, #right, #right#end, #right#start, #right#stride, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc '='
Types: Now assigned = semipure test computation binding {#left, #left#end, #left#start, #left#stride, #right, #right#end, #right#start, #right#stride, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc '='
Types: Assigned by then branch: semipure test computation binding {#left, #left#end, #left#start, #left#stride, #right, #right#end, #right#start, #right#stride, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt fail
Types: Mode checking Fail
Types: Now assigned = semipure failing computation binding Everything, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc '='
Types: Assigned by else branch: semipure failing computation binding Everything, break set = Everything, with resources {}
Types: Assigned by conditional: semipure test computation binding {#left, #left#end, #left#start, #left#stride, #right, #right#end, #right#start, #right#stride, tmp#0}, break set = Everything, with resources {}
Types: Type variable 2 is bound to Just wybe.int
Types: Type variable 0 is bound to Just wybe.int
Types: Type variable 1 is bound to Just wybe.int
Types: Type variable 5 is bound to Just wybe.int
Types: Type variable 3 is bound to Just wybe.int
Types: Type variable 4 is bound to Just wybe.int
Types: Type variable 6 is bound to Nothing
Types: Now assigned = semipure test computation binding {#left, #left#end, #left#start, #left#stride, #right, #right#end, #right#start, #right#stride, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc '='
Types: Mode checked body   : [{if {(   foreign llvm icmp_uge(#left:!wybe.int, 0:wybe.int, ?tmp#0:!wybe.bool)
Types:         & testbool tmp#0:!wybe.bool)::
Types: 
Types:         (   wybe.range.<1>range(?#left#start:wybe.int, ?#left#stride:wybe.int, ?#left#end:wybe.int, #left:wybe.range)
Types:         & wybe.range.<1>range(?#right#start:wybe.int, ?#right#stride:wybe.int, ?#right#end:wybe.int, #right:wybe.range)
Types:         & wybe.int.<0>=(#left#start:wybe.int, #right#start:wybe.int)
Types:         & wybe.int.<0>=(#left#stride:wybe.int, #right#stride:wybe.int)
Types:         & wybe.int.<0>=(#left#end:wybe.int, #right#end:wybe.int))
Types:     else::
Types:         fail
Types: 
Types:     }
Types:    condition -> {#left::wybe.range, #right::wybe.range, tmp#0::6}
Types:    then&else -> {#left::wybe.range, #left#end::wybe.int, #left#start::wybe.int, #left#stride::wybe.int, #right::wybe.range, #right#end::wybe.int, #right#start::wybe.int, #right#stride::wybe.int, tmp#0::6}}]
Types: Vars defined by body: semipure test computation binding {#left, #left#end, #left#start, #left#stride, #right, #right#end, #right#start, #right#stride, tmp#0}, break set = Everything, with resources {}
Types: Output parameters   : 
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of =:
Types: 
Types: = > public {test,inline} (0 calls)
Types: 4: =(#left:wybe.range, #right:wybe.range):
Types:     if {(   foreign llvm icmp_uge(#left:!wybe.int, 0:wybe.int, ?tmp#0:!wybe.bool)
Types:         & testbool tmp#0:!wybe.bool)::
Types: 
Types:         (   wybe.range.<1>range(?#left#start:wybe.int, ?#left#stride:wybe.int, ?#left#end:wybe.int, #left:wybe.range)
Types:         & wybe.range.<1>range(?#right#start:wybe.int, ?#right#stride:wybe.int, ?#right#end:wybe.int, #right:wybe.range)
Types:         & wybe.int.<0>=(#left#start:wybe.int, #right#start:wybe.int)
Types:         & wybe.int.<0>=(#left#stride:wybe.int, #right#stride:wybe.int)
Types:         & wybe.int.<0>=(#left#end:wybe.int, #right#end:wybe.int))
Types:     else::
Types:         fail
Types: 
Types:     }
Types:    condition -> {#left::wybe.range, #right::wybe.range, tmp#0::6}
Types:    then&else -> {#left::wybe.range, #left#end::wybe.int, #left#start::wybe.int, #left#stride::wybe.int, #right::wybe.range, #right#end::wybe.int, #right#start::wybe.int, #right#stride::wybe.int, tmp#0::6}
Types: **** Completed checking of wybe.range.= with 0 errors
Types: Type checking non-recursive proc wybe.range.[]
Types: ** Type checking decl of proc []
Types: found 1 definition(s)
Types: Type checking []
Types: ** Type checking []: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         <=(0 @range:21:6, idx @range:21:12)
Types:         range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)
Types:         *(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)
Types:         +(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)
Types:         =(?value @range:23:6, tmp#0)
Types:         <=(0 @range:24:10, stride @range:24:16)
Types:         <(value @range:24:27, end @range:24:35)
Types:         <(end @range:24:51, value @range:24:57)
Types:    and defaults: 
Types:    with assigned vars: fromList ["end","idx","r","size","stride","tmp#0","tmp#1","value"]
Types: Recording parameter types: r:wybe.range, idx:wybe.int, ?value:wybe.int
Types:     type of 'r' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable r type constrained to wybe.range
Types:     type of 'idx' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable idx type constrained to wybe.int
Types:     type of 'value' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable value type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {<=(0 @range:21:6, idx @range:21:12)}
Types: Recording casts in {range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)}
Types: Recording casts in {*(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)}
Types: Recording casts in {+(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)}
Types: Recording casts in {=(?value @range:23:6, tmp#0)}
Types: Recording casts in {<=(0 @range:24:10, stride @range:24:16)}
Types: Recording casts in {<(value @range:24:27, end @range:24:35)}
Types: Recording casts in {<(end @range:24:51, value @range:24:57)}
Types: *** Before calls Typing {idx::wybe.int, r::wybe.range, value::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {<=(0 @range:21:6, idx @range:21:12)} @range:21:6, typingInfos = [wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)} @range:22:5, typingInfos = [wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)]}
Types:     StmtTypings {typingStmt = {*(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)} @range:23:21, typingInfos = [wybe.int.*<0>(wybe.int,wybe.int,?wybe.int)]}
Types:     StmtTypings {typingStmt = {+(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)} @range:23:14, typingInfos = [wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?value @range:23:6, tmp#0)} @range:23:6, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),{test} wybe.range.=<0>(wybe.range,wybe.range)]}
Types:     StmtTypings {typingStmt = {<=(0 @range:24:10, stride @range:24:16)} @range:24:10, typingInfos = [wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {<(value @range:24:27, end @range:24:35)} @range:24:27, typingInfos = [wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {<(end @range:24:51, value @range:24:57)} @range:24:51, typingInfos = [wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)]}Typing {idx::wybe.int, r::wybe.range, value::wybe.int}; {} (with no errors)
Types: Type checking call {<=(0 @range:21:6, idx @range:21:12)} @range:21:6
Types: Candidate types:
Types:     wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr 0 @range:21:6
Types:   Type = wybe.int
Types: Finding type of expr idx @range:21:12
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {idx::wybe.int, r::wybe.range, value::wybe.int}; {} (with no errors)]
Types: Resulting typing = Typing {idx::wybe.int, r::wybe.range, value::wybe.int}; {} (with no errors)
Types: Type checking call {range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)} @range:22:5
Types: Candidate types:
Types:     wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types:     wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Finding type of expr ?size @range:22:16
Types:   Type = 0
Types: Finding type of expr ?stride @range:22:23
Types:   Type = 1
Types: Finding type of expr ?end @range:22:32
Types:   Type = 2
Types: Finding type of expr r @range:22:5
Types:   Type = wybe.range
Types: Actual types: [0,1,2,wybe.range]
Types: Matching types [0,1,2,wybe.range] with wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 2 is bound to Nothing
Types: Unifying types 2 (-> 2) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Matching types [0,1,2,wybe.range] with wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 2 is bound to Nothing
Types: Unifying types 2 (-> 2) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Valid types = [Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int} (with no errors)]
Types: Resulting typing = Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int} (with no errors)
Types: Type checking call {*(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)} @range:23:21
Types: Candidate types:
Types:     wybe.int.*<0>(wybe.int,wybe.int,?wybe.int)
Types: Finding type of expr stride @range:23:21
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr idx @range:23:30
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @range:23:21
Types:   Type = 3
Types: Actual types: [wybe.int,wybe.int,3]
Types: Matching types [wybe.int,wybe.int,3] with wybe.int.*<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 3 is bound to Nothing
Types: Unifying types 3 (-> 3) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int} (with no errors)]
Types: Resulting typing = Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int} (with no errors)
Types: Type checking call {+(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)} @range:23:14
Types: Candidate types:
Types:     wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Finding type of expr size @range:23:14
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr tmp#1
Types: Type variable 3 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:23:14
Types:   Type = 4
Types: Actual types: [wybe.int,wybe.int,4]
Types: Matching types [wybe.int,wybe.int,4] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 4 is bound to Nothing
Types: Unifying types 4 (-> 4) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,4] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 4 is bound to Nothing
Types: Unifying types 4 (-> 4) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,4] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 4 is bound to Nothing
Types: Unifying types 4 (-> 4) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors)]
Types: Resulting typing = Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors)
Types: Type checking call {=(?value @range:23:6, tmp#0)} @range:23:6
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types:     {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Finding type of expr ?value @range:23:6
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 23, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 23, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 23, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 23, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors)]
Types: Resulting typing = Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors)
Types: Type checking call {<=(0 @range:24:10, stride @range:24:16)} @range:24:10
Types: Candidate types:
Types:     wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr 0 @range:24:10
Types:   Type = wybe.int
Types: Finding type of expr stride @range:24:16
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors)]
Types: Resulting typing = Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors)
Types: Type checking call {<(value @range:24:27, end @range:24:35)} @range:24:27
Types: Candidate types:
Types:     wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr value @range:24:27
Types:   Type = wybe.int
Types: Finding type of expr end @range:24:35
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors)]
Types: Resulting typing = Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors)
Types: Type checking call {<(end @range:24:51, value @range:24:57)} @range:24:51
Types: Candidate types:
Types:     wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr end @range:24:51
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr value @range:24:57
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors)]
Types: Resulting typing = Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors)
Types: Now mode checking proc []
Types: bound vars: semipure normal (total) computation binding {idx, r}, break set = Everything, with resources {}
Types: Mode check stmt <=(0 @range:21:6, idx @range:21:12)
Types: Mode checking call   : {<=(0 @range:21:6, idx @range:21:12)}
Types:     with assigned    : semipure normal (total) computation binding {idx, r}, break set = Everything, with resources {}
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp idx
Types: Mode check exp resulted in idx
Types: Finding type of expr 0 @range:21:6
Types:   Type = wybe.int
Types: Finding type of expr idx @range:21:12
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Finding type of expr 0 @range:21:6
Types:   Type = wybe.int
Types: Finding type of expr idx @range:21:12
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0><=(0:wybe.int @range:21:6, idx:wybe.int @range:21:12)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"idx", "r"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0><=(0:wybe.int @range:21:6, idx:wybe.int @range:21:12)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '[]'
Types: Now assigned = semipure test computation binding {idx, r}, break set = Everything, with resources {}
Types: Mode check stmt range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)
Types: Mode checking call   : {range(?size @range:22:16, ?stride @range:22:23, ?end @range:22:32, r @range:22:5)}
Types:     with assigned    : semipure test computation binding {idx, r}, break set = Everything, with resources {}
Types: Mode check exp ?size
Types: Mode check exp resulted in ?size
Types: Mode check exp ?stride
Types: Mode check exp resulted in ?stride
Types: Mode check exp ?end
Types: Mode check exp resulted in ?end
Types: Mode check exp r
Types: Mode check exp resulted in r
Types: Finding type of expr ?size @range:22:16
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?stride @range:22:23
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?end @range:22:32
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr r @range:22:5
Types:   Type = wybe.range
Types:     actual types     : [wybe.int,wybe.int,wybe.int,wybe.range]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamOut,False,Nothing),(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Type-correct modes   : [(wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors)),(wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Finding type of expr ?size @range:22:16
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?stride @range:22:23
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?end @range:22:32
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr r @range:22:5
Types:   Type = wybe.range
Types: Finalising call    :  {wybe.range.<1>range(?size:wybe.int @range:22:16, ?stride:wybe.int @range:22:23, ?end:wybe.int @range:22:32, r:wybe.range @range:22:5)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"idx", "r"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.range.<1>range(?size:wybe.int @range:22:16, ?stride:wybe.int @range:22:23, ?end:wybe.int @range:22:32, r:wybe.range @range:22:5)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '[]'
Types: Now assigned = semipure test computation binding {end, idx, r, size, stride}, break set = Everything, with resources {}
Types: Mode check stmt *(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)
Types: Mode checking call   : {*(stride @range:23:21, idx @range:23:30, ?tmp#1 @range:23:21)}
Types:     with assigned    : semipure test computation binding {end, idx, r, size, stride}, break set = Everything, with resources {}
Types: Mode check exp stride
Types: Mode check exp resulted in stride
Types: Mode check exp idx
Types: Mode check exp resulted in idx
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr stride @range:23:21
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr idx @range:23:30
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @range:23:21
Types: Type variable 3 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.*<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.*<0>(wybe.int,wybe.int,?wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.*<0>(wybe.int,wybe.int,?wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.*<0>(wybe.int,wybe.int,?wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Finding type of expr stride @range:23:21
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr idx @range:23:30
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @range:23:21
Types: Type variable 3 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>*(stride:wybe.int @range:23:21, idx:wybe.int @range:23:30, ?tmp#1:wybe.int @range:23:21)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "idx", "r", "size", "stride"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>*(stride:wybe.int @range:23:21, idx:wybe.int @range:23:30, ?tmp#1:wybe.int @range:23:21)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '[]'
Types: Now assigned = semipure test computation binding {end, idx, r, size, stride, tmp#1}, break set = Everything, with resources {}
Types: Mode check stmt +(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)
Types: Mode checking call   : {+(size @range:23:14, tmp#1, ?tmp#0 @range:23:14)}
Types:     with assigned    : semipure test computation binding {end, idx, r, size, stride, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp size
Types: Mode check exp resulted in size
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr size @range:23:14
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr tmp#1
Types: Type variable 3 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:23:14
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors)),(wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors)),(wybe.int.+<2>(wybe.int,?wybe.int,wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Finding type of expr size @range:23:14
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr tmp#1
Types: Type variable 3 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:23:14
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>+(size:wybe.int @range:23:14, tmp#1:wybe.int, ?tmp#0:wybe.int @range:23:14)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "idx", "r", "size", "stride", "tmp#1"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>+(size:wybe.int @range:23:14, tmp#1:wybe.int, ?tmp#0:wybe.int @range:23:14)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '[]'
Types: Now assigned = semipure test computation binding {end, idx, r, size, stride, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check stmt =(?value @range:23:6, tmp#0)
Types: Mode checking call   : {=(?value @range:23:6, tmp#0)}
Types:     with assigned    : semipure test computation binding {end, idx, r, size, stride, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp ?value
Types: Mode check exp resulted in ?value
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?value @range:23:6
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 23, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 23, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 23, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 23, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?value @range:23:6)}
Types:     with assigned semipure test computation binding {end, idx, r, size, stride, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?value
Types: Mode check exp resulted in ?value
Types: Finding type of expr tmp#0
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?value @range:23:6
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?value:wybe.int @range:23:6)}
Types: Now assigned = semipure test computation binding {end, idx, r, size, stride, tmp#0, tmp#1, value}, break set = Everything, with resources {}
Types: Mode check stmt if {<=(0 @range:24:10, stride @range:24:16)::
Types: 
Types:                     <(value @range:24:27, end @range:24:35)
Types:                 else::
Types:                     <(end @range:24:51, value @range:24:57)
Types: 
Types:                 }
Types: Mode checking conditional {if {<=(0 @range:24:10, stride @range:24:16)::
Types: 
Types:         <(value @range:24:27, end @range:24:35)
Types:     else::
Types:         <(end @range:24:51, value @range:24:57)
Types: 
Types:     }}
Types: Mode checking call   : {<=(0 @range:24:10, stride @range:24:16)}
Types:     with assigned    : semipure test computation binding {end, idx, r, size, stride, tmp#0, tmp#1, value}, break set = Everything, with resources {}
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp stride
Types: Mode check exp resulted in stride
Types: Finding type of expr 0 @range:24:10
Types:   Type = wybe.int
Types: Finding type of expr stride @range:24:16
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Finding type of expr 0 @range:24:10
Types:   Type = wybe.int
Types: Finding type of expr stride @range:24:16
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0><=(0:wybe.int @range:24:10, stride:wybe.int @range:24:16)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "idx", "r", "size", "stride", "tmp#0", "tmp#1", "value"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0><=(0:wybe.int @range:24:10, stride:wybe.int @range:24:16)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '[]'
Types: Assigned by test: semipure test computation binding {end, idx, r, size, stride, tmp#0, tmp#1, value}, break set = Everything, with resources {}
Types: Type variable 2 is bound to Just wybe.int
Types: Type variable 0 is bound to Just wybe.int
Types: Type variable 1 is bound to Just wybe.int
Types: Type variable 4 is bound to Just wybe.int
Types: Type variable 3 is bound to Just wybe.int
Types: Mode check stmt <(value @range:24:27, end @range:24:35)
Types: Mode checking call   : {<(value @range:24:27, end @range:24:35)}
Types:     with assigned    : semipure normal (total) computation binding {end, idx, r, size, stride, tmp#0, tmp#1, value}, break set = Everything, with resources {}
Types: Mode check exp value
Types: Mode check exp resulted in value
Types: Mode check exp end
Types: Mode check exp resulted in end
Types: Finding type of expr value @range:24:27
Types:   Type = wybe.int
Types: Finding type of expr end @range:24:35
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.<<0>(wybe.int,wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.<<0>(wybe.int,wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.<<0>(wybe.int,wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Finding type of expr value @range:24:27
Types:   Type = wybe.int
Types: Finding type of expr end @range:24:35
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0><(value:wybe.int @range:24:27, end:wybe.int @range:24:35)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "idx", "r", "size", "stride", "tmp#0", "tmp#1", "value"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0><(value:wybe.int @range:24:27, end:wybe.int @range:24:35)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '[]'
Types: Now assigned = semipure test computation binding {end, idx, r, size, stride, tmp#0, tmp#1, value}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc '[]'
Types: Assigned by then branch: semipure test computation binding {end, idx, r, size, stride, tmp#0, tmp#1, value}, break set = Everything, with resources {}
Types: Mode check stmt <(end @range:24:51, value @range:24:57)
Types: Mode checking call   : {<(end @range:24:51, value @range:24:57)}
Types:     with assigned    : semipure test computation binding {end, idx, r, size, stride, tmp#0, tmp#1, value}, break set = Everything, with resources {}
Types: Mode check exp end
Types: Mode check exp resulted in end
Types: Mode check exp value
Types: Mode check exp resulted in value
Types: Finding type of expr end @range:24:51
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr value @range:24:57
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.<<0>(wybe.int,wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.<<0>(wybe.int,wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.<<0>(wybe.int,wybe.int),Typing {end::2, idx::wybe.int, r::wybe.range, size::0, stride::1, tmp#0::4, tmp#1::3, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.int, 4::wybe.int} (with no errors))]
Types: Finding type of expr end @range:24:51
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr value @range:24:57
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0><(end:wybe.int @range:24:51, value:wybe.int @range:24:57)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "idx", "r", "size", "stride", "tmp#0", "tmp#1", "value"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0><(end:wybe.int @range:24:51, value:wybe.int @range:24:57)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '[]'
Types: Now assigned = semipure test computation binding {end, idx, r, size, stride, tmp#0, tmp#1, value}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc '[]'
Types: Assigned by else branch: semipure test computation binding {end, idx, r, size, stride, tmp#0, tmp#1, value}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure test computation binding {end, idx, r, size, stride, tmp#0, tmp#1, value}, break set = Everything, with resources {}
Types: Type variable 2 is bound to Just wybe.int
Types: Type variable 0 is bound to Just wybe.int
Types: Type variable 1 is bound to Just wybe.int
Types: Type variable 4 is bound to Just wybe.int
Types: Type variable 3 is bound to Just wybe.int
Types: Now assigned = semipure test computation binding {end, idx, r, size, stride, tmp#0, tmp#1, value}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc '[]'
Types: Mode checked body   : [{wybe.int.<0><=(0:wybe.int @range:21:6, idx:wybe.int @range:21:12)} @range:21:6,{wybe.range.<1>range(?size:wybe.int @range:22:16, ?stride:wybe.int @range:22:23, ?end:wybe.int @range:22:32, r:wybe.range @range:22:5)} @range:22:5,{wybe.int.<0>*(stride:wybe.int @range:23:21, idx:wybe.int @range:23:30, ?tmp#1:wybe.int @range:23:21)} @range:23:21,{wybe.int.<0>+(size:wybe.int @range:23:14, tmp#1:wybe.int, ?tmp#0:wybe.int @range:23:14)} @range:23:14,{foreign llvm move(tmp#0:wybe.int, ?value:wybe.int @range:23:6)} @range:23:6,{if {wybe.int.<0><=(0:wybe.int @range:24:10, stride:wybe.int @range:24:16)::
Types: 
Types:         wybe.int.<0><(value:wybe.int @range:24:27, end:wybe.int @range:24:35)
Types:     else::
Types:         wybe.int.<0><(end:wybe.int @range:24:51, value:wybe.int @range:24:57)
Types: 
Types:     }
Types:    condition -> {end::wybe.int, idx::wybe.int, r::wybe.range, size::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int, value::wybe.int}
Types:    then&else -> {end::wybe.int, idx::wybe.int, r::wybe.range, size::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int, value::wybe.int}} @range:24:10]
Types: Vars defined by body: semipure test computation binding {end, idx, r, size, stride, tmp#0, tmp#1, value}, break set = Everything, with resources {}
Types: Output parameters   : value
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of []:
Types: 
Types: [] > public {test} (0 calls)
Types: 4: [](r:wybe.range @range:20:19, idx:wybe.int @range:20:24, ?value:wybe.int @range:20:34):
Types:     wybe.int.<0><=(0:wybe.int @range:21:6, idx:wybe.int @range:21:12)
Types:     wybe.range.<1>range(?size:wybe.int @range:22:16, ?stride:wybe.int @range:22:23, ?end:wybe.int @range:22:32, r:wybe.range @range:22:5)
Types:     wybe.int.<0>*(stride:wybe.int @range:23:21, idx:wybe.int @range:23:30, ?tmp#1:wybe.int @range:23:21)
Types:     wybe.int.<0>+(size:wybe.int @range:23:14, tmp#1:wybe.int, ?tmp#0:wybe.int @range:23:14)
Types:     foreign llvm move(tmp#0:wybe.int, ?value:wybe.int @range:23:6)
Types:     if {wybe.int.<0><=(0:wybe.int @range:24:10, stride:wybe.int @range:24:16)::
Types: 
Types:         wybe.int.<0><(value:wybe.int @range:24:27, end:wybe.int @range:24:35)
Types:     else::
Types:         wybe.int.<0><(end:wybe.int @range:24:51, value:wybe.int @range:24:57)
Types: 
Types:     }
Types:    condition -> {end::wybe.int, idx::wybe.int, r::wybe.range, size::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int, value::wybe.int}
Types:    then&else -> {end::wybe.int, idx::wybe.int, r::wybe.range, size::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int, value::wybe.int}
Types: Type checking non-recursive proc wybe.range.construct
Types: ** Type checking decl of proc construct
Types: found 1 definition(s)
Types: Type checking construct
Types: ** Type checking construct: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         -(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)
Types:         %(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)
Types:         =(?diff @range:50:6, tmp#0)
Types:         <=(0 @range:51:19, stride @range:51:25)
Types:         =(diff @range:52:26, 0 @range:52:33)
Types:         max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
Types:         foreign llvm move(tmp#4, ?tmp#3)
Types:         +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
Types:         -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
Types:         max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
Types:         foreign llvm move(tmp#5, ?tmp#3)
Types:         foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
Types:         =(diff @range:55:26, 0 @range:55:33)
Types:         min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
Types:         foreign llvm move(tmp#9, ?tmp#8)
Types:         +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
Types:         min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
Types:         foreign llvm move(tmp#10, ?tmp#8)
Types:         foreign llvm move(tmp#8 @range:55:26, ?tmp#2)
Types:         =(?final @range:51:6, tmp#2 @range:51:19)
Types:         range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)
Types:         =(?r @range:58:6, tmp#12)
Types:         foreign llvm move(r @range:49:51, ?#result @range:49:1)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","diff","end","final","r","start","stride","tmp#0","tmp#1","tmp#10","tmp#11","tmp#12","tmp#2","tmp#3","tmp#4","tmp#5","tmp#6","tmp#7","tmp#8","tmp#9"]
Types: Recording parameter types: start:wybe.int, stride:wybe.int, end:wybe.int, ?#result:wybe.range
Types:     type of 'start' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable start type constrained to wybe.int
Types:     type of 'stride' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable stride type constrained to wybe.int
Types:     type of 'end' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable end type constrained to wybe.int
Types:     type of '#result' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #result type constrained to wybe.range
Types: Recording resource types: 
Types: Recording casts in {-(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)}
Types: Recording casts in {%(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)}
Types: Recording casts in {=(?diff @range:50:6, tmp#0)}
Types: Recording casts in {<=(0 @range:51:19, stride @range:51:25)}
Types: Recording casts in {=(diff @range:52:26, 0 @range:52:33)}
Types: Recording casts in {max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)}
Types: Recording casts in {foreign llvm move(tmp#4, ?tmp#3)}
Types: Unifying move argument types tmp#4 and ?tmp#3
Types: Finding type of expr tmp#4
Types:   Type = 0
Types: Finding type of expr ?tmp#3
Types:   Type = 1
Types: Type variable 0 is bound to Nothing
Types: Type variable 1 is bound to Nothing
Types: Unifying types 0 (-> 0) and 1 (-> 1)
Types:   Unification yields 0
Types: Recording casts in {+(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)}
Types: Recording casts in {-(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)}
Types: Recording casts in {max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)}
Types: Recording casts in {foreign llvm move(tmp#5, ?tmp#3)}
Types: Unifying move argument types tmp#5 and ?tmp#3
Types: Finding type of expr tmp#5
Types:   Type = 2
Types: Finding type of expr ?tmp#3
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Nothing
Types:   Type = 0
Types: Type variable 2 is bound to Nothing
Types: Type variable 0 is bound to Nothing
Types: Unifying types 2 (-> 2) and 0 (-> 0)
Types:   Unification yields 0
Types: Recording casts in {foreign llvm move(tmp#3 @range:52:26, ?tmp#2)}
Types: Unifying move argument types tmp#3 @range:52:26 and ?tmp#2
Types: Finding type of expr tmp#3 @range:52:26
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Nothing
Types:   Type = 0
Types: Finding type of expr ?tmp#2
Types:   Type = 3
Types: Type variable 0 is bound to Nothing
Types: Type variable 3 is bound to Nothing
Types: Unifying types 0 (-> 0) and 3 (-> 3)
Types:   Unification yields 0
Types: Recording casts in {=(diff @range:55:26, 0 @range:55:33)}
Types: Recording casts in {min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)}
Types: Recording casts in {foreign llvm move(tmp#9, ?tmp#8)}
Types: Unifying move argument types tmp#9 and ?tmp#8
Types: Finding type of expr tmp#9
Types:   Type = 4
Types: Finding type of expr ?tmp#8
Types:   Type = 5
Types: Type variable 4 is bound to Nothing
Types: Type variable 5 is bound to Nothing
Types: Unifying types 4 (-> 4) and 5 (-> 5)
Types:   Unification yields 4
Types: Recording casts in {+(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)}
Types: Recording casts in {min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)}
Types: Recording casts in {foreign llvm move(tmp#10, ?tmp#8)}
Types: Unifying move argument types tmp#10 and ?tmp#8
Types: Finding type of expr tmp#10
Types:   Type = 6
Types: Finding type of expr ?tmp#8
Types: Type variable 5 is bound to Just 4
Types: Type variable 4 is bound to Nothing
Types:   Type = 4
Types: Type variable 6 is bound to Nothing
Types: Type variable 4 is bound to Nothing
Types: Unifying types 6 (-> 6) and 4 (-> 4)
Types:   Unification yields 4
Types: Recording casts in {foreign llvm move(tmp#8 @range:55:26, ?tmp#2)}
Types: Unifying move argument types tmp#8 @range:55:26 and ?tmp#2
Types: Finding type of expr tmp#8 @range:55:26
Types: Type variable 5 is bound to Just 4
Types: Type variable 4 is bound to Nothing
Types:   Type = 4
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 0
Types: Type variable 0 is bound to Nothing
Types:   Type = 0
Types: Type variable 4 is bound to Nothing
Types: Type variable 0 is bound to Nothing
Types: Unifying types 4 (-> 4) and 0 (-> 0)
Types:   Unification yields 0
Types: Recording casts in {=(?final @range:51:6, tmp#2 @range:51:19)}
Types: Recording casts in {range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)}
Types: Recording casts in {=(?r @range:58:6, tmp#12)}
Types: Recording casts in {foreign llvm move(r @range:49:51, ?#result @range:49:1)}
Types: Unifying move argument types r @range:49:51 and ?#result @range:49:1
Types: Finding type of expr r @range:49:51
Types:   Type = 7
Types: Finding type of expr ?#result @range:49:1
Types:   Type = wybe.range
Types: Type variable 7 is bound to Nothing
Types: Unifying types 7 (-> 7) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: *** Before calls Typing {#result::wybe.range, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#8::5, tmp#9::4}; {1::0, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {-(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)} @range:50:14, typingInfos = [wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),wybe.int.-<3>(wybe.int,?wybe.int),wybe.int.-<4>(?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {%(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)} @range:50:13, typingInfos = [wybe.int.%<0>(wybe.int,wybe.int,?wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?diff @range:50:6, tmp#0)} @range:50:6, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),{test} wybe.range.=<0>(wybe.range,wybe.range)]}
Types:     StmtTypings {typingStmt = {<=(0 @range:51:19, stride @range:51:25)} @range:51:19, typingInfos = [wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {=(diff @range:52:26, 0 @range:52:33)} @range:52:26, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),{test} wybe.range.=<0>(wybe.range,wybe.range)]}
Types:     StmtTypings {typingStmt = {max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)} @range:52:38, typingInfos = [wybe.int.max<0>(wybe.int,wybe.int,?wybe.int)]}
Types:     StmtTypings {typingStmt = {+(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)} @range:53:45, typingInfos = [wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {-(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)} @range:53:45, typingInfos = [wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),wybe.int.-<3>(wybe.int,?wybe.int),wybe.int.-<4>(?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)} @range:53:34, typingInfos = [wybe.int.max<0>(wybe.int,wybe.int,?wybe.int)]}
Types:     StmtTypings {typingStmt = {=(diff @range:55:26, 0 @range:55:33)} @range:55:26, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),{test} wybe.range.=<0>(wybe.range,wybe.range)]}
Types:     StmtTypings {typingStmt = {min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)} @range:55:38, typingInfos = [wybe.int.min<0>(wybe.int,wybe.int,?wybe.int)]}
Types:     StmtTypings {typingStmt = {+(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)} @range:56:45, typingInfos = [wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)} @range:56:34, typingInfos = [wybe.int.min<0>(wybe.int,wybe.int,?wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?final @range:51:6, tmp#2 @range:51:19)} @range:51:6, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),{test} wybe.range.=<0>(wybe.range,wybe.range)]}
Types:     StmtTypings {typingStmt = {range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)} @range:58:10, typingInfos = [wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)]}
Types:     StmtTypings {typingStmt = {=(?r @range:58:6, tmp#12)} @range:58:6, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),{test} wybe.range.=<0>(wybe.range,wybe.range)]}Typing {#result::wybe.range, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#8::5, tmp#9::4}; {1::0, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range} (with no errors)
Types: Type checking call {-(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)} @range:50:14
Types: Candidate types:
Types:     wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types:     wybe.int.-<3>(wybe.int,?wybe.int)
Types:     wybe.int.-<4>(?wybe.int,wybe.int)
Types: Finding type of expr end @range:50:14
Types:   Type = wybe.int
Types: Finding type of expr start @range:50:20
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @range:50:14
Types:   Type = 8
Types: Actual types: [wybe.int,wybe.int,8]
Types: Matching types [wybe.int,wybe.int,8] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 8 is bound to Nothing
Types: Unifying types 8 (-> 8) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,8] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 8 is bound to Nothing
Types: Unifying types 8 (-> 8) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,8] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 8 is bound to Nothing
Types: Unifying types 8 (-> 8) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.range, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#8::5, tmp#9::4}; {1::0, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#8::5, tmp#9::4}; {1::0, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int} (with no errors)
Types: Type checking call {%(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)} @range:50:13
Types: Candidate types:
Types:     wybe.int.%<0>(wybe.int,wybe.int,?wybe.int)
Types: Finding type of expr tmp#1
Types: Type variable 8 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr stride @range:50:29
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:50:13
Types:   Type = 9
Types: Actual types: [wybe.int,wybe.int,9]
Types: Matching types [wybe.int,wybe.int,9] with wybe.int.%<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 9 is bound to Nothing
Types: Unifying types 9 (-> 9) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.range, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#8::5, tmp#9::4}; {1::0, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#8::5, tmp#9::4}; {1::0, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {=(?diff @range:50:6, tmp#0)} @range:50:6
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types:     {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Finding type of expr ?diff @range:50:6
Types:   Type = 10
Types: Finding type of expr tmp#0
Types: Type variable 9 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [10,wybe.int]
Types: Matching types [10,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Type variable 10 is bound to Nothing
Types: Unifying types 10 (-> 10) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 50, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [10,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Type variable 10 is bound to Nothing
Types: Unifying types 10 (-> 10) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [10,wybe.int] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Type variable 10 is bound to Nothing
Types: Unifying types 10 (-> 10) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 50, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#8::5, tmp#9::4}; {1::0, 10::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#8::5, tmp#9::4}; {1::0, 10::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {<=(0 @range:51:19, stride @range:51:25)} @range:51:19
Types: Candidate types:
Types:     wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr 0 @range:51:19
Types:   Type = wybe.int
Types: Finding type of expr stride @range:51:25
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#8::5, tmp#9::4}; {1::0, 10::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#8::5, tmp#9::4}; {1::0, 10::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {=(diff @range:52:26, 0 @range:52:33)} @range:52:26
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types:     {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Finding type of expr diff @range:52:26
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0 @range:52:33
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 52, column 26): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 52, column 26): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 52, column 26): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 52, column 26): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#8::5, tmp#9::4}; {1::0, 10::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#8::5, tmp#9::4}; {1::0, 10::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)} @range:52:38
Types: Candidate types:
Types:     wybe.int.max<0>(wybe.int,wybe.int,?wybe.int)
Types: Finding type of expr start @range:52:42
Types:   Type = wybe.int
Types: Finding type of expr end @range:52:49
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#4 @range:52:38
Types: Type variable 0 is bound to Nothing
Types:   Type = 0
Types: Actual types: [wybe.int,wybe.int,0]
Types: Matching types [wybe.int,wybe.int,0] with wybe.int.max<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {+(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)} @range:53:45
Types: Candidate types:
Types:     wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Finding type of expr end @range:53:45
Types:   Type = wybe.int
Types: Finding type of expr stride @range:53:51
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#7 @range:53:45
Types:   Type = 11
Types: Actual types: [wybe.int,wybe.int,11]
Types: Matching types [wybe.int,wybe.int,11] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 11 is bound to Nothing
Types: Unifying types 11 (-> 11) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,11] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 11 is bound to Nothing
Types: Unifying types 11 (-> 11) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,11] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 11 is bound to Nothing
Types: Unifying types 11 (-> 11) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {-(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)} @range:53:45
Types: Candidate types:
Types:     wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types:     wybe.int.-<3>(wybe.int,?wybe.int)
Types:     wybe.int.-<4>(?wybe.int,wybe.int)
Types: Finding type of expr tmp#7
Types: Type variable 11 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr diff @range:53:60
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#6 @range:53:45
Types:   Type = 12
Types: Actual types: [wybe.int,wybe.int,12]
Types: Matching types [wybe.int,wybe.int,12] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 12 is bound to Nothing
Types: Unifying types 12 (-> 12) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,12] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 12 is bound to Nothing
Types: Unifying types 12 (-> 12) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,12] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 12 is bound to Nothing
Types: Unifying types 12 (-> 12) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)} @range:53:34
Types: Candidate types:
Types:     wybe.int.max<0>(wybe.int,wybe.int,?wybe.int)
Types: Finding type of expr start @range:53:38
Types:   Type = wybe.int
Types: Finding type of expr tmp#6
Types: Type variable 12 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#5 @range:53:34
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.max<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {=(diff @range:55:26, 0 @range:55:33)} @range:55:26
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types:     {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Finding type of expr diff @range:55:26
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0 @range:55:33
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 55, column 26): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 55, column 26): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 55, column 26): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 55, column 26): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)} @range:55:38
Types: Candidate types:
Types:     wybe.int.min<0>(wybe.int,wybe.int,?wybe.int)
Types: Finding type of expr start @range:55:42
Types:   Type = wybe.int
Types: Finding type of expr end @range:55:49
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#9 @range:55:38
Types: Type variable 4 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.min<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {+(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)} @range:56:45
Types: Candidate types:
Types:     wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Finding type of expr end @range:56:45
Types:   Type = wybe.int
Types: Finding type of expr diff @range:56:51
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#11 @range:56:45
Types:   Type = 13
Types: Actual types: [wybe.int,wybe.int,13]
Types: Matching types [wybe.int,wybe.int,13] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 13 is bound to Nothing
Types: Unifying types 13 (-> 13) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,13] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 13 is bound to Nothing
Types: Unifying types 13 (-> 13) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,13] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 13 is bound to Nothing
Types: Unifying types 13 (-> 13) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)} @range:56:34
Types: Candidate types:
Types:     wybe.int.min<0>(wybe.int,wybe.int,?wybe.int)
Types: Finding type of expr start @range:56:38
Types:   Type = wybe.int
Types: Finding type of expr tmp#11
Types: Type variable 13 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#10 @range:56:34
Types: Type variable 6 is bound to Just 4
Types: Type variable 4 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.min<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, diff::10, end::wybe.int, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {=(?final @range:51:6, tmp#2 @range:51:19)} @range:51:6
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types:     {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Finding type of expr ?final @range:51:6
Types:   Type = 14
Types: Finding type of expr tmp#2 @range:51:19
Types: Type variable 3 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [14,wybe.int]
Types: Matching types [14,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Type variable 14 is bound to Nothing
Types: Unifying types 14 (-> 14) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 51, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [14,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Type variable 14 is bound to Nothing
Types: Unifying types 14 (-> 14) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [14,wybe.int] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Type variable 14 is bound to Nothing
Types: Unifying types 14 (-> 14) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 51, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)} @range:58:10
Types: Candidate types:
Types:     wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types:     wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Finding type of expr start @range:58:16
Types:   Type = wybe.int
Types: Finding type of expr stride @range:58:23
Types:   Type = wybe.int
Types: Finding type of expr final @range:58:31
Types: Type variable 14 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#12 @range:58:10
Types:   Type = 15
Types: Actual types: [wybe.int,wybe.int,wybe.int,15]
Types: Matching types [wybe.int,wybe.int,wybe.int,15] with wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 15 is bound to Nothing
Types: Unifying types 15 (-> 15) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Matching types [wybe.int,wybe.int,wybe.int,15] with wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 15 is bound to Nothing
Types: Unifying types 15 (-> 15) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Valid types = [Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {=(?r @range:58:6, tmp#12)} @range:58:6
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types:     {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Finding type of expr ?r @range:58:6
Types: Type variable 7 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Finding type of expr tmp#12
Types: Type variable 15 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Actual types: [wybe.range,wybe.range]
Types: Matching types [wybe.range,wybe.range] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 58, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.range (-> wybe.range) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 58, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.range,wybe.range] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 58, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.range (-> wybe.range) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 58, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.range,wybe.range] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Valid types = [Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Finding type of expr tmp#4
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#3
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#5
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#3
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#3 @range:52:26
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#9
Types: Type variable 4 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#8
Types: Type variable 5 is bound to Just 4
Types: Type variable 4 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#10
Types: Type variable 6 is bound to Just 4
Types: Type variable 4 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#8
Types: Type variable 5 is bound to Just 4
Types: Type variable 4 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#8 @range:55:26
Types: Type variable 5 is bound to Just 4
Types: Type variable 4 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr r @range:49:51
Types: Type variable 7 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Finding type of expr ?#result @range:49:1
Types:   Type = wybe.range
Types: Type checking foreign llvm call move(address, address)
Types: Now mode checking proc construct
Types: bound vars: semipure normal (total) computation binding {end, start, stride}, break set = Everything, with resources {}
Types: Mode check stmt -(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)
Types: Mode checking call   : {-(end @range:50:14, start @range:50:20, ?tmp#1 @range:50:14)}
Types:     with assigned    : semipure normal (total) computation binding {end, start, stride}, break set = Everything, with resources {}
Types: Mode check exp end
Types: Mode check exp resulted in end
Types: Mode check exp start
Types: Mode check exp resulted in start
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr end @range:50:14
Types:   Type = wybe.int
Types: Finding type of expr start @range:50:20
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @range:50:14
Types: Type variable 8 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr end @range:50:14
Types:   Type = wybe.int
Types: Finding type of expr start @range:50:20
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @range:50:14
Types: Type variable 8 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>-(end:wybe.int @range:50:14, start:wybe.int @range:50:20, ?tmp#1:wybe.int @range:50:14)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "start", "stride"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>-(end:wybe.int @range:50:14, start:wybe.int @range:50:20, ?tmp#1:wybe.int @range:50:14)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'construct'
Types: Now assigned = semipure normal (total) computation binding {end, start, stride, tmp#1}, break set = Everything, with resources {}
Types: Mode check stmt %(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)
Types: Mode checking call   : {%(tmp#1, stride @range:50:29, ?tmp#0 @range:50:13)}
Types:     with assigned    : semipure normal (total) computation binding {end, start, stride, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp stride
Types: Mode check exp resulted in stride
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#1
Types: Type variable 8 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr stride @range:50:29
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:50:13
Types: Type variable 9 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.%<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.%<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.%<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.%<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr tmp#1
Types: Type variable 8 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr stride @range:50:29
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:50:13
Types: Type variable 9 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>%(tmp#1:wybe.int, stride:wybe.int @range:50:29, ?tmp#0:wybe.int @range:50:13)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "start", "stride", "tmp#1"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>%(tmp#1:wybe.int, stride:wybe.int @range:50:29, ?tmp#0:wybe.int @range:50:13)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'construct'
Types: Now assigned = semipure normal (total) computation binding {end, start, stride, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check stmt =(?diff @range:50:6, tmp#0)
Types: Mode checking call   : {=(?diff @range:50:6, tmp#0)}
Types:     with assigned    : semipure normal (total) computation binding {end, start, stride, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp ?diff
Types: Mode check exp resulted in ?diff
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?diff @range:50:6
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr tmp#0
Types: Type variable 9 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 50, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 50, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 50, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 50, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?diff @range:50:6)}
Types:     with assigned semipure normal (total) computation binding {end, start, stride, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?diff
Types: Mode check exp resulted in ?diff
Types: Finding type of expr tmp#0
Types: Type variable 9 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?diff @range:50:6
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int, ?diff:wybe.int @range:50:6)}
Types: Now assigned = semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check stmt if {<=(0 @range:51:19, stride @range:51:25)::
Types: 
Types:                     if {=(diff @range:52:26, 0 @range:52:33)::
Types: 
Types:                         max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
Types:                         foreign llvm move(tmp#4, ?tmp#3)
Types:                     else::
Types:                         +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
Types:                         -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
Types:                         max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
Types:                         foreign llvm move(tmp#5, ?tmp#3)
Types: 
Types:                     }
Types:                     foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
Types:                 else::
Types:                     if {=(diff @range:55:26, 0 @range:55:33)::
Types: 
Types:                         min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
Types:                         foreign llvm move(tmp#9, ?tmp#8)
Types:                     else::
Types:                         +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
Types:                         min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
Types:                         foreign llvm move(tmp#10, ?tmp#8)
Types: 
Types:                     }
Types:                     foreign llvm move(tmp#8 @range:55:26, ?tmp#2)
Types: 
Types:                 }
Types: Mode checking conditional {if {<=(0 @range:51:19, stride @range:51:25)::
Types: 
Types:         if {=(diff @range:52:26, 0 @range:52:33)::
Types: 
Types:             max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
Types:             foreign llvm move(tmp#4, ?tmp#3)
Types:         else::
Types:             +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
Types:             -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
Types:             max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
Types:             foreign llvm move(tmp#5, ?tmp#3)
Types: 
Types:         }
Types:         foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
Types:     else::
Types:         if {=(diff @range:55:26, 0 @range:55:33)::
Types: 
Types:             min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
Types:             foreign llvm move(tmp#9, ?tmp#8)
Types:         else::
Types:             +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
Types:             min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
Types:             foreign llvm move(tmp#10, ?tmp#8)
Types: 
Types:         }
Types:         foreign llvm move(tmp#8 @range:55:26, ?tmp#2)
Types: 
Types:     }}
Types: Mode checking call   : {<=(0 @range:51:19, stride @range:51:25)}
Types:     with assigned    : semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp stride
Types: Mode check exp resulted in stride
Types: Finding type of expr 0 @range:51:19
Types:   Type = wybe.int
Types: Finding type of expr stride @range:51:25
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr 0 @range:51:19
Types:   Type = wybe.int
Types: Finding type of expr stride @range:51:25
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0><=(0:wybe.int @range:51:19, stride:wybe.int @range:51:25)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"diff", "end", "start", "stride", "tmp#0", "tmp#1"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0><=(0:wybe.int @range:51:19, stride:wybe.int @range:51:25)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc 'construct'
Types: Assigned by test: semipure test computation binding {diff, end, start, stride, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Type variable 10 is bound to Just wybe.int
Types: Type variable 9 is bound to Just wybe.int
Types: Type variable 8 is bound to Just wybe.int
Types: Mode check stmt if {=(diff @range:52:26, 0 @range:52:33)::
Types: 
Types:                     max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
Types:                     foreign llvm move(tmp#4, ?tmp#3)
Types:                 else::
Types:                     +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
Types:                     -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
Types:                     max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
Types:                     foreign llvm move(tmp#5, ?tmp#3)
Types: 
Types:                 }
Types: Mode checking conditional {if {=(diff @range:52:26, 0 @range:52:33)::
Types: 
Types:         max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
Types:         foreign llvm move(tmp#4, ?tmp#3)
Types:     else::
Types:         +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
Types:         -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
Types:         max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
Types:         foreign llvm move(tmp#5, ?tmp#3)
Types: 
Types:     }}
Types: Mode checking call   : {=(diff @range:52:26, 0 @range:52:33)}
Types:     with assigned    : semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp diff
Types: Mode check exp resulted in diff
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Finding type of expr diff @range:52:26
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0 @range:52:33
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 52, column 26): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 52, column 26): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 52, column 26): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 52, column 26): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr diff @range:52:26
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0 @range:52:33
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>=(diff:wybe.int @range:52:26, 0:wybe.int @range:52:33)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"diff", "end", "start", "stride", "tmp#0", "tmp#1"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>=(diff:wybe.int @range:52:26, 0:wybe.int @range:52:33)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc 'construct'
Types: Assigned by test: semipure test computation binding {diff, end, start, stride, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Type variable 10 is bound to Just wybe.int
Types: Type variable 9 is bound to Just wybe.int
Types: Type variable 8 is bound to Just wybe.int
Types: Mode check stmt max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)
Types: Mode checking call   : {max(start @range:52:42, end @range:52:49, ?tmp#4 @range:52:38)}
Types:     with assigned    : semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp start
Types: Mode check exp resulted in start
Types: Mode check exp end
Types: Mode check exp resulted in end
Types: Mode check exp ?tmp#4
Types: Mode check exp resulted in ?tmp#4
Types: Finding type of expr start @range:52:42
Types:   Type = wybe.int
Types: Finding type of expr end @range:52:49
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#4 @range:52:38
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.max<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.max<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.max<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.max<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr start @range:52:42
Types:   Type = wybe.int
Types: Finding type of expr end @range:52:49
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#4 @range:52:38
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>max(start:wybe.int @range:52:42, end:wybe.int @range:52:49, ?tmp#4:wybe.int @range:52:38)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"diff", "end", "start", "stride", "tmp#0", "tmp#1"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>max(start:wybe.int @range:52:42, end:wybe.int @range:52:49, ?tmp#4:wybe.int @range:52:38)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'construct'
Types: Now assigned = semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#4}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#4, ?tmp#3)
Types: Mode checking foreign call {foreign llvm move(tmp#4, ?tmp#3)}
Types:     with assigned semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#4}, break set = Everything, with resources {}
Types: Mode check exp tmp#4
Types: Mode check exp resulted in tmp#4
Types: Mode check exp ?tmp#3
Types: Mode check exp resulted in ?tmp#3
Types: Finding type of expr tmp#4
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#3
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#4:wybe.int, ?tmp#3:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#3, tmp#4}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'construct'
Types: Assigned by then branch: semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#3, tmp#4}, break set = Everything, with resources {}
Types: Mode check stmt +(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)
Types: Mode checking call   : {+(end @range:53:45, stride @range:53:51, ?tmp#7 @range:53:45)}
Types:     with assigned    : semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp end
Types: Mode check exp resulted in end
Types: Mode check exp stride
Types: Mode check exp resulted in stride
Types: Mode check exp ?tmp#7
Types: Mode check exp resulted in ?tmp#7
Types: Finding type of expr end @range:53:45
Types:   Type = wybe.int
Types: Finding type of expr stride @range:53:51
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#7 @range:53:45
Types: Type variable 11 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.+<2>(wybe.int,?wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr end @range:53:45
Types:   Type = wybe.int
Types: Finding type of expr stride @range:53:51
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#7 @range:53:45
Types: Type variable 11 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>+(end:wybe.int @range:53:45, stride:wybe.int @range:53:51, ?tmp#7:wybe.int @range:53:45)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"diff", "end", "start", "stride", "tmp#0", "tmp#1"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>+(end:wybe.int @range:53:45, stride:wybe.int @range:53:51, ?tmp#7:wybe.int @range:53:45)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'construct'
Types: Now assigned = semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#7}, break set = Everything, with resources {}
Types: Mode check stmt -(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)
Types: Mode checking call   : {-(tmp#7, diff @range:53:60, ?tmp#6 @range:53:45)}
Types:     with assigned    : semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#7}, break set = Everything, with resources {}
Types: Mode check exp tmp#7
Types: Mode check exp resulted in tmp#7
Types: Mode check exp diff
Types: Mode check exp resulted in diff
Types: Mode check exp ?tmp#6
Types: Mode check exp resulted in ?tmp#6
Types: Finding type of expr tmp#7
Types: Type variable 11 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr diff @range:53:60
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#6 @range:53:45
Types: Type variable 12 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr tmp#7
Types: Type variable 11 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr diff @range:53:60
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#6 @range:53:45
Types: Type variable 12 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>-(tmp#7:wybe.int, diff:wybe.int @range:53:60, ?tmp#6:wybe.int @range:53:45)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"diff", "end", "start", "stride", "tmp#0", "tmp#1", "tmp#7"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>-(tmp#7:wybe.int, diff:wybe.int @range:53:60, ?tmp#6:wybe.int @range:53:45)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'construct'
Types: Now assigned = semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#6, tmp#7}, break set = Everything, with resources {}
Types: Mode check stmt max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)
Types: Mode checking call   : {max(start @range:53:38, tmp#6, ?tmp#5 @range:53:34)}
Types:     with assigned    : semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#6, tmp#7}, break set = Everything, with resources {}
Types: Mode check exp start
Types: Mode check exp resulted in start
Types: Mode check exp tmp#6
Types: Mode check exp resulted in tmp#6
Types: Mode check exp ?tmp#5
Types: Mode check exp resulted in ?tmp#5
Types: Finding type of expr start @range:53:38
Types:   Type = wybe.int
Types: Finding type of expr tmp#6
Types: Type variable 12 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#5 @range:53:34
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.max<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.max<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.max<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.max<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr start @range:53:38
Types:   Type = wybe.int
Types: Finding type of expr tmp#6
Types: Type variable 12 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#5 @range:53:34
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>max(start:wybe.int @range:53:38, tmp#6:wybe.int, ?tmp#5:wybe.int @range:53:34)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"diff", "end", "start", "stride", "tmp#0", "tmp#1", "tmp#6", "tmp#7"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>max(start:wybe.int @range:53:38, tmp#6:wybe.int, ?tmp#5:wybe.int @range:53:34)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'construct'
Types: Now assigned = semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#5, tmp#6, tmp#7}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#5, ?tmp#3)
Types: Mode checking foreign call {foreign llvm move(tmp#5, ?tmp#3)}
Types:     with assigned semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#5, tmp#6, tmp#7}, break set = Everything, with resources {}
Types: Mode check exp tmp#5
Types: Mode check exp resulted in tmp#5
Types: Mode check exp ?tmp#3
Types: Mode check exp resulted in ?tmp#3
Types: Finding type of expr tmp#5
Types: Type variable 2 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#3
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#5:wybe.int, ?tmp#3:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#3, tmp#5, tmp#6, tmp#7}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'construct'
Types: Assigned by else branch: semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#3, tmp#5, tmp#6, tmp#7}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#3}, break set = Everything, with resources {}
Types: Type variable 10 is bound to Just wybe.int
Types: Type variable 9 is bound to Just wybe.int
Types: Type variable 8 is bound to Just wybe.int
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types: Now assigned = semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#3}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#3 @range:52:26, ?tmp#2)
Types: Mode checking foreign call {foreign llvm move(tmp#3 @range:52:26, ?tmp#2)}
Types:     with assigned semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#3}, break set = Everything, with resources {}
Types: Mode check exp tmp#3
Types: Mode check exp resulted in tmp#3
Types: Mode check exp ?tmp#2
Types: Mode check exp resulted in ?tmp#2
Types: Finding type of expr tmp#3 @range:52:26
Types: Type variable 1 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#3:wybe.int @range:52:26, ?tmp#2:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#2, tmp#3}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'construct'
Types: Assigned by then branch: semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#2, tmp#3}, break set = Everything, with resources {}
Types: Mode check stmt if {=(diff @range:55:26, 0 @range:55:33)::
Types: 
Types:                     min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
Types:                     foreign llvm move(tmp#9, ?tmp#8)
Types:                 else::
Types:                     +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
Types:                     min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
Types:                     foreign llvm move(tmp#10, ?tmp#8)
Types: 
Types:                 }
Types: Mode checking conditional {if {=(diff @range:55:26, 0 @range:55:33)::
Types: 
Types:         min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
Types:         foreign llvm move(tmp#9, ?tmp#8)
Types:     else::
Types:         +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
Types:         min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
Types:         foreign llvm move(tmp#10, ?tmp#8)
Types: 
Types:     }}
Types: Mode checking call   : {=(diff @range:55:26, 0 @range:55:33)}
Types:     with assigned    : semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp diff
Types: Mode check exp resulted in diff
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Finding type of expr diff @range:55:26
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0 @range:55:33
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 55, column 26): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 55, column 26): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 55, column 26): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 55, column 26): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr diff @range:55:26
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0 @range:55:33
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>=(diff:wybe.int @range:55:26, 0:wybe.int @range:55:33)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"diff", "end", "start", "stride", "tmp#0", "tmp#1"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>=(diff:wybe.int @range:55:26, 0:wybe.int @range:55:33)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc 'construct'
Types: Assigned by test: semipure test computation binding {diff, end, start, stride, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Type variable 10 is bound to Just wybe.int
Types: Type variable 9 is bound to Just wybe.int
Types: Type variable 8 is bound to Just wybe.int
Types: Mode check stmt min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)
Types: Mode checking call   : {min(start @range:55:42, end @range:55:49, ?tmp#9 @range:55:38)}
Types:     with assigned    : semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp start
Types: Mode check exp resulted in start
Types: Mode check exp end
Types: Mode check exp resulted in end
Types: Mode check exp ?tmp#9
Types: Mode check exp resulted in ?tmp#9
Types: Finding type of expr start @range:55:42
Types:   Type = wybe.int
Types: Finding type of expr end @range:55:49
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#9 @range:55:38
Types: Type variable 4 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.min<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.min<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.min<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.min<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr start @range:55:42
Types:   Type = wybe.int
Types: Finding type of expr end @range:55:49
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#9 @range:55:38
Types: Type variable 4 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>min(start:wybe.int @range:55:42, end:wybe.int @range:55:49, ?tmp#9:wybe.int @range:55:38)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"diff", "end", "start", "stride", "tmp#0", "tmp#1"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>min(start:wybe.int @range:55:42, end:wybe.int @range:55:49, ?tmp#9:wybe.int @range:55:38)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'construct'
Types: Now assigned = semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#9}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#9, ?tmp#8)
Types: Mode checking foreign call {foreign llvm move(tmp#9, ?tmp#8)}
Types:     with assigned semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#9}, break set = Everything, with resources {}
Types: Mode check exp tmp#9
Types: Mode check exp resulted in tmp#9
Types: Mode check exp ?tmp#8
Types: Mode check exp resulted in ?tmp#8
Types: Finding type of expr tmp#9
Types: Type variable 4 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#8
Types: Type variable 5 is bound to Just 4
Types: Type variable 4 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#9:wybe.int, ?tmp#8:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#8, tmp#9}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'construct'
Types: Assigned by then branch: semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#8, tmp#9}, break set = Everything, with resources {}
Types: Mode check stmt +(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)
Types: Mode checking call   : {+(end @range:56:45, diff @range:56:51, ?tmp#11 @range:56:45)}
Types:     with assigned    : semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp end
Types: Mode check exp resulted in end
Types: Mode check exp diff
Types: Mode check exp resulted in diff
Types: Mode check exp ?tmp#11
Types: Mode check exp resulted in ?tmp#11
Types: Finding type of expr end @range:56:45
Types:   Type = wybe.int
Types: Finding type of expr diff @range:56:51
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#11 @range:56:45
Types: Type variable 13 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.+<2>(wybe.int,?wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr end @range:56:45
Types:   Type = wybe.int
Types: Finding type of expr diff @range:56:51
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#11 @range:56:45
Types: Type variable 13 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>+(end:wybe.int @range:56:45, diff:wybe.int @range:56:51, ?tmp#11:wybe.int @range:56:45)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"diff", "end", "start", "stride", "tmp#0", "tmp#1"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>+(end:wybe.int @range:56:45, diff:wybe.int @range:56:51, ?tmp#11:wybe.int @range:56:45)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'construct'
Types: Now assigned = semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#11}, break set = Everything, with resources {}
Types: Mode check stmt min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)
Types: Mode checking call   : {min(start @range:56:38, tmp#11, ?tmp#10 @range:56:34)}
Types:     with assigned    : semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#11}, break set = Everything, with resources {}
Types: Mode check exp start
Types: Mode check exp resulted in start
Types: Mode check exp tmp#11
Types: Mode check exp resulted in tmp#11
Types: Mode check exp ?tmp#10
Types: Mode check exp resulted in ?tmp#10
Types: Finding type of expr start @range:56:38
Types:   Type = wybe.int
Types: Finding type of expr tmp#11
Types: Type variable 13 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#10 @range:56:34
Types: Type variable 6 is bound to Just 4
Types: Type variable 4 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.min<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.min<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.min<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.min<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr start @range:56:38
Types:   Type = wybe.int
Types: Finding type of expr tmp#11
Types: Type variable 13 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#10 @range:56:34
Types: Type variable 6 is bound to Just 4
Types: Type variable 4 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>min(start:wybe.int @range:56:38, tmp#11:wybe.int, ?tmp#10:wybe.int @range:56:34)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"diff", "end", "start", "stride", "tmp#0", "tmp#1", "tmp#11"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>min(start:wybe.int @range:56:38, tmp#11:wybe.int, ?tmp#10:wybe.int @range:56:34)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'construct'
Types: Now assigned = semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#10, tmp#11}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#10, ?tmp#8)
Types: Mode checking foreign call {foreign llvm move(tmp#10, ?tmp#8)}
Types:     with assigned semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#10, tmp#11}, break set = Everything, with resources {}
Types: Mode check exp tmp#10
Types: Mode check exp resulted in tmp#10
Types: Mode check exp ?tmp#8
Types: Mode check exp resulted in ?tmp#8
Types: Finding type of expr tmp#10
Types: Type variable 6 is bound to Just 4
Types: Type variable 4 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#8
Types: Type variable 5 is bound to Just 4
Types: Type variable 4 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#10:wybe.int, ?tmp#8:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#10, tmp#11, tmp#8}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'construct'
Types: Assigned by else branch: semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#10, tmp#11, tmp#8}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#8}, break set = Everything, with resources {}
Types: Type variable 10 is bound to Just wybe.int
Types: Type variable 9 is bound to Just wybe.int
Types: Type variable 8 is bound to Just wybe.int
Types: Type variable 5 is bound to Just 4
Types: Type variable 4 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types: Now assigned = semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#8}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#8 @range:55:26, ?tmp#2)
Types: Mode checking foreign call {foreign llvm move(tmp#8 @range:55:26, ?tmp#2)}
Types:     with assigned semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#8}, break set = Everything, with resources {}
Types: Mode check exp tmp#8
Types: Mode check exp resulted in tmp#8
Types: Mode check exp ?tmp#2
Types: Mode check exp resulted in ?tmp#2
Types: Finding type of expr tmp#8 @range:55:26
Types: Type variable 5 is bound to Just 4
Types: Type variable 4 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2
Types: Type variable 3 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#8:wybe.int @range:55:26, ?tmp#2:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#2, tmp#8}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'construct'
Types: Assigned by else branch: semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#2, tmp#8}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Type variable 10 is bound to Just wybe.int
Types: Type variable 9 is bound to Just wybe.int
Types: Type variable 8 is bound to Just wybe.int
Types: Type variable 3 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types: Now assigned = semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt =(?final @range:51:6, tmp#2 @range:51:19)
Types: Mode checking call   : {=(?final @range:51:6, tmp#2 @range:51:19)}
Types:     with assigned    : semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp ?final
Types: Mode check exp resulted in ?final
Types: Mode check exp tmp#2
Types: Mode check exp resulted in tmp#2
Types: Finding type of expr ?final @range:51:6
Types: Type variable 14 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr tmp#2 @range:51:19
Types: Type variable 3 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 51, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 51, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 51, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 51, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.int.=<0>(wybe.int,wybe.int),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#2 @range:51:19, ?final @range:51:6)}
Types:     with assigned semipure normal (total) computation binding {diff, end, start, stride, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2
Types: Mode check exp resulted in tmp#2
Types: Mode check exp ?final
Types: Mode check exp resulted in ?final
Types: Finding type of expr tmp#2 @range:51:19
Types: Type variable 3 is bound to Just 0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?final @range:51:6
Types: Type variable 14 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#2:wybe.int @range:51:19, ?final:wybe.int @range:51:6)}
Types: Now assigned = semipure normal (total) computation binding {diff, end, final, start, stride, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)
Types: Mode checking call   : {range(start @range:58:16, stride @range:58:23, final @range:58:31, ?tmp#12 @range:58:10)}
Types:     with assigned    : semipure normal (total) computation binding {diff, end, final, start, stride, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp start
Types: Mode check exp resulted in start
Types: Mode check exp stride
Types: Mode check exp resulted in stride
Types: Mode check exp final
Types: Mode check exp resulted in final
Types: Mode check exp ?tmp#12
Types: Mode check exp resulted in ?tmp#12
Types: Finding type of expr start @range:58:16
Types:   Type = wybe.int
Types: Finding type of expr stride @range:58:23
Types:   Type = wybe.int
Types: Finding type of expr final @range:58:31
Types: Type variable 14 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#12 @range:58:10
Types: Type variable 15 is bound to Just wybe.range
Types:   Type = wybe.range
Types:     actual types     : [wybe.int,wybe.int,wybe.int,wybe.range]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Type-correct modes   : [(wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr start @range:58:16
Types:   Type = wybe.int
Types: Finding type of expr stride @range:58:23
Types:   Type = wybe.int
Types: Finding type of expr final @range:58:31
Types: Type variable 14 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#12 @range:58:10
Types: Type variable 15 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Finalising call    :  {wybe.range.<0>range(start:wybe.int @range:58:16, stride:wybe.int @range:58:23, final:wybe.int @range:58:31, ?tmp#12:wybe.range @range:58:10)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"diff", "end", "final", "start", "stride", "tmp#0", "tmp#1", "tmp#2"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.range.<0>range(start:wybe.int @range:58:16, stride:wybe.int @range:58:23, final:wybe.int @range:58:31, ?tmp#12:wybe.range @range:58:10)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'construct'
Types: Now assigned = semipure normal (total) computation binding {diff, end, final, start, stride, tmp#0, tmp#1, tmp#12, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt =(?r @range:58:6, tmp#12)
Types: Mode checking call   : {=(?r @range:58:6, tmp#12)}
Types:     with assigned    : semipure normal (total) computation binding {diff, end, final, start, stride, tmp#0, tmp#1, tmp#12, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp ?r
Types: Mode check exp resulted in ?r
Types: Mode check exp tmp#12
Types: Mode check exp resulted in tmp#12
Types: Finding type of expr ?r @range:58:6
Types: Type variable 7 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Finding type of expr tmp#12
Types: Type variable 15 is bound to Just wybe.range
Types:   Type = wybe.range
Types:     actual types     : [wybe.range,wybe.range]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.range,wybe.range] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 58, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.range (-> wybe.range) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 58, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.range,wybe.range] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 58, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.range (-> wybe.range) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 58, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.range,wybe.range] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Type-correct modes   : [({test} wybe.range.=<0>(wybe.range,wybe.range),Typing {#result::wybe.range, diff::10, end::wybe.int, final::14, r::7, start::wybe.int, stride::wybe.int, tmp#0::9, tmp#1::8, tmp#10::6, tmp#11::13, tmp#12::15, tmp#2::3, tmp#3::1, tmp#4::0, tmp#5::2, tmp#6::12, tmp#7::11, tmp#8::5, tmp#9::4}; {0::wybe.int, 1::0, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.range, 2::0, 3::0, 4::0, 5::4, 6::4, 7::wybe.range, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#12, ?r @range:58:6)}
Types:     with assigned semipure normal (total) computation binding {diff, end, final, start, stride, tmp#0, tmp#1, tmp#12, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#12
Types: Mode check exp resulted in tmp#12
Types: Mode check exp ?r
Types: Mode check exp resulted in ?r
Types: Finding type of expr tmp#12
Types: Type variable 15 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Finding type of expr ?r @range:58:6
Types: Type variable 7 is bound to Just wybe.range
Types:   Type = wybe.range
Types:     types and modes = [wybe.range,?wybe.range]
Types: New instr = {foreign llvm move(tmp#12:wybe.range, ?r:wybe.range @range:58:6)}
Types: Now assigned = semipure normal (total) computation binding {diff, end, final, r, start, stride, tmp#0, tmp#1, tmp#12, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(r @range:49:51, ?#result @range:49:1)
Types: Mode checking foreign call {foreign llvm move(r @range:49:51, ?#result @range:49:1)}
Types:     with assigned semipure normal (total) computation binding {diff, end, final, r, start, stride, tmp#0, tmp#1, tmp#12, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp r
Types: Mode check exp resulted in r
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr r @range:49:51
Types: Type variable 7 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Finding type of expr ?#result @range:49:1
Types:   Type = wybe.range
Types:     types and modes = [wybe.range,?wybe.range]
Types: New instr = {foreign llvm move(r:wybe.range @range:49:51, ?#result:wybe.range @range:49:1)}
Types: Now assigned = semipure normal (total) computation binding {#result, diff, end, final, r, start, stride, tmp#0, tmp#1, tmp#12, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'construct'
Types: Mode checked body   : [{wybe.int.<0>-(end:wybe.int @range:50:14, start:wybe.int @range:50:20, ?tmp#1:wybe.int @range:50:14)} @range:50:14,{wybe.int.<0>%(tmp#1:wybe.int, stride:wybe.int @range:50:29, ?tmp#0:wybe.int @range:50:13)} @range:50:13,{foreign llvm move(tmp#0:wybe.int, ?diff:wybe.int @range:50:6)} @range:50:6,{if {wybe.int.<0><=(0:wybe.int @range:51:19, stride:wybe.int @range:51:25)::
Types: 
Types:         if {wybe.int.<0>=(diff:wybe.int @range:52:26, 0:wybe.int @range:52:33)::
Types: 
Types:             wybe.int.<0>max(start:wybe.int @range:52:42, end:wybe.int @range:52:49, ?tmp#4:wybe.int @range:52:38)
Types:             foreign llvm move(tmp#4:wybe.int, ?tmp#3:wybe.int)
Types:         else::
Types:             wybe.int.<0>+(end:wybe.int @range:53:45, stride:wybe.int @range:53:51, ?tmp#7:wybe.int @range:53:45)
Types:             wybe.int.<0>-(tmp#7:wybe.int, diff:wybe.int @range:53:60, ?tmp#6:wybe.int @range:53:45)
Types:             wybe.int.<0>max(start:wybe.int @range:53:38, tmp#6:wybe.int, ?tmp#5:wybe.int @range:53:34)
Types:             foreign llvm move(tmp#5:wybe.int, ?tmp#3:wybe.int)
Types: 
Types:         }
Types:    condition -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int}
Types:    then&else -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int, tmp#3::wybe.int}
Types:         foreign llvm move(tmp#3:wybe.int @range:52:26, ?tmp#2:wybe.int)
Types:     else::
Types:         if {wybe.int.<0>=(diff:wybe.int @range:55:26, 0:wybe.int @range:55:33)::
Types: 
Types:             wybe.int.<0>min(start:wybe.int @range:55:42, end:wybe.int @range:55:49, ?tmp#9:wybe.int @range:55:38)
Types:             foreign llvm move(tmp#9:wybe.int, ?tmp#8:wybe.int)
Types:         else::
Types:             wybe.int.<0>+(end:wybe.int @range:56:45, diff:wybe.int @range:56:51, ?tmp#11:wybe.int @range:56:45)
Types:             wybe.int.<0>min(start:wybe.int @range:56:38, tmp#11:wybe.int, ?tmp#10:wybe.int @range:56:34)
Types:             foreign llvm move(tmp#10:wybe.int, ?tmp#8:wybe.int)
Types: 
Types:         }
Types:    condition -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int}
Types:    then&else -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int, tmp#8::wybe.int}
Types:         foreign llvm move(tmp#8:wybe.int @range:55:26, ?tmp#2:wybe.int)
Types: 
Types:     }
Types:    condition -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int}
Types:    then&else -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int, tmp#2::wybe.int}} @range:51:19,{foreign llvm move(tmp#2:wybe.int @range:51:19, ?final:wybe.int @range:51:6)} @range:51:6,{wybe.range.<0>range(start:wybe.int @range:58:16, stride:wybe.int @range:58:23, final:wybe.int @range:58:31, ?tmp#12:wybe.range @range:58:10)} @range:58:10,{foreign llvm move(tmp#12:wybe.range, ?r:wybe.range @range:58:6)} @range:58:6,{foreign llvm move(r:wybe.range @range:49:51, ?#result:wybe.range @range:49:1)} @range:49:1]
Types: Vars defined by body: semipure normal (total) computation binding {#result, diff, end, final, r, start, stride, tmp#0, tmp#1, tmp#12, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of construct:
Types: 
Types: construct > (0 calls)
Types: 4: construct(start:wybe.int @range:49:15, stride:wybe.int @range:49:26, end:wybe.int @range:49:38, ?#result:wybe.range @range:49:1):
Types:     wybe.int.<0>-(end:wybe.int @range:50:14, start:wybe.int @range:50:20, ?tmp#1:wybe.int @range:50:14)
Types:     wybe.int.<0>%(tmp#1:wybe.int, stride:wybe.int @range:50:29, ?tmp#0:wybe.int @range:50:13)
Types:     foreign llvm move(tmp#0:wybe.int, ?diff:wybe.int @range:50:6)
Types:     if {wybe.int.<0><=(0:wybe.int @range:51:19, stride:wybe.int @range:51:25)::
Types: 
Types:         if {wybe.int.<0>=(diff:wybe.int @range:52:26, 0:wybe.int @range:52:33)::
Types: 
Types:             wybe.int.<0>max(start:wybe.int @range:52:42, end:wybe.int @range:52:49, ?tmp#4:wybe.int @range:52:38)
Types:             foreign llvm move(tmp#4:wybe.int, ?tmp#3:wybe.int)
Types:         else::
Types:             wybe.int.<0>+(end:wybe.int @range:53:45, stride:wybe.int @range:53:51, ?tmp#7:wybe.int @range:53:45)
Types:             wybe.int.<0>-(tmp#7:wybe.int, diff:wybe.int @range:53:60, ?tmp#6:wybe.int @range:53:45)
Types:             wybe.int.<0>max(start:wybe.int @range:53:38, tmp#6:wybe.int, ?tmp#5:wybe.int @range:53:34)
Types:             foreign llvm move(tmp#5:wybe.int, ?tmp#3:wybe.int)
Types: 
Types:         }
Types:    condition -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int}
Types:    then&else -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int, tmp#3::wybe.int}
Types:         foreign llvm move(tmp#3:wybe.int @range:52:26, ?tmp#2:wybe.int)
Types:     else::
Types:         if {wybe.int.<0>=(diff:wybe.int @range:55:26, 0:wybe.int @range:55:33)::
Types: 
Types:             wybe.int.<0>min(start:wybe.int @range:55:42, end:wybe.int @range:55:49, ?tmp#9:wybe.int @range:55:38)
Types:             foreign llvm move(tmp#9:wybe.int, ?tmp#8:wybe.int)
Types:         else::
Types:             wybe.int.<0>+(end:wybe.int @range:56:45, diff:wybe.int @range:56:51, ?tmp#11:wybe.int @range:56:45)
Types:             wybe.int.<0>min(start:wybe.int @range:56:38, tmp#11:wybe.int, ?tmp#10:wybe.int @range:56:34)
Types:             foreign llvm move(tmp#10:wybe.int, ?tmp#8:wybe.int)
Types: 
Types:         }
Types:    condition -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int}
Types:    then&else -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int, tmp#8::wybe.int}
Types:         foreign llvm move(tmp#8:wybe.int @range:55:26, ?tmp#2:wybe.int)
Types: 
Types:     }
Types:    condition -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int}
Types:    then&else -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int, tmp#2::wybe.int}
Types:     foreign llvm move(tmp#2:wybe.int @range:51:19, ?final:wybe.int @range:51:6)
Types:     wybe.range.<0>range(start:wybe.int @range:58:16, stride:wybe.int @range:58:23, final:wybe.int @range:58:31, ?tmp#12:wybe.range @range:58:10)
Types:     foreign llvm move(tmp#12:wybe.range, ?r:wybe.range @range:58:6)
Types:     foreign llvm move(r:wybe.range @range:49:51, ?#result:wybe.range @range:49:1)
Types: Type checking non-recursive proc wybe.range.irange
Types: ** Type checking decl of proc irange
Types: found 1 definition(s)
Types: Type checking irange
Types: ** Type checking irange: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         <(stride @range:33:41, 0 @range:33:50)
Types:         foreign llvm move(-1 @range:33:55, ?tmp#2)
Types:         foreign llvm move(1 @range:33:68, ?tmp#2)
Types:         +(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)
Types:         construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)
Types:         foreign llvm move(tmp#0, ?#result @range:32:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","end","start","stride","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: start:wybe.int, stride:wybe.int, end:wybe.int, ?#result:wybe.range
Types:     type of 'start' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable start type constrained to wybe.int
Types:     type of 'stride' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable stride type constrained to wybe.int
Types:     type of 'end' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable end type constrained to wybe.int
Types:     type of '#result' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #result type constrained to wybe.range
Types: Recording resource types: 
Types: Recording casts in {<(stride @range:33:41, 0 @range:33:50)}
Types: Recording casts in {foreign llvm move(-1 @range:33:55, ?tmp#2)}
Types: Unifying move argument types -1 @range:33:55 and ?tmp#2
Types: Finding type of expr -1 @range:33:55
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2
Types:   Type = 0
Types: Type variable 0 is bound to Nothing
Types: Unifying types wybe.int (-> wybe.int) and 0 (-> 0)
Types:   Unification yields wybe.int
Types: Recording casts in {foreign llvm move(1 @range:33:68, ?tmp#2)}
Types: Unifying move argument types 1 @range:33:68 and ?tmp#2
Types: Finding type of expr 1 @range:33:68
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Recording casts in {+(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)}
Types: Recording casts in {construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @range:32:5)}
Types: Unifying move argument types tmp#0 and ?#result @range:32:5
Types: Finding type of expr tmp#0
Types:   Type = 1
Types: Finding type of expr ?#result @range:32:5
Types:   Type = wybe.range
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: *** Before calls Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#2::0}; {0::wybe.int, 1::wybe.range} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {<(stride @range:33:41, 0 @range:33:50)} @range:33:41, typingInfos = [wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {+(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)} @range:33:30, typingInfos = [wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)} @range:33:5, typingInfos = [wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range)]}Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#2::0}; {0::wybe.int, 1::wybe.range} (with no errors)
Types: Type checking call {<(stride @range:33:41, 0 @range:33:50)} @range:33:41
Types: Candidate types:
Types:     wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr stride @range:33:41
Types:   Type = wybe.int
Types: Finding type of expr 0 @range:33:50
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#2::0}; {0::wybe.int, 1::wybe.range} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#2::0}; {0::wybe.int, 1::wybe.range} (with no errors)
Types: Type checking call {+(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)} @range:33:30
Types: Candidate types:
Types:     wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Finding type of expr end @range:33:30
Types:   Type = wybe.int
Types: Finding type of expr tmp#2 @range:33:41
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @range:33:30
Types:   Type = 2
Types: Actual types: [wybe.int,wybe.int,2]
Types: Matching types [wybe.int,wybe.int,2] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 2 is bound to Nothing
Types: Unifying types 2 (-> 2) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,2] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 2 is bound to Nothing
Types: Unifying types 2 (-> 2) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,2] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 2 is bound to Nothing
Types: Unifying types 2 (-> 2) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#1::2, tmp#2::0}; {0::wybe.int, 1::wybe.range, 2::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#1::2, tmp#2::0}; {0::wybe.int, 1::wybe.range, 2::wybe.int} (with no errors)
Types: Type checking call {construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)} @range:33:5
Types: Candidate types:
Types:     wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Finding type of expr start @range:33:15
Types:   Type = wybe.int
Types: Finding type of expr stride @range:33:22
Types:   Type = wybe.int
Types: Finding type of expr tmp#1
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:33:5
Types: Type variable 1 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Actual types: [wybe.int,wybe.int,wybe.int,wybe.range]
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Valid types = [Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#1::2, tmp#2::0}; {0::wybe.int, 1::wybe.range, 2::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#1::2, tmp#2::0}; {0::wybe.int, 1::wybe.range, 2::wybe.int} (with no errors)
Types: Finding type of expr -1 @range:33:55
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr 1 @range:33:68
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 1 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Finding type of expr ?#result @range:32:5
Types:   Type = wybe.range
Types: Type checking foreign llvm call move(address, address)
Types: Now mode checking proc irange
Types: bound vars: semipure normal (total) computation binding {end, start, stride}, break set = Everything, with resources {}
Types: Mode check stmt if {<(stride @range:33:41, 0 @range:33:50)::
Types: 
Types:                     foreign llvm move(-1 @range:33:55, ?tmp#2)
Types:                 else::
Types:                     foreign llvm move(1 @range:33:68, ?tmp#2)
Types: 
Types:                 }
Types: Mode checking conditional {if {<(stride @range:33:41, 0 @range:33:50)::
Types: 
Types:         foreign llvm move(-1 @range:33:55, ?tmp#2)
Types:     else::
Types:         foreign llvm move(1 @range:33:68, ?tmp#2)
Types: 
Types:     }}
Types: Mode checking call   : {<(stride @range:33:41, 0 @range:33:50)}
Types:     with assigned    : semipure normal (total) computation binding {end, start, stride}, break set = Everything, with resources {}
Types: Mode check exp stride
Types: Mode check exp resulted in stride
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Finding type of expr stride @range:33:41
Types:   Type = wybe.int
Types: Finding type of expr 0 @range:33:50
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.<<0>(wybe.int,wybe.int),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#1::2, tmp#2::0}; {0::wybe.int, 1::wybe.range, 2::wybe.int} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.<<0>(wybe.int,wybe.int),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#1::2, tmp#2::0}; {0::wybe.int, 1::wybe.range, 2::wybe.int} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.<<0>(wybe.int,wybe.int),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#1::2, tmp#2::0}; {0::wybe.int, 1::wybe.range, 2::wybe.int} (with no errors))]
Types: Finding type of expr stride @range:33:41
Types:   Type = wybe.int
Types: Finding type of expr 0 @range:33:50
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0><(stride:wybe.int @range:33:41, 0:wybe.int @range:33:50)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "start", "stride"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0><(stride:wybe.int @range:33:41, 0:wybe.int @range:33:50)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc 'irange'
Types: Assigned by test: semipure test computation binding {end, start, stride}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(-1 @range:33:55, ?tmp#2)
Types: Mode checking foreign call {foreign llvm move(-1 @range:33:55, ?tmp#2)}
Types:     with assigned semipure normal (total) computation binding {end, start, stride}, break set = Everything, with resources {}
Types: Mode check exp -1
Types: Mode check exp resulted in -1
Types: Mode check exp ?tmp#2
Types: Mode check exp resulted in ?tmp#2
Types: Finding type of expr -1 @range:33:55
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(-1:wybe.int @range:33:55, ?tmp#2:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {end, start, stride, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'irange'
Types: Assigned by then branch: semipure normal (total) computation binding {end, start, stride, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(1 @range:33:68, ?tmp#2)
Types: Mode checking foreign call {foreign llvm move(1 @range:33:68, ?tmp#2)}
Types:     with assigned semipure normal (total) computation binding {end, start, stride}, break set = Everything, with resources {}
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp ?tmp#2
Types: Mode check exp resulted in ?tmp#2
Types: Finding type of expr 1 @range:33:68
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(1:wybe.int @range:33:68, ?tmp#2:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {end, start, stride, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'irange'
Types: Assigned by else branch: semipure normal (total) computation binding {end, start, stride, tmp#2}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {end, start, stride, tmp#2}, break set = Everything, with resources {}
Types: Type variable 0 is bound to Just wybe.int
Types: Now assigned = semipure normal (total) computation binding {end, start, stride, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt +(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)
Types: Mode checking call   : {+(end @range:33:30, tmp#2 @range:33:41, ?tmp#1 @range:33:30)}
Types:     with assigned    : semipure normal (total) computation binding {end, start, stride, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp end
Types: Mode check exp resulted in end
Types: Mode check exp tmp#2
Types: Mode check exp resulted in tmp#2
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr end @range:33:30
Types:   Type = wybe.int
Types: Finding type of expr tmp#2 @range:33:41
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @range:33:30
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#1::2, tmp#2::0}; {0::wybe.int, 1::wybe.range, 2::wybe.int} (with no errors)),(wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#1::2, tmp#2::0}; {0::wybe.int, 1::wybe.range, 2::wybe.int} (with no errors)),(wybe.int.+<2>(wybe.int,?wybe.int,wybe.int),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#1::2, tmp#2::0}; {0::wybe.int, 1::wybe.range, 2::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#1::2, tmp#2::0}; {0::wybe.int, 1::wybe.range, 2::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#1::2, tmp#2::0}; {0::wybe.int, 1::wybe.range, 2::wybe.int} (with no errors))]
Types: Finding type of expr end @range:33:30
Types:   Type = wybe.int
Types: Finding type of expr tmp#2 @range:33:41
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @range:33:30
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>+(end:wybe.int @range:33:30, tmp#2:wybe.int @range:33:41, ?tmp#1:wybe.int @range:33:30)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "start", "stride", "tmp#2"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>+(end:wybe.int @range:33:30, tmp#2:wybe.int @range:33:41, ?tmp#1:wybe.int @range:33:30)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'irange'
Types: Now assigned = semipure normal (total) computation binding {end, start, stride, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)
Types: Mode checking call   : {construct(start @range:33:15, stride @range:33:22, tmp#1, ?tmp#0 @range:33:5)}
Types:     with assigned    : semipure normal (total) computation binding {end, start, stride, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp start
Types: Mode check exp resulted in start
Types: Mode check exp stride
Types: Mode check exp resulted in stride
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr start @range:33:15
Types:   Type = wybe.int
Types: Finding type of expr stride @range:33:22
Types:   Type = wybe.int
Types: Finding type of expr tmp#1
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:33:5
Types: Type variable 1 is bound to Just wybe.range
Types:   Type = wybe.range
Types:     actual types     : [wybe.int,wybe.int,wybe.int,wybe.range]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Type-correct modes   : [(wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#1::2, tmp#2::0}; {0::wybe.int, 1::wybe.range, 2::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#1::2, tmp#2::0}; {0::wybe.int, 1::wybe.range, 2::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::1, tmp#1::2, tmp#2::0}; {0::wybe.int, 1::wybe.range, 2::wybe.int} (with no errors))]
Types: Finding type of expr start @range:33:15
Types:   Type = wybe.int
Types: Finding type of expr stride @range:33:22
Types:   Type = wybe.int
Types: Finding type of expr tmp#1
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:33:5
Types: Type variable 1 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Finalising call    :  {wybe.range.<0>construct(start:wybe.int @range:33:15, stride:wybe.int @range:33:22, tmp#1:wybe.int, ?tmp#0:wybe.range @range:33:5)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "start", "stride", "tmp#1", "tmp#2"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.range.<0>construct(start:wybe.int @range:33:15, stride:wybe.int @range:33:22, tmp#1:wybe.int, ?tmp#0:wybe.range @range:33:5)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'irange'
Types: Now assigned = semipure normal (total) computation binding {end, start, stride, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @range:32:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @range:32:5)}
Types:     with assigned semipure normal (total) computation binding {end, start, stride, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 1 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Finding type of expr ?#result @range:32:5
Types:   Type = wybe.range
Types:     types and modes = [wybe.range,?wybe.range]
Types: New instr = {foreign llvm move(tmp#0:wybe.range, ?#result:wybe.range @range:32:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, end, start, stride, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'irange'
Types: Mode checked body   : [{if {wybe.int.<0><(stride:wybe.int @range:33:41, 0:wybe.int @range:33:50)::
Types: 
Types:         foreign llvm move(-1:wybe.int @range:33:55, ?tmp#2:wybe.int)
Types:     else::
Types:         foreign llvm move(1:wybe.int @range:33:68, ?tmp#2:wybe.int)
Types: 
Types:     }
Types:    condition -> {end::wybe.int, start::wybe.int, stride::wybe.int}
Types:    then&else -> {end::wybe.int, start::wybe.int, stride::wybe.int, tmp#2::wybe.int}} @range:33:41,{wybe.int.<0>+(end:wybe.int @range:33:30, tmp#2:wybe.int @range:33:41, ?tmp#1:wybe.int @range:33:30)} @range:33:30,{wybe.range.<0>construct(start:wybe.int @range:33:15, stride:wybe.int @range:33:22, tmp#1:wybe.int, ?tmp#0:wybe.range @range:33:5)} @range:33:5,{foreign llvm move(tmp#0:wybe.range, ?#result:wybe.range @range:32:5)} @range:32:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, end, start, stride, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of irange:
Types: 
Types: irange > public (0 calls)
Types: 4: irange(start:wybe.int @range:32:16, stride:wybe.int @range:32:27, end:wybe.int @range:32:39, ?#result:wybe.range @range:32:5):
Types:     if {wybe.int.<0><(stride:wybe.int @range:33:41, 0:wybe.int @range:33:50)::
Types: 
Types:         foreign llvm move(-1:wybe.int @range:33:55, ?tmp#2:wybe.int)
Types:     else::
Types:         foreign llvm move(1:wybe.int @range:33:68, ?tmp#2:wybe.int)
Types: 
Types:     }
Types:    condition -> {end::wybe.int, start::wybe.int, stride::wybe.int}
Types:    then&else -> {end::wybe.int, start::wybe.int, stride::wybe.int, tmp#2::wybe.int}
Types:     wybe.int.<0>+(end:wybe.int @range:33:30, tmp#2:wybe.int @range:33:41, ?tmp#1:wybe.int @range:33:30)
Types:     wybe.range.<0>construct(start:wybe.int @range:33:15, stride:wybe.int @range:33:22, tmp#1:wybe.int, ?tmp#0:wybe.range @range:33:5)
Types:     foreign llvm move(tmp#0:wybe.range, ?#result:wybe.range @range:32:5)
Types: Type checking non-recursive proc wybe.range.xrange
Types: ** Type checking decl of proc xrange
Types: found 1 definition(s)
Types: Type checking xrange
Types: ** Type checking xrange: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)
Types:         foreign llvm move(tmp#0, ?#result @range:28:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","end","start","stride","tmp#0"]
Types: Recording parameter types: start:wybe.int, stride:wybe.int, end:wybe.int, ?#result:wybe.range
Types:     type of 'start' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable start type constrained to wybe.int
Types:     type of 'stride' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable stride type constrained to wybe.int
Types:     type of 'end' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable end type constrained to wybe.int
Types:     type of '#result' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #result type constrained to wybe.range
Types: Recording resource types: 
Types: Recording casts in {construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @range:28:5)}
Types: Unifying move argument types tmp#0 and ?#result @range:28:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @range:28:5
Types:   Type = wybe.range
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: *** Before calls Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::0}; {0::wybe.range} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)} @range:29:5, typingInfos = [wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range)]}Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::0}; {0::wybe.range} (with no errors)
Types: Type checking call {construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)} @range:29:5
Types: Candidate types:
Types:     wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Finding type of expr start @range:29:15
Types:   Type = wybe.int
Types: Finding type of expr stride @range:29:22
Types:   Type = wybe.int
Types: Finding type of expr end @range:29:30
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:29:5
Types: Type variable 0 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Actual types: [wybe.int,wybe.int,wybe.int,wybe.range]
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Valid types = [Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::0}; {0::wybe.range} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::0}; {0::wybe.range} (with no errors)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Finding type of expr ?#result @range:28:5
Types:   Type = wybe.range
Types: Type checking foreign llvm call move(address, address)
Types: Now mode checking proc xrange
Types: bound vars: semipure normal (total) computation binding {end, start, stride}, break set = Everything, with resources {}
Types: Mode check stmt construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)
Types: Mode checking call   : {construct(start @range:29:15, stride @range:29:22, end @range:29:30, ?tmp#0 @range:29:5)}
Types:     with assigned    : semipure normal (total) computation binding {end, start, stride}, break set = Everything, with resources {}
Types: Mode check exp start
Types: Mode check exp resulted in start
Types: Mode check exp stride
Types: Mode check exp resulted in stride
Types: Mode check exp end
Types: Mode check exp resulted in end
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr start @range:29:15
Types:   Type = wybe.int
Types: Finding type of expr stride @range:29:22
Types:   Type = wybe.int
Types: Finding type of expr end @range:29:30
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:29:5
Types: Type variable 0 is bound to Just wybe.range
Types:   Type = wybe.range
Types:     actual types     : [wybe.int,wybe.int,wybe.int,wybe.range]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Type-correct modes   : [(wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::0}; {0::wybe.range} (with no errors))]
Types: Possible mode matches: [(wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::0}; {0::wybe.range} (with no errors))]
Types: Exact mode matches: [(wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::0}; {0::wybe.range} (with no errors))]
Types: Finding type of expr start @range:29:15
Types:   Type = wybe.int
Types: Finding type of expr stride @range:29:22
Types:   Type = wybe.int
Types: Finding type of expr end @range:29:30
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:29:5
Types: Type variable 0 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Finalising call    :  {wybe.range.<0>construct(start:wybe.int @range:29:15, stride:wybe.int @range:29:22, end:wybe.int @range:29:30, ?tmp#0:wybe.range @range:29:5)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "start", "stride"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.range.<0>construct(start:wybe.int @range:29:15, stride:wybe.int @range:29:22, end:wybe.int @range:29:30, ?tmp#0:wybe.range @range:29:5)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'xrange'
Types: Now assigned = semipure normal (total) computation binding {end, start, stride, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @range:28:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @range:28:5)}
Types:     with assigned semipure normal (total) computation binding {end, start, stride, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Finding type of expr ?#result @range:28:5
Types:   Type = wybe.range
Types:     types and modes = [wybe.range,?wybe.range]
Types: New instr = {foreign llvm move(tmp#0:wybe.range, ?#result:wybe.range @range:28:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, end, start, stride, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'xrange'
Types: Mode checked body   : [{wybe.range.<0>construct(start:wybe.int @range:29:15, stride:wybe.int @range:29:22, end:wybe.int @range:29:30, ?tmp#0:wybe.range @range:29:5)} @range:29:5,{foreign llvm move(tmp#0:wybe.range, ?#result:wybe.range @range:28:5)} @range:28:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, end, start, stride, tmp#0}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of xrange:
Types: 
Types: xrange > public (0 calls)
Types: 4: xrange(start:wybe.int @range:28:16, stride:wybe.int @range:28:27, end:wybe.int @range:28:39, ?#result:wybe.range @range:28:5):
Types:     wybe.range.<0>construct(start:wybe.int @range:29:15, stride:wybe.int @range:29:22, end:wybe.int @range:29:30, ?tmp#0:wybe.range @range:29:5)
Types:     foreign llvm move(tmp#0:wybe.range, ?#result:wybe.range @range:28:5)
Types: Type checking non-recursive proc wybe.range.~=
Types: ** Type checking decl of proc ~=
Types: found 1 definition(s)
Types: Type checking ~=
Types: ** Type checking ~=: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         =(#left:_, #right:_)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#left","#right"]
Types: Recording parameter types: #left:wybe.range, #right:wybe.range
Types:     type of '#left' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #left type constrained to wybe.range
Types:     type of '#right' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #right type constrained to wybe.range
Types: Recording resource types: 
Types: Recording casts in {=(#left:_, #right:_)}
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #left type constrained to wybe.range
Types: Unifying types _ (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #right type constrained to wybe.range
Types: *** Before calls Typing {#left::wybe.range, #right::wybe.range}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {=(#left:_, #right:_)}, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),{test} wybe.range.=<0>(wybe.range,wybe.range)]}Typing {#left::wybe.range, #right::wybe.range}; {} (with no errors)
Types: Type checking call {=(#left:_, #right:_)}
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types:     {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Finding type of expr #left:_
Types:   Type = wybe.range
Types: Finding type of expr #right:_
Types:   Type = wybe.range
Types: Actual types: [wybe.range,wybe.range]
Types: Matching types [wybe.range,wybe.range] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.range (-> wybe.range) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.range,wybe.range] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.range (-> wybe.range) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.range,wybe.range] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Valid types = [Typing {#left::wybe.range, #right::wybe.range}; {} (with no errors)]
Types: Resulting typing = Typing {#left::wybe.range, #right::wybe.range}; {} (with no errors)
Types: Now mode checking proc ~=
Types: bound vars: semipure normal (total) computation binding {#left, #right}, break set = Everything, with resources {}
Types: Mode check stmt ~(=(#left:_, #right:_))
Types: Mode checking negation {=(#left:_, #right:_)}
Types: Mode checking call   : {=(#left:_, #right:_)}
Types:     with assigned    : semipure normal (total) computation binding {#left, #right}, break set = Everything, with resources {}
Types: Mode check exp #left:_
Types: Mode check exp resulted in #left:_
Types: Mode check exp #right:_
Types: Mode check exp resulted in #right:_
Types: Finding type of expr #left:_
Types:   Type = wybe.range
Types: Finding type of expr #right:_
Types:   Type = wybe.range
Types:     actual types     : [wybe.range,wybe.range]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.range,wybe.range] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.range (-> wybe.range) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.range,wybe.range] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.range (-> wybe.range) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Nothing: Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.range,wybe.range] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Type-correct modes   : [({test} wybe.range.=<0>(wybe.range,wybe.range),Typing {#left::wybe.range, #right::wybe.range}; {} (with no errors))]
Types: Possible mode matches: [({test} wybe.range.=<0>(wybe.range,wybe.range),Typing {#left::wybe.range, #right::wybe.range}; {} (with no errors))]
Types: Exact mode matches: [({test} wybe.range.=<0>(wybe.range,wybe.range),Typing {#left::wybe.range, #right::wybe.range}; {} (with no errors))]
Types: Finding type of expr #left:_
Types:   Type = wybe.range
Types: Finding type of expr #right:_
Types:   Type = wybe.range
Types: Finalising call    :  {wybe.range.<0>=(#left:wybe.range, #right:wybe.range)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"#left", "#right"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.range.<0>=(#left:wybe.range, #right:wybe.range)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '~='
Types: Now assigned = semipure normal (total) computation binding {#left, #right}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc '~='
Types: Mode checked body   : [{~(wybe.range.<0>=(#left:wybe.range, #right:wybe.range))}]
Types: Vars defined by body: semipure normal (total) computation binding {#left, #right}, break set = Everything, with resources {}
Types: Output parameters   : 
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of ~=:
Types: 
Types: ~= > public {test,inline} (0 calls)
Types: 4: ~=(#left:wybe.range, #right:wybe.range):
Types:     ~(wybe.range.<0>=(#left:wybe.range, #right:wybe.range))
Types: Type checking non-recursive proc wybe.range.[|]
Types: ** Type checking decl of proc [|]
Types: found 1 definition(s)
Types: Type checking [|]
Types: ** Type checking [|]: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)
Types:         ~=(value @range:14:6, end @range:14:16)
Types:         +(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)
Types:         range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)
Types:         =(?rest @range:15:6, tmp#0)
Types:    and defaults: 
Types:    with assigned vars: fromList ["current","end","rest","stride","tmp#0","tmp#1","value"]
Types: Recording parameter types: ?value:wybe.int, ?rest:wybe.range, current:wybe.range
Types:     type of 'value' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable value type constrained to wybe.int
Types:     type of 'rest' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable rest type constrained to wybe.range
Types:     type of 'current' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable current type constrained to wybe.range
Types: Recording resource types: 
Types: Recording casts in {range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)}
Types: Recording casts in {~=(value @range:14:6, end @range:14:16)}
Types: Recording casts in {+(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)}
Types: Recording casts in {range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)}
Types: Recording casts in {=(?rest @range:15:6, tmp#0)}
Types: *** Before calls Typing {current::wybe.range, rest::wybe.range, value::wybe.int}; {} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)} @range:13:5, typingInfos = [wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)]}
Types:     StmtTypings {typingStmt = {~=(value @range:14:6, end @range:14:16)} @range:14:6, typingInfos = [wybe.bool.~=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.int.~=<0>(wybe.int,wybe.int,?wybe.bool),{test} wybe.range.~=<0>(wybe.range,wybe.range)]}
Types:     StmtTypings {typingStmt = {+(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)} @range:15:19, typingInfos = [wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)} @range:15:13, typingInfos = [wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)]}
Types:     StmtTypings {typingStmt = {=(?rest @range:15:6, tmp#0)} @range:15:6, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),{test} wybe.range.=<0>(wybe.range,wybe.range)]}Typing {current::wybe.range, rest::wybe.range, value::wybe.int}; {} (with no errors)
Types: Type checking call {range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)} @range:13:5
Types: Candidate types:
Types:     wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types:     wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Finding type of expr ?value @range:13:22
Types:   Type = wybe.int
Types: Finding type of expr ?stride @range:13:30
Types:   Type = 0
Types: Finding type of expr ?end @range:13:39
Types:   Type = 1
Types: Finding type of expr current @range:13:5
Types:   Type = wybe.range
Types: Actual types: [wybe.int,0,1,wybe.range]
Types: Matching types [wybe.int,0,1,wybe.range] with wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Matching types [wybe.int,0,1,wybe.range] with wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Valid types = [Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, value::wybe.int}; {0::wybe.int, 1::wybe.int} (with no errors)]
Types: Resulting typing = Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, value::wybe.int}; {0::wybe.int, 1::wybe.int} (with no errors)
Types: Type checking call {~=(value @range:14:6, end @range:14:16)} @range:14:6
Types: Candidate types:
Types:     wybe.bool.~=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.int.~=<0>(wybe.int,wybe.int,?wybe.bool)
Types:     {test} wybe.range.~=<0>(wybe.range,wybe.range)
Types: Finding type of expr value @range:14:6
Types:   Type = wybe.int
Types: Finding type of expr end @range:14:16
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.~=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 14, column 6): Type error in call to ~=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 14, column 6): Type error in call to ~=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.~=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.~=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 14, column 6): Type error in call to ~=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 14, column 6): Type error in call to ~=, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, value::wybe.int}; {0::wybe.int, 1::wybe.int} (with no errors)]
Types: Resulting typing = Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, value::wybe.int}; {0::wybe.int, 1::wybe.int} (with no errors)
Types: Type checking call {+(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)} @range:15:19
Types: Candidate types:
Types:     wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Finding type of expr value @range:15:19
Types:   Type = wybe.int
Types: Finding type of expr stride @range:15:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @range:15:19
Types:   Type = 2
Types: Actual types: [wybe.int,wybe.int,2]
Types: Matching types [wybe.int,wybe.int,2] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 2 is bound to Nothing
Types: Unifying types 2 (-> 2) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,2] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 2 is bound to Nothing
Types: Unifying types 2 (-> 2) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,2] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 2 is bound to Nothing
Types: Unifying types 2 (-> 2) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int} (with no errors)]
Types: Resulting typing = Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int} (with no errors)
Types: Type checking call {range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)} @range:15:13
Types: Candidate types:
Types:     wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types:     wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Finding type of expr tmp#1
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr stride @range:15:35
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr end @range:15:43
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:15:13
Types:   Type = 3
Types: Actual types: [wybe.int,wybe.int,wybe.int,3]
Types: Matching types [wybe.int,wybe.int,wybe.int,3] with wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 3 is bound to Nothing
Types: Unifying types 3 (-> 3) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Matching types [wybe.int,wybe.int,wybe.int,3] with wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 3 is bound to Nothing
Types: Unifying types 3 (-> 3) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Valid types = [Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors)]
Types: Resulting typing = Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors)
Types: Type checking call {=(?rest @range:15:6, tmp#0)} @range:15:6
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types:     {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Finding type of expr ?rest @range:15:6
Types:   Type = wybe.range
Types: Finding type of expr tmp#0
Types: Type variable 3 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Actual types: [wybe.range,wybe.range]
Types: Matching types [wybe.range,wybe.range] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 15, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.range (-> wybe.range) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 15, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.range,wybe.range] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 15, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.range (-> wybe.range) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 15, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.range,wybe.range] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Valid types = [Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors)]
Types: Resulting typing = Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors)
Types: Now mode checking proc [|]
Types: bound vars: semipure normal (total) computation binding {current}, break set = Everything, with resources {}
Types: Mode check stmt range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)
Types: Mode checking call   : {range(?value @range:13:22, ?stride @range:13:30, ?end @range:13:39, current @range:13:5)}
Types:     with assigned    : semipure normal (total) computation binding {current}, break set = Everything, with resources {}
Types: Mode check exp ?value
Types: Mode check exp resulted in ?value
Types: Mode check exp ?stride
Types: Mode check exp resulted in ?stride
Types: Mode check exp ?end
Types: Mode check exp resulted in ?end
Types: Mode check exp current
Types: Mode check exp resulted in current
Types: Finding type of expr ?value @range:13:22
Types:   Type = wybe.int
Types: Finding type of expr ?stride @range:13:30
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?end @range:13:39
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr current @range:13:5
Types:   Type = wybe.range
Types:     actual types     : [wybe.int,wybe.int,wybe.int,wybe.range]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamOut,False,Nothing),(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Type-correct modes   : [(wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors)),(wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range),Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors))]
Types: Possible mode matches: [(wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range),Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors))]
Types: Exact mode matches: [(wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range),Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors))]
Types: Finding type of expr ?value @range:13:22
Types:   Type = wybe.int
Types: Finding type of expr ?stride @range:13:30
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?end @range:13:39
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr current @range:13:5
Types:   Type = wybe.range
Types: Finalising call    :  {wybe.range.<1>range(?value:wybe.int @range:13:22, ?stride:wybe.int @range:13:30, ?end:wybe.int @range:13:39, current:wybe.range @range:13:5)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"current"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.range.<1>range(?value:wybe.int @range:13:22, ?stride:wybe.int @range:13:30, ?end:wybe.int @range:13:39, current:wybe.range @range:13:5)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '[|]'
Types: Now assigned = semipure normal (total) computation binding {current, end, stride, value}, break set = Everything, with resources {}
Types: Mode check stmt ~=(value @range:14:6, end @range:14:16)
Types: Mode checking call   : {~=(value @range:14:6, end @range:14:16)}
Types:     with assigned    : semipure normal (total) computation binding {current, end, stride, value}, break set = Everything, with resources {}
Types: Mode check exp value
Types: Mode check exp resulted in value
Types: Mode check exp end
Types: Mode check exp resulted in end
Types: Finding type of expr value @range:14:6
Types:   Type = wybe.int
Types: Finding type of expr end @range:14:16
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.~=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 14, column 6): Type error in call to ~=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 14, column 6): Type error in call to ~=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.~=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.~=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 14, column 6): Type error in call to ~=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 14, column 6): Type error in call to ~=, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.int.~=<0>(wybe.int,wybe.int),Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.~=<0>(wybe.int,wybe.int),Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.~=<0>(wybe.int,wybe.int),Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors))]
Types: Finding type of expr value @range:14:6
Types:   Type = wybe.int
Types: Finding type of expr end @range:14:16
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>~=(value:wybe.int @range:14:6, end:wybe.int @range:14:16)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"current", "end", "stride", "value"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>~=(value:wybe.int @range:14:6, end:wybe.int @range:14:16)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '[|]'
Types: Now assigned = semipure test computation binding {current, end, stride, value}, break set = Everything, with resources {}
Types: Mode check stmt +(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)
Types: Mode checking call   : {+(value @range:15:19, stride @range:15:27, ?tmp#1 @range:15:19)}
Types:     with assigned    : semipure test computation binding {current, end, stride, value}, break set = Everything, with resources {}
Types: Mode check exp value
Types: Mode check exp resulted in value
Types: Mode check exp stride
Types: Mode check exp resulted in stride
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr value @range:15:19
Types:   Type = wybe.int
Types: Finding type of expr stride @range:15:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @range:15:19
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors)),(wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors)),(wybe.int.+<2>(wybe.int,?wybe.int,wybe.int),Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors))]
Types: Possible mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors))]
Types: Exact mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors))]
Types: Finding type of expr value @range:15:19
Types:   Type = wybe.int
Types: Finding type of expr stride @range:15:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @range:15:19
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>+(value:wybe.int @range:15:19, stride:wybe.int @range:15:27, ?tmp#1:wybe.int @range:15:19)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"current", "end", "stride", "value"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>+(value:wybe.int @range:15:19, stride:wybe.int @range:15:27, ?tmp#1:wybe.int @range:15:19)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '[|]'
Types: Now assigned = semipure test computation binding {current, end, stride, tmp#1, value}, break set = Everything, with resources {}
Types: Mode check stmt range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)
Types: Mode checking call   : {range(tmp#1, stride @range:15:35, end @range:15:43, ?tmp#0 @range:15:13)}
Types:     with assigned    : semipure test computation binding {current, end, stride, tmp#1, value}, break set = Everything, with resources {}
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp stride
Types: Mode check exp resulted in stride
Types: Mode check exp end
Types: Mode check exp resulted in end
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#1
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr stride @range:15:35
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr end @range:15:43
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:15:13
Types: Type variable 3 is bound to Just wybe.range
Types:   Type = wybe.range
Types:     actual types     : [wybe.int,wybe.int,wybe.int,wybe.range]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Type-correct modes   : [(wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors)),(wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range),Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors))]
Types: Possible mode matches: [(wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors))]
Types: Exact mode matches: [(wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors))]
Types: Finding type of expr tmp#1
Types: Type variable 2 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr stride @range:15:35
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr end @range:15:43
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:15:13
Types: Type variable 3 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Finalising call    :  {wybe.range.<0>range(tmp#1:wybe.int, stride:wybe.int @range:15:35, end:wybe.int @range:15:43, ?tmp#0:wybe.range @range:15:13)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"current", "end", "stride", "tmp#1", "value"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.range.<0>range(tmp#1:wybe.int, stride:wybe.int @range:15:35, end:wybe.int @range:15:43, ?tmp#0:wybe.range @range:15:13)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '[|]'
Types: Now assigned = semipure test computation binding {current, end, stride, tmp#0, tmp#1, value}, break set = Everything, with resources {}
Types: Mode check stmt =(?rest @range:15:6, tmp#0)
Types: Mode checking call   : {=(?rest @range:15:6, tmp#0)}
Types:     with assigned    : semipure test computation binding {current, end, stride, tmp#0, tmp#1, value}, break set = Everything, with resources {}
Types: Mode check exp ?rest
Types: Mode check exp resulted in ?rest
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Finding type of expr ?rest @range:15:6
Types:   Type = wybe.range
Types: Finding type of expr tmp#0
Types: Type variable 3 is bound to Just wybe.range
Types:   Type = wybe.range
Types:     actual types     : [wybe.range,wybe.range]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.range,wybe.range] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 15, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.range (-> wybe.range) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 15, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.range,wybe.range] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 15, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.range (-> wybe.range) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 15, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.range,wybe.range] with {test} wybe.range.=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Type-correct modes   : [({test} wybe.range.=<0>(wybe.range,wybe.range),Typing {current::wybe.range, end::1, rest::wybe.range, stride::0, tmp#0::3, tmp#1::2, value::wybe.int}; {0::wybe.int, 1::wybe.int, 2::wybe.int, 3::wybe.range} (with no errors))]
Types: Possible mode matches: []
Types: Exact mode matches: []
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?rest @range:15:6)}
Types:     with assigned semipure test computation binding {current, end, stride, tmp#0, tmp#1, value}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?rest
Types: Mode check exp resulted in ?rest
Types: Finding type of expr tmp#0
Types: Type variable 3 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Finding type of expr ?rest @range:15:6
Types:   Type = wybe.range
Types:     types and modes = [wybe.range,?wybe.range]
Types: New instr = {foreign llvm move(tmp#0:wybe.range, ?rest:wybe.range @range:15:6)}
Types: Now assigned = semipure test computation binding {current, end, rest, stride, tmp#0, tmp#1, value}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc '[|]'
Types: Mode checked body   : [{wybe.range.<1>range(?value:wybe.int @range:13:22, ?stride:wybe.int @range:13:30, ?end:wybe.int @range:13:39, current:wybe.range @range:13:5)} @range:13:5,{wybe.int.<0>~=(value:wybe.int @range:14:6, end:wybe.int @range:14:16)} @range:14:6,{wybe.int.<0>+(value:wybe.int @range:15:19, stride:wybe.int @range:15:27, ?tmp#1:wybe.int @range:15:19)} @range:15:19,{wybe.range.<0>range(tmp#1:wybe.int, stride:wybe.int @range:15:35, end:wybe.int @range:15:43, ?tmp#0:wybe.range @range:15:13)} @range:15:13,{foreign llvm move(tmp#0:wybe.range, ?rest:wybe.range @range:15:6)} @range:15:6]
Types: Vars defined by body: semipure test computation binding {current, end, rest, stride, tmp#0, tmp#1, value}, break set = Everything, with resources {}
Types: Output parameters   : rest, value
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of [|]:
Types: 
Types: [|] > public {test} (0 calls)
Types: 4: [|](?value:wybe.int @range:12:23, ?rest:wybe.range @range:12:35, current:wybe.range @range:12:43):
Types:     wybe.range.<1>range(?value:wybe.int @range:13:22, ?stride:wybe.int @range:13:30, ?end:wybe.int @range:13:39, current:wybe.range @range:13:5)
Types:     wybe.int.<0>~=(value:wybe.int @range:14:6, end:wybe.int @range:14:16)
Types:     wybe.int.<0>+(value:wybe.int @range:15:19, stride:wybe.int @range:15:27, ?tmp#1:wybe.int @range:15:19)
Types:     wybe.range.<0>range(tmp#1:wybe.int, stride:wybe.int @range:15:35, end:wybe.int @range:15:43, ?tmp#0:wybe.range @range:15:13)
Types:     foreign llvm move(tmp#0:wybe.range, ?rest:wybe.range @range:15:6)
Types: Type checking non-recursive proc wybe.range.size
Types: ** Type checking decl of proc size
Types: found 1 definition(s)
Types: Type checking size
Types: ** Type checking size: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)
Types:         signum(stride @range:44:17, ?tmp#1 @range:44:10)
Types:         -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
Types:         signum(tmp#3, ?tmp#2 @range:44:29)
Types:         ~=(tmp#1, tmp#2)
Types:         foreign llvm move(0 @range:44:52, ?tmp#0)
Types:         <=(0 @range:45:10, stride @range:45:16)
Types:         -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
Types:         -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
Types:         /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
Types:         +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
Types:         foreign llvm move(tmp#5, ?tmp#4)
Types:         -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
Types:         -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
Types:         -(stride @range:46:39, ?tmp#13 @range:46:38)
Types:         /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
Types:         +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
Types:         foreign llvm move(tmp#9, ?tmp#4)
Types:         foreign llvm move(tmp#4 @range:45:10, ?tmp#0)
Types:         foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","end","r","start","stride","tmp#0","tmp#1","tmp#10","tmp#11","tmp#12","tmp#13","tmp#2","tmp#3","tmp#4","tmp#5","tmp#6","tmp#7","tmp#8","tmp#9"]
Types: Recording parameter types: r:wybe.range, ?#result:wybe.int
Types:     type of 'r' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable r type constrained to wybe.range
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)}
Types: Recording casts in {signum(stride @range:44:17, ?tmp#1 @range:44:10)}
Types: Recording casts in {-(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)}
Types: Recording casts in {signum(tmp#3, ?tmp#2 @range:44:29)}
Types: Recording casts in {~=(tmp#1, tmp#2)}
Types: Recording casts in {foreign llvm move(0 @range:44:52, ?tmp#0)}
Types: Unifying move argument types 0 @range:44:52 and ?tmp#0
Types: Finding type of expr 0 @range:44:52
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0
Types:   Type = 0
Types: Type variable 0 is bound to Nothing
Types: Unifying types wybe.int (-> wybe.int) and 0 (-> 0)
Types:   Unification yields wybe.int
Types: Recording casts in {<=(0 @range:45:10, stride @range:45:16)}
Types: Recording casts in {-(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)}
Types: Recording casts in {-(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)}
Types: Recording casts in {/(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)}
Types: Recording casts in {+(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)}
Types: Recording casts in {foreign llvm move(tmp#5, ?tmp#4)}
Types: Unifying move argument types tmp#5 and ?tmp#4
Types: Finding type of expr tmp#5
Types:   Type = 1
Types: Finding type of expr ?tmp#4
Types:   Type = 2
Types: Type variable 1 is bound to Nothing
Types: Type variable 2 is bound to Nothing
Types: Unifying types 1 (-> 1) and 2 (-> 2)
Types:   Unification yields 1
Types: Recording casts in {-(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)}
Types: Recording casts in {-(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)}
Types: Recording casts in {-(stride @range:46:39, ?tmp#13 @range:46:38)}
Types: Recording casts in {/(tmp#11, tmp#13, ?tmp#10 @range:46:18)}
Types: Recording casts in {+(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)}
Types: Recording casts in {foreign llvm move(tmp#9, ?tmp#4)}
Types: Unifying move argument types tmp#9 and ?tmp#4
Types: Finding type of expr tmp#9
Types:   Type = 3
Types: Finding type of expr ?tmp#4
Types: Type variable 2 is bound to Just 1
Types: Type variable 1 is bound to Nothing
Types:   Type = 1
Types: Type variable 3 is bound to Nothing
Types: Type variable 1 is bound to Nothing
Types: Unifying types 3 (-> 3) and 1 (-> 1)
Types:   Unification yields 1
Types: Recording casts in {foreign llvm move(tmp#4 @range:45:10, ?tmp#0)}
Types: Unifying move argument types tmp#4 @range:45:10 and ?tmp#0
Types: Finding type of expr tmp#4 @range:45:10
Types: Type variable 2 is bound to Just 1
Types: Type variable 1 is bound to Nothing
Types:   Type = 1
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Recording casts in {foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)}
Types: Unifying move argument types tmp#0 @range:44:10 and ?#result @range:42:5
Types: Finding type of expr tmp#0 @range:44:10
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @range:42:5
Types:   Type = wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: *** Before calls Typing {#result::wybe.int, r::wybe.range, tmp#0::0, tmp#4::2, tmp#5::1, tmp#9::3}; {0::wybe.int, 1::wybe.int, 2::1, 3::1} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)} @range:43:11, typingInfos = [wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)]}
Types:     StmtTypings {typingStmt = {signum(stride @range:44:17, ?tmp#1 @range:44:10)} @range:44:10, typingInfos = [wybe.int.signum<0>(wybe.int,?wybe.int)]}
Types:     StmtTypings {typingStmt = {-(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)} @range:44:36, typingInfos = [wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),wybe.int.-<3>(wybe.int,?wybe.int),wybe.int.-<4>(?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {signum(tmp#3, ?tmp#2 @range:44:29)} @range:44:29, typingInfos = [wybe.int.signum<0>(wybe.int,?wybe.int)]}
Types:     StmtTypings {typingStmt = {~=(tmp#1, tmp#2)} @range:44:10, typingInfos = [wybe.bool.~=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.int.~=<0>(wybe.int,wybe.int,?wybe.bool),{test} wybe.range.~=<0>(wybe.range,wybe.range)]}
Types:     StmtTypings {typingStmt = {<=(0 @range:45:10, stride @range:45:16)} @range:45:10, typingInfos = [wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {-(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)} @range:45:27, typingInfos = [wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),wybe.int.-<3>(wybe.int,?wybe.int),wybe.int.-<4>(?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {-(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)} @range:45:27, typingInfos = [wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),wybe.int.-<3>(wybe.int,?wybe.int),wybe.int.-<4>(?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {/(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)} @range:45:26, typingInfos = [wybe.int./<0>(wybe.int,wybe.int,?wybe.int)]}
Types:     StmtTypings {typingStmt = {+(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)} @range:45:26, typingInfos = [wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {-(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)} @range:46:19, typingInfos = [wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),wybe.int.-<3>(wybe.int,?wybe.int),wybe.int.-<4>(?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {-(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)} @range:46:19, typingInfos = [wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),wybe.int.-<3>(wybe.int,?wybe.int),wybe.int.-<4>(?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {-(stride @range:46:39, ?tmp#13 @range:46:38)} @range:46:38, typingInfos = [wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),wybe.int.-<3>(wybe.int,?wybe.int),wybe.int.-<4>(?wybe.int,wybe.int)]}
Types:     StmtTypings {typingStmt = {/(tmp#11, tmp#13, ?tmp#10 @range:46:18)} @range:46:18, typingInfos = [wybe.int./<0>(wybe.int,wybe.int,?wybe.int)]}
Types:     StmtTypings {typingStmt = {+(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)} @range:46:18, typingInfos = [wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)]}Typing {#result::wybe.int, r::wybe.range, tmp#0::0, tmp#4::2, tmp#5::1, tmp#9::3}; {0::wybe.int, 1::wybe.int, 2::1, 3::1} (with no errors)
Types: Type checking call {range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)} @range:43:11
Types: Candidate types:
Types:     wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types:     wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Finding type of expr ?start @range:43:22
Types:   Type = 4
Types: Finding type of expr ?stride @range:43:30
Types:   Type = 5
Types: Finding type of expr ?end @range:43:39
Types:   Type = 6
Types: Finding type of expr r @range:43:11
Types:   Type = wybe.range
Types: Actual types: [4,5,6,wybe.range]
Types: Matching types [4,5,6,wybe.range] with wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Type variable 4 is bound to Nothing
Types: Unifying types 4 (-> 4) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 5 is bound to Nothing
Types: Unifying types 5 (-> 5) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 6 is bound to Nothing
Types: Unifying types 6 (-> 6) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Matching types [4,5,6,wybe.range] with wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Type variable 4 is bound to Nothing
Types: Unifying types 4 (-> 4) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 5 is bound to Nothing
Types: Unifying types 5 (-> 5) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 6 is bound to Nothing
Types: Unifying types 6 (-> 6) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Valid types = [Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#4::2, tmp#5::1, tmp#9::3}; {0::wybe.int, 1::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#4::2, tmp#5::1, tmp#9::3}; {0::wybe.int, 1::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int} (with no errors)
Types: Type checking call {signum(stride @range:44:17, ?tmp#1 @range:44:10)} @range:44:10
Types: Candidate types:
Types:     wybe.int.signum<0>(wybe.int,?wybe.int)
Types: Finding type of expr stride @range:44:17
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @range:44:10
Types:   Type = 7
Types: Actual types: [wybe.int,7]
Types: Matching types [wybe.int,7] with wybe.int.signum<0>(wybe.int,?wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 7 is bound to Nothing
Types: Unifying types 7 (-> 7) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#4::2, tmp#5::1, tmp#9::3}; {0::wybe.int, 1::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#4::2, tmp#5::1, tmp#9::3}; {0::wybe.int, 1::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int} (with no errors)
Types: Type checking call {-(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)} @range:44:36
Types: Candidate types:
Types:     wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types:     wybe.int.-<3>(wybe.int,?wybe.int)
Types:     wybe.int.-<4>(?wybe.int,wybe.int)
Types: Finding type of expr end @range:44:36
Types: Type variable 6 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr start @range:44:42
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#3 @range:44:36
Types:   Type = 8
Types: Actual types: [wybe.int,wybe.int,8]
Types: Matching types [wybe.int,wybe.int,8] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 8 is bound to Nothing
Types: Unifying types 8 (-> 8) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,8] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 8 is bound to Nothing
Types: Unifying types 8 (-> 8) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,8] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 8 is bound to Nothing
Types: Unifying types 8 (-> 8) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#3::8, tmp#4::2, tmp#5::1, tmp#9::3}; {0::wybe.int, 1::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#3::8, tmp#4::2, tmp#5::1, tmp#9::3}; {0::wybe.int, 1::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int} (with no errors)
Types: Type checking call {signum(tmp#3, ?tmp#2 @range:44:29)} @range:44:29
Types: Candidate types:
Types:     wybe.int.signum<0>(wybe.int,?wybe.int)
Types: Finding type of expr tmp#3
Types: Type variable 8 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2 @range:44:29
Types:   Type = 9
Types: Actual types: [wybe.int,9]
Types: Matching types [wybe.int,9] with wybe.int.signum<0>(wybe.int,?wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 9 is bound to Nothing
Types: Unifying types 9 (-> 9) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#9::3}; {0::wybe.int, 1::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#9::3}; {0::wybe.int, 1::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {~=(tmp#1, tmp#2)} @range:44:10
Types: Candidate types:
Types:     wybe.bool.~=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.int.~=<0>(wybe.int,wybe.int,?wybe.bool)
Types:     {test} wybe.range.~=<0>(wybe.range,wybe.range)
Types: Finding type of expr tmp#1
Types: Type variable 7 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr tmp#2
Types: Type variable 9 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.~=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 44, column 10): Type error in call to ~=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 44, column 10): Type error in call to ~=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.~=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.~=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 44, column 10): Type error in call to ~=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 44, column 10): Type error in call to ~=, argument 2]
Types:   Unification yields XXX
Types: Valid types = [Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#9::3}; {0::wybe.int, 1::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#9::3}; {0::wybe.int, 1::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {<=(0 @range:45:10, stride @range:45:16)} @range:45:10
Types: Candidate types:
Types:     wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr 0 @range:45:10
Types:   Type = wybe.int
Types: Finding type of expr stride @range:45:16
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#9::3}; {0::wybe.int, 1::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#9::3}; {0::wybe.int, 1::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {-(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)} @range:45:27
Types: Candidate types:
Types:     wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types:     wybe.int.-<3>(wybe.int,?wybe.int)
Types:     wybe.int.-<4>(?wybe.int,wybe.int)
Types: Finding type of expr end @range:45:27
Types: Type variable 6 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr start @range:45:33
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#8 @range:45:27
Types:   Type = 10
Types: Actual types: [wybe.int,wybe.int,10]
Types: Matching types [wybe.int,wybe.int,10] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 10 is bound to Nothing
Types: Unifying types 10 (-> 10) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,10] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 10 is bound to Nothing
Types: Unifying types 10 (-> 10) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,10] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 10 is bound to Nothing
Types: Unifying types 10 (-> 10) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {-(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)} @range:45:27
Types: Candidate types:
Types:     wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types:     wybe.int.-<3>(wybe.int,?wybe.int)
Types:     wybe.int.-<4>(?wybe.int,wybe.int)
Types: Finding type of expr tmp#8
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1 @range:45:41
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#7 @range:45:27
Types:   Type = 11
Types: Actual types: [wybe.int,wybe.int,11]
Types: Matching types [wybe.int,wybe.int,11] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 11 is bound to Nothing
Types: Unifying types 11 (-> 11) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,11] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 11 is bound to Nothing
Types: Unifying types 11 (-> 11) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,11] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 11 is bound to Nothing
Types: Unifying types 11 (-> 11) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {/(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)} @range:45:26
Types: Candidate types:
Types:     wybe.int./<0>(wybe.int,wybe.int,?wybe.int)
Types: Finding type of expr tmp#7
Types: Type variable 11 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr stride @range:45:46
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#6 @range:45:26
Types:   Type = 12
Types: Actual types: [wybe.int,wybe.int,12]
Types: Matching types [wybe.int,wybe.int,12] with wybe.int./<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 12 is bound to Nothing
Types: Unifying types 12 (-> 12) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {+(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)} @range:45:26
Types: Candidate types:
Types:     wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Finding type of expr tmp#6
Types: Type variable 12 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1 @range:45:55
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#5 @range:45:26
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {-(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)} @range:46:19
Types: Candidate types:
Types:     wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types:     wybe.int.-<3>(wybe.int,?wybe.int)
Types:     wybe.int.-<4>(?wybe.int,wybe.int)
Types: Finding type of expr start @range:46:19
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr end @range:46:27
Types: Type variable 6 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#12 @range:46:19
Types:   Type = 13
Types: Actual types: [wybe.int,wybe.int,13]
Types: Matching types [wybe.int,wybe.int,13] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 13 is bound to Nothing
Types: Unifying types 13 (-> 13) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,13] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 13 is bound to Nothing
Types: Unifying types 13 (-> 13) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,13] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 13 is bound to Nothing
Types: Unifying types 13 (-> 13) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#12::13, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#12::13, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {-(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)} @range:46:19
Types: Candidate types:
Types:     wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types:     wybe.int.-<3>(wybe.int,?wybe.int)
Types:     wybe.int.-<4>(?wybe.int,wybe.int)
Types: Finding type of expr tmp#12
Types: Type variable 13 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1 @range:46:33
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#11 @range:46:19
Types:   Type = 14
Types: Actual types: [wybe.int,wybe.int,14]
Types: Matching types [wybe.int,wybe.int,14] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 14 is bound to Nothing
Types: Unifying types 14 (-> 14) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,14] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 14 is bound to Nothing
Types: Unifying types 14 (-> 14) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,14] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 14 is bound to Nothing
Types: Unifying types 14 (-> 14) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#11::14, tmp#12::13, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#11::14, tmp#12::13, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {-(stride @range:46:39, ?tmp#13 @range:46:38)} @range:46:38
Types: Candidate types:
Types:     wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types:     wybe.int.-<3>(wybe.int,?wybe.int)
Types:     wybe.int.-<4>(?wybe.int,wybe.int)
Types: Finding type of expr stride @range:46:39
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#13 @range:46:38
Types:   Type = 15
Types: Actual types: [wybe.int,15]
Types: Matching types [wybe.int,15] with partial application of wybe.int.-<0>(wybe.int,?(wybe.int, ?wybe.int))
Types: Call arity 2; proc arity 3 - 3
Types: Filling  -1 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 15 is bound to Nothing
Types: Unifying types 15 (-> 15) and (wybe.int, ?wybe.int) (-> (wybe.int, ?wybe.int))
Types:   Unification yields (wybe.int, ?wybe.int)
Types: Matching types [wybe.int,15] with partial application of wybe.int.-<1>(?wybe.int,?(wybe.int, wybe.int))
Types: Call arity 2; proc arity 3 - 3
Types: Filling  -1 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 15 is bound to Nothing
Types: Unifying types 15 (-> 15) and (wybe.int, wybe.int) (-> (wybe.int, wybe.int))
Types:   Unification yields (wybe.int, wybe.int)
Types: Matching types [wybe.int,15] with partial application of wybe.int.-<2>(wybe.int,?(?wybe.int, wybe.int))
Types: Call arity 2; proc arity 3 - 3
Types: Filling  -1 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 15 is bound to Nothing
Types: Unifying types 15 (-> 15) and (?wybe.int, wybe.int) (-> (?wybe.int, wybe.int))
Types:   Unification yields (?wybe.int, wybe.int)
Types: Matching types [wybe.int,15] with wybe.int.-<3>(wybe.int,?wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 15 is bound to Nothing
Types: Unifying types 15 (-> 15) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,15] with wybe.int.-<4>(?wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 15 is bound to Nothing
Types: Unifying types 15 (-> 15) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::(wybe.int, ?wybe.int), 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::(wybe.int, wybe.int), 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::(?wybe.int, wybe.int), 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Type checking call {/(tmp#11, tmp#13, ?tmp#10 @range:46:18)} @range:46:18
Types: Candidate types:
Types:     wybe.int./<0>(wybe.int,wybe.int,?wybe.int)
Types: Finding type of expr tmp#11
Types: Type variable 14 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr tmp#13
Types: Type variable 15 is bound to Nothing
Types:   Type = 15
Types: Finding type of expr ?tmp#10 @range:46:18
Types:   Type = 16
Types: Actual types: [wybe.int,15,16]
Types: Matching types [wybe.int,15,16] with wybe.int./<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 15 is bound to Nothing
Types: Unifying types 15 (-> 15) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type variable 16 is bound to Nothing
Types: Unifying types 16 (-> 16) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {+(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)} @range:46:18
Types: Candidate types:
Types:     wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types:     wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types:     wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Finding type of expr tmp#10
Types: Type variable 16 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1 @range:46:48
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#9 @range:46:18
Types: Type variable 3 is bound to Just 1
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Type checking call {-(stride @range:46:39, ?tmp#13 @range:46:38)} @range:46:38
Types: Candidate types:
Types:     partial application of wybe.int.-<0>(wybe.int,?(wybe.int, ?wybe.int))
Types:     partial application of wybe.int.-<1>(?wybe.int,?(wybe.int, wybe.int))
Types:     partial application of wybe.int.-<2>(wybe.int,?(?wybe.int, wybe.int))
Types:     wybe.int.-<3>(wybe.int,?wybe.int)
Types: Finding type of expr stride @range:46:39
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#13 @range:46:38
Types: Type variable 15 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with wybe.int.-<3>(wybe.int,?wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)
Types: Finding type of expr 0 @range:44:52
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#5
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#4
Types: Type variable 2 is bound to Just 1
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#9
Types: Type variable 3 is bound to Just 1
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#4
Types: Type variable 2 is bound to Just 1
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#4 @range:45:10
Types: Type variable 2 is bound to Just 1
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#0 @range:44:10
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @range:42:5
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Now mode checking proc size
Types: bound vars: semipure normal (total) computation binding {r}, break set = Everything, with resources {}
Types: Mode check stmt range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)
Types: Mode checking call   : {range(?start @range:43:22, ?stride @range:43:30, ?end @range:43:39, r @range:43:11)}
Types:     with assigned    : semipure normal (total) computation binding {r}, break set = Everything, with resources {}
Types: Mode check exp ?start
Types: Mode check exp resulted in ?start
Types: Mode check exp ?stride
Types: Mode check exp resulted in ?stride
Types: Mode check exp ?end
Types: Mode check exp resulted in ?end
Types: Mode check exp r
Types: Mode check exp resulted in r
Types: Finding type of expr ?start @range:43:22
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?stride @range:43:30
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?end @range:43:39
Types: Type variable 6 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr r @range:43:11
Types:   Type = wybe.range
Types:     actual types     : [wybe.int,wybe.int,wybe.int,wybe.range]
Types:     actual modes     : [(ParamOut,False,Nothing),(ParamOut,False,Nothing),(ParamOut,False,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Type-correct modes   : [(wybe.range.range<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.range.range<1>(?wybe.int,?wybe.int,?wybe.int,wybe.range),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr ?start @range:43:22
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?stride @range:43:30
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?end @range:43:39
Types: Type variable 6 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr r @range:43:11
Types:   Type = wybe.range
Types: Finalising call    :  {wybe.range.<1>range(?start:wybe.int @range:43:22, ?stride:wybe.int @range:43:30, ?end:wybe.int @range:43:39, r:wybe.range @range:43:11)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"r"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.range.<1>range(?start:wybe.int @range:43:22, ?stride:wybe.int @range:43:30, ?end:wybe.int @range:43:39, r:wybe.range @range:43:11)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'size'
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride}, break set = Everything, with resources {}
Types: Mode check stmt if {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
Types:                     & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
Types:                     & signum(tmp#3, ?tmp#2 @range:44:29)
Types:                     & ~=(tmp#1, tmp#2))::
Types: 
Types:                     foreign llvm move(0 @range:44:52, ?tmp#0)
Types:                 else::
Types:                     if {<=(0 @range:45:10, stride @range:45:16)::
Types: 
Types:                         -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
Types:                         -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
Types:                         /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
Types:                         +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
Types:                         foreign llvm move(tmp#5, ?tmp#4)
Types:                     else::
Types:                         -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
Types:                         -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
Types:                         -(stride @range:46:39, ?tmp#13 @range:46:38)
Types:                         /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
Types:                         +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
Types:                         foreign llvm move(tmp#9, ?tmp#4)
Types: 
Types:                     }
Types:                     foreign llvm move(tmp#4 @range:45:10, ?tmp#0)
Types: 
Types:                 }
Types: Mode checking conditional {if {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
Types:         & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
Types:         & signum(tmp#3, ?tmp#2 @range:44:29)
Types:         & ~=(tmp#1, tmp#2))::
Types: 
Types:         foreign llvm move(0 @range:44:52, ?tmp#0)
Types:     else::
Types:         if {<=(0 @range:45:10, stride @range:45:16)::
Types: 
Types:             -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
Types:             -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
Types:             /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
Types:             +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
Types:             foreign llvm move(tmp#5, ?tmp#4)
Types:         else::
Types:             -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
Types:             -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
Types:             -(stride @range:46:39, ?tmp#13 @range:46:38)
Types:             /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
Types:             +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
Types:             foreign llvm move(tmp#9, ?tmp#4)
Types: 
Types:         }
Types:         foreign llvm move(tmp#4 @range:45:10, ?tmp#0)
Types: 
Types:     }}
Types: Mode checking conjunction {(   signum(stride @range:44:17, ?tmp#1 @range:44:10)
Types:     & -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
Types:     & signum(tmp#3, ?tmp#2 @range:44:29)
Types:     & ~=(tmp#1, tmp#2))}
Types: Mode check stmt signum(stride @range:44:17, ?tmp#1 @range:44:10)
Types: Mode checking call   : {signum(stride @range:44:17, ?tmp#1 @range:44:10)}
Types:     with assigned    : semipure normal (total) computation binding {end, r, start, stride}, break set = Everything, with resources {}
Types: Mode check exp stride
Types: Mode check exp resulted in stride
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr stride @range:44:17
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @range:44:10
Types: Type variable 7 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int] with wybe.int.signum<0>(wybe.int,?wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.signum<0>(wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.signum<0>(wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.signum<0>(wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr stride @range:44:17
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1 @range:44:10
Types: Type variable 7 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>signum(stride:wybe.int @range:44:17, ?tmp#1:wybe.int @range:44:10)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "r", "start", "stride"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>signum(stride:wybe.int @range:44:17, ?tmp#1:wybe.int @range:44:10)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc 'size'
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#1}, break set = Everything, with resources {}
Types: Mode check stmt -(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)
Types: Mode checking call   : {-(end @range:44:36, start @range:44:42, ?tmp#3 @range:44:36)}
Types:     with assigned    : semipure normal (total) computation binding {end, r, start, stride, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp end
Types: Mode check exp resulted in end
Types: Mode check exp start
Types: Mode check exp resulted in start
Types: Mode check exp ?tmp#3
Types: Mode check exp resulted in ?tmp#3
Types: Finding type of expr end @range:44:36
Types: Type variable 6 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr start @range:44:42
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#3 @range:44:36
Types: Type variable 8 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr end @range:44:36
Types: Type variable 6 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr start @range:44:42
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#3 @range:44:36
Types: Type variable 8 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>-(end:wybe.int @range:44:36, start:wybe.int @range:44:42, ?tmp#3:wybe.int @range:44:36)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "r", "start", "stride", "tmp#1"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>-(end:wybe.int @range:44:36, start:wybe.int @range:44:42, ?tmp#3:wybe.int @range:44:36)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc 'size'
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#1, tmp#3}, break set = Everything, with resources {}
Types: Mode check stmt signum(tmp#3, ?tmp#2 @range:44:29)
Types: Mode checking call   : {signum(tmp#3, ?tmp#2 @range:44:29)}
Types:     with assigned    : semipure normal (total) computation binding {end, r, start, stride, tmp#1, tmp#3}, break set = Everything, with resources {}
Types: Mode check exp tmp#3
Types: Mode check exp resulted in tmp#3
Types: Mode check exp ?tmp#2
Types: Mode check exp resulted in ?tmp#2
Types: Finding type of expr tmp#3
Types: Type variable 8 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2 @range:44:29
Types: Type variable 9 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int] with wybe.int.signum<0>(wybe.int,?wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.signum<0>(wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.signum<0>(wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.signum<0>(wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr tmp#3
Types: Type variable 8 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2 @range:44:29
Types: Type variable 9 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>signum(tmp#3:wybe.int, ?tmp#2:wybe.int @range:44:29)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "r", "start", "stride", "tmp#1", "tmp#3"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>signum(tmp#3:wybe.int, ?tmp#2:wybe.int @range:44:29)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc 'size'
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#1, tmp#2, tmp#3}, break set = Everything, with resources {}
Types: Mode check stmt ~=(tmp#1, tmp#2)
Types: Mode checking call   : {~=(tmp#1, tmp#2)}
Types:     with assigned    : semipure normal (total) computation binding {end, r, start, stride, tmp#1, tmp#2, tmp#3}, break set = Everything, with resources {}
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp tmp#2
Types: Mode check exp resulted in tmp#2
Types: Finding type of expr tmp#1
Types: Type variable 7 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr tmp#2
Types: Type variable 9 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.bool.~=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 44, column 10): Type error in call to ~=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 44, column 10): Type error in call to ~=, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.~=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with {test} wybe.range.~=<0>(wybe.range,wybe.range)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 44, column 10): Type error in call to ~=, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.int (-> wybe.int) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 44, column 10): Type error in call to ~=, argument 2]
Types:   Unification yields XXX
Types: Type-correct modes   : [({test} wybe.int.~=<0>(wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.~=<0>(wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.~=<0>(wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr tmp#1
Types: Type variable 7 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr tmp#2
Types: Type variable 9 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>~=(tmp#1:wybe.int, tmp#2:wybe.int)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "r", "start", "stride", "tmp#1", "tmp#2", "tmp#3"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>~=(tmp#1:wybe.int, tmp#2:wybe.int)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc 'size'
Types: Now assigned = semipure test computation binding {end, r, start, stride, tmp#1, tmp#2, tmp#3}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'size'
Types: Assigned by test: semipure test computation binding {end, r, start, stride, tmp#1, tmp#2, tmp#3}, break set = Everything, with resources {}
Types: Type variable 6 is bound to Just wybe.int
Types: Type variable 4 is bound to Just wybe.int
Types: Type variable 5 is bound to Just wybe.int
Types: Type variable 7 is bound to Just wybe.int
Types: Type variable 9 is bound to Just wybe.int
Types: Type variable 8 is bound to Just wybe.int
Types: Mode check stmt foreign llvm move(0 @range:44:52, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(0 @range:44:52, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {end, r, start, stride, tmp#1, tmp#2, tmp#3}, break set = Everything, with resources {}
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr 0 @range:44:52
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(0:wybe.int @range:44:52, ?tmp#0:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#0, tmp#1, tmp#2, tmp#3}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'size'
Types: Assigned by then branch: semipure normal (total) computation binding {end, r, start, stride, tmp#0, tmp#1, tmp#2, tmp#3}, break set = Everything, with resources {}
Types: Mode check stmt if {<=(0 @range:45:10, stride @range:45:16)::
Types: 
Types:                     -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
Types:                     -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
Types:                     /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
Types:                     +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
Types:                     foreign llvm move(tmp#5, ?tmp#4)
Types:                 else::
Types:                     -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
Types:                     -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
Types:                     -(stride @range:46:39, ?tmp#13 @range:46:38)
Types:                     /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
Types:                     +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
Types:                     foreign llvm move(tmp#9, ?tmp#4)
Types: 
Types:                 }
Types: Mode checking conditional {if {<=(0 @range:45:10, stride @range:45:16)::
Types: 
Types:         -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
Types:         -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
Types:         /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
Types:         +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
Types:         foreign llvm move(tmp#5, ?tmp#4)
Types:     else::
Types:         -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
Types:         -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
Types:         -(stride @range:46:39, ?tmp#13 @range:46:38)
Types:         /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
Types:         +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
Types:         foreign llvm move(tmp#9, ?tmp#4)
Types: 
Types:     }}
Types: Mode checking call   : {<=(0 @range:45:10, stride @range:45:16)}
Types:     with assigned    : semipure normal (total) computation binding {end, r, start, stride}, break set = Everything, with resources {}
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp stride
Types: Mode check exp resulted in stride
Types: Finding type of expr 0 @range:45:10
Types:   Type = wybe.int
Types: Finding type of expr stride @range:45:16
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr 0 @range:45:10
Types:   Type = wybe.int
Types: Finding type of expr stride @range:45:16
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0><=(0:wybe.int @range:45:10, stride:wybe.int @range:45:16)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "r", "start", "stride"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0><=(0:wybe.int @range:45:10, stride:wybe.int @range:45:16)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc 'size'
Types: Assigned by test: semipure test computation binding {end, r, start, stride}, break set = Everything, with resources {}
Types: Type variable 6 is bound to Just wybe.int
Types: Type variable 4 is bound to Just wybe.int
Types: Type variable 5 is bound to Just wybe.int
Types: Mode check stmt -(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)
Types: Mode checking call   : {-(end @range:45:27, start @range:45:33, ?tmp#8 @range:45:27)}
Types:     with assigned    : semipure normal (total) computation binding {end, r, start, stride}, break set = Everything, with resources {}
Types: Mode check exp end
Types: Mode check exp resulted in end
Types: Mode check exp start
Types: Mode check exp resulted in start
Types: Mode check exp ?tmp#8
Types: Mode check exp resulted in ?tmp#8
Types: Finding type of expr end @range:45:27
Types: Type variable 6 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr start @range:45:33
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#8 @range:45:27
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr end @range:45:27
Types: Type variable 6 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr start @range:45:33
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#8 @range:45:27
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>-(end:wybe.int @range:45:27, start:wybe.int @range:45:33, ?tmp#8:wybe.int @range:45:27)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "r", "start", "stride"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>-(end:wybe.int @range:45:27, start:wybe.int @range:45:33, ?tmp#8:wybe.int @range:45:27)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'size'
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#8}, break set = Everything, with resources {}
Types: Mode check stmt -(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)
Types: Mode checking call   : {-(tmp#8, 1 @range:45:41, ?tmp#7 @range:45:27)}
Types:     with assigned    : semipure normal (total) computation binding {end, r, start, stride, tmp#8}, break set = Everything, with resources {}
Types: Mode check exp tmp#8
Types: Mode check exp resulted in tmp#8
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp ?tmp#7
Types: Mode check exp resulted in ?tmp#7
Types: Finding type of expr tmp#8
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1 @range:45:41
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#7 @range:45:27
Types: Type variable 11 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr tmp#8
Types: Type variable 10 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1 @range:45:41
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#7 @range:45:27
Types: Type variable 11 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>-(tmp#8:wybe.int, 1:wybe.int @range:45:41, ?tmp#7:wybe.int @range:45:27)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "r", "start", "stride", "tmp#8"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>-(tmp#8:wybe.int, 1:wybe.int @range:45:41, ?tmp#7:wybe.int @range:45:27)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'size'
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#7, tmp#8}, break set = Everything, with resources {}
Types: Mode check stmt /(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)
Types: Mode checking call   : {/(tmp#7, stride @range:45:46, ?tmp#6 @range:45:26)}
Types:     with assigned    : semipure normal (total) computation binding {end, r, start, stride, tmp#7, tmp#8}, break set = Everything, with resources {}
Types: Mode check exp tmp#7
Types: Mode check exp resulted in tmp#7
Types: Mode check exp stride
Types: Mode check exp resulted in stride
Types: Mode check exp ?tmp#6
Types: Mode check exp resulted in ?tmp#6
Types: Finding type of expr tmp#7
Types: Type variable 11 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr stride @range:45:46
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#6 @range:45:26
Types: Type variable 12 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int./<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int./<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int./<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int./<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr tmp#7
Types: Type variable 11 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr stride @range:45:46
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#6 @range:45:26
Types: Type variable 12 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>/(tmp#7:wybe.int, stride:wybe.int @range:45:46, ?tmp#6:wybe.int @range:45:26)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "r", "start", "stride", "tmp#7", "tmp#8"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>/(tmp#7:wybe.int, stride:wybe.int @range:45:46, ?tmp#6:wybe.int @range:45:26)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'size'
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#6, tmp#7, tmp#8}, break set = Everything, with resources {}
Types: Mode check stmt +(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)
Types: Mode checking call   : {+(tmp#6, 1 @range:45:55, ?tmp#5 @range:45:26)}
Types:     with assigned    : semipure normal (total) computation binding {end, r, start, stride, tmp#6, tmp#7, tmp#8}, break set = Everything, with resources {}
Types: Mode check exp tmp#6
Types: Mode check exp resulted in tmp#6
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp ?tmp#5
Types: Mode check exp resulted in ?tmp#5
Types: Finding type of expr tmp#6
Types: Type variable 12 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1 @range:45:55
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#5 @range:45:26
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.+<2>(wybe.int,?wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr tmp#6
Types: Type variable 12 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1 @range:45:55
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#5 @range:45:26
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>+(tmp#6:wybe.int, 1:wybe.int @range:45:55, ?tmp#5:wybe.int @range:45:26)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "r", "start", "stride", "tmp#6", "tmp#7", "tmp#8"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>+(tmp#6:wybe.int, 1:wybe.int @range:45:55, ?tmp#5:wybe.int @range:45:26)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'size'
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#5, tmp#6, tmp#7, tmp#8}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#5, ?tmp#4)
Types: Mode checking foreign call {foreign llvm move(tmp#5, ?tmp#4)}
Types:     with assigned semipure normal (total) computation binding {end, r, start, stride, tmp#5, tmp#6, tmp#7, tmp#8}, break set = Everything, with resources {}
Types: Mode check exp tmp#5
Types: Mode check exp resulted in tmp#5
Types: Mode check exp ?tmp#4
Types: Mode check exp resulted in ?tmp#4
Types: Finding type of expr tmp#5
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#4
Types: Type variable 2 is bound to Just 1
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#5:wybe.int, ?tmp#4:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#4, tmp#5, tmp#6, tmp#7, tmp#8}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'size'
Types: Assigned by then branch: semipure normal (total) computation binding {end, r, start, stride, tmp#4, tmp#5, tmp#6, tmp#7, tmp#8}, break set = Everything, with resources {}
Types: Mode check stmt -(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)
Types: Mode checking call   : {-(start @range:46:19, end @range:46:27, ?tmp#12 @range:46:19)}
Types:     with assigned    : semipure normal (total) computation binding {end, r, start, stride}, break set = Everything, with resources {}
Types: Mode check exp start
Types: Mode check exp resulted in start
Types: Mode check exp end
Types: Mode check exp resulted in end
Types: Mode check exp ?tmp#12
Types: Mode check exp resulted in ?tmp#12
Types: Finding type of expr start @range:46:19
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr end @range:46:27
Types: Type variable 6 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#12 @range:46:19
Types: Type variable 13 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr start @range:46:19
Types: Type variable 4 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr end @range:46:27
Types: Type variable 6 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#12 @range:46:19
Types: Type variable 13 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>-(start:wybe.int @range:46:19, end:wybe.int @range:46:27, ?tmp#12:wybe.int @range:46:19)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "r", "start", "stride"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>-(start:wybe.int @range:46:19, end:wybe.int @range:46:27, ?tmp#12:wybe.int @range:46:19)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'size'
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#12}, break set = Everything, with resources {}
Types: Mode check stmt -(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)
Types: Mode checking call   : {-(tmp#12, 1 @range:46:33, ?tmp#11 @range:46:19)}
Types:     with assigned    : semipure normal (total) computation binding {end, r, start, stride, tmp#12}, break set = Everything, with resources {}
Types: Mode check exp tmp#12
Types: Mode check exp resulted in tmp#12
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp ?tmp#11
Types: Mode check exp resulted in ?tmp#11
Types: Finding type of expr tmp#12
Types: Type variable 13 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1 @range:46:33
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#11 @range:46:19
Types: Type variable 14 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.-<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.-<1>(?wybe.int,wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.-<2>(wybe.int,?wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.-<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr tmp#12
Types: Type variable 13 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1 @range:46:33
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#11 @range:46:19
Types: Type variable 14 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>-(tmp#12:wybe.int, 1:wybe.int @range:46:33, ?tmp#11:wybe.int @range:46:19)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "r", "start", "stride", "tmp#12"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>-(tmp#12:wybe.int, 1:wybe.int @range:46:33, ?tmp#11:wybe.int @range:46:19)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'size'
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#11, tmp#12}, break set = Everything, with resources {}
Types: Mode check stmt -(stride @range:46:39, ?tmp#13 @range:46:38)
Types: Mode checking call   : {-(stride @range:46:39, ?tmp#13 @range:46:38)}
Types:     with assigned    : semipure normal (total) computation binding {end, r, start, stride, tmp#11, tmp#12}, break set = Everything, with resources {}
Types: Mode check exp stride
Types: Mode check exp resulted in stride
Types: Mode check exp ?tmp#13
Types: Mode check exp resulted in ?tmp#13
Types: Finding type of expr stride @range:46:39
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#13 @range:46:38
Types: Type variable 15 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int] with partial application of wybe.int.-<0>(wybe.int,?(wybe.int, ?wybe.int))
Types: Call arity 2; proc arity 3 - 3
Types: Filling  -1 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and (wybe.int, ?wybe.int) (-> (wybe.int, ?wybe.int))
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 46, column 38): Type error in call to -, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with partial application of wybe.int.-<1>(?wybe.int,?(wybe.int, wybe.int))
Types: Call arity 2; proc arity 3 - 3
Types: Filling  -1 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and (wybe.int, wybe.int) (-> (wybe.int, wybe.int))
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 46, column 38): Type error in call to -, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with partial application of wybe.int.-<2>(wybe.int,?(?wybe.int, wybe.int))
Types: Call arity 2; proc arity 3 - 3
Types: Filling  -1 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and (?wybe.int, wybe.int) (-> (?wybe.int, wybe.int))
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/range.wybe" (line 46, column 38): Type error in call to -, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.int,wybe.int] with wybe.int.-<3>(wybe.int,?wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int] with wybe.int.-<4>(?wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.-<3>(wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.-<4>(?wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.-<3>(wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.-<3>(wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr stride @range:46:39
Types: Type variable 5 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#13 @range:46:38
Types: Type variable 15 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<3>-(stride:wybe.int @range:46:39, ?tmp#13:wybe.int @range:46:38)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "r", "start", "stride", "tmp#11", "tmp#12"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<3>-(stride:wybe.int @range:46:39, ?tmp#13:wybe.int @range:46:38)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'size'
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#11, tmp#12, tmp#13}, break set = Everything, with resources {}
Types: Mode check stmt /(tmp#11, tmp#13, ?tmp#10 @range:46:18)
Types: Mode checking call   : {/(tmp#11, tmp#13, ?tmp#10 @range:46:18)}
Types:     with assigned    : semipure normal (total) computation binding {end, r, start, stride, tmp#11, tmp#12, tmp#13}, break set = Everything, with resources {}
Types: Mode check exp tmp#11
Types: Mode check exp resulted in tmp#11
Types: Mode check exp tmp#13
Types: Mode check exp resulted in tmp#13
Types: Mode check exp ?tmp#10
Types: Mode check exp resulted in ?tmp#10
Types: Finding type of expr tmp#11
Types: Type variable 14 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr tmp#13
Types: Type variable 15 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#10 @range:46:18
Types: Type variable 16 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int./<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int./<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int./<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int./<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr tmp#11
Types: Type variable 14 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr tmp#13
Types: Type variable 15 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#10 @range:46:18
Types: Type variable 16 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>/(tmp#11:wybe.int, tmp#13:wybe.int, ?tmp#10:wybe.int @range:46:18)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "r", "start", "stride", "tmp#11", "tmp#12", "tmp#13"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>/(tmp#11:wybe.int, tmp#13:wybe.int, ?tmp#10:wybe.int @range:46:18)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'size'
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#10, tmp#11, tmp#12, tmp#13}, break set = Everything, with resources {}
Types: Mode check stmt +(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)
Types: Mode checking call   : {+(tmp#10, 1 @range:46:48, ?tmp#9 @range:46:18)}
Types:     with assigned    : semipure normal (total) computation binding {end, r, start, stride, tmp#10, tmp#11, tmp#12, tmp#13}, break set = Everything, with resources {}
Types: Mode check exp tmp#10
Types: Mode check exp resulted in tmp#10
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp ?tmp#9
Types: Mode check exp resulted in ?tmp#9
Types: Finding type of expr tmp#10
Types: Type variable 16 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1 @range:46:48
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#9 @range:46:18
Types: Type variable 3 is bound to Just 1
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<0>(wybe.int,wybe.int,?wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<1>(?wybe.int,wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Matching types [wybe.int,wybe.int,wybe.int] with wybe.int.+<2>(wybe.int,?wybe.int,wybe.int)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.+<1>(?wybe.int,wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors)),(wybe.int.+<2>(wybe.int,?wybe.int,wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Possible mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Exact mode matches: [(wybe.int.+<0>(wybe.int,wybe.int,?wybe.int),Typing {#result::wybe.int, end::6, r::wybe.range, start::4, stride::5, tmp#0::0, tmp#1::7, tmp#10::16, tmp#11::14, tmp#12::13, tmp#13::15, tmp#2::9, tmp#3::8, tmp#4::2, tmp#5::1, tmp#6::12, tmp#7::11, tmp#8::10, tmp#9::3}; {0::wybe.int, 1::wybe.int, 10::wybe.int, 11::wybe.int, 12::wybe.int, 13::wybe.int, 14::wybe.int, 15::wybe.int, 16::wybe.int, 2::1, 3::1, 4::wybe.int, 5::wybe.int, 6::wybe.int, 7::wybe.int, 8::wybe.int, 9::wybe.int} (with no errors))]
Types: Finding type of expr tmp#10
Types: Type variable 16 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1 @range:46:48
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#9 @range:46:18
Types: Type variable 3 is bound to Just 1
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0>+(tmp#10:wybe.int, 1:wybe.int @range:46:48, ?tmp#9:wybe.int @range:46:18)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "r", "start", "stride", "tmp#10", "tmp#11", "tmp#12", "tmp#13"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0>+(tmp#10:wybe.int, 1:wybe.int @range:46:48, ?tmp#9:wybe.int @range:46:18)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc 'size'
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#10, tmp#11, tmp#12, tmp#13, tmp#9}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#9, ?tmp#4)
Types: Mode checking foreign call {foreign llvm move(tmp#9, ?tmp#4)}
Types:     with assigned semipure normal (total) computation binding {end, r, start, stride, tmp#10, tmp#11, tmp#12, tmp#13, tmp#9}, break set = Everything, with resources {}
Types: Mode check exp tmp#9
Types: Mode check exp resulted in tmp#9
Types: Mode check exp ?tmp#4
Types: Mode check exp resulted in ?tmp#4
Types: Finding type of expr tmp#9
Types: Type variable 3 is bound to Just 1
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#4
Types: Type variable 2 is bound to Just 1
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#9:wybe.int, ?tmp#4:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#10, tmp#11, tmp#12, tmp#13, tmp#4, tmp#9}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'size'
Types: Assigned by else branch: semipure normal (total) computation binding {end, r, start, stride, tmp#10, tmp#11, tmp#12, tmp#13, tmp#4, tmp#9}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {end, r, start, stride, tmp#4}, break set = Everything, with resources {}
Types: Type variable 6 is bound to Just wybe.int
Types: Type variable 4 is bound to Just wybe.int
Types: Type variable 5 is bound to Just wybe.int
Types: Type variable 2 is bound to Just 1
Types: Type variable 1 is bound to Just wybe.int
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#4}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#4 @range:45:10, ?tmp#0)
Types: Mode checking foreign call {foreign llvm move(tmp#4 @range:45:10, ?tmp#0)}
Types:     with assigned semipure normal (total) computation binding {end, r, start, stride, tmp#4}, break set = Everything, with resources {}
Types: Mode check exp tmp#4
Types: Mode check exp resulted in tmp#4
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#4 @range:45:10
Types: Type variable 2 is bound to Just 1
Types: Type variable 1 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#4:wybe.int @range:45:10, ?tmp#0:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#0, tmp#4}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'size'
Types: Assigned by else branch: semipure normal (total) computation binding {end, r, start, stride, tmp#0, tmp#4}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {end, r, start, stride, tmp#0}, break set = Everything, with resources {}
Types: Type variable 6 is bound to Just wybe.int
Types: Type variable 4 is bound to Just wybe.int
Types: Type variable 5 is bound to Just wybe.int
Types: Type variable 0 is bound to Just wybe.int
Types: Now assigned = semipure normal (total) computation binding {end, r, start, stride, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0 @range:44:10, ?#result @range:42:5)}
Types:     with assigned semipure normal (total) computation binding {end, r, start, stride, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0 @range:44:10
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?#result @range:42:5
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(tmp#0:wybe.int @range:44:10, ?#result:wybe.int @range:42:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, end, r, start, stride, tmp#0}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'size'
Types: Mode checked body   : [{wybe.range.<1>range(?start:wybe.int @range:43:22, ?stride:wybe.int @range:43:30, ?end:wybe.int @range:43:39, r:wybe.range @range:43:11)} @range:43:11,{if {(   wybe.int.<0>signum(stride:wybe.int @range:44:17, ?tmp#1:wybe.int @range:44:10)
Types:         & wybe.int.<0>-(end:wybe.int @range:44:36, start:wybe.int @range:44:42, ?tmp#3:wybe.int @range:44:36)
Types:         & wybe.int.<0>signum(tmp#3:wybe.int, ?tmp#2:wybe.int @range:44:29)
Types:         & wybe.int.<0>~=(tmp#1:wybe.int, tmp#2:wybe.int))::
Types: 
Types:         foreign llvm move(0:wybe.int @range:44:52, ?tmp#0:wybe.int)
Types:     else::
Types:         if {wybe.int.<0><=(0:wybe.int @range:45:10, stride:wybe.int @range:45:16)::
Types: 
Types:             wybe.int.<0>-(end:wybe.int @range:45:27, start:wybe.int @range:45:33, ?tmp#8:wybe.int @range:45:27)
Types:             wybe.int.<0>-(tmp#8:wybe.int, 1:wybe.int @range:45:41, ?tmp#7:wybe.int @range:45:27)
Types:             wybe.int.<0>/(tmp#7:wybe.int, stride:wybe.int @range:45:46, ?tmp#6:wybe.int @range:45:26)
Types:             wybe.int.<0>+(tmp#6:wybe.int, 1:wybe.int @range:45:55, ?tmp#5:wybe.int @range:45:26)
Types:             foreign llvm move(tmp#5:wybe.int, ?tmp#4:wybe.int)
Types:         else::
Types:             wybe.int.<0>-(start:wybe.int @range:46:19, end:wybe.int @range:46:27, ?tmp#12:wybe.int @range:46:19)
Types:             wybe.int.<0>-(tmp#12:wybe.int, 1:wybe.int @range:46:33, ?tmp#11:wybe.int @range:46:19)
Types:             wybe.int.<3>-(stride:wybe.int @range:46:39, ?tmp#13:wybe.int @range:46:38)
Types:             wybe.int.<0>/(tmp#11:wybe.int, tmp#13:wybe.int, ?tmp#10:wybe.int @range:46:18)
Types:             wybe.int.<0>+(tmp#10:wybe.int, 1:wybe.int @range:46:48, ?tmp#9:wybe.int @range:46:18)
Types:             foreign llvm move(tmp#9:wybe.int, ?tmp#4:wybe.int)
Types: 
Types:         }
Types:    condition -> {end::wybe.int, r::wybe.range, start::wybe.int, stride::wybe.int}
Types:    then&else -> {end::wybe.int, r::wybe.range, start::wybe.int, stride::wybe.int, tmp#4::wybe.int}
Types:         foreign llvm move(tmp#4:wybe.int @range:45:10, ?tmp#0:wybe.int)
Types: 
Types:     }
Types:    condition -> {end::wybe.int, r::wybe.range, start::wybe.int, stride::wybe.int, tmp#1::wybe.int, tmp#2::wybe.int, tmp#3::wybe.int}
Types:    then&else -> {end::wybe.int, r::wybe.range, start::wybe.int, stride::wybe.int, tmp#0::wybe.int}} @range:44:10,{foreign llvm move(tmp#0:wybe.int @range:44:10, ?#result:wybe.int @range:42:5)} @range:42:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, end, r, start, stride, tmp#0}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of size:
Types: 
Types: size > public (0 calls)
Types: 4: size(r:wybe.range @range:42:14, ?#result:wybe.int @range:42:5):
Types:     wybe.range.<1>range(?start:wybe.int @range:43:22, ?stride:wybe.int @range:43:30, ?end:wybe.int @range:43:39, r:wybe.range @range:43:11)
Types:     if {(   wybe.int.<0>signum(stride:wybe.int @range:44:17, ?tmp#1:wybe.int @range:44:10)
Types:         & wybe.int.<0>-(end:wybe.int @range:44:36, start:wybe.int @range:44:42, ?tmp#3:wybe.int @range:44:36)
Types:         & wybe.int.<0>signum(tmp#3:wybe.int, ?tmp#2:wybe.int @range:44:29)
Types:         & wybe.int.<0>~=(tmp#1:wybe.int, tmp#2:wybe.int))::
Types: 
Types:         foreign llvm move(0:wybe.int @range:44:52, ?tmp#0:wybe.int)
Types:     else::
Types:         if {wybe.int.<0><=(0:wybe.int @range:45:10, stride:wybe.int @range:45:16)::
Types: 
Types:             wybe.int.<0>-(end:wybe.int @range:45:27, start:wybe.int @range:45:33, ?tmp#8:wybe.int @range:45:27)
Types:             wybe.int.<0>-(tmp#8:wybe.int, 1:wybe.int @range:45:41, ?tmp#7:wybe.int @range:45:27)
Types:             wybe.int.<0>/(tmp#7:wybe.int, stride:wybe.int @range:45:46, ?tmp#6:wybe.int @range:45:26)
Types:             wybe.int.<0>+(tmp#6:wybe.int, 1:wybe.int @range:45:55, ?tmp#5:wybe.int @range:45:26)
Types:             foreign llvm move(tmp#5:wybe.int, ?tmp#4:wybe.int)
Types:         else::
Types:             wybe.int.<0>-(start:wybe.int @range:46:19, end:wybe.int @range:46:27, ?tmp#12:wybe.int @range:46:19)
Types:             wybe.int.<0>-(tmp#12:wybe.int, 1:wybe.int @range:46:33, ?tmp#11:wybe.int @range:46:19)
Types:             wybe.int.<3>-(stride:wybe.int @range:46:39, ?tmp#13:wybe.int @range:46:38)
Types:             wybe.int.<0>/(tmp#11:wybe.int, tmp#13:wybe.int, ?tmp#10:wybe.int @range:46:18)
Types:             wybe.int.<0>+(tmp#10:wybe.int, 1:wybe.int @range:46:48, ?tmp#9:wybe.int @range:46:18)
Types:             foreign llvm move(tmp#9:wybe.int, ?tmp#4:wybe.int)
Types: 
Types:         }
Types:    condition -> {end::wybe.int, r::wybe.range, start::wybe.int, stride::wybe.int}
Types:    then&else -> {end::wybe.int, r::wybe.range, start::wybe.int, stride::wybe.int, tmp#4::wybe.int}
Types:         foreign llvm move(tmp#4:wybe.int @range:45:10, ?tmp#0:wybe.int)
Types: 
Types:     }
Types:    condition -> {end::wybe.int, r::wybe.range, start::wybe.int, stride::wybe.int, tmp#1::wybe.int, tmp#2::wybe.int, tmp#3::wybe.int}
Types:    then&else -> {end::wybe.int, r::wybe.range, start::wybe.int, stride::wybe.int, tmp#0::wybe.int}
Types:     foreign llvm move(tmp#0:wybe.int @range:44:10, ?#result:wybe.int @range:42:5)
Types: Type checking non-recursive proc wybe.range...
Types: ** Type checking decl of proc ..
Types: found 1 definition(s)
Types: Type checking ..
Types: ** Type checking ..: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         <=(start @range:39:27, end @range:39:37)
Types:         foreign llvm move(1 @range:39:44, ?tmp#1)
Types:         foreign llvm move(-1 @range:39:56, ?tmp#1)
Types:         construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)
Types:         foreign llvm move(tmp#0, ?#result @range:38:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","end","start","tmp#0","tmp#1"]
Types: Recording parameter types: start:wybe.int, end:wybe.int, ?#result:wybe.range
Types:     type of 'start' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable start type constrained to wybe.int
Types:     type of 'end' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable end type constrained to wybe.int
Types:     type of '#result' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #result type constrained to wybe.range
Types: Recording resource types: 
Types: Recording casts in {<=(start @range:39:27, end @range:39:37)}
Types: Recording casts in {foreign llvm move(1 @range:39:44, ?tmp#1)}
Types: Unifying move argument types 1 @range:39:44 and ?tmp#1
Types: Finding type of expr 1 @range:39:44
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1
Types:   Type = 0
Types: Type variable 0 is bound to Nothing
Types: Unifying types wybe.int (-> wybe.int) and 0 (-> 0)
Types:   Unification yields wybe.int
Types: Recording casts in {foreign llvm move(-1 @range:39:56, ?tmp#1)}
Types: Unifying move argument types -1 @range:39:56 and ?tmp#1
Types: Finding type of expr -1 @range:39:56
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Recording casts in {construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @range:38:5)}
Types: Unifying move argument types tmp#0 and ?#result @range:38:5
Types: Finding type of expr tmp#0
Types:   Type = 1
Types: Finding type of expr ?#result @range:38:5
Types:   Type = wybe.range
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: *** Before calls Typing {#result::wybe.range, end::wybe.int, start::wybe.int, tmp#0::1, tmp#1::0}; {0::wybe.int, 1::wybe.range} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {<=(start @range:39:27, end @range:39:37)} @range:39:27, typingInfos = [wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)} @range:39:5, typingInfos = [wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range)]}Typing {#result::wybe.range, end::wybe.int, start::wybe.int, tmp#0::1, tmp#1::0}; {0::wybe.int, 1::wybe.range} (with no errors)
Types: Type checking call {<=(start @range:39:27, end @range:39:37)} @range:39:27
Types: Candidate types:
Types:     wybe.int.<=<0>(wybe.int,wybe.int,?wybe.bool)
Types: Finding type of expr start @range:39:27
Types:   Type = wybe.int
Types: Finding type of expr end @range:39:37
Types:   Type = wybe.int
Types: Actual types: [wybe.int,wybe.int]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Valid types = [Typing {#result::wybe.range, end::wybe.int, start::wybe.int, tmp#0::1, tmp#1::0}; {0::wybe.int, 1::wybe.range} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, end::wybe.int, start::wybe.int, tmp#0::1, tmp#1::0}; {0::wybe.int, 1::wybe.range} (with no errors)
Types: Type checking call {construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)} @range:39:5
Types: Candidate types:
Types:     wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Finding type of expr start @range:39:15
Types:   Type = wybe.int
Types: Finding type of expr tmp#1 @range:39:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr end @range:39:62
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:39:5
Types: Type variable 1 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Actual types: [wybe.int,wybe.int,wybe.int,wybe.range]
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Valid types = [Typing {#result::wybe.range, end::wybe.int, start::wybe.int, tmp#0::1, tmp#1::0}; {0::wybe.int, 1::wybe.range} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.range, end::wybe.int, start::wybe.int, tmp#0::1, tmp#1::0}; {0::wybe.int, 1::wybe.range} (with no errors)
Types: Finding type of expr 1 @range:39:44
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr -1 @range:39:56
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call move(64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#0
Types: Type variable 1 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Finding type of expr ?#result @range:38:5
Types:   Type = wybe.range
Types: Type checking foreign llvm call move(address, address)
Types: Now mode checking proc ..
Types: bound vars: semipure normal (total) computation binding {end, start}, break set = Everything, with resources {}
Types: Mode check stmt if {<=(start @range:39:27, end @range:39:37)::
Types: 
Types:                     foreign llvm move(1 @range:39:44, ?tmp#1)
Types:                 else::
Types:                     foreign llvm move(-1 @range:39:56, ?tmp#1)
Types: 
Types:                 }
Types: Mode checking conditional {if {<=(start @range:39:27, end @range:39:37)::
Types: 
Types:         foreign llvm move(1 @range:39:44, ?tmp#1)
Types:     else::
Types:         foreign llvm move(-1 @range:39:56, ?tmp#1)
Types: 
Types:     }}
Types: Mode checking call   : {<=(start @range:39:27, end @range:39:37)}
Types:     with assigned    : semipure normal (total) computation binding {end, start}, break set = Everything, with resources {}
Types: Mode check exp start
Types: Mode check exp resulted in start
Types: Mode check exp end
Types: Mode check exp resulted in end
Types: Finding type of expr start @range:39:27
Types:   Type = wybe.int
Types: Finding type of expr end @range:39:37
Types:   Type = wybe.int
Types:     actual types     : [wybe.int,wybe.int]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing)]
Types: Matching types [wybe.int,wybe.int] with {test} wybe.int.<=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Type-correct modes   : [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, tmp#0::1, tmp#1::0}; {0::wybe.int, 1::wybe.range} (with no errors))]
Types: Possible mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, tmp#0::1, tmp#1::0}; {0::wybe.int, 1::wybe.range} (with no errors))]
Types: Exact mode matches: [({test} wybe.int.<=<0>(wybe.int,wybe.int),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, tmp#0::1, tmp#1::0}; {0::wybe.int, 1::wybe.range} (with no errors))]
Types: Finding type of expr start @range:39:27
Types:   Type = wybe.int
Types: Finding type of expr end @range:39:37
Types:   Type = wybe.int
Types: Finalising call    :  {wybe.int.<0><=(start:wybe.int @range:39:27, end:wybe.int @range:39:37)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "start"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.int.<0><=(start:wybe.int @range:39:27, end:wybe.int @range:39:37)}
Types: Generated extra stmts = []
Types: Mode check end of SemiDet proc '..'
Types: Assigned by test: semipure test computation binding {end, start}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(1 @range:39:44, ?tmp#1)
Types: Mode checking foreign call {foreign llvm move(1 @range:39:44, ?tmp#1)}
Types:     with assigned semipure normal (total) computation binding {end, start}, break set = Everything, with resources {}
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr 1 @range:39:44
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(1:wybe.int @range:39:44, ?tmp#1:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {end, start, tmp#1}, break set = Everything, with resources {}
Types: Mode check end of Det proc '..'
Types: Assigned by then branch: semipure normal (total) computation binding {end, start, tmp#1}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(-1 @range:39:56, ?tmp#1)
Types: Mode checking foreign call {foreign llvm move(-1 @range:39:56, ?tmp#1)}
Types:     with assigned semipure normal (total) computation binding {end, start}, break set = Everything, with resources {}
Types: Mode check exp -1
Types: Mode check exp resulted in -1
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr -1 @range:39:56
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,?wybe.int]
Types: New instr = {foreign llvm move(-1:wybe.int @range:39:56, ?tmp#1:wybe.int)}
Types: Now assigned = semipure normal (total) computation binding {end, start, tmp#1}, break set = Everything, with resources {}
Types: Mode check end of Det proc '..'
Types: Assigned by else branch: semipure normal (total) computation binding {end, start, tmp#1}, break set = Everything, with resources {}
Types: Assigned by conditional: semipure normal (total) computation binding {end, start, tmp#1}, break set = Everything, with resources {}
Types: Type variable 0 is bound to Just wybe.int
Types: Now assigned = semipure normal (total) computation binding {end, start, tmp#1}, break set = Everything, with resources {}
Types: Mode check stmt construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)
Types: Mode checking call   : {construct(start @range:39:15, tmp#1 @range:39:27, end @range:39:62, ?tmp#0 @range:39:5)}
Types:     with assigned    : semipure normal (total) computation binding {end, start, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp start
Types: Mode check exp resulted in start
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp end
Types: Mode check exp resulted in end
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr start @range:39:15
Types:   Type = wybe.int
Types: Finding type of expr tmp#1 @range:39:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr end @range:39:62
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:39:5
Types: Type variable 1 is bound to Just wybe.range
Types:   Type = wybe.range
Types:     actual types     : [wybe.int,wybe.int,wybe.int,wybe.range]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.int,wybe.int,wybe.int,wybe.range] with wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range)
Types: Call arity 4; proc arity 4 - 4
Types: Filling  0 optional arguments
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Unifying types wybe.range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Type-correct modes   : [(wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, tmp#0::1, tmp#1::0}; {0::wybe.int, 1::wybe.range} (with no errors))]
Types: Possible mode matches: [(wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, tmp#0::1, tmp#1::0}; {0::wybe.int, 1::wybe.range} (with no errors))]
Types: Exact mode matches: [(wybe.range.construct<0>(wybe.int,wybe.int,wybe.int,?wybe.range),Typing {#result::wybe.range, end::wybe.int, start::wybe.int, tmp#0::1, tmp#1::0}; {0::wybe.int, 1::wybe.range} (with no errors))]
Types: Finding type of expr start @range:39:15
Types:   Type = wybe.int
Types: Finding type of expr tmp#1 @range:39:27
Types: Type variable 0 is bound to Just wybe.int
Types:   Type = wybe.int
Types: Finding type of expr end @range:39:62
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0 @range:39:5
Types: Type variable 1 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Finalising call    :  {wybe.range.<0>construct(start:wybe.int @range:39:15, tmp#1:wybe.int @range:39:27, end:wybe.int @range:39:62, ?tmp#0:wybe.range @range:39:5)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"end", "start", "tmp#1"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.range.<0>construct(start:wybe.int @range:39:15, tmp#1:wybe.int @range:39:27, end:wybe.int @range:39:62, ?tmp#0:wybe.range @range:39:5)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '..'
Types: Now assigned = semipure normal (total) computation binding {end, start, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @range:38:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @range:38:5)}
Types:     with assigned semipure normal (total) computation binding {end, start, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 1 is bound to Just wybe.range
Types:   Type = wybe.range
Types: Finding type of expr ?#result @range:38:5
Types:   Type = wybe.range
Types:     types and modes = [wybe.range,?wybe.range]
Types: New instr = {foreign llvm move(tmp#0:wybe.range, ?#result:wybe.range @range:38:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, end, start, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Mode check end of Det proc '..'
Types: Mode checked body   : [{if {wybe.int.<0><=(start:wybe.int @range:39:27, end:wybe.int @range:39:37)::
Types: 
Types:         foreign llvm move(1:wybe.int @range:39:44, ?tmp#1:wybe.int)
Types:     else::
Types:         foreign llvm move(-1:wybe.int @range:39:56, ?tmp#1:wybe.int)
Types: 
Types:     }
Types:    condition -> {end::wybe.int, start::wybe.int}
Types:    then&else -> {end::wybe.int, start::wybe.int, tmp#1::wybe.int}} @range:39:27,{wybe.range.<0>construct(start:wybe.int @range:39:15, tmp#1:wybe.int @range:39:27, end:wybe.int @range:39:62, ?tmp#0:wybe.range @range:39:5)} @range:39:5,{foreign llvm move(tmp#0:wybe.range, ?#result:wybe.range @range:38:5)} @range:38:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, end, start, tmp#0, tmp#1}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of ..:
Types: 
Types: .. > public (0 calls)
Types: 4: ..(start:wybe.int @range:38:10, end:wybe.int @range:38:23, ?#result:wybe.range @range:38:5):
Types:     if {wybe.int.<0><=(start:wybe.int @range:39:27, end:wybe.int @range:39:37)::
Types: 
Types:         foreign llvm move(1:wybe.int @range:39:44, ?tmp#1:wybe.int)
Types:     else::
Types:         foreign llvm move(-1:wybe.int @range:39:56, ?tmp#1:wybe.int)
Types: 
Types:     }
Types:    condition -> {end::wybe.int, start::wybe.int}
Types:    then&else -> {end::wybe.int, start::wybe.int, tmp#1::wybe.int}
Types:     wybe.range.<0>construct(start:wybe.int @range:39:15, tmp#1:wybe.int @range:39:27, end:wybe.int @range:39:62, ?tmp#0:wybe.range @range:39:5)
Types:     foreign llvm move(tmp#0:wybe.range, ?#result:wybe.range @range:38:5)
======================================================================
AFTER TYPE CHECK:
 Module wybe
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : 
  imports         : public use wybe.array
                    public use wybe.bool
                    public use wybe.c_string
                    public use wybe.char
                    public use wybe.comparison
                    public use wybe.control
                    public use wybe.count
                    public use wybe.float
                    public use wybe.int
                    public use wybe.io
                    public use wybe.list
                    public use wybe.machine_word
                    public use wybe.memory_management
                    public use wybe.phantom
                    public use wybe.predicate
                    public use wybe.range
                    public use wybe.string
  resources       : 
  submodules      : wybe.array, wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.control, wybe.count, wybe.float, wybe.int, wybe.io, wybe.list, wybe.machine_word, wybe.memory_management, wybe.phantom, wybe.predicate, wybe.range, wybe.string
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.array(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.array.[]<0>
                    wybe.array.[]<1>
                    wybe.array.[|]<0>
                    wybe.array.array<0>
                    wybe.array.array<1>
                    wybe.array.inbounds<0>
                    wybe.array.unsafe_get<0>
                    wybe.array.unsafe_update<0>
  imports         : public use wybe.array.raw_array
                    use wybe.bool
                    use wybe.int
                    use wybe.list
                    use wybe.machine_word
  resources       : 
  submodules      : wybe.array.raw_array
  procs           : 

[] > public {test} (0 calls)
0: [](a:_(T) @array:67:21, idx:int @array:67:29, ?#result:T @array:67:5):
    inbounds(a @array:68:14, idx @array:68:17)
    unsafe_get(a @array:69:10, idx @array:69:23, ?tmp#0 @array:69:10)
    =(?x @array:69:6, tmp#0)
    foreign llvm move(x @array:67:42, ?#result @array:67:5)
[] > public {test} (0 calls)
1: [](!a:_(T) @array:81:22, idx:int @array:81:30, x:T @array:81:39):
    inbounds(a @array:82:14, idx @array:82:17)
    unsafe_update(!a @array:83:20, idx @array:83:23, x @array:83:28)


[|] > public {test} (0 calls)
0: [|](?head:T @array:51:23, ?tail:_(T) @array:51:32, a:_(T) @array:51:43):
    array(?length @array:52:12, ?data @array:52:21, a @array:52:29)
    >(length @array:53:6, 0 @array:53:15)
    word_size_bytes(?tmp#0 @array:54:34)
    foreign lpvm access(data @array:54:25, 0 @array:54:31, tmp#0, 0 @array:54:51, ?head @array:54:55)
    word_size_bytes(?tmp#1 @array:55:28)
    foreign llvm add(data @array:55:22, tmp#1, ?data @array:55:46)
    -(length @array:56:19, 1 @array:56:28, ?tmp#3 @array:56:19)
    array(tmp#3, data @array:56:31, ?tmp#2 @array:56:13)
    =(?tail @array:56:6, tmp#2)


array > public (0 calls)
0: array(x:T @array:18:15, len:int @array:18:20, ?#result:_(T) @array:18:5):
    word_size_bytes(?tmp#1 @array:19:19)
    *(len @array:19:13, tmp#1, ?tmp#0 @array:19:13)
    =(?size @array:19:6, tmp#0)
    foreign lpvm alloc(size @array:20:24, ?data @array:20:31)
    =(?offset @array:21:6, 0 @array:21:15)
    do {
        if {<(offset @array:23:15, size @array:23:24)::

            pass
        else::
            break

        }
        foreign lpvm mutate(data @array:24:29, ?data @array:24:36, offset @array:24:42, 1 @array:24:50, size @array:24:53, 0 @array:24:59, x @array:24:62)
        word_size_bytes(?tmp#2 @array:25:21)
        +=(!offset @array:25:10, tmp#2)
    }
    array(len @array:27:17, data @array:27:22, ?tmp#3 @array:27:11)
    =(?ar @array:27:6, tmp#3)
    foreign llvm move(ar @array:18:36, ?#result @array:18:5)
array > public (0 calls)
1: array(ls:list(T) @array:34:15, ?#result:_(T) @array:34:5):
    length(ls @array:35:19, ?tmp#0 @array:35:12)
    =(?len @array:35:6, tmp#0)
    word_size_bytes(?tmp#2 @array:36:19)
    *(len @array:36:13, tmp#2, ?tmp#1 @array:36:13)
    =(?size @array:36:6, tmp#1)
    foreign lpvm alloc(size @array:37:24, ?data @array:37:31)
    =(?offset @array:38:6, 0 @array:38:15)
    foreign llvm move(ls @array:39:15, ?tmp#3)
    do {
        if {[|](?x @array:39:10, ?tmp#3, tmp#3)::

            foreign lpvm mutate(data @array:40:29, ?data @array:40:36, offset @array:40:42, 1 @array:40:50, size @array:40:53, 0 @array:40:59, x @array:40:62)
            word_size_bytes(?tmp#4 @array:41:21)
            +=(!offset @array:41:10, tmp#4)
        else::
            break

        }
    }
    array(len @array:43:17, data @array:43:22, ?tmp#5 @array:43:11)
    =(?ar @array:43:6, tmp#5)
    foreign llvm move(ar @array:34:34, ?#result @array:34:5)


inbounds > public {test,inline} (0 calls)
0: inbounds(a:_(T) @array:60:33, idx:int @array:60:41):
    <=(0 @array:61:6, idx @array:61:12)
    length(a @array:62:12, ?tmp#0 @array:62:12)
    <(idx @array:62:6, tmp#0)


unsafe_get > public {inline} (0 calls)
0: unsafe_get(a:_(T) @array:75:29, idx:int @array:75:37, ?#result:T @array:75:5):
    raw_data(a @array:76:25, ?tmp#0 @array:76:25)
    word_size_bytes(?tmp#2 @array:76:43)
    *(idx @array:76:37, tmp#2, ?tmp#1 @array:76:37)
    word_size_bytes(?tmp#3 @array:76:60)
    foreign lpvm access(tmp#0, tmp#1, tmp#3, 0 @array:76:77, ?x @array:76:81)
    foreign llvm move(x @array:75:50, ?#result @array:75:5)


unsafe_update > public {inline} (0 calls)
0: unsafe_update(!a:_(T) @array:89:33, idx:int @array:89:41, x:T @array:89:50):
    raw_data(a @array:90:25, ?tmp#0 @array:90:25)
    word_size_bytes(?tmp#2 @array:90:50)
    *(idx @array:90:44, tmp#2, ?tmp#1 @array:90:44)
    length(a @array:91:44, ?tmp#4 @array:91:44)
    word_size_bytes(?tmp#5 @array:91:55)
    *(tmp#4, tmp#5, ?tmp#3 @array:91:44)
    foreign lpvm mutate(tmp#0, ?data @array:90:38, tmp#1, 0 @array:90:67, tmp#3, 0 @array:91:72, x @array:91:75)
    raw_data(!a @array:92:6, data @array:92:19)

LLVM code       : None

--------------------------------------------------
 Module wybe.array.raw_array(T)
  representation  : address
  public submods  : 
  public resources: 
  public procs    : 
  imports         : use wybe
                    use wybe.array
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.bool
  representation  : 1 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.bool.&&<0>
                    wybe.bool.&=<0>
                    wybe.bool.=<0>
                    wybe.bool.^=<0>
                    wybe.bool.^^<0>
                    wybe.bool.false<0>
                    wybe.bool.print<0>
                    wybe.bool.println<0>
                    wybe.bool.succeed<0>
                    wybe.bool.true<0>
                    wybe.bool.|=<0>
                    wybe.bool.||<0>
                    wybe.bool.~<0>
                    wybe.bool.~=<0>
  imports         : use wybe.c_string
                    use wybe.io
  resources       : 
  procs           : 

&& > public {inline} (1 calls)
0: wybe.bool.&&<0>
&&(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:13:27


&= > public {inline} (0 calls)
0: wybe.bool.&=<0>
&=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:13:27


= > public {inline} (0 calls)
0: wybe.bool.=<0>
=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:37:26


^= > public {inline} (0 calls)
0: wybe.bool.^=<0>
^=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:25:27


^^ > public {inline} (1 calls)
0: wybe.bool.^^<0>
^^(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:25:27


false > public {inline} (0 calls)
0: wybe.bool.false<0>
false(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.bool, ?#result##0:wybe.bool)


print > public (1 calls)
0: wybe.bool.print<0>
print(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    case ~x##0:wybe.bool of
    0:
        wybe.c_string.print<0>(c"false":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #1 @bool:47:31

    1:
        wybe.c_string.print<0>(c"true":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:47:31



println > public {inline} (0 calls)
0: wybe.bool.println<0>
println(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.bool.print<0>(~x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:49:33
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#0##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~tmp#0##0:wybe.phantom, ?tmp#1##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#1##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


succeed > public {inline} (0 calls)
0: wybe.bool.succeed<0>
succeed()<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []


true > public {inline} (1 calls)
0: wybe.bool.true<0>
true(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.bool, ?#result##0:wybe.bool)


|= > public {inline} (0 calls)
0: wybe.bool.|=<0>
|=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:19:27


|| > public {inline} (1 calls)
0: wybe.bool.||<0>
||(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:19:27


~ > public {inline} (0 calls)
0: wybe.bool.~<0>
~(p##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, 1:wybe.bool, ?#result##0:wybe.bool) @bool:31:20


~= > public {inline} (0 calls)
0: wybe.bool.~=<0>
~=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:38:27

LLVM code       : None

--------------------------------------------------
 Module wybe.c_string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.c_string.<<0>
                    wybe.c_string.<=<0>
                    wybe.c_string.=<0>
                    wybe.c_string.><0>
                    wybe.c_string.>=<0>
                    wybe.c_string.[]<0>
                    wybe.c_string.[|]<0>
                    wybe.c_string.length<0>
                    wybe.c_string.print<0>
                    wybe.c_string.println<0>
                    wybe.c_string.read<0>
                    wybe.c_string.unsafe_c_string_index<0>
                    wybe.c_string.~=<0>
  imports         : use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.c_string.<<0>
<(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:12:29
    wybe.int.<<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:12:29


<= > public {inline} (0 calls)
0: wybe.c_string.<=<0>
<=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:13:30
    wybe.int.<=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:13:30


= > public {inline} (0 calls)
0: wybe.c_string.=<0>
=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:10:29
    wybe.int.=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:10:29


> > public {inline} (0 calls)
0: wybe.c_string.><0>
>(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:14:29
    wybe.int.><0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:14:29


>= > public {inline} (0 calls)
0: wybe.c_string.>=<0>
>=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:15:30
    wybe.int.>=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:15:30


[] > public (0 calls)
0: wybe.c_string.[]<0>
[](str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, idx##0:wybe.int, ?tmp#2##0:wybe.bool) #0 @c_string:27:6
    case ~tmp#2##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        foreign c strlen(str##0:wybe.c_string, ?tmp#0##0:wybe.int) @c_string:17:29
        wybe.int.<<0>(idx##0:wybe.int, ~tmp#0##0:wybe.int, ?tmp#3##0:wybe.bool) #2 @c_string:28:6
        case ~tmp#3##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




[|] > public (0 calls)
0: wybe.c_string.[|]<0>
[|](?head##0:wybe.char, ?tail##0:wybe.c_string, str##0:wybe.c_string, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(str##0:wybe.c_string, 0:wybe.int, 0:wybe.int, 0:wybe.int, ?head##0:wybe.char) @c_string:20:5
    foreign llvm icmp_ne(head##0:wybe.char, '\NUL':wybe.char, ?not_done##0:wybe.bool) @c_string:21:5
    foreign llvm icmp_eq(~not_done##0:wybe.bool, 1:wybe.bool, ?tmp#1##0:wybe.bool) @bool:37:26
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.c_string, ?tail##0:wybe.c_string)

    1:
        foreign llvm add(~str##0:wybe.c_string, 1:wybe.int, ?tail##0:wybe.c_string) @c_string:23:5
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



length > public {inline} (3 calls)
0: wybe.c_string.length<0>
length(str##0:wybe.c_string, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strlen(~str##0:wybe.c_string, ?#result##0:wybe.int) @c_string:17:29


print > public {inline} (1 calls)
0: wybe.c_string.print<0>
print(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:35:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:35:30


println > public {inline} (0 calls)
0: wybe.c_string.println<0>
println(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @c_string:35:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.c_string.read<0>
read(?x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:39:30
    foreign c read_line(?x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:39:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:39:30


unsafe_c_string_index > public {inline} (1 calls)
0: wybe.c_string.unsafe_c_string_index<0>
unsafe_c_string_index(str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7


~= > public {inline} (0 calls)
0: wybe.c_string.~=<0>
~=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:11:30
    wybe.int.~=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.char
  representation  : 8 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.char.<<0>
                    wybe.char.<=<0>
                    wybe.char.<=><0>
                    wybe.char.=<0>
                    wybe.char.><0>
                    wybe.char.>=<0>
                    wybe.char.chr<0>
                    wybe.char.ord<0>
                    wybe.char.print<0>
                    wybe.char.println<0>
                    wybe.char.read<0>
                    wybe.char.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (4 calls)
0: wybe.char.<<0>
<(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:17:29


<= > public {inline} (0 calls)
0: wybe.char.<=<0>
<=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:18:30


<=> > public (0 calls)
0: wybe.char.<=><0>
<=>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.char, y##0:wybe.char, ?tmp#6##0:wybe.bool) @char:17:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?tmp#5##0:wybe.bool) @char:13:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5



= > public {inline} (2 calls)
0: wybe.char.=<0>
=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:13:29


> > public {inline} (0 calls)
0: wybe.char.><0>
>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:19:29


>= > public {inline} (0 calls)
0: wybe.char.>=<0>
>=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:20:30


chr > public (0 calls)
0: wybe.char.chr<0>
chr(i##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, i##0:wybe.int, ?tmp#1##0:wybe.bool) #0 @char:33:60
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        wybe.int.<=<0>(i##0:wybe.int, 255:wybe.int, ?tmp#2##0:wybe.bool) #1 @char:33:70
        case ~tmp#2##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm cast(~i##0:wybe.int, ?#result##0:wybe.char) @char:33:31
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




ord > public {inline} (0 calls)
0: wybe.char.ord<0>
ord(c##0:wybe.char, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(~c##0:wybe.char, ?#result##0:wybe.int) @char:30:24


print > public {inline} (1 calls)
0: wybe.char.print<0>
print(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:37:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:37:30


println > public {inline} (0 calls)
0: wybe.char.println<0>
println(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @char:37:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.char.read<0>
read(?x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:41:30
    foreign c read_char(?x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:41:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:41:30


~= > public {inline} (0 calls)
0: wybe.char.~=<0>
~=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:14:30

LLVM code       : None

--------------------------------------------------
 Module wybe.comparison
  representation  : 2 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.comparison.<<0>
                    wybe.comparison.<=<0>
                    wybe.comparison.=<0>
                    wybe.comparison.><0>
                    wybe.comparison.>=<0>
                    wybe.comparison.equal<0>
                    wybe.comparison.greater<0>
                    wybe.comparison.lesser<0>
                    wybe.comparison.~=<0>
  imports         : use wybe.bool
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.comparison.<<0>
<(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:12:29


<= > public {inline} (0 calls)
0: wybe.comparison.<=<0>
<=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:13:30


= > public {inline} (0 calls)
0: wybe.comparison.=<0>
=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:10:29


> > public {inline} (0 calls)
0: wybe.comparison.><0>
>(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:14:29


>= > public {inline} (0 calls)
0: wybe.comparison.>=<0>
>=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:15:30


equal > public {inline} (0 calls)
0: wybe.comparison.equal<0>
equal(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison)


greater > public {inline} (0 calls)
0: wybe.comparison.greater<0>
greater(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison)


lesser > public {inline} (0 calls)
0: wybe.comparison.lesser<0>
lesser(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison)


~= > public {inline} (0 calls)
0: wybe.comparison.~=<0>
~=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.control
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.control.assert<0>
                    wybe.control.error<0>
                    wybe.control.error<1>
                    wybe.control.exit<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.int
                    use wybe.string
  resources       : 
  procs           : 

assert > public {semipure} (0 calls)
0: assert(condition:bool @control:26:27) use call_source_location:
    if {~(condition @control:27:11)::

        !error(c"assertion failed" @control:27:31)
    else::
        pass

    }


error > public {terminal,semipure} (0 calls)
0: error(message:string @control:17:35) use call_source_location:
    c_string(message @control:18:77, ?tmp#0 @control:18:68)
    foreign c {terminal,semipure} error_exit(call_source_location @control:18:46, tmp#0)
error > public {terminal,semipure} (0 calls)
1: error(message:c_string @control:21:35) use call_source_location:
    foreign c {terminal,semipure} error_exit(call_source_location @control:22:46, message @control:22:68)


exit > public {terminal,semipure} (0 calls)
0: exit(code:int @control:10:34):
    foreign c {terminal,semipure} exit(code @control:11:40)

LLVM code       : None

--------------------------------------------------
 Module wybe.count
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.count.%<0>
                    wybe.count.%=<0>
                    wybe.count.*<0>
                    wybe.count.*=<0>
                    wybe.count.+<0>
                    wybe.count.+<1>
                    wybe.count.+<2>
                    wybe.count.+=<0>
                    wybe.count.-<0>
                    wybe.count.-<1>
                    wybe.count.-<2>
                    wybe.count.-=<0>
                    wybe.count./<0>
                    wybe.count./=<0>
                    wybe.count.<<0>
                    wybe.count.<=<0>
                    wybe.count.<=><0>
                    wybe.count.=<0>
                    wybe.count.><0>
                    wybe.count.>=<0>
                    wybe.count.decr<0>
                    wybe.count.incr<0>
                    wybe.count.max<0>
                    wybe.count.min<0>
                    wybe.count.print<0>
                    wybe.count.println<0>
                    wybe.count.read<0>
                    wybe.count.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.count.%<0>
%(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:51:25


%= > public {inline} (0 calls)
0: wybe.count.%=<0>
%=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:51:25


* > public {inline} (1 calls)
0: wybe.count.*<0>
*(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:39:25


*= > public {inline} (0 calls)
0: wybe.count.*=<0>
*=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:39:25


+ > public {inline} (2 calls)
0: wybe.count.+<0>
+(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:15:25
+ > public (0 calls)
1: wybe.count.+<1>
+(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(y##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?x##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~y##0:wybe.count, ?x##0:wybe.count) @count:18:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

+ > public (0 calls)
2: wybe.count.+<2>
+(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?y##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:22:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



+= > public {inline} (0 calls)
0: wybe.count.+=<0>
+=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:15:25


- > public (6 calls)
0: wybe.count.-<0>
-(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?#result##0:wybe.count)

    1:
        foreign llvm sub(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:31:35
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

- > public {inline} (0 calls)
1: wybe.count.-<1>
-(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.count, ~z##0:wybe.count, ?x##0:wybe.count) @count:32:42
- > public {inline} (0 calls)
2: wybe.count.-<2>
-(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:33:42


-= > public (0 calls)
0: wybe.count.-=<0>
-=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, ~y##0:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:36:41
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:36:37
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



/ > public {inline} (1 calls)
0: wybe.count./<0>
/(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:45:25


/= > public {inline} (0 calls)
0: wybe.count./=<0>
/=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:45:25


< > public {inline} (4 calls)
0: wybe.count.<<0>
<(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:64:29


<= > public {inline} (3 calls)
0: wybe.count.<=<0>
<=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:65:30


<=> > public (0 calls)
0: wybe.count.<=><0>
<=>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.count, y##0:wybe.count, ?tmp#6##0:wybe.bool) @count:64:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?tmp#5##0:wybe.bool) @count:60:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5



= > public {inline} (2 calls)
0: wybe.count.=<0>
=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:60:29


> > public {inline} (0 calls)
0: wybe.count.><0>
>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:66:29


>= > public {inline} (12 calls)
0: wybe.count.>=<0>
>=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:67:30


decr > public (0 calls)
0: wybe.count.decr<0>
decr(x##0:wybe.count, ?x##1:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, 1:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:84:37
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:84:33
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



incr > public {inline} (0 calls)
0: wybe.count.incr<0>
incr(x##0:wybe.count, ?x##1:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, 1:wybe.count, ?x##1:wybe.count) @count:15:25


max > public (0 calls)
0: wybe.count.max<0>
max(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:75:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:75:5



min > public (0 calls)
0: wybe.count.min<0>
min(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:65:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:74:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:74:5



print > public {inline} (1 calls)
0: wybe.count.print<0>
print(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:88:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:88:30


println > public {inline} (0 calls)
0: wybe.count.println<0>
println(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @count:88:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.count.read<0>
read(?x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:92:30
    foreign c read_count(?x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:92:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:92:30


~= > public {inline} (0 calls)
0: wybe.count.~=<0>
~=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:61:30

LLVM code       : None

--------------------------------------------------
 Module wybe.float
  representation  : 64 bit float
  public submods  : 
  public resources: 
  public procs    : wybe.float.*<0>
                    wybe.float.**<0>
                    wybe.float.*=<0>
                    wybe.float.+<0>
                    wybe.float.+<1>
                    wybe.float.+<2>
                    wybe.float.+=<0>
                    wybe.float.-<0>
                    wybe.float.-<1>
                    wybe.float.-<2>
                    wybe.float.-<3>
                    wybe.float.-<4>
                    wybe.float.-=<0>
                    wybe.float./<0>
                    wybe.float./=<0>
                    wybe.float.<<0>
                    wybe.float.<=<0>
                    wybe.float.<=><0>
                    wybe.float.=<0>
                    wybe.float.><0>
                    wybe.float.>=<0>
                    wybe.float.abs<0>
                    wybe.float.ceil<0>
                    wybe.float.cos<0>
                    wybe.float.e<0>
                    wybe.float.exp<0>
                    wybe.float.floor<0>
                    wybe.float.iceil<0>
                    wybe.float.ifloor<0>
                    wybe.float.iround<0>
                    wybe.float.log<0>
                    wybe.float.log10<0>
                    wybe.float.log2<0>
                    wybe.float.max<0>
                    wybe.float.min<0>
                    wybe.float.pi<0>
                    wybe.float.power<0>
                    wybe.float.print<0>
                    wybe.float.println<0>
                    wybe.float.read<0>
                    wybe.float.round<0>
                    wybe.float.sin<0>
                    wybe.float.sqrt<0>
                    wybe.float.square<0>
                    wybe.float.tan<0>
                    wybe.float.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

* > public {inline} (1 calls)
0: wybe.float.*<0>
*(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:45:25


** > public {inline} (0 calls)
0: wybe.float.**<0>
**(x##0:wybe.float, n##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.pow.f64(~x##0:wybe.float, ~n##0:wybe.float, ?#result##0:wybe.float) @float:112:27


*= > public {inline} (0 calls)
0: wybe.float.*=<0>
*=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:45:25


+ > public {inline} (1 calls)
0: wybe.float.+<0>
+(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:23:27
+ > public {inline} (0 calls)
1: wybe.float.+<1>
+(?x##0:wybe.float, y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:24:43
+ > public {inline} (0 calls)
2: wybe.float.+<2>
+(x##0:wybe.float, ?y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~x##0:wybe.float, ?y##0:wybe.float) @float:25:43


+= > public {inline} (0 calls)
0: wybe.float.+=<0>
+=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:23:27


- > public {inline} (1 calls)
0: wybe.float.-<0>
-(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:32:27
- > public {inline} (0 calls)
1: wybe.float.-<1>
-(?x##0:wybe.float, y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~z##0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:33:43
- > public {inline} (0 calls)
2: wybe.float.-<2>
-(x##0:wybe.float, ?y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~x##0:wybe.float, ?y##0:wybe.float) @float:34:43
- > public {inline} (0 calls)
3: wybe.float.-<3>
-(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(0.0:wybe.float, ~x##0:wybe.float, ?#result##0:wybe.float) @float:38:21
- > public {inline} (0 calls)
4: wybe.float.-<4>
-(?x##0:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(0.0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:39:37


-= > public {inline} (0 calls)
0: wybe.float.-=<0>
-=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:32:27


/ > public {inline} (2 calls)
0: wybe.float./<0>
/(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fdiv(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:51:25


/= > public {inline} (0 calls)
0: wybe.float./=<0>
/=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fdiv(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:51:25


< > public {inline} (4 calls)
0: wybe.float.<<0>
<(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_slt(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:70:29


<= > public {inline} (0 calls)
0: wybe.float.<=<0>
<=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sle(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:71:30


<=> > public (0 calls)
0: wybe.float.<=><0>
<=>(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_slt(x##0:wybe.float, y##0:wybe.float, ?tmp#6##0:wybe.bool) @float:70:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm fcmp_eq(~x##0:wybe.float, ~y##0:wybe.float, ?tmp#5##0:wybe.bool) @float:66:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5



= > public {inline} (2 calls)
0: wybe.float.=<0>
=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_eq(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:66:29


> > public {inline} (0 calls)
0: wybe.float.><0>
>(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sgt(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:72:29


>= > public {inline} (0 calls)
0: wybe.float.>=<0>
>=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sge(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:73:30


abs > public {inline} (0 calls)
0: wybe.float.abs<0>
abs(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.fabs.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:60:22


ceil > public {inline} (1 calls)
0: wybe.float.ceil<0>
ceil(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.ceil.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:87:23


cos > public {inline} (0 calls)
0: wybe.float.cos<0>
cos(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.cos.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:116:22


e > public {inline} (0 calls)
0: wybe.float.e<0>
e(?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2.7182818284590455:wybe.float, ?#result##0:wybe.float) @float:16:5


exp > public {inline} (0 calls)
0: wybe.float.exp<0>
exp(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.exp.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:120:22


floor > public {inline} (1 calls)
0: wybe.float.floor<0>
floor(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.floor.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:90:24


iceil > public {inline} (0 calls)
0: wybe.float.iceil<0>
iceil(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.ceil.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:87:23
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:99:26


ifloor > public {inline} (0 calls)
0: wybe.float.ifloor<0>
ifloor(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.floor.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:90:24
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:102:27


iround > public {inline} (0 calls)
0: wybe.float.iround<0>
iround(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.round.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:93:24
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:96:27


log > public {inline} (0 calls)
0: wybe.float.log<0>
log(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:123:22


log10 > public {inline} (0 calls)
0: wybe.float.log10<0>
log10(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log10.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:126:24


log2 > public {inline} (0 calls)
0: wybe.float.log2<0>
log2(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log2.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:129:23


max > public {inline} (0 calls)
0: wybe.float.max<0>
max(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.maxnum.f64(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:81:27


min > public {inline} (0 calls)
0: wybe.float.min<0>
min(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.minnum.f64(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:80:27


pi > public {inline} (0 calls)
0: wybe.float.pi<0>
pi(?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(3.141592653589793:wybe.float, ?#result##0:wybe.float) @float:13:5


power > public {inline} (0 calls)
0: wybe.float.power<0>
power(x##0:wybe.float, n##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.pow.f64(~x##0:wybe.float, ~n##0:wybe.float, ?#result##0:wybe.float) @float:111:28


print > public {inline} (1 calls)
0: wybe.float.print<0>
print(x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @float:133:30
    foreign c print_float(~x##0:wybe.float, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @float:133:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @float:133:30


println > public {inline} (0 calls)
0: wybe.float.println<0>
println(x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @float:133:30
    foreign c print_float(~x##0:wybe.float, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @float:133:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.float.read<0>
read(?x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @float:137:30
    foreign c read_float(?x##0:wybe.float, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @float:137:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @float:137:30


round > public {inline} (1 calls)
0: wybe.float.round<0>
round(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.round.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:93:24


sin > public {inline} (0 calls)
0: wybe.float.sin<0>
sin(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sin.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:115:22


sqrt > public {inline} (0 calls)
0: wybe.float.sqrt<0>
sqrt(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sqrt.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:108:23


square > public {inline} (0 calls)
0: wybe.float.square<0>
square(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~x##0:wybe.float, ?#result##0:wybe.float) @float:57:25


tan > public {inline} (0 calls)
0: wybe.float.tan<0>
tan(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sin.f64(x##0:wybe.float, ?tmp#1##0:wybe.float) @float:117:22
    foreign c llvm.cos.f64(~x##0:wybe.float, ?tmp#2##0:wybe.float) @float:117:52
    foreign llvm fdiv(~tmp#1##0:wybe.float, ~tmp#2##0:wybe.float, ?#result##0:wybe.float) @float:51:25


~= > public {inline} (0 calls)
0: wybe.float.~=<0>
~=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_ne(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:67:30

LLVM code       : None

--------------------------------------------------
 Module wybe.int
  representation  : 64 bit signed
  public submods  : 
  public resources: 
  public procs    : wybe.int.%<0>
                    wybe.int.%=<0>
                    wybe.int.*<0>
                    wybe.int.*=<0>
                    wybe.int.+<0>
                    wybe.int.+<1>
                    wybe.int.+<2>
                    wybe.int.+=<0>
                    wybe.int.-<0>
                    wybe.int.-<1>
                    wybe.int.-<2>
                    wybe.int.-<3>
                    wybe.int.-<4>
                    wybe.int.-=<0>
                    wybe.int./<0>
                    wybe.int./=<0>
                    wybe.int.<<0>
                    wybe.int.<<<0>
                    wybe.int.<<=<0>
                    wybe.int.<=<0>
                    wybe.int.<=><0>
                    wybe.int.=<0>
                    wybe.int.><0>
                    wybe.int.>=<0>
                    wybe.int.>><0>
                    wybe.int.>>=<0>
                    wybe.int.decr<0>
                    wybe.int.incr<0>
                    wybe.int.logical_bitshift<0>
                    wybe.int.logical_bitshift<1>
                    wybe.int.max<0>
                    wybe.int.min<0>
                    wybe.int.power<0>
                    wybe.int.print<0>
                    wybe.int.println<0>
                    wybe.int.read<0>
                    wybe.int.signum<0>
                    wybe.int.sqrt<0>
                    wybe.int.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.int.%<0>
%(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:50:25


%= > public {inline} (0 calls)
0: wybe.int.%=<0>
%=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:50:25


* > public {inline} (1 calls)
0: wybe.int.*<0>
*(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:38:25


*= > public {inline} (0 calls)
0: wybe.int.*=<0>
*=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:38:25


+ > public {inline} (2 calls)
0: wybe.int.+<0>
+(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:16:27
+ > public {inline} (0 calls)
1: wybe.int.+<1>
+(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:17:43
+ > public {inline} (0 calls)
2: wybe.int.+<2>
+(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:18:43


+= > public {inline} (0 calls)
0: wybe.int.+=<0>
+=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:16:27


- > public {inline} (2 calls)
0: wybe.int.-<0>
-(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:25:27
- > public {inline} (0 calls)
1: wybe.int.-<1>
-(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.int, ~z##0:wybe.int, ?x##0:wybe.int) @int:26:43
- > public {inline} (0 calls)
2: wybe.int.-<2>
-(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:27:43
- > public {inline} (0 calls)
3: wybe.int.-<3>
-(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~x##0:wybe.int, ?#result##0:wybe.int) @int:31:21
- > public {inline} (0 calls)
4: wybe.int.-<4>
-(?x##0:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:32:37


-= > public {inline} (0 calls)
0: wybe.int.-=<0>
-=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:25:27


/ > public {inline} (1 calls)
0: wybe.int./<0>
/(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:44:25


/= > public {inline} (0 calls)
0: wybe.int./=<0>
/=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:44:25


< > public {inline} (4 calls)
0: wybe.int.<<0>
<(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:87:29


<< > public {inline} (1 calls)
0: wybe.int.<<<0>
<<(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:56:27


<<= > public {inline} (0 calls)
0: wybe.int.<<=<0>
<<=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:56:27


<= > public {inline} (3 calls)
0: wybe.int.<=<0>
<=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:88:30


<=> > public (0 calls)
0: wybe.int.<=><0>
<=>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(x##0:wybe.int, y##0:wybe.int, ?tmp#6##0:wybe.bool) @int:87:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?tmp#5##0:wybe.bool) @int:83:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5



= > public {inline} (2 calls)
0: wybe.int.=<0>
=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:83:29


> > public {inline} (0 calls)
0: wybe.int.><0>
>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sgt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:89:29


>= > public {inline} (3 calls)
0: wybe.int.>=<0>
>=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:90:30


>> > public {inline} (1 calls)
0: wybe.int.>><0>
>>(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:65:27


>>= > public {inline} (0 calls)
0: wybe.int.>>=<0>
>>=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:65:27


decr > public {inline} (0 calls)
0: wybe.int.decr<0>
decr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:25:27


incr > public {inline} (0 calls)
0: wybe.int.incr<0>
incr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:16:27


logical_bitshift > public {inline} (1 calls)
0: wybe.int.logical_bitshift<0>
logical_bitshift(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:74:40
logical_bitshift > public {inline} (0 calls)
1: wybe.int.logical_bitshift<1>
logical_bitshift(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:74:40


max > public (0 calls)
0: wybe.int.max<0>
max(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:90:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:98:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:98:5



min > public (0 calls)
0: wybe.int.min<0>
min(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:88:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:97:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:97:5



power > public {inline} (0 calls)
0: wybe.int.power<0>
power(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c ipow(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:107:29


print > public {inline} (1 calls)
0: wybe.int.print<0>
print(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:119:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:119:30


println > public {inline} (0 calls)
0: wybe.int.println<0>
println(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @int:119:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.int.read<0>
read(?x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:123:30
    foreign c read_int(?x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:123:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:123:30


signum > public {inline} (0 calls)
0: wybe.int.signum<0>
signum(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c signum(~x##0:wybe.int, ?#result##0:wybe.int) @int:114:25


sqrt > public {inline} (0 calls)
0: wybe.int.sqrt<0>
sqrt(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c isqrt(~x##0:wybe.int, ?#result##0:wybe.int) @int:104:23


~= > public {inline} (0 calls)
0: wybe.int.~=<0>
~=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:84:30

LLVM code       : None

--------------------------------------------------
 Module wybe.io
  representation  : (not a type)
  public submods  : phantom -> wybe.phantom
  public resources: io: wybe.io.io
  public procs    : wybe.io.<0>
                    wybe.io.eof<0>
                    wybe.io.nl<0>
  imports         : use wybe.char
                    public use wybe.phantom
  resources       : io: fromList [(wybe.io.io,wybe.phantom = 0:phantom @io:13:27 @io:13:5)]
  procs           : 

module top-level code > public {inline,semipure} (0 calls)
0: wybe.io.<0>
()<{}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm store(0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:13:5


eof > public {inline} (0 calls)
0: wybe.io.eof<0>
eof(?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(-1:wybe.int, ?#result##0:wybe.char) @io:20:29


nl > public {inline} (0 calls)
0: wybe.io.nl<0>
nl()<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @io:17:31
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31

LLVM code       : None

--------------------------------------------------
 Module wybe.list(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.list.,,<0>
                    wybe.list.[]<0>
                    wybe.list.all<0>
                    wybe.list.any<0>
                    wybe.list.empty<0>
                    wybe.list.filter<0>
                    wybe.list.foldl<0>
                    wybe.list.foldr<0>
                    wybe.list.length<0>
                    wybe.list.list<0>
                    wybe.list.map<0>
                    wybe.list.map<1>
                    wybe.list.map<2>
                    wybe.list.print<0>
                    wybe.list.println<0>
                    wybe.list.reverse<0>
  imports         : use wybe.array
                    use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
                    use wybe.machine_word
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_(T) @list:20:10, y:_(T) @list:20:20, ?#result:_(T) @list:20:5):
    if {[|](?h @list:21:16, ?t @list:21:21, x @list:21:10)::

        ,,(t @list:21:32, y @list:21:37, ?tmp#2 @list:21:32)
        [|](h @list:21:28, tmp#2, ?tmp#1 @list:21:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(y @list:21:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:21:10, ?#result @list:20:5)


[] > public {test} (0 calls)
0: [](xs:_(T) @list:31:21, idx:int @list:31:30, ?#result:T @list:31:5):
    >=(idx @list:32:5, 0 @list:32:13)
    index1(xs @list:33:17, idx @list:33:21, ?tmp#0 @list:33:10)
    =(?x @list:33:6, tmp#0)
    foreign llvm move(x @list:31:43, ?#result @list:31:5)


all > public {test} (0 calls)
0: all(p:{test}(T) @list:61:20, xs:_(T) @list:61:33):
    foreign llvm move(xs @list:62:15, ?tmp#0)
    do {
        if {[|](?x @list:62:10, ?tmp#0, tmp#0)::

            p(x @list:63:11)
        else::
            break

        }
    }


any > public {test} (0 calls)
0: any(p:{test}(T) @list:69:20, xs:_(T) @list:69:33):
    [|](?x @list:70:7, ?xs @list:70:12, xs @list:70:18)
    (   p(x @list:71:8)
    | any(p @list:71:17, xs @list:71:20))


empty > public {test} (0 calls)
0: empty(xs:_(T) @list:15:22):
    if {[|](?tmp#0 @list:16:11, ?tmp#1 @list:16:15, xs @list:16:20)::

        fail
    else::
        pass

    }


filter > public (0 calls)
0: filter(p:{test}(T) @list:95:16, !xs:_(T) @list:95:30):
    [](?tmp#0 @list:96:12)
    =(?out @list:96:6, tmp#0)
    foreign llvm move(xs @list:97:15, ?tmp#1)
    do {
        if {[|](?x @list:97:10, ?tmp#1, tmp#1)::

            if {p(x @list:98:16)::

                [|](x @list:98:30, out @list:98:34, ?tmp#2 @list:98:29)
                =(?out @list:98:23, tmp#2)
            else::
                pass

            }
        else::
            break

        }
    }
    reverse(out @list:100:19, ?tmp#3 @list:100:11)
    =(?as @list:100:6, tmp#3)


foldl > public (0 calls)
0: foldl(f:(A, !B) @list:77:15, as:_(A) @list:77:26, !b:B @list:77:36):
    foreign llvm move(as @list:78:15, ?tmp#0)
    do {
        if {[|](?a @list:78:10, ?tmp#0, tmp#0)::

            f(a @list:79:11, !b @list:79:15)
        else::
            break

        }
    }


foldr > public (0 calls)
0: foldr(f:(A, !B) @list:86:15, as:_(A) @list:86:26, !b:B @list:86:36):
    if {[|](?a @list:87:12, ?as @list:87:17, as @list:87:23)::

        foldr(f @list:88:15, as @list:88:18, !b @list:88:23)
        f(a @list:89:11, !b @list:89:15)
    else::
        pass

    }


index1 > {test} (0 calls)
0: index1(xs:_(T) @list:148:19, idx:int @list:148:28, ?#result:T @list:148:1):
    [|](?x @list:149:7, ?xs @list:149:12, xs @list:149:18)
    (   =(idx @list:150:6, 0 @list:150:12)
    | (   -(idx @list:150:27, 1 @list:150:33, ?tmp#0 @list:150:27)
        & index1(xs @list:150:23, tmp#0, ?x @list:150:37)))
    foreign llvm move(x @list:148:41, ?#result @list:148:1)


length > public (0 calls)
0: length(x:_(T) @list:24:16, ?#result:int @list:24:5):
    length1(x @list:24:38, 0 @list:24:41, ?tmp#0 @list:24:30)
    foreign llvm move(tmp#0, ?#result @list:24:5)


length1 > (0 calls)
0: length1(x:_(T) @list:140:13, acc:int @list:140:21, ?#result:int @list:140:1):
    if {[|](?h @list:141:16, ?t @list:141:21, x @list:141:10)::

        +(acc @list:141:38, 1 @list:141:44, ?tmp#2 @list:141:38)
        length1(t @list:141:35, tmp#2, ?tmp#1 @list:141:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(acc @list:141:57, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:141:10, ?#result @list:140:1)


list > public (0 calls)
0: list(ar:array(T) @list:128:14, ?#result:_(T) @list:128:5):
    [](?tmp#0 @list:129:11)
    =(?ls @list:129:6, tmp#0)
    foreign llvm move(ar @list:130:15, ?tmp#1)
    do {
        if {[|](?x @list:130:10, ?tmp#1, tmp#1)::

            [|](x @list:131:16, ls @list:131:20, ?tmp#2 @list:131:15)
            =(?ls @list:131:10, tmp#2)
        else::
            break

        }
    }
    reverse(ls @list:133:13, ?ls @list:133:18)
    foreign llvm move(ls @list:128:34, ?#result @list:128:5)


map > public (0 calls)
0: map(f:{resource}(T) @list:41:13, xs:_(T) @list:41:30):
    foreign llvm move(xs @list:42:15, ?tmp#0)
    do {
        if {[|](?x @list:42:10, ?tmp#0, tmp#0)::

            !f(x @list:43:12)
        else::
            break

        }
    }
map > public (0 calls)
1: map(f:(A, ?B) @list:49:13, as:_(A) @list:49:24, ?#result:_(B) @list:49:5):
    if {[|](?a @list:50:12, ?as @list:50:17, as @list:50:23)::

        f(a @list:50:33, ?tmp#2 @list:50:31)
        map(f @list:50:42, as @list:50:45, ?tmp#3 @list:50:38)
        [|](tmp#2, tmp#3, ?tmp#1 @list:50:29)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:50:61)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:50:10, ?#result @list:49:5)
map > public (0 calls)
2: map(f:(A, B, ?C) @list:55:13, as:_(A) @list:55:27, bs:_(B) @list:55:36, ?#result:_(C) @list:55:5):
    if {(   [|](?a @list:56:12, ?as @list:56:17, as @list:56:23)
        & [|](?b @list:56:30, ?bs @list:56:35, bs @list:56:41))::

        f(a @list:56:51, b @list:56:54, ?tmp#2 @list:56:49)
        map(f @list:56:63, as @list:56:66, bs @list:56:70, ?tmp#3 @list:56:59)
        [|](tmp#2, tmp#3, ?tmp#1 @list:56:47)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:57:47)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:56:10, ?#result @list:55:5)


print > public (0 calls)
0: print(printer:{resource}(T) @list:108:15, xs:_(T) @list:108:38) use !io:
    !print('[' @list:109:12)
    if {[|](?x @list:110:12, ?xs @list:110:17, xs @list:110:23)::

        !printer(x @list:111:18)
        !print1(printer @list:112:17, xs @list:112:26)
    else::
        pass

    }
    !print(']' @list:114:12)


print1 > (0 calls)
0: print1(printer:{resource}(T) @list:154:12, xs:_(T) @list:154:35) use !io:
    if {[|](?x @list:155:12, ?xs @list:155:17, xs @list:155:23)::

        !print(',' @list:156:16)
        !printer(x @list:157:18)
        !print1(printer @list:158:17, xs @list:158:26)
    else::
        pass

    }


println > public (0 calls)
0: println(printer:{resource}(T) @list:119:17, xs:_(T) @list:119:40) use !io:
    !print(printer @list:120:12, xs @list:120:21)
    !nl


reverse > public (0 calls)
0: reverse(x:_(T) @list:27:17, ?#result:_(T) @list:27:5):
    [](?tmp#1 @list:27:44)
    reverse1(x @list:27:41, tmp#1, ?tmp#0 @list:27:32)
    foreign llvm move(tmp#0, ?#result @list:27:5)


reverse1 > (0 calls)
0: reverse1(x:_(T) @list:144:14, tail:_(T) @list:144:22, ?#result:_(T) @list:144:1):
    if {[|](?h @list:145:16, ?t @list:145:21, x @list:145:10)::

        [|](h @list:145:40, tail @list:145:44, ?tmp#2 @list:145:39)
        reverse1(t @list:145:36, tmp#2, ?tmp#1 @list:145:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(tail @list:145:61, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:145:10, ?#result @list:144:1)

LLVM code       : None

--------------------------------------------------
 Module wybe.machine_word
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.machine_word.word_size_bits<0>
                    wybe.machine_word.word_size_bytes<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

word_size_bits > public {inline} (0 calls)
0: wybe.machine_word.word_size_bits<0>
word_size_bits(?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(64:wybe.int, ?#result##0:wybe.int) @machine_word:12:5


word_size_bytes > public {inline} (1 calls)
0: wybe.machine_word.word_size_bytes<0>
word_size_bytes(?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(8:wybe.int, ?#result##0:wybe.int) @machine_word:10:5

LLVM code       : None

--------------------------------------------------
 Module wybe.memory_management
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.memory_management.<0>
                    wybe.memory_management.malloc_count<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

module top-level code > public {inline,semipure} (0 calls)
0: wybe.memory_management.<0>
()<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c {impure} gc_init @memory_management:15:1


malloc_count > public {inline,semipure} (0 calls)
0: wybe.memory_management.malloc_count<0>
malloc_count(?x##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c {impure} malloc_count(?x##0:wybe.int) @memory_management:12:5

LLVM code       : None

--------------------------------------------------
 Module wybe.phantom
 modifiers       : {unique} 
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : 
  imports         : 
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.predicate
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.predicate.const<0>
                    wybe.predicate.id<0>
  imports         : 
  resources       : 
  procs           : 

const > public {inline} (0 calls)
0: wybe.predicate.const<0>
const(a##0:A <{}; {}; {0}>, [b##0:B <{}; {}; {1}>], ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:8:5


id > public {inline} (0 calls)
0: wybe.predicate.id<0>
id(a##0:A <{}; {}; {0}>, ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:6:5

LLVM code       : None

--------------------------------------------------
 Module wybe.range
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.range...<0>
                    wybe.range.=<0>
                    wybe.range.[]<0>
                    wybe.range.[|]<0>
                    wybe.range.end<0>
                    wybe.range.end<1>
                    wybe.range.irange<0>
                    wybe.range.range<0>
                    wybe.range.range<1>
                    wybe.range.size<0>
                    wybe.range.start<0>
                    wybe.range.start<1>
                    wybe.range.stride<0>
                    wybe.range.stride<1>
                    wybe.range.xrange<0>
                    wybe.range.~=<0>
  imports         : use wybe.bool
                    use wybe.int
  resources       : 
  procs           : 

.. > public (0 calls)
0: ..(start:wybe.int @range:38:10, end:wybe.int @range:38:23, ?#result:wybe.range @range:38:5):
    if {wybe.int.<0><=(start:wybe.int @range:39:27, end:wybe.int @range:39:37)::

        foreign llvm move(1:wybe.int @range:39:44, ?tmp#1:wybe.int)
    else::
        foreign llvm move(-1:wybe.int @range:39:56, ?tmp#1:wybe.int)

    }
   condition -> {end::wybe.int, start::wybe.int}
   then&else -> {end::wybe.int, start::wybe.int, tmp#1::wybe.int}
    wybe.range.<0>construct(start:wybe.int @range:39:15, tmp#1:wybe.int @range:39:27, end:wybe.int @range:39:62, ?tmp#0:wybe.range @range:39:5)
    foreign llvm move(tmp#0:wybe.range, ?#result:wybe.range @range:38:5)


= > public {test,inline} (0 calls)
0: =(#left:wybe.range, #right:wybe.range):
    if {(   foreign llvm icmp_uge(#left:!wybe.int, 0:wybe.int, ?tmp#0:!wybe.bool)
        & testbool tmp#0:!wybe.bool)::

        (   wybe.range.<1>range(?#left#start:wybe.int, ?#left#stride:wybe.int, ?#left#end:wybe.int, #left:wybe.range)
        & wybe.range.<1>range(?#right#start:wybe.int, ?#right#stride:wybe.int, ?#right#end:wybe.int, #right:wybe.range)
        & wybe.int.<0>=(#left#start:wybe.int, #right#start:wybe.int)
        & wybe.int.<0>=(#left#stride:wybe.int, #right#stride:wybe.int)
        & wybe.int.<0>=(#left#end:wybe.int, #right#end:wybe.int))
    else::
        fail

    }
   condition -> {#left::wybe.range, #right::wybe.range, tmp#0::6}
   then&else -> {#left::wybe.range, #left#end::wybe.int, #left#start::wybe.int, #left#stride::wybe.int, #right::wybe.range, #right#end::wybe.int, #right#start::wybe.int, #right#stride::wybe.int, tmp#0::6}


[] > public {test} (0 calls)
0: [](r:wybe.range @range:20:19, idx:wybe.int @range:20:24, ?value:wybe.int @range:20:34):
    wybe.int.<0><=(0:wybe.int @range:21:6, idx:wybe.int @range:21:12)
    wybe.range.<1>range(?size:wybe.int @range:22:16, ?stride:wybe.int @range:22:23, ?end:wybe.int @range:22:32, r:wybe.range @range:22:5)
    wybe.int.<0>*(stride:wybe.int @range:23:21, idx:wybe.int @range:23:30, ?tmp#1:wybe.int @range:23:21)
    wybe.int.<0>+(size:wybe.int @range:23:14, tmp#1:wybe.int, ?tmp#0:wybe.int @range:23:14)
    foreign llvm move(tmp#0:wybe.int, ?value:wybe.int @range:23:6)
    if {wybe.int.<0><=(0:wybe.int @range:24:10, stride:wybe.int @range:24:16)::

        wybe.int.<0><(value:wybe.int @range:24:27, end:wybe.int @range:24:35)
    else::
        wybe.int.<0><(end:wybe.int @range:24:51, value:wybe.int @range:24:57)

    }
   condition -> {end::wybe.int, idx::wybe.int, r::wybe.range, size::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int, value::wybe.int}
   then&else -> {end::wybe.int, idx::wybe.int, r::wybe.range, size::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int, value::wybe.int}


[|] > public {test} (0 calls)
0: [|](?value:wybe.int @range:12:23, ?rest:wybe.range @range:12:35, current:wybe.range @range:12:43):
    wybe.range.<1>range(?value:wybe.int @range:13:22, ?stride:wybe.int @range:13:30, ?end:wybe.int @range:13:39, current:wybe.range @range:13:5)
    wybe.int.<0>~=(value:wybe.int @range:14:6, end:wybe.int @range:14:16)
    wybe.int.<0>+(value:wybe.int @range:15:19, stride:wybe.int @range:15:27, ?tmp#1:wybe.int @range:15:19)
    wybe.range.<0>range(tmp#1:wybe.int, stride:wybe.int @range:15:35, end:wybe.int @range:15:43, ?tmp#0:wybe.range @range:15:13)
    foreign llvm move(tmp#0:wybe.range, ?rest:wybe.range @range:15:6)


construct > (0 calls)
0: construct(start:wybe.int @range:49:15, stride:wybe.int @range:49:26, end:wybe.int @range:49:38, ?#result:wybe.range @range:49:1):
    wybe.int.<0>-(end:wybe.int @range:50:14, start:wybe.int @range:50:20, ?tmp#1:wybe.int @range:50:14)
    wybe.int.<0>%(tmp#1:wybe.int, stride:wybe.int @range:50:29, ?tmp#0:wybe.int @range:50:13)
    foreign llvm move(tmp#0:wybe.int, ?diff:wybe.int @range:50:6)
    if {wybe.int.<0><=(0:wybe.int @range:51:19, stride:wybe.int @range:51:25)::

        if {wybe.int.<0>=(diff:wybe.int @range:52:26, 0:wybe.int @range:52:33)::

            wybe.int.<0>max(start:wybe.int @range:52:42, end:wybe.int @range:52:49, ?tmp#4:wybe.int @range:52:38)
            foreign llvm move(tmp#4:wybe.int, ?tmp#3:wybe.int)
        else::
            wybe.int.<0>+(end:wybe.int @range:53:45, stride:wybe.int @range:53:51, ?tmp#7:wybe.int @range:53:45)
            wybe.int.<0>-(tmp#7:wybe.int, diff:wybe.int @range:53:60, ?tmp#6:wybe.int @range:53:45)
            wybe.int.<0>max(start:wybe.int @range:53:38, tmp#6:wybe.int, ?tmp#5:wybe.int @range:53:34)
            foreign llvm move(tmp#5:wybe.int, ?tmp#3:wybe.int)

        }
   condition -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int}
   then&else -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int, tmp#3::wybe.int}
        foreign llvm move(tmp#3:wybe.int @range:52:26, ?tmp#2:wybe.int)
    else::
        if {wybe.int.<0>=(diff:wybe.int @range:55:26, 0:wybe.int @range:55:33)::

            wybe.int.<0>min(start:wybe.int @range:55:42, end:wybe.int @range:55:49, ?tmp#9:wybe.int @range:55:38)
            foreign llvm move(tmp#9:wybe.int, ?tmp#8:wybe.int)
        else::
            wybe.int.<0>+(end:wybe.int @range:56:45, diff:wybe.int @range:56:51, ?tmp#11:wybe.int @range:56:45)
            wybe.int.<0>min(start:wybe.int @range:56:38, tmp#11:wybe.int, ?tmp#10:wybe.int @range:56:34)
            foreign llvm move(tmp#10:wybe.int, ?tmp#8:wybe.int)

        }
   condition -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int}
   then&else -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int, tmp#8::wybe.int}
        foreign llvm move(tmp#8:wybe.int @range:55:26, ?tmp#2:wybe.int)

    }
   condition -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int}
   then&else -> {diff::wybe.int, end::wybe.int, start::wybe.int, stride::wybe.int, tmp#0::wybe.int, tmp#1::wybe.int, tmp#2::wybe.int}
    foreign llvm move(tmp#2:wybe.int @range:51:19, ?final:wybe.int @range:51:6)
    wybe.range.<0>range(start:wybe.int @range:58:16, stride:wybe.int @range:58:23, final:wybe.int @range:58:31, ?tmp#12:wybe.range @range:58:10)
    foreign llvm move(tmp#12:wybe.range, ?r:wybe.range @range:58:6)
    foreign llvm move(r:wybe.range @range:49:51, ?#result:wybe.range @range:49:1)


end > public {inline} (0 calls)
0: end(#rec:wybe.range @range:8:46, ?#result:wybe.int @range:8:46):
    foreign lpvm access(#rec:wybe.range @range:8:46, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?#result:wybe.int @range:8:46)
end > public {inline} (0 calls)
1: end(!#rec:wybe.range @range:8:46, #field:wybe.int @range:8:46):
    foreign lpvm {noalias} mutate(#rec:wybe.range @range:8:46, ?#rec:wybe.range @range:8:46, 16:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, #field:wybe.int)


irange > public (0 calls)
0: irange(start:wybe.int @range:32:16, stride:wybe.int @range:32:27, end:wybe.int @range:32:39, ?#result:wybe.range @range:32:5):
    if {wybe.int.<0><(stride:wybe.int @range:33:41, 0:wybe.int @range:33:50)::

        foreign llvm move(-1:wybe.int @range:33:55, ?tmp#2:wybe.int)
    else::
        foreign llvm move(1:wybe.int @range:33:68, ?tmp#2:wybe.int)

    }
   condition -> {end::wybe.int, start::wybe.int, stride::wybe.int}
   then&else -> {end::wybe.int, start::wybe.int, stride::wybe.int, tmp#2::wybe.int}
    wybe.int.<0>+(end:wybe.int @range:33:30, tmp#2:wybe.int @range:33:41, ?tmp#1:wybe.int @range:33:30)
    wybe.range.<0>construct(start:wybe.int @range:33:15, stride:wybe.int @range:33:22, tmp#1:wybe.int, ?tmp#0:wybe.range @range:33:5)
    foreign llvm move(tmp#0:wybe.range, ?#result:wybe.range @range:32:5)


range > public {inline} (0 calls)
0: range(start:wybe.int @range:8:23, stride:wybe.int @range:8:34, end:wybe.int @range:8:46, ?#result:wybe.range @range:8:17):
    foreign lpvm alloc(24:wybe.int, ?#rec:wybe.range @range:8:17)
    foreign lpvm mutate(#rec:wybe.range @range:8:17, ?#rec:wybe.range @range:8:17, 0:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, start:wybe.int @range:8:23)
    foreign lpvm mutate(#rec:wybe.range @range:8:17, ?#rec:wybe.range @range:8:17, 8:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, stride:wybe.int @range:8:34)
    foreign lpvm mutate(#rec:wybe.range @range:8:17, ?#rec:wybe.range @range:8:17, 16:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, end:wybe.int @range:8:46)
    foreign llvm or(#rec:wybe.range @range:8:17, 0:wybe.int, ?#result:wybe.range @range:8:17)
range > public {inline} (0 calls)
1: range(?start:wybe.int @range:8:23, ?stride:wybe.int @range:8:34, ?end:wybe.int @range:8:46, #result:wybe.range @range:8:17):
    pass
    foreign lpvm access(#result:wybe.range @range:8:17, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?start:wybe.int @range:8:23)
    foreign lpvm access(#result:wybe.range @range:8:17, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?stride:wybe.int @range:8:34)
    foreign lpvm access(#result:wybe.range @range:8:17, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?end:wybe.int @range:8:46)


size > public (0 calls)
0: size(r:wybe.range @range:42:14, ?#result:wybe.int @range:42:5):
    wybe.range.<1>range(?start:wybe.int @range:43:22, ?stride:wybe.int @range:43:30, ?end:wybe.int @range:43:39, r:wybe.range @range:43:11)
    if {(   wybe.int.<0>signum(stride:wybe.int @range:44:17, ?tmp#1:wybe.int @range:44:10)
        & wybe.int.<0>-(end:wybe.int @range:44:36, start:wybe.int @range:44:42, ?tmp#3:wybe.int @range:44:36)
        & wybe.int.<0>signum(tmp#3:wybe.int, ?tmp#2:wybe.int @range:44:29)
        & wybe.int.<0>~=(tmp#1:wybe.int, tmp#2:wybe.int))::

        foreign llvm move(0:wybe.int @range:44:52, ?tmp#0:wybe.int)
    else::
        if {wybe.int.<0><=(0:wybe.int @range:45:10, stride:wybe.int @range:45:16)::

            wybe.int.<0>-(end:wybe.int @range:45:27, start:wybe.int @range:45:33, ?tmp#8:wybe.int @range:45:27)
            wybe.int.<0>-(tmp#8:wybe.int, 1:wybe.int @range:45:41, ?tmp#7:wybe.int @range:45:27)
            wybe.int.<0>/(tmp#7:wybe.int, stride:wybe.int @range:45:46, ?tmp#6:wybe.int @range:45:26)
            wybe.int.<0>+(tmp#6:wybe.int, 1:wybe.int @range:45:55, ?tmp#5:wybe.int @range:45:26)
            foreign llvm move(tmp#5:wybe.int, ?tmp#4:wybe.int)
        else::
            wybe.int.<0>-(start:wybe.int @range:46:19, end:wybe.int @range:46:27, ?tmp#12:wybe.int @range:46:19)
            wybe.int.<0>-(tmp#12:wybe.int, 1:wybe.int @range:46:33, ?tmp#11:wybe.int @range:46:19)
            wybe.int.<3>-(stride:wybe.int @range:46:39, ?tmp#13:wybe.int @range:46:38)
            wybe.int.<0>/(tmp#11:wybe.int, tmp#13:wybe.int, ?tmp#10:wybe.int @range:46:18)
            wybe.int.<0>+(tmp#10:wybe.int, 1:wybe.int @range:46:48, ?tmp#9:wybe.int @range:46:18)
            foreign llvm move(tmp#9:wybe.int, ?tmp#4:wybe.int)

        }
   condition -> {end::wybe.int, r::wybe.range, start::wybe.int, stride::wybe.int}
   then&else -> {end::wybe.int, r::wybe.range, start::wybe.int, stride::wybe.int, tmp#4::wybe.int}
        foreign llvm move(tmp#4:wybe.int @range:45:10, ?tmp#0:wybe.int)

    }
   condition -> {end::wybe.int, r::wybe.range, start::wybe.int, stride::wybe.int, tmp#1::wybe.int, tmp#2::wybe.int, tmp#3::wybe.int}
   then&else -> {end::wybe.int, r::wybe.range, start::wybe.int, stride::wybe.int, tmp#0::wybe.int}
    foreign llvm move(tmp#0:wybe.int @range:44:10, ?#result:wybe.int @range:42:5)


start > public {inline} (0 calls)
0: start(#rec:wybe.range @range:8:23, ?#result:wybe.int @range:8:23):
    foreign lpvm access(#rec:wybe.range @range:8:23, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?#result:wybe.int @range:8:23)
start > public {inline} (0 calls)
1: start(!#rec:wybe.range @range:8:23, #field:wybe.int @range:8:23):
    foreign lpvm {noalias} mutate(#rec:wybe.range @range:8:23, ?#rec:wybe.range @range:8:23, 0:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, #field:wybe.int)


stride > public {inline} (0 calls)
0: stride(#rec:wybe.range @range:8:34, ?#result:wybe.int @range:8:34):
    foreign lpvm access(#rec:wybe.range @range:8:34, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?#result:wybe.int @range:8:34)
stride > public {inline} (0 calls)
1: stride(!#rec:wybe.range @range:8:34, #field:wybe.int @range:8:34):
    foreign lpvm {noalias} mutate(#rec:wybe.range @range:8:34, ?#rec:wybe.range @range:8:34, 8:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, #field:wybe.int)


xrange > public (0 calls)
0: xrange(start:wybe.int @range:28:16, stride:wybe.int @range:28:27, end:wybe.int @range:28:39, ?#result:wybe.range @range:28:5):
    wybe.range.<0>construct(start:wybe.int @range:29:15, stride:wybe.int @range:29:22, end:wybe.int @range:29:30, ?tmp#0:wybe.range @range:29:5)
    foreign llvm move(tmp#0:wybe.range, ?#result:wybe.range @range:28:5)


~= > public {test,inline} (0 calls)
0: ~=(#left:wybe.range, #right:wybe.range):
    ~(wybe.range.<0>=(#left:wybe.range, #right:wybe.range))

LLVM code       : None

--------------------------------------------------
 Module wybe.string
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.string.,,<0>
                    wybe.string.<<0>
                    wybe.string.<=<0>
                    wybe.string.<=><0>
                    wybe.string.=<0>
                    wybe.string.><0>
                    wybe.string.>=<0>
                    wybe.string.[]<0>
                    wybe.string.[]<1>
                    wybe.string.[|]<0>
                    wybe.string.c_string<0>
                    wybe.string.length<0>
                    wybe.string.print<0>
                    wybe.string.println<0>
                    wybe.string.read<0>
                    wybe.string.string<0>
                    wybe.string.string<1>
                    wybe.string.~=<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.char
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
                    use wybe.range
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_ @string:64:10, y:_ @string:64:17, ?#result:_ @string:64:5):
    if {(   empty(?tmp#1 @string:65:14)
        & =(x @string:65:10, tmp#1))::

        foreign llvm move(y @string:65:23, ?tmp#0)
    else::
        if {(   empty(?tmp#3 @string:66:14)
            & =(y @string:66:10, tmp#3))::

            foreign llvm move(x @string:66:23, ?tmp#2)
        else::
            concat(x @string:67:25, y @string:67:28, ?tmp#4 @string:67:18)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:66:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:65:10, ?#result @string:64:5)


< > public (0 calls)
0: <(x:_ @string:119:10, y:_ @string:119:17, ?#result:bool @string:119:5):
    <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
    equal(?tmp#2 @string:119:44)
    <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
    foreign llvm move(tmp#0, ?#result @string:119:5)


<= > public (0 calls)
0: <=(x:_ @string:120:10, y:_ @string:120:18, ?#result:bool @string:120:5):
    <=>(x @string:120:31, y @string:120:39, ?tmp#1 @string:120:31)
    equal(?tmp#2 @string:120:46)
    <=(tmp#1, tmp#2, ?tmp#0 @string:120:30)
    foreign llvm move(tmp#0, ?#result @string:120:5)


<=> > public (0 calls)
0: <=>(x:_ @string:125:10, y:_ @string:125:20, ?#result:comparison @string:125:5):
    equal(?tmp#0 @string:126:10)
    =(?c @string:126:6, tmp#0)
    foreign llvm move(x @string:127:16, ?tmp#1)
    foreign llvm move(y @string:127:26, ?tmp#2)
    do {
        if {[|](?cx @string:127:10, ?tmp#1, tmp#1)::

            if {[|](?cy @string:127:20, ?tmp#2, tmp#2)::

                if {<(cx @string:128:14, cy @string:128:19)::

                    lesser(?tmp#3 @string:128:30)
                    =(?c @string:128:26, tmp#3)
                    break
                else::
                    if {>(cx @string:129:14, cy @string:129:19)::

                        greater(?tmp#4 @string:129:30)
                        =(?c @string:129:26, tmp#4)
                        break
                    else::
                        pass

                    }

                }
            else::
                break

            }
        else::
            break

        }
    }
    if {(   equal(?tmp#5 @string:132:14)
        & =(c @string:132:10, tmp#5))::

        length(x @string:133:22, ?tmp#6 @string:133:15)
        =(?lx @string:133:10, tmp#6)
        length(y @string:134:22, ?tmp#7 @string:134:15)
        =(?ly @string:134:10, tmp#7)
        if {<(lx @string:135:14, ly @string:135:19)::

            lesser(?tmp#8 @string:135:30)
            =(?c @string:135:26, tmp#8)
        else::
            if {>(lx @string:135:39, ly @string:135:44)::

                greater(?tmp#9 @string:135:55)
                =(?c @string:135:51, tmp#9)
            else::
                pass

            }

        }
    else::
        pass

    }
    foreign llvm move(c @string:125:38, ?#result @string:125:5)


= > public (0 calls)
0: =(x:_ @string:115:10, y:_ @string:115:17, ?#result:bool @string:115:5):
    <=>(x @string:115:30, y @string:115:38, ?tmp#1 @string:115:30)
    equal(?tmp#2 @string:115:44)
    =(tmp#1, tmp#2, ?tmp#0 @string:115:29)
    foreign llvm move(tmp#0, ?#result @string:115:5)


> > public (0 calls)
0: >(x:_ @string:121:10, y:_ @string:121:17, ?#result:bool @string:121:5):
    <=>(x @string:121:30, y @string:121:38, ?tmp#1 @string:121:30)
    equal(?tmp#2 @string:121:44)
    >(tmp#1, tmp#2, ?tmp#0 @string:121:29)
    foreign llvm move(tmp#0, ?#result @string:121:5)


>= > public (0 calls)
0: >=(x:_ @string:122:10, y:_ @string:122:18, ?#result:bool @string:122:5):
    <=>(x @string:122:31, y @string:122:39, ?tmp#1 @string:122:31)
    equal(?tmp#2 @string:122:46)
    >=(tmp#1, tmp#2, ?tmp#0 @string:122:30)
    foreign llvm move(tmp#0, ?#result @string:122:5)


[] > public {test} (0 calls)
0: [](s:_ @string:91:19, idx:int @string:91:24, ?c:char @string:91:34):
    if {buffer(?len @string:93:17, ?str @string:93:23, s @string:92:10)::

        <=(0 @string:94:14, idx @string:94:20)
        <(idx @string:95:14, len @string:95:20)
        unsafe_c_string_index(str @string:96:35, idx @string:96:40, ?c @string:96:46)
    else::
        if {concat(?left @string:97:17, ?right @string:97:24, s @string:92:10)::

            length(left @string:98:32, ?tmp#0 @string:98:25)
            =(?left_len @string:98:14, tmp#0)
            if {<(idx @string:99:18, left_len @string:99:24)::

                [](left @string:99:41, idx @string:99:46, ?tmp#1 @string:99:41)
                =(?c @string:99:37, tmp#1)
            else::
                -(idx @string:100:37, left_len @string:100:43, ?tmp#3 @string:100:37)
                [](right @string:100:31, tmp#3, ?tmp#2 @string:100:31)
                =(?c @string:100:27, tmp#2)

            }
        else::
            if {slice(?base @string:102:16, ?range @string:102:23, s @string:92:10)::

                [](range @string:102:43, idx @string:102:49, ?tmp#5 @string:102:43)
                [](base @string:102:38, tmp#5, ?tmp#4 @string:102:38)
                =(?c @string:102:34, tmp#4)
            else::
                if {singleton(?c @string:103:20, s @string:92:10)::

                    =(idx @string:103:27, 0 @string:103:33)
                else::
                    fail

                }

            }

        }

    }
[] > public (0 calls)
1: [](s:_ @string:109:12, r:range @string:109:17, ?#result:_ @string:109:5):
    slice(s @string:109:36, r @string:109:39, ?tmp#0 @string:109:30)
    foreign llvm move(tmp#0, ?#result @string:109:5)


[|] > public {test} (0 calls)
0: [|](?head:char @string:71:23, ?tail:_ @string:71:35, s:_ @string:71:43):
    if {buffer(?len @string:73:17, ?str @string:73:23, s @string:72:10)::

        [|](?head @string:74:15, ?str @string:74:23, str @string:74:30)
        if {=(len @string:75:26, 1 @string:75:32)::

            empty(?tmp#1 @string:75:37)
            foreign llvm move(tmp#1, ?tmp#0)
        else::
            -(len @string:75:60, 1 @string:75:66, ?tmp#3 @string:75:60)
            buffer(tmp#3, str @string:75:69, ?tmp#2 @string:75:53)
            foreign llvm move(tmp#2, ?tmp#0)

        }
        =(?tail @string:75:14, tmp#0 @string:75:26)
    else::
        if {concat(?left @string:76:17, ?right @string:76:24, s @string:72:10)::

            if {[|](?head @string:77:20, ?t @string:77:28, left @string:77:33)::

                concat(t @string:77:56, right @string:77:59, ?tmp#4 @string:77:49)
                =(?tail @string:77:42, tmp#4)
            else::
                [|](?head @string:78:28, ?tail @string:78:36, right @string:78:44)

            }
        else::
            if {slice(?base @string:80:16, ?range @string:80:23, s @string:72:10)::

                do {
                    [|](?idx @string:82:19, ?range @string:82:26, range @string:82:35)
                    if {(   [](base @string:83:30, idx @string:83:35, ?tmp#5 @string:83:30)
                        & =(?head @string:83:23, tmp#5))::

                        slice(base @string:83:57, range @string:83:63, ?tmp#6 @string:83:51)
                        =(?tail @string:83:44, tmp#6)
                        break
                    else::
                        pass

                    }
                }
            else::
                if {singleton(?head @string:85:20, s @string:72:10)::

                    empty(?tmp#7 @string:85:37)
                    =(?tail @string:85:30, tmp#7)
                else::
                    fail

                }

            }

        }

    }


c_string > public (0 calls)
0: c_string(s:_ @string:40:18, ?#result:c_string @string:40:5):
    if {buffer(?tmp#0 @string:41:21, ?str @string:41:25, s @string:41:10)::

        pass
    else::
        length(s @string:43:27, ?tmp#2 @string:43:20)
        +(tmp#2, 1 @string:43:32, ?tmp#1 @string:43:20)
        =(?len @string:43:14, tmp#1)
        foreign lpvm alloc(len @string:44:32, ?str @string:44:38)
        true(?tmp#3 @string:45:49)
        foreign lpvm mutate(str @string:45:33, ?str @string:45:39, len @string:45:44, tmp#3, len @string:45:55, 0 @string:45:60, '\NUL' @string:45:63)
        =(?offset @string:46:14, 0 @string:46:23)
        pack(s @string:47:18, !str @string:47:22, len @string:47:27, !offset @string:47:33)

    }
    foreign llvm move(str @string:40:34, ?#result @string:40:5)


fixed_range_size > (0 calls)
0: fixed_range_size(hi:int @string:184:22, r:range @string:184:30, ?sz:int @string:184:40):
    range(?start @string:185:16, ?stride @string:185:24, ?end @string:185:33, r @string:185:5)
    if {<=(0 @string:186:10, stride @string:186:16)::

        -(start @string:187:39, ?tmp#4 @string:187:38)
        /(tmp#4, stride @string:187:47, ?tmp#3 @string:187:38)
        *(tmp#3, stride @string:187:56, ?tmp#2 @string:187:38)
        +(start @string:187:30, tmp#2, ?tmp#1 @string:187:30)
        max(start @string:187:23, tmp#1, ?tmp#0 @string:187:19)
        =(?lo @string:187:14, tmp#0)
        min(hi @string:188:23, end @string:188:27, ?tmp#5 @string:188:19)
        =(?hi @string:188:14, tmp#5)
    else::
        max(-1 @string:190:23, end @string:190:27, ?tmp#6 @string:190:19)
        =(?lo @string:190:14, tmp#6)
        +(hi @string:191:30, stride @string:191:35, ?tmp#10 @string:191:30)
        -(start @string:191:45, hi @string:191:53, ?tmp#13 @string:191:45)
        -(tmp#13, 1 @string:191:58, ?tmp#12 @string:191:45)
        -(stride @string:191:64, ?tmp#14 @string:191:63)
        %(tmp#12, tmp#14, ?tmp#11 @string:191:44)
        +(tmp#10, tmp#11, ?tmp#9 @string:191:30)
        +(tmp#9, 1 @string:191:73, ?tmp#8 @string:191:30)
        min(start @string:191:23, tmp#8, ?tmp#7 @string:191:19)
        =(?hi @string:191:14, tmp#7)
        -(stride @string:192:24, ?tmp#15 @string:192:23)
        =(?stride @string:192:14, tmp#15)

    }
    if {<=(hi @string:194:16, lo @string:194:23)::

        foreign llvm move(0 @string:194:29, ?tmp#16)
    else::
        -(hi @string:194:42, lo @string:194:47, ?tmp#20 @string:194:42)
        -(tmp#20, 1 @string:194:52, ?tmp#19 @string:194:42)
        /(tmp#19, stride @string:194:57, ?tmp#18 @string:194:41)
        +(tmp#18, 1 @string:194:66, ?tmp#17 @string:194:41)
        foreign llvm move(tmp#17, ?tmp#16)

    }
    =(?sz @string:194:6, tmp#16 @string:194:16)


length > public (0 calls)
0: length(s:_ @string:52:16, ?#result:int @string:52:5):
    if {buffer(?len @string:53:22, ?tmp#1 @string:53:27, s @string:53:10)::

        foreign llvm move(len @string:53:33, ?tmp#0)
    else::
        if {concat(?left @string:54:22, ?right @string:54:29, s @string:54:10)::

            length(left @string:54:46, ?tmp#4 @string:54:39)
            length(right @string:54:61, ?tmp#5 @string:54:54)
            +(tmp#4, tmp#5, ?tmp#3 @string:54:39)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            if {slice(?base @string:55:21, ?range @string:55:28, s @string:55:10)::

                length(base @string:55:62, ?tmp#8 @string:55:55)
                fixed_range_size(tmp#8, range @string:55:69, ?tmp#7 @string:55:38)
                foreign llvm move(tmp#7, ?tmp#6)
            else::
                if {singleton(?tmp#10 @string:56:24, s @string:56:10)::

                    foreign llvm move(1 @string:56:30, ?tmp#9)
                else::
                    foreign llvm move(0 @string:57:18, ?tmp#9)

                }
                foreign llvm move(tmp#9 @string:56:10, ?tmp#6)

            }
            foreign llvm move(tmp#6 @string:55:10, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:54:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:53:10, ?#result @string:52:5)


pack > (0 calls)
0: pack(s:_ @string:160:10, !raw:c_string @string:160:16, size:int @string:160:30, !offset:int @string:160:41):
    if {buffer(?tmp#0 @string:162:16, ?str @string:162:20, s @string:161:10)::

        foreign llvm move(str @string:163:23, ?tmp#1)
        do {
            if {[|](?c @string:163:18, ?tmp#1, tmp#1)::

                true(?tmp#2 @string:164:56)
                foreign lpvm mutate(raw @string:164:37, ?raw @string:164:43, offset @string:164:48, tmp#2, size @string:164:62, 0 @string:164:68, c @string:164:71)
                incr(!offset @string:165:23)
            else::
                break

            }
        }
    else::
        if {concat(?left @string:167:17, ?right @string:167:24, s @string:161:10)::

            pack(left @string:168:18, !raw @string:168:25, size @string:168:30, !offset @string:168:37)
            pack(right @string:169:18, !raw @string:169:26, size @string:169:31, !offset @string:169:38)
            incr(!offset @string:170:19)
        else::
            if {slice(?tmp#3 @string:171:15, ?tmp#4 @string:171:18, s @string:161:10)::

                foreign llvm move(s @string:172:23, ?tmp#5)
                do {
                    if {[|](?c @string:172:18, ?tmp#5, tmp#5)::

                        true(?tmp#6 @string:173:56)
                        foreign lpvm mutate(raw @string:173:37, ?raw @string:173:43, offset @string:173:48, tmp#6, size @string:173:62, 0 @string:173:68, c @string:173:71)
                        incr(!offset @string:174:23)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:176:20, s @string:161:10)::

                    true(?tmp#7 @string:177:52)
                    foreign lpvm mutate(raw @string:177:33, ?raw @string:177:39, offset @string:177:44, tmp#7, size @string:177:58, 0 @string:177:64, c @string:177:67)
                    incr(!offset @string:178:19)
                else::
                    fail

                }

            }

        }

    }


print > public (0 calls)
0: print(x:_ @string:142:15) use !io:
    if {buffer(?tmp#0 @string:144:16, ?str @string:144:20, x @string:143:10)::

        !print(str @string:144:35)
    else::
        if {concat(?left @string:145:17, ?right @string:145:24, x @string:143:10)::

            !print(left @string:145:41)
            !print(right @string:145:55)
        else::
            if {slice(?tmp#1 @string:146:15, ?tmp#2 @string:146:18, x @string:143:10)::

                foreign llvm move(x @string:146:34, ?tmp#3)
                do {
                    if {[|](?c @string:146:29, ?tmp#3, tmp#3)::

                        !print(c @string:146:45)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:147:20, x @string:143:10)::

                    !print(c @string:147:33)
                else::
                    fail

                }

            }

        }

    }


println > public (0 calls)
0: println(x:_ @string:151:17) use !io:
    !print(x @string:151:39)
    !nl


read > public (0 calls)
0: read(?x:_ @string:153:15) use !io:
    !read(?str:c_string @string:153:37)
    string(str @string:153:64, ?tmp#0 @string:153:57)
    =(?x @string:153:53, tmp#0)


string > public (0 calls)
0: string(str:c_string @string:28:16, ?#result:_ @string:28:5):
    length(str @string:29:19, ?tmp#0 @string:29:12)
    =(?len @string:29:6, tmp#0)
    if {=(len @string:30:15, 0 @string:30:21)::

        empty(?tmp#2 @string:30:26)
        foreign llvm move(tmp#2, ?tmp#1)
    else::
        if {=(len @string:31:15, 1 @string:31:21)::

            foreign lpvm access(str @string:31:56, 0 @string:31:61, 1 @string:31:64, 0 @string:31:67, ?tmp#5 @string:31:36)
            singleton(tmp#5, ?tmp#4 @string:31:26)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            buffer(len @string:32:33, str @string:32:38, ?tmp#6 @string:32:26)
            foreign llvm move(tmp#6, ?tmp#3)

        }
        foreign llvm move(tmp#3 @string:31:15, ?tmp#1)

    }
    =(?s @string:30:6, tmp#1 @string:30:15)
    foreign llvm move(s @string:28:34, ?#result @string:28:5)
string > public (0 calls)
1: string(c:char @string:37:16, ?#result:_ @string:37:5):
    singleton(c @string:37:38, ?tmp#0 @string:37:28)
    foreign llvm move(tmp#0, ?#result @string:37:5)


~= > public (0 calls)
0: ~=(x:_ @string:116:10, y:_ @string:116:18, ?#result:bool @string:116:5):
    <=>(x @string:116:31, y @string:116:39, ?tmp#1 @string:116:31)
    equal(?tmp#2 @string:116:46)
    ~=(tmp#1, tmp#2, ?tmp#0 @string:116:30)
    foreign llvm move(tmp#0, ?#result @string:116:5)

LLVM code       : None

======================================================================
AFTER FLATTENING:
 Module wybe
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : 
  imports         : public use wybe.array
                    public use wybe.bool
                    public use wybe.c_string
                    public use wybe.char
                    public use wybe.comparison
                    public use wybe.control
                    public use wybe.count
                    public use wybe.float
                    public use wybe.int
                    public use wybe.io
                    public use wybe.list
                    public use wybe.machine_word
                    public use wybe.memory_management
                    public use wybe.phantom
                    public use wybe.predicate
                    public use wybe.range
                    public use wybe.string
  resources       : 
  submodules      : wybe.array, wybe.bool, wybe.c_string, wybe.char, wybe.comparison, wybe.control, wybe.count, wybe.float, wybe.int, wybe.io, wybe.list, wybe.machine_word, wybe.memory_management, wybe.phantom, wybe.predicate, wybe.range, wybe.string
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.array(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.array.[]<0>
                    wybe.array.[]<1>
                    wybe.array.[|]<0>
                    wybe.array.array<0>
                    wybe.array.array<1>
                    wybe.array.inbounds<0>
                    wybe.array.unsafe_get<0>
                    wybe.array.unsafe_update<0>
  imports         : public use wybe.array.raw_array
                    use wybe.bool
                    use wybe.int
                    use wybe.list
                    use wybe.machine_word
  resources       : 
  submodules      : wybe.array.raw_array
  procs           : 

[] > public {test} (0 calls)
0: [](a:_(T) @array:67:21, idx:int @array:67:29, ?#result:T @array:67:5):
    inbounds(a @array:68:14, idx @array:68:17)
    unsafe_get(a @array:69:10, idx @array:69:23, ?tmp#0 @array:69:10)
    =(?x @array:69:6, tmp#0)
    foreign llvm move(x @array:67:42, ?#result @array:67:5)
[] > public {test} (0 calls)
1: [](!a:_(T) @array:81:22, idx:int @array:81:30, x:T @array:81:39):
    inbounds(a @array:82:14, idx @array:82:17)
    unsafe_update(!a @array:83:20, idx @array:83:23, x @array:83:28)


[|] > public {test} (0 calls)
0: [|](?head:T @array:51:23, ?tail:_(T) @array:51:32, a:_(T) @array:51:43):
    array(?length @array:52:12, ?data @array:52:21, a @array:52:29)
    >(length @array:53:6, 0 @array:53:15)
    word_size_bytes(?tmp#0 @array:54:34)
    foreign lpvm access(data @array:54:25, 0 @array:54:31, tmp#0, 0 @array:54:51, ?head @array:54:55)
    word_size_bytes(?tmp#1 @array:55:28)
    foreign llvm add(data @array:55:22, tmp#1, ?data @array:55:46)
    -(length @array:56:19, 1 @array:56:28, ?tmp#3 @array:56:19)
    array(tmp#3, data @array:56:31, ?tmp#2 @array:56:13)
    =(?tail @array:56:6, tmp#2)


array > public (0 calls)
0: array(x:T @array:18:15, len:int @array:18:20, ?#result:_(T) @array:18:5):
    word_size_bytes(?tmp#1 @array:19:19)
    *(len @array:19:13, tmp#1, ?tmp#0 @array:19:13)
    =(?size @array:19:6, tmp#0)
    foreign lpvm alloc(size @array:20:24, ?data @array:20:31)
    =(?offset @array:21:6, 0 @array:21:15)
    do {
        if {<(offset @array:23:15, size @array:23:24)::

            pass
        else::
            break

        }
        foreign lpvm mutate(data @array:24:29, ?data @array:24:36, offset @array:24:42, 1 @array:24:50, size @array:24:53, 0 @array:24:59, x @array:24:62)
        word_size_bytes(?tmp#2 @array:25:21)
        +=(!offset @array:25:10, tmp#2)
    }
    array(len @array:27:17, data @array:27:22, ?tmp#3 @array:27:11)
    =(?ar @array:27:6, tmp#3)
    foreign llvm move(ar @array:18:36, ?#result @array:18:5)
array > public (0 calls)
1: array(ls:list(T) @array:34:15, ?#result:_(T) @array:34:5):
    length(ls @array:35:19, ?tmp#0 @array:35:12)
    =(?len @array:35:6, tmp#0)
    word_size_bytes(?tmp#2 @array:36:19)
    *(len @array:36:13, tmp#2, ?tmp#1 @array:36:13)
    =(?size @array:36:6, tmp#1)
    foreign lpvm alloc(size @array:37:24, ?data @array:37:31)
    =(?offset @array:38:6, 0 @array:38:15)
    foreign llvm move(ls @array:39:15, ?tmp#3)
    do {
        if {[|](?x @array:39:10, ?tmp#3, tmp#3)::

            foreign lpvm mutate(data @array:40:29, ?data @array:40:36, offset @array:40:42, 1 @array:40:50, size @array:40:53, 0 @array:40:59, x @array:40:62)
            word_size_bytes(?tmp#4 @array:41:21)
            +=(!offset @array:41:10, tmp#4)
        else::
            break

        }
    }
    array(len @array:43:17, data @array:43:22, ?tmp#5 @array:43:11)
    =(?ar @array:43:6, tmp#5)
    foreign llvm move(ar @array:34:34, ?#result @array:34:5)


inbounds > public {test,inline} (0 calls)
0: inbounds(a:_(T) @array:60:33, idx:int @array:60:41):
    <=(0 @array:61:6, idx @array:61:12)
    length(a @array:62:12, ?tmp#0 @array:62:12)
    <(idx @array:62:6, tmp#0)


unsafe_get > public {inline} (0 calls)
0: unsafe_get(a:_(T) @array:75:29, idx:int @array:75:37, ?#result:T @array:75:5):
    raw_data(a @array:76:25, ?tmp#0 @array:76:25)
    word_size_bytes(?tmp#2 @array:76:43)
    *(idx @array:76:37, tmp#2, ?tmp#1 @array:76:37)
    word_size_bytes(?tmp#3 @array:76:60)
    foreign lpvm access(tmp#0, tmp#1, tmp#3, 0 @array:76:77, ?x @array:76:81)
    foreign llvm move(x @array:75:50, ?#result @array:75:5)


unsafe_update > public {inline} (0 calls)
0: unsafe_update(!a:_(T) @array:89:33, idx:int @array:89:41, x:T @array:89:50):
    raw_data(a @array:90:25, ?tmp#0 @array:90:25)
    word_size_bytes(?tmp#2 @array:90:50)
    *(idx @array:90:44, tmp#2, ?tmp#1 @array:90:44)
    length(a @array:91:44, ?tmp#4 @array:91:44)
    word_size_bytes(?tmp#5 @array:91:55)
    *(tmp#4, tmp#5, ?tmp#3 @array:91:44)
    foreign lpvm mutate(tmp#0, ?data @array:90:38, tmp#1, 0 @array:90:67, tmp#3, 0 @array:91:72, x @array:91:75)
    raw_data(!a @array:92:6, data @array:92:19)

LLVM code       : None

--------------------------------------------------
 Module wybe.array.raw_array(T)
  representation  : address
  public submods  : 
  public resources: 
  public procs    : 
  imports         : use wybe
                    use wybe.array
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.bool
  representation  : 1 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.bool.&&<0>
                    wybe.bool.&=<0>
                    wybe.bool.=<0>
                    wybe.bool.^=<0>
                    wybe.bool.^^<0>
                    wybe.bool.false<0>
                    wybe.bool.print<0>
                    wybe.bool.println<0>
                    wybe.bool.succeed<0>
                    wybe.bool.true<0>
                    wybe.bool.|=<0>
                    wybe.bool.||<0>
                    wybe.bool.~<0>
                    wybe.bool.~=<0>
  imports         : use wybe.c_string
                    use wybe.io
  resources       : 
  procs           : 

&& > public {inline} (1 calls)
0: wybe.bool.&&<0>
&&(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:13:27


&= > public {inline} (0 calls)
0: wybe.bool.&=<0>
&=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm and(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:13:27


= > public {inline} (0 calls)
0: wybe.bool.=<0>
=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:37:26


^= > public {inline} (0 calls)
0: wybe.bool.^=<0>
^=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:25:27


^^ > public {inline} (1 calls)
0: wybe.bool.^^<0>
^^(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:25:27


false > public {inline} (0 calls)
0: wybe.bool.false<0>
false(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.bool, ?#result##0:wybe.bool)


print > public (1 calls)
0: wybe.bool.print<0>
print(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    case ~x##0:wybe.bool of
    0:
        wybe.c_string.print<0>(c"false":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #1 @bool:47:31

    1:
        wybe.c_string.print<0>(c"true":wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:47:31



println > public {inline} (0 calls)
0: wybe.bool.println<0>
println(x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.bool.print<0>(~x##0:wybe.bool)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}> #0 @bool:49:33
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#0##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~tmp#0##0:wybe.phantom, ?tmp#1##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#1##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


succeed > public {inline} (0 calls)
0: wybe.bool.succeed<0>
succeed()<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []


true > public {inline} (1 calls)
0: wybe.bool.true<0>
true(?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.bool, ?#result##0:wybe.bool)


|= > public {inline} (0 calls)
0: wybe.bool.|=<0>
|=(p##0:wybe.bool, ?p##1:wybe.bool, q##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?p##1:wybe.bool) @bool:19:27


|| > public {inline} (1 calls)
0: wybe.bool.||<0>
||(p##0:wybe.bool, q##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm or(~p##0:wybe.bool, ~q##0:wybe.bool, ?#result##0:wybe.bool) @bool:19:27


~ > public {inline} (0 calls)
0: wybe.bool.~<0>
~(p##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm xor(~p##0:wybe.bool, 1:wybe.bool, ?#result##0:wybe.bool) @bool:31:20


~= > public {inline} (0 calls)
0: wybe.bool.~=<0>
~=(x##0:wybe.bool, y##0:wybe.bool, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.bool, ~y##0:wybe.bool, ?#result##0:wybe.bool) @bool:38:27

LLVM code       : None

--------------------------------------------------
 Module wybe.c_string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.c_string.<<0>
                    wybe.c_string.<=<0>
                    wybe.c_string.=<0>
                    wybe.c_string.><0>
                    wybe.c_string.>=<0>
                    wybe.c_string.[]<0>
                    wybe.c_string.[|]<0>
                    wybe.c_string.length<0>
                    wybe.c_string.print<0>
                    wybe.c_string.println<0>
                    wybe.c_string.read<0>
                    wybe.c_string.unsafe_c_string_index<0>
                    wybe.c_string.~=<0>
  imports         : use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.c_string.<<0>
<(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:12:29
    wybe.int.<<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:12:29


<= > public {inline} (0 calls)
0: wybe.c_string.<=<0>
<=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:13:30
    wybe.int.<=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:13:30


= > public {inline} (0 calls)
0: wybe.c_string.=<0>
=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:10:29
    wybe.int.=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:10:29


> > public {inline} (0 calls)
0: wybe.c_string.><0>
>(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:14:29
    wybe.int.><0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:14:29


>= > public {inline} (0 calls)
0: wybe.c_string.>=<0>
>=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:15:30
    wybe.int.>=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:15:30


[] > public (0 calls)
0: wybe.c_string.[]<0>
[](str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, idx##0:wybe.int, ?tmp#2##0:wybe.bool) #0 @c_string:27:6
    case ~tmp#2##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        foreign c strlen(str##0:wybe.c_string, ?tmp#0##0:wybe.int) @c_string:17:29
        wybe.int.<<0>(idx##0:wybe.int, ~tmp#0##0:wybe.int, ?tmp#3##0:wybe.bool) #2 @c_string:28:6
        case ~tmp#3##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




[|] > public (0 calls)
0: wybe.c_string.[|]<0>
[|](?head##0:wybe.char, ?tail##0:wybe.c_string, str##0:wybe.c_string, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(str##0:wybe.c_string, 0:wybe.int, 0:wybe.int, 0:wybe.int, ?head##0:wybe.char) @c_string:20:5
    foreign llvm icmp_ne(head##0:wybe.char, '\NUL':wybe.char, ?not_done##0:wybe.bool) @c_string:21:5
    foreign llvm icmp_eq(~not_done##0:wybe.bool, 1:wybe.bool, ?tmp#1##0:wybe.bool) @bool:37:26
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.c_string, ?tail##0:wybe.c_string)

    1:
        foreign llvm add(~str##0:wybe.c_string, 1:wybe.int, ?tail##0:wybe.c_string) @c_string:23:5
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



length > public {inline} (3 calls)
0: wybe.c_string.length<0>
length(str##0:wybe.c_string, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strlen(~str##0:wybe.c_string, ?#result##0:wybe.int) @c_string:17:29


print > public {inline} (1 calls)
0: wybe.c_string.print<0>
print(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:35:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:35:30


println > public {inline} (0 calls)
0: wybe.c_string.println<0>
println(x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @c_string:35:30
    foreign c print_string(~x##0:wybe.c_string, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @c_string:35:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.c_string.read<0>
read(?x##0:wybe.c_string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @c_string:39:30
    foreign c read_line(?x##0:wybe.c_string, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @c_string:39:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @c_string:39:30


unsafe_c_string_index > public {inline} (1 calls)
0: wybe.c_string.unsafe_c_string_index<0>
unsafe_c_string_index(str##0:wybe.c_string, idx##0:wybe.int, ?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(~str##0:wybe.c_string, ~idx##0:wybe.int, 1:wybe.int, 0:wybe.int, ?#result##0:wybe.char) @c_string:33:7


~= > public {inline} (0 calls)
0: wybe.c_string.~=<0>
~=(x##0:wybe.c_string, y##0:wybe.c_string, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c strcmp(~x##0:wybe.c_string, ~y##0:wybe.c_string, ?tmp#1##0:wybe.int) @c_string:11:30
    wybe.int.~=<0>(~tmp#1##0:wybe.int, 0:wybe.int, ?#result##0:wybe.bool) #0 @c_string:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.char
  representation  : 8 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.char.<<0>
                    wybe.char.<=<0>
                    wybe.char.<=><0>
                    wybe.char.=<0>
                    wybe.char.><0>
                    wybe.char.>=<0>
                    wybe.char.chr<0>
                    wybe.char.ord<0>
                    wybe.char.print<0>
                    wybe.char.println<0>
                    wybe.char.read<0>
                    wybe.char.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

< > public {inline} (4 calls)
0: wybe.char.<<0>
<(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:17:29


<= > public {inline} (0 calls)
0: wybe.char.<=<0>
<=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:18:30


<=> > public (0 calls)
0: wybe.char.<=><0>
<=>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.char, y##0:wybe.char, ?tmp#6##0:wybe.bool) @char:17:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?tmp#5##0:wybe.bool) @char:13:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @char:23:5



= > public {inline} (2 calls)
0: wybe.char.=<0>
=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:13:29


> > public {inline} (0 calls)
0: wybe.char.><0>
>(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:19:29


>= > public {inline} (0 calls)
0: wybe.char.>=<0>
>=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:20:30


chr > public (0 calls)
0: wybe.char.chr<0>
chr(i##0:wybe.int, ?#result##0:wybe.char, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.int.<=<0>(0:wybe.int, i##0:wybe.int, ?tmp#1##0:wybe.bool) #0 @char:33:60
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

    1:
        wybe.int.<=<0>(i##0:wybe.int, 255:wybe.int, ?tmp#2##0:wybe.bool) #1 @char:33:70
        case ~tmp#2##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.char, ?#result##0:wybe.char)

        1:
            foreign lpvm cast(~i##0:wybe.int, ?#result##0:wybe.char) @char:33:31
            foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)




ord > public {inline} (0 calls)
0: wybe.char.ord<0>
ord(c##0:wybe.char, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(~c##0:wybe.char, ?#result##0:wybe.int) @char:30:24


print > public {inline} (1 calls)
0: wybe.char.print<0>
print(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:37:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:37:30


println > public {inline} (0 calls)
0: wybe.char.println<0>
println(x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @char:37:30
    foreign c putchar(~x##0:wybe.char, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @char:37:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.char.read<0>
read(?x##0:wybe.char)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @char:41:30
    foreign c read_char(?x##0:wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @char:41:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @char:41:30


~= > public {inline} (0 calls)
0: wybe.char.~=<0>
~=(x##0:wybe.char, y##0:wybe.char, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.char, ~y##0:wybe.char, ?#result##0:wybe.bool) @char:14:30

LLVM code       : None

--------------------------------------------------
 Module wybe.comparison
  representation  : 2 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.comparison.<<0>
                    wybe.comparison.<=<0>
                    wybe.comparison.=<0>
                    wybe.comparison.><0>
                    wybe.comparison.>=<0>
                    wybe.comparison.equal<0>
                    wybe.comparison.greater<0>
                    wybe.comparison.lesser<0>
                    wybe.comparison.~=<0>
  imports         : use wybe.bool
  resources       : 
  procs           : 

< > public {inline} (0 calls)
0: wybe.comparison.<<0>
<(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:12:29


<= > public {inline} (0 calls)
0: wybe.comparison.<=<0>
<=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:13:30


= > public {inline} (0 calls)
0: wybe.comparison.=<0>
=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:10:29


> > public {inline} (0 calls)
0: wybe.comparison.><0>
>(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:14:29


>= > public {inline} (0 calls)
0: wybe.comparison.>=<0>
>=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:15:30


equal > public {inline} (0 calls)
0: wybe.comparison.equal<0>
equal(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison)


greater > public {inline} (0 calls)
0: wybe.comparison.greater<0>
greater(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison)


lesser > public {inline} (0 calls)
0: wybe.comparison.lesser<0>
lesser(?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison)


~= > public {inline} (0 calls)
0: wybe.comparison.~=<0>
~=(x##0:wybe.comparison, y##0:wybe.comparison, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.comparison, ~y##0:wybe.comparison, ?#result##0:wybe.bool) @comparison:11:30

LLVM code       : None

--------------------------------------------------
 Module wybe.control
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.control.assert<0>
                    wybe.control.error<0>
                    wybe.control.error<1>
                    wybe.control.exit<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.int
                    use wybe.string
  resources       : 
  procs           : 

assert > public {semipure} (0 calls)
0: assert(condition:bool @control:26:27) use call_source_location:
    if {~(condition @control:27:11)::

        !error(c"assertion failed" @control:27:31)
    else::
        pass

    }


error > public {terminal,semipure} (0 calls)
0: error(message:string @control:17:35) use call_source_location:
    c_string(message @control:18:77, ?tmp#0 @control:18:68)
    foreign c {terminal,semipure} error_exit(call_source_location @control:18:46, tmp#0)
error > public {terminal,semipure} (0 calls)
1: error(message:c_string @control:21:35) use call_source_location:
    foreign c {terminal,semipure} error_exit(call_source_location @control:22:46, message @control:22:68)


exit > public {terminal,semipure} (0 calls)
0: exit(code:int @control:10:34):
    foreign c {terminal,semipure} exit(code @control:11:40)

LLVM code       : None

--------------------------------------------------
 Module wybe.count
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : wybe.count.%<0>
                    wybe.count.%=<0>
                    wybe.count.*<0>
                    wybe.count.*=<0>
                    wybe.count.+<0>
                    wybe.count.+<1>
                    wybe.count.+<2>
                    wybe.count.+=<0>
                    wybe.count.-<0>
                    wybe.count.-<1>
                    wybe.count.-<2>
                    wybe.count.-=<0>
                    wybe.count./<0>
                    wybe.count./=<0>
                    wybe.count.<<0>
                    wybe.count.<=<0>
                    wybe.count.<=><0>
                    wybe.count.=<0>
                    wybe.count.><0>
                    wybe.count.>=<0>
                    wybe.count.decr<0>
                    wybe.count.incr<0>
                    wybe.count.max<0>
                    wybe.count.min<0>
                    wybe.count.print<0>
                    wybe.count.println<0>
                    wybe.count.read<0>
                    wybe.count.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.count.%<0>
%(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:51:25


%= > public {inline} (0 calls)
0: wybe.count.%=<0>
%=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm urem(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:51:25


* > public {inline} (1 calls)
0: wybe.count.*<0>
*(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:39:25


*= > public {inline} (0 calls)
0: wybe.count.*=<0>
*=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:39:25


+ > public {inline} (2 calls)
0: wybe.count.+<0>
+(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:15:25
+ > public (0 calls)
1: wybe.count.+<1>
+(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(y##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?x##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~y##0:wybe.count, ?x##0:wybe.count) @count:18:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

+ > public (0 calls)
2: wybe.count.+<2>
+(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, z##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?y##0:wybe.count)

    1:
        foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:22:10
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



+= > public {inline} (0 calls)
0: wybe.count.+=<0>
+=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:15:25


- > public (6 calls)
0: wybe.count.-<0>
-(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.count, ?#result##0:wybe.count)

    1:
        foreign llvm sub(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:31:35
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

- > public {inline} (0 calls)
1: wybe.count.-<1>
-(?x##0:wybe.count, y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.count, ~z##0:wybe.count, ?x##0:wybe.count) @count:32:42
- > public {inline} (0 calls)
2: wybe.count.-<2>
-(x##0:wybe.count, ?y##0:wybe.count, z##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.count, ~x##0:wybe.count, ?y##0:wybe.count) @count:33:42


-= > public (0 calls)
0: wybe.count.-=<0>
-=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, ~y##0:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:36:41
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:36:37
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



/ > public {inline} (1 calls)
0: wybe.count./<0>
/(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.count) @count:45:25


/= > public {inline} (0 calls)
0: wybe.count./=<0>
/=(x##0:wybe.count, ?x##1:wybe.count, y##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm udiv(~x##0:wybe.count, ~y##0:wybe.count, ?x##1:wybe.count) @count:45:25


< > public {inline} (4 calls)
0: wybe.count.<<0>
<(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:64:29


<= > public {inline} (3 calls)
0: wybe.count.<=<0>
<=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:65:30


<=> > public (0 calls)
0: wybe.count.<=><0>
<=>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ult(x##0:wybe.count, y##0:wybe.count, ?tmp#6##0:wybe.bool) @count:64:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?tmp#5##0:wybe.bool) @count:60:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @count:70:5



= > public {inline} (2 calls)
0: wybe.count.=<0>
=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:60:29


> > public {inline} (0 calls)
0: wybe.count.><0>
>(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ugt(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:66:29


>= > public {inline} (12 calls)
0: wybe.count.>=<0>
>=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:67:30


decr > public (0 calls)
0: wybe.count.decr<0>
decr(x##0:wybe.count, ?x##1:wybe.count, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.count.-<0>(x##0:wybe.count, 1:wybe.count, ?tmp#0##0:wybe.count, ?tmp#1##0:wybe.bool) #0 @count:84:37
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(~x##0:wybe.count, ?x##1:wybe.count)

    1:
        foreign llvm move(~tmp#0##0:wybe.count, ?x##1:wybe.count) @count:84:33
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



incr > public {inline} (0 calls)
0: wybe.count.incr<0>
incr(x##0:wybe.count, ?x##1:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.count, 1:wybe.count, ?x##1:wybe.count) @count:15:25


max > public (0 calls)
0: wybe.count.max<0>
max(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_uge(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:67:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:75:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:75:5



min > public (0 calls)
0: wybe.count.min<0>
min(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.count)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ule(x##0:wybe.count, y##0:wybe.count, ?tmp#1##0:wybe.bool) @count:65:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.count, ?#result##0:wybe.count) @count:74:5

    1:
        foreign llvm move(~x##0:wybe.count, ?#result##0:wybe.count) @count:74:5



print > public {inline} (1 calls)
0: wybe.count.print<0>
print(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:88:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:88:30


println > public {inline} (0 calls)
0: wybe.count.println<0>
println(x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @count:88:30
    foreign c print_count(~x##0:wybe.count, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @count:88:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.count.read<0>
read(?x##0:wybe.count)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @count:92:30
    foreign c read_count(?x##0:wybe.count, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @count:92:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @count:92:30


~= > public {inline} (0 calls)
0: wybe.count.~=<0>
~=(x##0:wybe.count, y##0:wybe.count, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.count, ~y##0:wybe.count, ?#result##0:wybe.bool) @count:61:30

LLVM code       : None

--------------------------------------------------
 Module wybe.float
  representation  : 64 bit float
  public submods  : 
  public resources: 
  public procs    : wybe.float.*<0>
                    wybe.float.**<0>
                    wybe.float.*=<0>
                    wybe.float.+<0>
                    wybe.float.+<1>
                    wybe.float.+<2>
                    wybe.float.+=<0>
                    wybe.float.-<0>
                    wybe.float.-<1>
                    wybe.float.-<2>
                    wybe.float.-<3>
                    wybe.float.-<4>
                    wybe.float.-=<0>
                    wybe.float./<0>
                    wybe.float./=<0>
                    wybe.float.<<0>
                    wybe.float.<=<0>
                    wybe.float.<=><0>
                    wybe.float.=<0>
                    wybe.float.><0>
                    wybe.float.>=<0>
                    wybe.float.abs<0>
                    wybe.float.ceil<0>
                    wybe.float.cos<0>
                    wybe.float.e<0>
                    wybe.float.exp<0>
                    wybe.float.floor<0>
                    wybe.float.iceil<0>
                    wybe.float.ifloor<0>
                    wybe.float.iround<0>
                    wybe.float.log<0>
                    wybe.float.log10<0>
                    wybe.float.log2<0>
                    wybe.float.max<0>
                    wybe.float.min<0>
                    wybe.float.pi<0>
                    wybe.float.power<0>
                    wybe.float.print<0>
                    wybe.float.println<0>
                    wybe.float.read<0>
                    wybe.float.round<0>
                    wybe.float.sin<0>
                    wybe.float.sqrt<0>
                    wybe.float.square<0>
                    wybe.float.tan<0>
                    wybe.float.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
  resources       : 
  procs           : 

* > public {inline} (1 calls)
0: wybe.float.*<0>
*(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:45:25


** > public {inline} (0 calls)
0: wybe.float.**<0>
**(x##0:wybe.float, n##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.pow.f64(~x##0:wybe.float, ~n##0:wybe.float, ?#result##0:wybe.float) @float:112:27


*= > public {inline} (0 calls)
0: wybe.float.*=<0>
*=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:45:25


+ > public {inline} (1 calls)
0: wybe.float.+<0>
+(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:23:27
+ > public {inline} (0 calls)
1: wybe.float.+<1>
+(?x##0:wybe.float, y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:24:43
+ > public {inline} (0 calls)
2: wybe.float.+<2>
+(x##0:wybe.float, ?y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~x##0:wybe.float, ?y##0:wybe.float) @float:25:43


+= > public {inline} (0 calls)
0: wybe.float.+=<0>
+=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:23:27


- > public {inline} (1 calls)
0: wybe.float.-<0>
-(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:32:27
- > public {inline} (0 calls)
1: wybe.float.-<1>
-(?x##0:wybe.float, y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fadd(~z##0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:33:43
- > public {inline} (0 calls)
2: wybe.float.-<2>
-(x##0:wybe.float, ?y##0:wybe.float, z##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~z##0:wybe.float, ~x##0:wybe.float, ?y##0:wybe.float) @float:34:43
- > public {inline} (0 calls)
3: wybe.float.-<3>
-(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(0.0:wybe.float, ~x##0:wybe.float, ?#result##0:wybe.float) @float:38:21
- > public {inline} (0 calls)
4: wybe.float.-<4>
-(?x##0:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(0.0:wybe.float, ~y##0:wybe.float, ?x##0:wybe.float) @float:39:37


-= > public {inline} (0 calls)
0: wybe.float.-=<0>
-=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fsub(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:32:27


/ > public {inline} (2 calls)
0: wybe.float./<0>
/(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fdiv(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:51:25


/= > public {inline} (0 calls)
0: wybe.float./=<0>
/=(x##0:wybe.float, ?x##1:wybe.float, y##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fdiv(~x##0:wybe.float, ~y##0:wybe.float, ?x##1:wybe.float) @float:51:25


< > public {inline} (4 calls)
0: wybe.float.<<0>
<(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_slt(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:70:29


<= > public {inline} (0 calls)
0: wybe.float.<=<0>
<=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sle(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:71:30


<=> > public (0 calls)
0: wybe.float.<=><0>
<=>(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_slt(x##0:wybe.float, y##0:wybe.float, ?tmp#6##0:wybe.bool) @float:70:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm fcmp_eq(~x##0:wybe.float, ~y##0:wybe.float, ?tmp#5##0:wybe.bool) @float:66:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @float:76:5



= > public {inline} (2 calls)
0: wybe.float.=<0>
=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_eq(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:66:29


> > public {inline} (0 calls)
0: wybe.float.><0>
>(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sgt(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:72:29


>= > public {inline} (0 calls)
0: wybe.float.>=<0>
>=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_sge(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:73:30


abs > public {inline} (0 calls)
0: wybe.float.abs<0>
abs(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.fabs.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:60:22


ceil > public {inline} (1 calls)
0: wybe.float.ceil<0>
ceil(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.ceil.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:87:23


cos > public {inline} (0 calls)
0: wybe.float.cos<0>
cos(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.cos.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:116:22


e > public {inline} (0 calls)
0: wybe.float.e<0>
e(?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(2.7182818284590455:wybe.float, ?#result##0:wybe.float) @float:16:5


exp > public {inline} (0 calls)
0: wybe.float.exp<0>
exp(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.exp.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:120:22


floor > public {inline} (1 calls)
0: wybe.float.floor<0>
floor(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.floor.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:90:24


iceil > public {inline} (0 calls)
0: wybe.float.iceil<0>
iceil(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.ceil.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:87:23
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:99:26


ifloor > public {inline} (0 calls)
0: wybe.float.ifloor<0>
ifloor(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.floor.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:90:24
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:102:27


iround > public {inline} (0 calls)
0: wybe.float.iround<0>
iround(x##0:wybe.float, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.round.f64(~x##0:wybe.float, ?tmp#1##0:wybe.float) @float:93:24
    foreign llvm fptosi(~tmp#1##0:wybe.float, ?#result##0:wybe.int) @float:96:27


log > public {inline} (0 calls)
0: wybe.float.log<0>
log(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:123:22


log10 > public {inline} (0 calls)
0: wybe.float.log10<0>
log10(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log10.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:126:24


log2 > public {inline} (0 calls)
0: wybe.float.log2<0>
log2(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.log2.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:129:23


max > public {inline} (0 calls)
0: wybe.float.max<0>
max(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.maxnum.f64(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:81:27


min > public {inline} (0 calls)
0: wybe.float.min<0>
min(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.minnum.f64(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.float) @float:80:27


pi > public {inline} (0 calls)
0: wybe.float.pi<0>
pi(?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(3.141592653589793:wybe.float, ?#result##0:wybe.float) @float:13:5


power > public {inline} (0 calls)
0: wybe.float.power<0>
power(x##0:wybe.float, n##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.pow.f64(~x##0:wybe.float, ~n##0:wybe.float, ?#result##0:wybe.float) @float:111:28


print > public {inline} (1 calls)
0: wybe.float.print<0>
print(x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @float:133:30
    foreign c print_float(~x##0:wybe.float, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @float:133:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @float:133:30


println > public {inline} (0 calls)
0: wybe.float.println<0>
println(x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @float:133:30
    foreign c print_float(~x##0:wybe.float, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @float:133:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.float.read<0>
read(?x##0:wybe.float)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @float:137:30
    foreign c read_float(?x##0:wybe.float, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @float:137:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @float:137:30


round > public {inline} (1 calls)
0: wybe.float.round<0>
round(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.round.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:93:24


sin > public {inline} (0 calls)
0: wybe.float.sin<0>
sin(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sin.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:115:22


sqrt > public {inline} (0 calls)
0: wybe.float.sqrt<0>
sqrt(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sqrt.f64(~x##0:wybe.float, ?#result##0:wybe.float) @float:108:23


square > public {inline} (0 calls)
0: wybe.float.square<0>
square(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fmul(~x##0:wybe.float, ~x##0:wybe.float, ?#result##0:wybe.float) @float:57:25


tan > public {inline} (0 calls)
0: wybe.float.tan<0>
tan(x##0:wybe.float, ?#result##0:wybe.float)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c llvm.sin.f64(x##0:wybe.float, ?tmp#1##0:wybe.float) @float:117:22
    foreign c llvm.cos.f64(~x##0:wybe.float, ?tmp#2##0:wybe.float) @float:117:52
    foreign llvm fdiv(~tmp#1##0:wybe.float, ~tmp#2##0:wybe.float, ?#result##0:wybe.float) @float:51:25


~= > public {inline} (0 calls)
0: wybe.float.~=<0>
~=(x##0:wybe.float, y##0:wybe.float, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm fcmp_ne(~x##0:wybe.float, ~y##0:wybe.float, ?#result##0:wybe.bool) @float:67:30

LLVM code       : None

--------------------------------------------------
 Module wybe.int
  representation  : 64 bit signed
  public submods  : 
  public resources: 
  public procs    : wybe.int.%<0>
                    wybe.int.%=<0>
                    wybe.int.*<0>
                    wybe.int.*=<0>
                    wybe.int.+<0>
                    wybe.int.+<1>
                    wybe.int.+<2>
                    wybe.int.+=<0>
                    wybe.int.-<0>
                    wybe.int.-<1>
                    wybe.int.-<2>
                    wybe.int.-<3>
                    wybe.int.-<4>
                    wybe.int.-=<0>
                    wybe.int./<0>
                    wybe.int./=<0>
                    wybe.int.<<0>
                    wybe.int.<<<0>
                    wybe.int.<<=<0>
                    wybe.int.<=<0>
                    wybe.int.<=><0>
                    wybe.int.=<0>
                    wybe.int.><0>
                    wybe.int.>=<0>
                    wybe.int.>><0>
                    wybe.int.>>=<0>
                    wybe.int.decr<0>
                    wybe.int.incr<0>
                    wybe.int.logical_bitshift<0>
                    wybe.int.logical_bitshift<1>
                    wybe.int.max<0>
                    wybe.int.min<0>
                    wybe.int.power<0>
                    wybe.int.print<0>
                    wybe.int.println<0>
                    wybe.int.read<0>
                    wybe.int.signum<0>
                    wybe.int.sqrt<0>
                    wybe.int.~=<0>
  imports         : use wybe.bool
                    use wybe.comparison
                    use wybe.io
  resources       : 
  procs           : 

% > public {inline} (1 calls)
0: wybe.int.%<0>
%(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:50:25


%= > public {inline} (0 calls)
0: wybe.int.%=<0>
%=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm srem(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:50:25


* > public {inline} (1 calls)
0: wybe.int.*<0>
*(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:38:25


*= > public {inline} (0 calls)
0: wybe.int.*=<0>
*=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm mul(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:38:25


+ > public {inline} (2 calls)
0: wybe.int.+<0>
+(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:16:27
+ > public {inline} (0 calls)
1: wybe.int.+<1>
+(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:17:43
+ > public {inline} (0 calls)
2: wybe.int.+<2>
+(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:18:43


+= > public {inline} (0 calls)
0: wybe.int.+=<0>
+=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:16:27


- > public {inline} (2 calls)
0: wybe.int.-<0>
-(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:25:27
- > public {inline} (0 calls)
1: wybe.int.-<1>
-(?x##0:wybe.int, y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~y##0:wybe.int, ~z##0:wybe.int, ?x##0:wybe.int) @int:26:43
- > public {inline} (0 calls)
2: wybe.int.-<2>
-(x##0:wybe.int, ?y##0:wybe.int, z##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~z##0:wybe.int, ~x##0:wybe.int, ?y##0:wybe.int) @int:27:43
- > public {inline} (0 calls)
3: wybe.int.-<3>
-(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~x##0:wybe.int, ?#result##0:wybe.int) @int:31:21
- > public {inline} (0 calls)
4: wybe.int.-<4>
-(?x##0:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(0:wybe.int, ~y##0:wybe.int, ?x##0:wybe.int) @int:32:37


-= > public {inline} (0 calls)
0: wybe.int.-=<0>
-=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:25:27


/ > public {inline} (1 calls)
0: wybe.int./<0>
/(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:44:25


/= > public {inline} (0 calls)
0: wybe.int./=<0>
/=(x##0:wybe.int, ?x##1:wybe.int, y##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sdiv(~x##0:wybe.int, ~y##0:wybe.int, ?x##1:wybe.int) @int:44:25


< > public {inline} (4 calls)
0: wybe.int.<<0>
<(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:87:29


<< > public {inline} (1 calls)
0: wybe.int.<<<0>
<<(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:56:27


<<= > public {inline} (0 calls)
0: wybe.int.<<=<0>
<<=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm shl(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:56:27


<= > public {inline} (3 calls)
0: wybe.int.<=<0>
<=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:88:30


<=> > public (0 calls)
0: wybe.int.<=><0>
<=>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.comparison)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(x##0:wybe.int, y##0:wybe.int, ?tmp#6##0:wybe.bool) @int:87:29
    case ~tmp#6##0:wybe.bool of
    0:
        foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?tmp#5##0:wybe.bool) @int:83:29
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm move(2:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5

        1:
            foreign llvm move(1:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5


    1:
        foreign llvm move(0:wybe.comparison, ?#result##0:wybe.comparison) @int:93:5



= > public {inline} (2 calls)
0: wybe.int.=<0>
=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_eq(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:83:29


> > public {inline} (0 calls)
0: wybe.int.><0>
>(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sgt(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:89:29


>= > public {inline} (3 calls)
0: wybe.int.>=<0>
>=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:90:30


>> > public {inline} (1 calls)
0: wybe.int.>><0>
>>(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:65:27


>>= > public {inline} (0 calls)
0: wybe.int.>>=<0>
>>=(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm ashr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:65:27


decr > public {inline} (0 calls)
0: wybe.int.decr<0>
decr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:25:27


incr > public {inline} (0 calls)
0: wybe.int.incr<0>
incr(x##0:wybe.int, ?x##1:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~x##0:wybe.int, 1:wybe.int, ?x##1:wybe.int) @int:16:27


logical_bitshift > public {inline} (1 calls)
0: wybe.int.logical_bitshift<0>
logical_bitshift(x##0:wybe.int, s##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?#result##0:wybe.int) @int:74:40
logical_bitshift > public {inline} (0 calls)
1: wybe.int.logical_bitshift<1>
logical_bitshift(x##0:wybe.int, ?x##1:wybe.int, s##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm lshr(~x##0:wybe.int, ~s##0:wybe.int, ?x##1:wybe.int) @int:74:40


max > public (0 calls)
0: wybe.int.max<0>
max(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:90:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:98:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:98:5



min > public (0 calls)
0: wybe.int.min<0>
min(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sle(x##0:wybe.int, y##0:wybe.int, ?tmp#1##0:wybe.bool) @int:88:30
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(~y##0:wybe.int, ?#result##0:wybe.int) @int:97:5

    1:
        foreign llvm move(~x##0:wybe.int, ?#result##0:wybe.int) @int:97:5



power > public {inline} (0 calls)
0: wybe.int.power<0>
power(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c ipow(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.int) @int:107:29


print > public {inline} (1 calls)
0: wybe.int.print<0>
print(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:119:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:119:30


println > public {inline} (0 calls)
0: wybe.int.println<0>
println(x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @int:119:30
    foreign c print_int(~x##0:wybe.int, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @int:119:30
    foreign c putchar('\n':wybe.char, ~tmp#2##0:wybe.phantom, ?tmp#4##0:wybe.phantom) @io:17:31
    foreign lpvm store(~%tmp#4##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31


read > public {inline} (0 calls)
0: wybe.int.read<0>
read(?x##0:wybe.int)<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @int:123:30
    foreign c read_int(?x##0:wybe.int, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @int:123:30
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @int:123:30


signum > public {inline} (0 calls)
0: wybe.int.signum<0>
signum(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c signum(~x##0:wybe.int, ?#result##0:wybe.int) @int:114:25


sqrt > public {inline} (0 calls)
0: wybe.int.sqrt<0>
sqrt(x##0:wybe.int, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c isqrt(~x##0:wybe.int, ?#result##0:wybe.int) @int:104:23


~= > public {inline} (0 calls)
0: wybe.int.~=<0>
~=(x##0:wybe.int, y##0:wybe.int, ?#result##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(~x##0:wybe.int, ~y##0:wybe.int, ?#result##0:wybe.bool) @int:84:30

LLVM code       : None

--------------------------------------------------
 Module wybe.io
  representation  : (not a type)
  public submods  : phantom -> wybe.phantom
  public resources: io: wybe.io.io
  public procs    : wybe.io.<0>
                    wybe.io.eof<0>
                    wybe.io.nl<0>
  imports         : use wybe.char
                    public use wybe.phantom
  resources       : io: fromList [(wybe.io.io,wybe.phantom = 0:phantom @io:13:27 @io:13:5)]
  procs           : 

module top-level code > public {inline,semipure} (0 calls)
0: wybe.io.<0>
()<{}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm store(0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:13:5


eof > public {inline} (0 calls)
0: wybe.io.eof<0>
eof(?#result##0:wybe.char)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm cast(-1:wybe.int, ?#result##0:wybe.char) @io:20:29


nl > public {inline} (0 calls)
0: wybe.io.nl<0>
nl()<{<<wybe.io.io>>}; {<<wybe.io.io>>}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%io##0:wybe.phantom) @io:17:31
    foreign c putchar('\n':wybe.char, ~io##0:wybe.phantom, ?io##1:wybe.phantom) @io:17:31
    foreign lpvm store(~%io##1:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:17:31

LLVM code       : None

--------------------------------------------------
 Module wybe.list(T)
  representation  : (not yet known)
  public submods  : 
  public resources: 
  public procs    : wybe.list.,,<0>
                    wybe.list.[]<0>
                    wybe.list.all<0>
                    wybe.list.any<0>
                    wybe.list.empty<0>
                    wybe.list.filter<0>
                    wybe.list.foldl<0>
                    wybe.list.foldr<0>
                    wybe.list.length<0>
                    wybe.list.list<0>
                    wybe.list.map<0>
                    wybe.list.map<1>
                    wybe.list.map<2>
                    wybe.list.print<0>
                    wybe.list.println<0>
                    wybe.list.reverse<0>
  imports         : use wybe.array
                    use wybe.bool
                    use wybe.char
                    use wybe.int
                    use wybe.io
                    use wybe.machine_word
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_(T) @list:20:10, y:_(T) @list:20:20, ?#result:_(T) @list:20:5):
    if {[|](?h @list:21:16, ?t @list:21:21, x @list:21:10)::

        ,,(t @list:21:32, y @list:21:37, ?tmp#2 @list:21:32)
        [|](h @list:21:28, tmp#2, ?tmp#1 @list:21:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(y @list:21:50, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:21:10, ?#result @list:20:5)


[] > public {test} (0 calls)
0: [](xs:_(T) @list:31:21, idx:int @list:31:30, ?#result:T @list:31:5):
    >=(idx @list:32:5, 0 @list:32:13)
    index1(xs @list:33:17, idx @list:33:21, ?tmp#0 @list:33:10)
    =(?x @list:33:6, tmp#0)
    foreign llvm move(x @list:31:43, ?#result @list:31:5)


all > public {test} (0 calls)
0: all(p:{test}(T) @list:61:20, xs:_(T) @list:61:33):
    foreign llvm move(xs @list:62:15, ?tmp#0)
    do {
        if {[|](?x @list:62:10, ?tmp#0, tmp#0)::

            p(x @list:63:11)
        else::
            break

        }
    }


any > public {test} (0 calls)
0: any(p:{test}(T) @list:69:20, xs:_(T) @list:69:33):
    [|](?x @list:70:7, ?xs @list:70:12, xs @list:70:18)
    (   p(x @list:71:8)
    | any(p @list:71:17, xs @list:71:20))


empty > public {test} (0 calls)
0: empty(xs:_(T) @list:15:22):
    if {[|](?tmp#0 @list:16:11, ?tmp#1 @list:16:15, xs @list:16:20)::

        fail
    else::
        pass

    }


filter > public (0 calls)
0: filter(p:{test}(T) @list:95:16, !xs:_(T) @list:95:30):
    [](?tmp#0 @list:96:12)
    =(?out @list:96:6, tmp#0)
    foreign llvm move(xs @list:97:15, ?tmp#1)
    do {
        if {[|](?x @list:97:10, ?tmp#1, tmp#1)::

            if {p(x @list:98:16)::

                [|](x @list:98:30, out @list:98:34, ?tmp#2 @list:98:29)
                =(?out @list:98:23, tmp#2)
            else::
                pass

            }
        else::
            break

        }
    }
    reverse(out @list:100:19, ?tmp#3 @list:100:11)
    =(?as @list:100:6, tmp#3)


foldl > public (0 calls)
0: foldl(f:(A, !B) @list:77:15, as:_(A) @list:77:26, !b:B @list:77:36):
    foreign llvm move(as @list:78:15, ?tmp#0)
    do {
        if {[|](?a @list:78:10, ?tmp#0, tmp#0)::

            f(a @list:79:11, !b @list:79:15)
        else::
            break

        }
    }


foldr > public (0 calls)
0: foldr(f:(A, !B) @list:86:15, as:_(A) @list:86:26, !b:B @list:86:36):
    if {[|](?a @list:87:12, ?as @list:87:17, as @list:87:23)::

        foldr(f @list:88:15, as @list:88:18, !b @list:88:23)
        f(a @list:89:11, !b @list:89:15)
    else::
        pass

    }


index1 > {test} (0 calls)
0: index1(xs:_(T) @list:148:19, idx:int @list:148:28, ?#result:T @list:148:1):
    [|](?x @list:149:7, ?xs @list:149:12, xs @list:149:18)
    (   =(idx @list:150:6, 0 @list:150:12)
    | (   -(idx @list:150:27, 1 @list:150:33, ?tmp#0 @list:150:27)
        & index1(xs @list:150:23, tmp#0, ?x @list:150:37)))
    foreign llvm move(x @list:148:41, ?#result @list:148:1)


length > public (0 calls)
0: length(x:_(T) @list:24:16, ?#result:int @list:24:5):
    length1(x @list:24:38, 0 @list:24:41, ?tmp#0 @list:24:30)
    foreign llvm move(tmp#0, ?#result @list:24:5)


length1 > (0 calls)
0: length1(x:_(T) @list:140:13, acc:int @list:140:21, ?#result:int @list:140:1):
    if {[|](?h @list:141:16, ?t @list:141:21, x @list:141:10)::

        +(acc @list:141:38, 1 @list:141:44, ?tmp#2 @list:141:38)
        length1(t @list:141:35, tmp#2, ?tmp#1 @list:141:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(acc @list:141:57, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:141:10, ?#result @list:140:1)


list > public (0 calls)
0: list(ar:array(T) @list:128:14, ?#result:_(T) @list:128:5):
    [](?tmp#0 @list:129:11)
    =(?ls @list:129:6, tmp#0)
    foreign llvm move(ar @list:130:15, ?tmp#1)
    do {
        if {[|](?x @list:130:10, ?tmp#1, tmp#1)::

            [|](x @list:131:16, ls @list:131:20, ?tmp#2 @list:131:15)
            =(?ls @list:131:10, tmp#2)
        else::
            break

        }
    }
    reverse(ls @list:133:13, ?ls @list:133:18)
    foreign llvm move(ls @list:128:34, ?#result @list:128:5)


map > public (0 calls)
0: map(f:{resource}(T) @list:41:13, xs:_(T) @list:41:30):
    foreign llvm move(xs @list:42:15, ?tmp#0)
    do {
        if {[|](?x @list:42:10, ?tmp#0, tmp#0)::

            !f(x @list:43:12)
        else::
            break

        }
    }
map > public (0 calls)
1: map(f:(A, ?B) @list:49:13, as:_(A) @list:49:24, ?#result:_(B) @list:49:5):
    if {[|](?a @list:50:12, ?as @list:50:17, as @list:50:23)::

        f(a @list:50:33, ?tmp#2 @list:50:31)
        map(f @list:50:42, as @list:50:45, ?tmp#3 @list:50:38)
        [|](tmp#2, tmp#3, ?tmp#1 @list:50:29)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:50:61)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:50:10, ?#result @list:49:5)
map > public (0 calls)
2: map(f:(A, B, ?C) @list:55:13, as:_(A) @list:55:27, bs:_(B) @list:55:36, ?#result:_(C) @list:55:5):
    if {(   [|](?a @list:56:12, ?as @list:56:17, as @list:56:23)
        & [|](?b @list:56:30, ?bs @list:56:35, bs @list:56:41))::

        f(a @list:56:51, b @list:56:54, ?tmp#2 @list:56:49)
        map(f @list:56:63, as @list:56:66, bs @list:56:70, ?tmp#3 @list:56:59)
        [|](tmp#2, tmp#3, ?tmp#1 @list:56:47)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        [](?tmp#4 @list:57:47)
        foreign llvm move(tmp#4, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:56:10, ?#result @list:55:5)


print > public (0 calls)
0: print(printer:{resource}(T) @list:108:15, xs:_(T) @list:108:38) use !io:
    !print('[' @list:109:12)
    if {[|](?x @list:110:12, ?xs @list:110:17, xs @list:110:23)::

        !printer(x @list:111:18)
        !print1(printer @list:112:17, xs @list:112:26)
    else::
        pass

    }
    !print(']' @list:114:12)


print1 > (0 calls)
0: print1(printer:{resource}(T) @list:154:12, xs:_(T) @list:154:35) use !io:
    if {[|](?x @list:155:12, ?xs @list:155:17, xs @list:155:23)::

        !print(',' @list:156:16)
        !printer(x @list:157:18)
        !print1(printer @list:158:17, xs @list:158:26)
    else::
        pass

    }


println > public (0 calls)
0: println(printer:{resource}(T) @list:119:17, xs:_(T) @list:119:40) use !io:
    !print(printer @list:120:12, xs @list:120:21)
    !nl


reverse > public (0 calls)
0: reverse(x:_(T) @list:27:17, ?#result:_(T) @list:27:5):
    [](?tmp#1 @list:27:44)
    reverse1(x @list:27:41, tmp#1, ?tmp#0 @list:27:32)
    foreign llvm move(tmp#0, ?#result @list:27:5)


reverse1 > (0 calls)
0: reverse1(x:_(T) @list:144:14, tail:_(T) @list:144:22, ?#result:_(T) @list:144:1):
    if {[|](?h @list:145:16, ?t @list:145:21, x @list:145:10)::

        [|](h @list:145:40, tail @list:145:44, ?tmp#2 @list:145:39)
        reverse1(t @list:145:36, tmp#2, ?tmp#1 @list:145:27)
        foreign llvm move(tmp#1, ?tmp#0)
    else::
        foreign llvm move(tail @list:145:61, ?tmp#0)

    }
    foreign llvm move(tmp#0 @list:145:10, ?#result @list:144:1)

LLVM code       : None

--------------------------------------------------
 Module wybe.machine_word
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.machine_word.word_size_bits<0>
                    wybe.machine_word.word_size_bytes<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

word_size_bits > public {inline} (0 calls)
0: wybe.machine_word.word_size_bits<0>
word_size_bits(?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(64:wybe.int, ?#result##0:wybe.int) @machine_word:12:5


word_size_bytes > public {inline} (1 calls)
0: wybe.machine_word.word_size_bytes<0>
word_size_bytes(?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(8:wybe.int, ?#result##0:wybe.int) @machine_word:10:5

LLVM code       : None

--------------------------------------------------
 Module wybe.memory_management
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.memory_management.<0>
                    wybe.memory_management.malloc_count<0>
  imports         : use wybe.int
  resources       : 
  procs           : 

module top-level code > public {inline,semipure} (0 calls)
0: wybe.memory_management.<0>
()<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c {impure} gc_init @memory_management:15:1


malloc_count > public {inline,semipure} (0 calls)
0: wybe.memory_management.malloc_count<0>
malloc_count(?x##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign c {impure} malloc_count(?x##0:wybe.int) @memory_management:12:5

LLVM code       : None

--------------------------------------------------
 Module wybe.phantom
 modifiers       : {unique} 
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : 
  imports         : 
  resources       : 
  procs           : 


LLVM code       : None

--------------------------------------------------
 Module wybe.predicate
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : wybe.predicate.const<0>
                    wybe.predicate.id<0>
  imports         : 
  resources       : 
  procs           : 

const > public {inline} (0 calls)
0: wybe.predicate.const<0>
const(a##0:A <{}; {}; {0}>, [b##0:B <{}; {}; {1}>], ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:8:5


id > public {inline} (0 calls)
0: wybe.predicate.id<0>
id(a##0:A <{}; {}; {0}>, ?#result##0:A <{}; {}; {0}>)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(~a##0:A, ?#result##0:A) @predicate:6:5

LLVM code       : None

--------------------------------------------------
 Module wybe.range
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.range...<0>
                    wybe.range.=<0>
                    wybe.range.[]<0>
                    wybe.range.[|]<0>
                    wybe.range.end<0>
                    wybe.range.end<1>
                    wybe.range.irange<0>
                    wybe.range.range<0>
                    wybe.range.range<1>
                    wybe.range.size<0>
                    wybe.range.start<0>
                    wybe.range.start<1>
                    wybe.range.stride<0>
                    wybe.range.stride<1>
                    wybe.range.xrange<0>
                    wybe.range.~=<0>
  imports         : use wybe.bool
                    use wybe.int
  resources       : 
  procs           : 

.. > public (0 calls)
0: wybe.range...<0>
..(start##0:wybe.int, end##0:wybe.int, ?#result##0:wybe.range)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(end##0:wybe.int, start##0:wybe.int, ?tmp#2##0:wybe.bool) @int:88:30
    case ~tmp#2##0:wybe.bool of
    0:
        wybe.range.construct<0>(~start##0:wybe.int, -1:wybe.int, ~end##0:wybe.int, ?#result##0:wybe.range) #2 @range:39:5

    1:
        wybe.range.construct<0>(~start##0:wybe.int, 1:wybe.int, ~end##0:wybe.int, ?#result##0:wybe.range) #1 @range:39:5



= > public {inline} (1 calls)
0: wybe.range.=<0>
=(#left##0:wybe.range, #right##0:wybe.range, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(#left##0:wybe.range, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?#left#start##0:wybe.int) @range:8:17
    foreign lpvm access(#left##0:wybe.range, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?#left#stride##0:wybe.int) @range:8:17
    foreign lpvm access(~#left##0:wybe.range, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?#left#end##0:wybe.int) @range:8:17
    foreign lpvm access(#right##0:wybe.range, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?#right#start##0:wybe.int) @range:8:17
    foreign lpvm access(#right##0:wybe.range, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?#right#stride##0:wybe.int) @range:8:17
    foreign lpvm access(~#right##0:wybe.range, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?#right#end##0:wybe.int) @range:8:17
    foreign llvm icmp_eq(~#left#start##0:wybe.int, ~#right#start##0:wybe.int, ?tmp#1##0:wybe.bool) @int:83:29
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)

    1:
        foreign llvm icmp_eq(~#left#stride##0:wybe.int, ~#right#stride##0:wybe.int, ?tmp#2##0:wybe.bool) @int:83:29
        case ~tmp#2##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)

        1:
            foreign llvm icmp_eq(~#left#end##0:wybe.int, ~#right#end##0:wybe.int, ?#success##0:wybe.bool) @int:83:29




[] > public (0 calls)
0: wybe.range.[]<0>
[](r##0:wybe.range, idx##0:wybe.int, ?value##0:wybe.int, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_sge(idx##0:wybe.int, 0:wybe.int, ?tmp#2##0:wybe.bool) @int:88:30
    case ~tmp#2##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?value##0:wybe.int)

    1:
        foreign lpvm access(r##0:wybe.range, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?size##0:wybe.int) @range:8:17
        foreign lpvm access(r##0:wybe.range, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?stride##0:wybe.int) @range:8:17
        foreign lpvm access(~r##0:wybe.range, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?end##0:wybe.int) @range:8:17
        foreign llvm mul(~idx##0:wybe.int, stride##0:wybe.int, ?tmp#1##0:wybe.int) @int:38:25
        foreign llvm add(~size##0:wybe.int, ~tmp#1##0:wybe.int, ?tmp#0##0:wybe.int) @int:16:27
        foreign llvm move(tmp#0##0:wybe.int, ?value##0:wybe.int) @range:23:6
        foreign llvm icmp_sge(~stride##0:wybe.int, 0:wybe.int, ?tmp#5##0:wybe.bool) @int:88:30
        case ~tmp#5##0:wybe.bool of
        0:
            foreign llvm icmp_slt(~end##0:wybe.int, ~tmp#0##0:wybe.int, ?#success##0:wybe.bool) @int:87:29

        1:
            foreign llvm icmp_sgt(~end##0:wybe.int, ~tmp#0##0:wybe.int, ?#success##0:wybe.bool) @int:87:29




[|] > public (0 calls)
0: wybe.range.[|]<0>
[|](?value##0:wybe.int, ?rest##0:wybe.range, current##0:wybe.range, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: [InterestingUnaliased 2]
    foreign lpvm access(current##0:wybe.range, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?value##0:wybe.int) @range:8:17
    foreign lpvm access(current##0:wybe.range, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?stride##0:wybe.int) @range:8:17
    foreign lpvm access(~current##0:wybe.range, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?end##0:wybe.int) @range:8:17
    foreign llvm icmp_ne(end##0:wybe.int, value##0:wybe.int, ?tmp#2##0:wybe.bool) @int:84:30
    case ~tmp#2##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
        foreign llvm move(undef:wybe.range, ?rest##0:wybe.range)

    1:
        foreign llvm add(stride##0:wybe.int, value##0:wybe.int, ?tmp#1##0:wybe.int) @int:16:27
        foreign lpvm alloc(24:wybe.int, ?tmp#11##0:wybe.range) @range:8:17
        foreign lpvm mutate(~tmp#11##0:wybe.range, ?tmp#12##0:wybe.range, 0:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~tmp#1##0:wybe.int) @range:8:17
        foreign lpvm mutate(~tmp#12##0:wybe.range, ?tmp#13##0:wybe.range, 8:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~stride##0:wybe.int) @range:8:17
        foreign lpvm mutate(~tmp#13##0:wybe.range, ?rest##0:wybe.range, 16:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~end##0:wybe.int) @range:8:17
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)



construct > (4 calls)
0: wybe.range.construct<0>
construct(start##0:wybe.int, stride##0:wybe.int, end##0:wybe.int, ?#result##0:wybe.range)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm sub(end##0:wybe.int, start##0:wybe.int, ?tmp#1##0:wybe.int) @int:25:27
    foreign llvm srem(~tmp#1##0:wybe.int, stride##0:wybe.int, ?tmp#0##0:wybe.int) @int:50:25
    foreign llvm icmp_sge(stride##0:wybe.int, 0:wybe.int, ?tmp#15##0:wybe.bool) @int:88:30
    case ~tmp#15##0:wybe.bool of
    0:
        foreign llvm icmp_eq(tmp#0##0:wybe.int, 0:wybe.int, ?tmp#14##0:wybe.bool) @int:83:29
        case ~tmp#14##0:wybe.bool of
        0:
            foreign llvm add(~end##0:wybe.int, ~tmp#0##0:wybe.int, ?tmp#11##0:wybe.int) @int:16:27
            wybe.int.min<0>(start##0:wybe.int, ~tmp#11##0:wybe.int, ?tmp#10##0:wybe.int) #14 @range:56:34
            wybe.range.construct#cont#1<0>(~start##0:wybe.int, ~stride##0:wybe.int, ~tmp#10##0:wybe.int, ?#result##0:wybe.range) #15

        1:
            wybe.int.min<0>(start##0:wybe.int, ~end##0:wybe.int, ?tmp#9##0:wybe.int) #11 @range:55:38
            wybe.range.construct#cont#1<0>(~start##0:wybe.int, ~stride##0:wybe.int, ~tmp#9##0:wybe.int, ?#result##0:wybe.range) #12


    1:
        foreign llvm icmp_eq(tmp#0##0:wybe.int, 0:wybe.int, ?tmp#13##0:wybe.bool) @int:83:29
        case ~tmp#13##0:wybe.bool of
        0:
            foreign llvm add(~end##0:wybe.int, stride##0:wybe.int, ?tmp#7##0:wybe.int) @int:16:27
            foreign llvm sub(~tmp#7##0:wybe.int, ~tmp#0##0:wybe.int, ?tmp#6##0:wybe.int) @int:25:27
            wybe.int.max<0>(start##0:wybe.int, ~tmp#6##0:wybe.int, ?tmp#5##0:wybe.int) #8 @range:53:34
            wybe.range.construct#cont#1<0>(~start##0:wybe.int, ~stride##0:wybe.int, ~tmp#5##0:wybe.int, ?#result##0:wybe.range) #9

        1:
            wybe.int.max<0>(start##0:wybe.int, ~end##0:wybe.int, ?tmp#4##0:wybe.int) #4 @range:52:38
            wybe.range.construct#cont#1<0>(~start##0:wybe.int, ~stride##0:wybe.int, ~tmp#4##0:wybe.int, ?#result##0:wybe.range) #5




construct#cont#1 > (4 calls)
0: wybe.range.construct#cont#1<0>
construct#cont#1(start##0:wybe.int, stride##0:wybe.int, tmp#2##0:wybe.int, ?#result##0:wybe.range)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm alloc(24:wybe.int, ?tmp#16##0:wybe.range) @range:8:17
    foreign lpvm mutate(~tmp#16##0:wybe.range, ?tmp#17##0:wybe.range, 0:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~start##0:wybe.int) @range:8:17
    foreign lpvm mutate(~tmp#17##0:wybe.range, ?tmp#18##0:wybe.range, 8:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~stride##0:wybe.int) @range:8:17
    foreign lpvm mutate(~tmp#18##0:wybe.range, ?#result##0:wybe.range, 16:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~tmp#2##0:wybe.int) @range:8:17


end > public {inline} (0 calls)
0: wybe.range.end<0>
end(#rec##0:wybe.range, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(~#rec##0:wybe.range, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?#result##0:wybe.int) @range:8:46
end > public {inline} (0 calls)
1: wybe.range.end<1>
end(#rec##0:wybe.range, ?#rec##1:wybe.range, #field##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm {noalias} mutate(~#rec##0:wybe.range, ?#rec##1:wybe.range, 16:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, ~#field##0:wybe.int) @range:8:46


irange > public (0 calls)
0: wybe.range.irange<0>
irange(start##0:wybe.int, stride##0:wybe.int, end##0:wybe.int, ?#result##0:wybe.range)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(stride##0:wybe.int, 0:wybe.int, ?tmp#3##0:wybe.bool) @int:87:29
    case ~tmp#3##0:wybe.bool of
    0:
        foreign llvm add(~end##0:wybe.int, 1:wybe.int, ?tmp#10##0:wybe.int) @int:16:27
        wybe.range.construct<0>(~start##0:wybe.int, ~stride##0:wybe.int, ~tmp#10##0:wybe.int, ?#result##0:wybe.range) #3 @range:33:5

    1:
        foreign llvm add(~end##0:wybe.int, -1:wybe.int, ?tmp#15##0:wybe.int) @int:16:27
        wybe.range.construct<0>(~start##0:wybe.int, ~stride##0:wybe.int, ~tmp#15##0:wybe.int, ?#result##0:wybe.range) #4 @range:33:5



irange#cont#1 > {inline} (2 calls)
0: wybe.range.irange#cont#1<0>
irange#cont#1(end##0:wybe.int, start##0:wybe.int, stride##0:wybe.int, tmp#2##0:wybe.int, ?#result##0:wybe.range)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm add(~end##0:wybe.int, ~tmp#2##0:wybe.int, ?tmp#1##0:wybe.int) @int:16:27
    wybe.range.construct<0>(~start##0:wybe.int, ~stride##0:wybe.int, ~tmp#1##0:wybe.int, ?#result##0:wybe.range) #1 @range:33:5


range > public {inline} (2 calls)
0: wybe.range.range<0>
range(start##0:wybe.int, stride##0:wybe.int, end##0:wybe.int, ?#result##0:wybe.range)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm alloc(24:wybe.int, ?#rec##0:wybe.range) @range:8:17
    foreign lpvm mutate(~#rec##0:wybe.range, ?#rec##1:wybe.range, 0:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~start##0:wybe.int) @range:8:17
    foreign lpvm mutate(~#rec##1:wybe.range, ?#rec##2:wybe.range, 8:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~stride##0:wybe.int) @range:8:17
    foreign lpvm mutate(~#rec##2:wybe.range, ?#result##0:wybe.range, 16:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~end##0:wybe.int) @range:8:17
range > public {inline} (20 calls)
1: wybe.range.range<1>
range(?start##0:wybe.int, ?stride##0:wybe.int, ?end##0:wybe.int, #result##0:wybe.range)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(#result##0:wybe.range, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?start##0:wybe.int) @range:8:17
    foreign lpvm access(#result##0:wybe.range, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?stride##0:wybe.int) @range:8:17
    foreign lpvm access(~#result##0:wybe.range, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?end##0:wybe.int) @range:8:17


size > public (0 calls)
0: wybe.range.size<0>
size(r##0:wybe.range, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(r##0:wybe.range, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?start##0:wybe.int) @range:8:17
    foreign lpvm access(r##0:wybe.range, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?stride##0:wybe.int) @range:8:17
    foreign lpvm access(~r##0:wybe.range, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?end##0:wybe.int) @range:8:17
    foreign c signum(stride##0:wybe.int, ?tmp#1##0:wybe.int) @int:114:25
    foreign llvm sub(end##0:wybe.int, start##0:wybe.int, ?tmp#3##0:wybe.int) @int:25:27
    foreign c signum(tmp#3##0:wybe.int, ?tmp#2##0:wybe.int) @int:114:25
    foreign llvm icmp_ne(~tmp#1##0:wybe.int, ~tmp#2##0:wybe.int, ?tmp#15##0:wybe.bool) @int:84:30
    case ~tmp#15##0:wybe.bool of
    0:
        foreign llvm icmp_sge(stride##0:wybe.int, 0:wybe.int, ?tmp#14##0:wybe.bool) @int:88:30
        case ~tmp#14##0:wybe.bool of
        0:
            foreign llvm sub(~start##0:wybe.int, ~end##0:wybe.int, ?tmp#12##0:wybe.int) @int:25:27
            foreign llvm sub(~tmp#12##0:wybe.int, 1:wybe.int, ?tmp#11##0:wybe.int) @int:25:27
            foreign llvm sub(0:wybe.int, ~stride##0:wybe.int, ?tmp#13##0:wybe.int) @int:31:21
            foreign llvm sdiv(~tmp#11##0:wybe.int, ~tmp#13##0:wybe.int, ?tmp#10##0:wybe.int) @int:44:25
            foreign llvm add(~tmp#10##0:wybe.int, 1:wybe.int, ?#result##0:wybe.int) @int:16:27

        1:
            foreign llvm sub(~tmp#3##0:wybe.int, 1:wybe.int, ?tmp#7##0:wybe.int) @int:25:27
            foreign llvm sdiv(~tmp#7##0:wybe.int, ~stride##0:wybe.int, ?tmp#6##0:wybe.int) @int:44:25
            foreign llvm add(~tmp#6##0:wybe.int, 1:wybe.int, ?#result##0:wybe.int) @int:16:27


    1:
        foreign llvm move(0:wybe.int, ?#result##0:wybe.int) @range:42:5



start > public {inline} (0 calls)
0: wybe.range.start<0>
start(#rec##0:wybe.range, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(~#rec##0:wybe.range, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?#result##0:wybe.int) @range:8:23
start > public {inline} (0 calls)
1: wybe.range.start<1>
start(#rec##0:wybe.range, ?#rec##1:wybe.range, #field##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm {noalias} mutate(~#rec##0:wybe.range, ?#rec##1:wybe.range, 0:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, ~#field##0:wybe.int) @range:8:23


stride > public {inline} (0 calls)
0: wybe.range.stride<0>
stride(#rec##0:wybe.range, ?#result##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(~#rec##0:wybe.range, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?#result##0:wybe.int) @range:8:34
stride > public {inline} (0 calls)
1: wybe.range.stride<1>
stride(#rec##0:wybe.range, ?#rec##1:wybe.range, #field##0:wybe.int)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm {noalias} mutate(~#rec##0:wybe.range, ?#rec##1:wybe.range, 8:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, ~#field##0:wybe.int) @range:8:34


xrange > public {inline} (0 calls)
0: wybe.range.xrange<0>
xrange(start##0:wybe.int, stride##0:wybe.int, end##0:wybe.int, ?#result##0:wybe.range)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.range.construct<0>(~start##0:wybe.int, ~stride##0:wybe.int, ~end##0:wybe.int, ?#result##0:wybe.range) #0 @range:29:5


~= > public {inline} (0 calls)
0: wybe.range.~=<0>
~=(#left##0:wybe.range, #right##0:wybe.range, ?#success##0:wybe.bool)<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(#left##0:wybe.range, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?tmp#3##0:wybe.int) @range:8:17
    foreign lpvm access(#left##0:wybe.range, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?tmp#4##0:wybe.int) @range:8:17
    foreign lpvm access(~#left##0:wybe.range, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?tmp#5##0:wybe.int) @range:8:17
    foreign lpvm access(#right##0:wybe.range, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?tmp#6##0:wybe.int) @range:8:17
    foreign lpvm access(#right##0:wybe.range, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?tmp#7##0:wybe.int) @range:8:17
    foreign lpvm access(~#right##0:wybe.range, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?tmp#8##0:wybe.int) @range:8:17
    foreign llvm icmp_eq(~tmp#3##0:wybe.int, ~tmp#6##0:wybe.int, ?tmp#9##0:wybe.bool) @int:83:29
    case ~tmp#9##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?tmp#0##0:wybe.bool)
        foreign llvm xor(~tmp#0##0:wybe.bool, 1:wybe.bool, ?#success##0:wybe.bool)

    1:
        foreign llvm icmp_eq(~tmp#4##0:wybe.int, ~tmp#7##0:wybe.int, ?tmp#10##0:wybe.bool) @int:83:29
        case ~tmp#10##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?tmp#0##0:wybe.bool)
            foreign llvm xor(~tmp#0##0:wybe.bool, 1:wybe.bool, ?#success##0:wybe.bool)

        1:
            foreign llvm icmp_eq(~tmp#5##0:wybe.int, ~tmp#8##0:wybe.int, ?tmp#0##0:wybe.bool) @int:83:29
            foreign llvm xor(~tmp#0##0:wybe.bool, 1:wybe.bool, ?#success##0:wybe.bool)



LLVM code       : None

--------------------------------------------------
 Module wybe.string
  representation  : address
  public submods  : 
  public resources: 
  public procs    : wybe.string.,,<0>
                    wybe.string.<<0>
                    wybe.string.<=<0>
                    wybe.string.<=><0>
                    wybe.string.=<0>
                    wybe.string.><0>
                    wybe.string.>=<0>
                    wybe.string.[]<0>
                    wybe.string.[]<1>
                    wybe.string.[|]<0>
                    wybe.string.c_string<0>
                    wybe.string.length<0>
                    wybe.string.print<0>
                    wybe.string.println<0>
                    wybe.string.read<0>
                    wybe.string.string<0>
                    wybe.string.string<1>
                    wybe.string.~=<0>
  imports         : use wybe.bool
                    use wybe.c_string
                    use wybe.char
                    use wybe.comparison
                    use wybe.int
                    use wybe.io
                    use wybe.range
  resources       : 
  procs           : 

,, > public (0 calls)
0: ,,(x:_ @string:64:10, y:_ @string:64:17, ?#result:_ @string:64:5):
    if {(   empty(?tmp#1 @string:65:14)
        & =(x @string:65:10, tmp#1))::

        foreign llvm move(y @string:65:23, ?tmp#0)
    else::
        if {(   empty(?tmp#3 @string:66:14)
            & =(y @string:66:10, tmp#3))::

            foreign llvm move(x @string:66:23, ?tmp#2)
        else::
            concat(x @string:67:25, y @string:67:28, ?tmp#4 @string:67:18)
            foreign llvm move(tmp#4, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:66:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:65:10, ?#result @string:64:5)


< > public (0 calls)
0: <(x:_ @string:119:10, y:_ @string:119:17, ?#result:bool @string:119:5):
    <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
    equal(?tmp#2 @string:119:44)
    <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
    foreign llvm move(tmp#0, ?#result @string:119:5)


<= > public (0 calls)
0: <=(x:_ @string:120:10, y:_ @string:120:18, ?#result:bool @string:120:5):
    <=>(x @string:120:31, y @string:120:39, ?tmp#1 @string:120:31)
    equal(?tmp#2 @string:120:46)
    <=(tmp#1, tmp#2, ?tmp#0 @string:120:30)
    foreign llvm move(tmp#0, ?#result @string:120:5)


<=> > public (0 calls)
0: <=>(x:_ @string:125:10, y:_ @string:125:20, ?#result:comparison @string:125:5):
    equal(?tmp#0 @string:126:10)
    =(?c @string:126:6, tmp#0)
    foreign llvm move(x @string:127:16, ?tmp#1)
    foreign llvm move(y @string:127:26, ?tmp#2)
    do {
        if {[|](?cx @string:127:10, ?tmp#1, tmp#1)::

            if {[|](?cy @string:127:20, ?tmp#2, tmp#2)::

                if {<(cx @string:128:14, cy @string:128:19)::

                    lesser(?tmp#3 @string:128:30)
                    =(?c @string:128:26, tmp#3)
                    break
                else::
                    if {>(cx @string:129:14, cy @string:129:19)::

                        greater(?tmp#4 @string:129:30)
                        =(?c @string:129:26, tmp#4)
                        break
                    else::
                        pass

                    }

                }
            else::
                break

            }
        else::
            break

        }
    }
    if {(   equal(?tmp#5 @string:132:14)
        & =(c @string:132:10, tmp#5))::

        length(x @string:133:22, ?tmp#6 @string:133:15)
        =(?lx @string:133:10, tmp#6)
        length(y @string:134:22, ?tmp#7 @string:134:15)
        =(?ly @string:134:10, tmp#7)
        if {<(lx @string:135:14, ly @string:135:19)::

            lesser(?tmp#8 @string:135:30)
            =(?c @string:135:26, tmp#8)
        else::
            if {>(lx @string:135:39, ly @string:135:44)::

                greater(?tmp#9 @string:135:55)
                =(?c @string:135:51, tmp#9)
            else::
                pass

            }

        }
    else::
        pass

    }
    foreign llvm move(c @string:125:38, ?#result @string:125:5)


= > public (0 calls)
0: =(x:_ @string:115:10, y:_ @string:115:17, ?#result:bool @string:115:5):
    <=>(x @string:115:30, y @string:115:38, ?tmp#1 @string:115:30)
    equal(?tmp#2 @string:115:44)
    =(tmp#1, tmp#2, ?tmp#0 @string:115:29)
    foreign llvm move(tmp#0, ?#result @string:115:5)


> > public (0 calls)
0: >(x:_ @string:121:10, y:_ @string:121:17, ?#result:bool @string:121:5):
    <=>(x @string:121:30, y @string:121:38, ?tmp#1 @string:121:30)
    equal(?tmp#2 @string:121:44)
    >(tmp#1, tmp#2, ?tmp#0 @string:121:29)
    foreign llvm move(tmp#0, ?#result @string:121:5)


>= > public (0 calls)
0: >=(x:_ @string:122:10, y:_ @string:122:18, ?#result:bool @string:122:5):
    <=>(x @string:122:31, y @string:122:39, ?tmp#1 @string:122:31)
    equal(?tmp#2 @string:122:46)
    >=(tmp#1, tmp#2, ?tmp#0 @string:122:30)
    foreign llvm move(tmp#0, ?#result @string:122:5)


[] > public {test} (0 calls)
0: [](s:_ @string:91:19, idx:int @string:91:24, ?c:char @string:91:34):
    if {buffer(?len @string:93:17, ?str @string:93:23, s @string:92:10)::

        <=(0 @string:94:14, idx @string:94:20)
        <(idx @string:95:14, len @string:95:20)
        unsafe_c_string_index(str @string:96:35, idx @string:96:40, ?c @string:96:46)
    else::
        if {concat(?left @string:97:17, ?right @string:97:24, s @string:92:10)::

            length(left @string:98:32, ?tmp#0 @string:98:25)
            =(?left_len @string:98:14, tmp#0)
            if {<(idx @string:99:18, left_len @string:99:24)::

                [](left @string:99:41, idx @string:99:46, ?tmp#1 @string:99:41)
                =(?c @string:99:37, tmp#1)
            else::
                -(idx @string:100:37, left_len @string:100:43, ?tmp#3 @string:100:37)
                [](right @string:100:31, tmp#3, ?tmp#2 @string:100:31)
                =(?c @string:100:27, tmp#2)

            }
        else::
            if {slice(?base @string:102:16, ?range @string:102:23, s @string:92:10)::

                [](range @string:102:43, idx @string:102:49, ?tmp#5 @string:102:43)
                [](base @string:102:38, tmp#5, ?tmp#4 @string:102:38)
                =(?c @string:102:34, tmp#4)
            else::
                if {singleton(?c @string:103:20, s @string:92:10)::

                    =(idx @string:103:27, 0 @string:103:33)
                else::
                    fail

                }

            }

        }

    }
[] > public (0 calls)
1: [](s:_ @string:109:12, r:range @string:109:17, ?#result:_ @string:109:5):
    slice(s @string:109:36, r @string:109:39, ?tmp#0 @string:109:30)
    foreign llvm move(tmp#0, ?#result @string:109:5)


[|] > public {test} (0 calls)
0: [|](?head:char @string:71:23, ?tail:_ @string:71:35, s:_ @string:71:43):
    if {buffer(?len @string:73:17, ?str @string:73:23, s @string:72:10)::

        [|](?head @string:74:15, ?str @string:74:23, str @string:74:30)
        if {=(len @string:75:26, 1 @string:75:32)::

            empty(?tmp#1 @string:75:37)
            foreign llvm move(tmp#1, ?tmp#0)
        else::
            -(len @string:75:60, 1 @string:75:66, ?tmp#3 @string:75:60)
            buffer(tmp#3, str @string:75:69, ?tmp#2 @string:75:53)
            foreign llvm move(tmp#2, ?tmp#0)

        }
        =(?tail @string:75:14, tmp#0 @string:75:26)
    else::
        if {concat(?left @string:76:17, ?right @string:76:24, s @string:72:10)::

            if {[|](?head @string:77:20, ?t @string:77:28, left @string:77:33)::

                concat(t @string:77:56, right @string:77:59, ?tmp#4 @string:77:49)
                =(?tail @string:77:42, tmp#4)
            else::
                [|](?head @string:78:28, ?tail @string:78:36, right @string:78:44)

            }
        else::
            if {slice(?base @string:80:16, ?range @string:80:23, s @string:72:10)::

                do {
                    [|](?idx @string:82:19, ?range @string:82:26, range @string:82:35)
                    if {(   [](base @string:83:30, idx @string:83:35, ?tmp#5 @string:83:30)
                        & =(?head @string:83:23, tmp#5))::

                        slice(base @string:83:57, range @string:83:63, ?tmp#6 @string:83:51)
                        =(?tail @string:83:44, tmp#6)
                        break
                    else::
                        pass

                    }
                }
            else::
                if {singleton(?head @string:85:20, s @string:72:10)::

                    empty(?tmp#7 @string:85:37)
                    =(?tail @string:85:30, tmp#7)
                else::
                    fail

                }

            }

        }

    }


base > {test,inline} (0 calls)
0: base(#rec:_ @string:19:20, ?#result:_ @string:19:20):
    (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign lpvm access(#rec:_ @string:19:20, -2, 16, 2, ?#result:_ @string:19:20)
base > {test,inline} (0 calls)
1: base(!#rec:_ @string:19:20, #field:_ @string:19:20):
    (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign lpvm mutate(#rec:_ @string:19:20, ?#rec:_ @string:19:20, -2, 0, 16, 2, #field)


buffer > {inline} (0 calls)
0: buffer(len:int @string:14:21, raw:c_string @string:14:30, ?#result:_ @string:14:14):
    foreign lpvm alloc(16, ?#rec:_ @string:14:14)
    foreign lpvm mutate(#rec:_ @string:14:14, ?#rec:_ @string:14:14, 0, 1, 16, 0, len:int @string:14:21)
    foreign lpvm mutate(#rec:_ @string:14:14, ?#rec:_ @string:14:14, 8, 1, 16, 0, raw:c_string @string:14:30)
    foreign llvm or(#rec:_ @string:14:14, 0, ?#result:_ @string:14:14)
buffer > {test,inline} (0 calls)
1: buffer(?len:int @string:14:21, ?raw:c_string @string:14:30, #result:_ @string:14:14):
    (   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign lpvm access(#result:_ @string:14:14, 0, 16, 0, ?len:int @string:14:21)
    foreign lpvm access(#result:_ @string:14:14, 8, 16, 0, ?raw:c_string @string:14:30)


c > {test,inline} (0 calls)
0: c(#rec:_ @string:21:24, ?#result:char @string:21:24):
    (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign llvm lshr(#rec:_ @string:21:24, 2:_ @string:21:24, ?#rec:_ @string:21:24)
    foreign llvm and(#rec:_ @string:21:24, 255:_ @string:21:24, ?#field:_ @string:21:24)
    foreign lpvm cast(#field:_ @string:21:24, ?#result:char @string:21:24)
c > {test,inline} (0 calls)
1: c(!#rec:_ @string:21:24, #field:char @string:21:24):
    (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign llvm and(#rec:_ @string:21:24, -1021:_ @string:21:24, ?#rec:_ @string:21:24)
    foreign llvm shl(#field:_:!char @string:21:24, 2:!_ @string:21:24, ?#temp:_ @string:21:24)
    foreign llvm or(#temp:_ @string:21:24, #rec:_ @string:21:24, ?#rec:_ @string:21:24)


c_string > public (0 calls)
0: c_string(s:_ @string:40:18, ?#result:c_string @string:40:5):
    if {buffer(?tmp#0 @string:41:21, ?str @string:41:25, s @string:41:10)::

        pass
    else::
        length(s @string:43:27, ?tmp#2 @string:43:20)
        +(tmp#2, 1 @string:43:32, ?tmp#1 @string:43:20)
        =(?len @string:43:14, tmp#1)
        foreign lpvm alloc(len @string:44:32, ?str @string:44:38)
        true(?tmp#3 @string:45:49)
        foreign lpvm mutate(str @string:45:33, ?str @string:45:39, len @string:45:44, tmp#3, len @string:45:55, 0 @string:45:60, '\NUL' @string:45:63)
        =(?offset @string:46:14, 0 @string:46:23)
        pack(s @string:47:18, !str @string:47:22, len @string:47:27, !offset @string:47:33)

    }
    foreign llvm move(str @string:40:34, ?#result @string:40:5)


concat > {inline} (0 calls)
0: concat(left:_ @string:17:21, right:_ @string:17:29, ?#result:_ @string:17:14):
    foreign lpvm alloc(16, ?#rec:_ @string:17:14)
    foreign lpvm mutate(#rec:_ @string:17:14, ?#rec:_ @string:17:14, 0, 1, 16, 0, left:_ @string:17:21)
    foreign lpvm mutate(#rec:_ @string:17:14, ?#rec:_ @string:17:14, 8, 1, 16, 0, right:_ @string:17:29)
    foreign llvm or(#rec:_ @string:17:14, 1, ?#result:_ @string:17:14)
concat > {test,inline} (0 calls)
1: concat(?left:_ @string:17:21, ?right:_ @string:17:29, #result:_ @string:17:14):
    (   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign lpvm access(#result:_ @string:17:14, -1, 16, 1, ?left:_ @string:17:21)
    foreign lpvm access(#result:_ @string:17:14, 7, 16, 1, ?right:_ @string:17:29)


empty > {inline} (0 calls)
0: empty(?#result:_ @string:12:14):
    foreign lpvm cast(0:!_, ?#result)


fixed_range_size > (0 calls)
0: fixed_range_size(hi:int @string:184:22, r:range @string:184:30, ?sz:int @string:184:40):
    range(?start @string:185:16, ?stride @string:185:24, ?end @string:185:33, r @string:185:5)
    if {<=(0 @string:186:10, stride @string:186:16)::

        -(start @string:187:39, ?tmp#4 @string:187:38)
        /(tmp#4, stride @string:187:47, ?tmp#3 @string:187:38)
        *(tmp#3, stride @string:187:56, ?tmp#2 @string:187:38)
        +(start @string:187:30, tmp#2, ?tmp#1 @string:187:30)
        max(start @string:187:23, tmp#1, ?tmp#0 @string:187:19)
        =(?lo @string:187:14, tmp#0)
        min(hi @string:188:23, end @string:188:27, ?tmp#5 @string:188:19)
        =(?hi @string:188:14, tmp#5)
    else::
        max(-1 @string:190:23, end @string:190:27, ?tmp#6 @string:190:19)
        =(?lo @string:190:14, tmp#6)
        +(hi @string:191:30, stride @string:191:35, ?tmp#10 @string:191:30)
        -(start @string:191:45, hi @string:191:53, ?tmp#13 @string:191:45)
        -(tmp#13, 1 @string:191:58, ?tmp#12 @string:191:45)
        -(stride @string:191:64, ?tmp#14 @string:191:63)
        %(tmp#12, tmp#14, ?tmp#11 @string:191:44)
        +(tmp#10, tmp#11, ?tmp#9 @string:191:30)
        +(tmp#9, 1 @string:191:73, ?tmp#8 @string:191:30)
        min(start @string:191:23, tmp#8, ?tmp#7 @string:191:19)
        =(?hi @string:191:14, tmp#7)
        -(stride @string:192:24, ?tmp#15 @string:192:23)
        =(?stride @string:192:14, tmp#15)

    }
    if {<=(hi @string:194:16, lo @string:194:23)::

        foreign llvm move(0 @string:194:29, ?tmp#16)
    else::
        -(hi @string:194:42, lo @string:194:47, ?tmp#20 @string:194:42)
        -(tmp#20, 1 @string:194:52, ?tmp#19 @string:194:42)
        /(tmp#19, stride @string:194:57, ?tmp#18 @string:194:41)
        +(tmp#18, 1 @string:194:66, ?tmp#17 @string:194:41)
        foreign llvm move(tmp#17, ?tmp#16)

    }
    =(?sz @string:194:6, tmp#16 @string:194:16)


left > {test,inline} (0 calls)
0: left(#rec:_ @string:17:21, ?#result:_ @string:17:21):
    (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign lpvm access(#rec:_ @string:17:21, -1, 16, 1, ?#result:_ @string:17:21)
left > {test,inline} (0 calls)
1: left(!#rec:_ @string:17:21, #field:_ @string:17:21):
    (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign lpvm mutate(#rec:_ @string:17:21, ?#rec:_ @string:17:21, -1, 0, 16, 1, #field)


len > {test,inline} (0 calls)
0: len(#rec:_ @string:14:21, ?#result:int @string:14:21):
    (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign lpvm access(#rec:_ @string:14:21, 0, 16, 0, ?#result:int @string:14:21)
len > {test,inline} (0 calls)
1: len(!#rec:_ @string:14:21, #field:int @string:14:21):
    (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign lpvm mutate(#rec:_ @string:14:21, ?#rec:_ @string:14:21, 0, 0, 16, 0, #field)


length > public (0 calls)
0: length(s:_ @string:52:16, ?#result:int @string:52:5):
    if {buffer(?len @string:53:22, ?tmp#1 @string:53:27, s @string:53:10)::

        foreign llvm move(len @string:53:33, ?tmp#0)
    else::
        if {concat(?left @string:54:22, ?right @string:54:29, s @string:54:10)::

            length(left @string:54:46, ?tmp#4 @string:54:39)
            length(right @string:54:61, ?tmp#5 @string:54:54)
            +(tmp#4, tmp#5, ?tmp#3 @string:54:39)
            foreign llvm move(tmp#3, ?tmp#2)
        else::
            if {slice(?base @string:55:21, ?range @string:55:28, s @string:55:10)::

                length(base @string:55:62, ?tmp#8 @string:55:55)
                fixed_range_size(tmp#8, range @string:55:69, ?tmp#7 @string:55:38)
                foreign llvm move(tmp#7, ?tmp#6)
            else::
                if {singleton(?tmp#10 @string:56:24, s @string:56:10)::

                    foreign llvm move(1 @string:56:30, ?tmp#9)
                else::
                    foreign llvm move(0 @string:57:18, ?tmp#9)

                }
                foreign llvm move(tmp#9 @string:56:10, ?tmp#6)

            }
            foreign llvm move(tmp#6 @string:55:10, ?tmp#2)

        }
        foreign llvm move(tmp#2 @string:54:10, ?tmp#0)

    }
    foreign llvm move(tmp#0 @string:53:10, ?#result @string:52:5)


pack > (0 calls)
0: pack(s:_ @string:160:10, !raw:c_string @string:160:16, size:int @string:160:30, !offset:int @string:160:41):
    if {buffer(?tmp#0 @string:162:16, ?str @string:162:20, s @string:161:10)::

        foreign llvm move(str @string:163:23, ?tmp#1)
        do {
            if {[|](?c @string:163:18, ?tmp#1, tmp#1)::

                true(?tmp#2 @string:164:56)
                foreign lpvm mutate(raw @string:164:37, ?raw @string:164:43, offset @string:164:48, tmp#2, size @string:164:62, 0 @string:164:68, c @string:164:71)
                incr(!offset @string:165:23)
            else::
                break

            }
        }
    else::
        if {concat(?left @string:167:17, ?right @string:167:24, s @string:161:10)::

            pack(left @string:168:18, !raw @string:168:25, size @string:168:30, !offset @string:168:37)
            pack(right @string:169:18, !raw @string:169:26, size @string:169:31, !offset @string:169:38)
            incr(!offset @string:170:19)
        else::
            if {slice(?tmp#3 @string:171:15, ?tmp#4 @string:171:18, s @string:161:10)::

                foreign llvm move(s @string:172:23, ?tmp#5)
                do {
                    if {[|](?c @string:172:18, ?tmp#5, tmp#5)::

                        true(?tmp#6 @string:173:56)
                        foreign lpvm mutate(raw @string:173:37, ?raw @string:173:43, offset @string:173:48, tmp#6, size @string:173:62, 0 @string:173:68, c @string:173:71)
                        incr(!offset @string:174:23)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:176:20, s @string:161:10)::

                    true(?tmp#7 @string:177:52)
                    foreign lpvm mutate(raw @string:177:33, ?raw @string:177:39, offset @string:177:44, tmp#7, size @string:177:58, 0 @string:177:64, c @string:177:67)
                    incr(!offset @string:178:19)
                else::
                    fail

                }

            }

        }

    }


print > public (0 calls)
0: print(x:_ @string:142:15) use !io:
    if {buffer(?tmp#0 @string:144:16, ?str @string:144:20, x @string:143:10)::

        !print(str @string:144:35)
    else::
        if {concat(?left @string:145:17, ?right @string:145:24, x @string:143:10)::

            !print(left @string:145:41)
            !print(right @string:145:55)
        else::
            if {slice(?tmp#1 @string:146:15, ?tmp#2 @string:146:18, x @string:143:10)::

                foreign llvm move(x @string:146:34, ?tmp#3)
                do {
                    if {[|](?c @string:146:29, ?tmp#3, tmp#3)::

                        !print(c @string:146:45)
                    else::
                        break

                    }
                }
            else::
                if {singleton(?c @string:147:20, x @string:143:10)::

                    !print(c @string:147:33)
                else::
                    fail

                }

            }

        }

    }


println > public (0 calls)
0: println(x:_ @string:151:17) use !io:
    !print(x @string:151:39)
    !nl


range > {test,inline} (0 calls)
0: range(#rec:_ @string:19:28, ?#result:range @string:19:28):
    (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign lpvm access(#rec:_ @string:19:28, 6, 16, 2, ?#result:range @string:19:28)
range > {test,inline} (0 calls)
1: range(!#rec:_ @string:19:28, #field:range @string:19:28):
    (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign lpvm mutate(#rec:_ @string:19:28, ?#rec:_ @string:19:28, 6, 0, 16, 2, #field)


raw > {test,inline} (0 calls)
0: raw(#rec:_ @string:14:30, ?#result:c_string @string:14:30):
    (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign lpvm access(#rec:_ @string:14:30, 8, 16, 0, ?#result:c_string @string:14:30)
raw > {test,inline} (0 calls)
1: raw(!#rec:_ @string:14:30, #field:c_string @string:14:30):
    (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign lpvm {noalias} mutate(#rec:_ @string:14:30, ?#rec:_ @string:14:30, 8, 0, 16, 0, #field)


read > public (0 calls)
0: read(?x:_ @string:153:15) use !io:
    !read(?str:c_string @string:153:37)
    string(str @string:153:64, ?tmp#0 @string:153:57)
    =(?x @string:153:53, tmp#0)


right > {test,inline} (0 calls)
0: right(#rec:_ @string:17:29, ?#result:_ @string:17:29):
    (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign lpvm access(#rec:_ @string:17:29, 7, 16, 1, ?#result:_ @string:17:29)
right > {test,inline} (0 calls)
1: right(!#rec:_ @string:17:29, #field:_ @string:17:29):
    (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign lpvm mutate(#rec:_ @string:17:29, ?#rec:_ @string:17:29, 7, 0, 16, 1, #field)


singleton > {inline} (0 calls)
0: singleton(c:char @string:21:24, ?#result:_ @string:21:14):
    foreign llvm move(0:_:!wybe.int @string:21:14, ?#result:_ @string:21:14)
    foreign llvm shl(c:_:!char @string:21:24, 2:!_ @string:21:14, ?#temp:_ @string:21:14)
    foreign llvm or(#temp:_ @string:21:14, #result:_ @string:21:14, ?#result:_ @string:21:14)
    foreign llvm or(#result:_ @string:21:14, 1024:_, ?#result:_ @string:21:14)
    foreign llvm or(#result:_ @string:21:14, 3:_, ?#result:_ @string:21:14)
singleton > {test,inline} (0 calls)
1: singleton(?c:char @string:21:24, #result:_ @string:21:14):
    (   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign llvm lshr(#result:_ @string:21:14, 2:_ @string:21:14, ?#temp:_ @string:21:14)
    foreign llvm and(#temp:_ @string:21:14, 255:_ @string:21:14, ?#temp2:_ @string:21:14)
    foreign lpvm cast(#temp2:_ @string:21:14, ?c:char @string:21:24)


slice > {inline} (0 calls)
0: slice(base:_ @string:19:20, range:range @string:19:28, ?#result:_ @string:19:14):
    foreign lpvm alloc(16, ?#rec:_ @string:19:14)
    foreign lpvm mutate(#rec:_ @string:19:14, ?#rec:_ @string:19:14, 0, 1, 16, 0, base:_ @string:19:20)
    foreign lpvm mutate(#rec:_ @string:19:14, ?#rec:_ @string:19:14, 8, 1, 16, 0, range:range @string:19:28)
    foreign llvm or(#rec:_ @string:19:14, 2, ?#result:_ @string:19:14)
slice > {test,inline} (0 calls)
1: slice(?base:_ @string:19:20, ?range:range @string:19:28, #result:_ @string:19:14):
    (   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
    & testbool tmp#0:!wybe.bool
    & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
    & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
    & testbool tmp#1:!wybe.bool)
    foreign lpvm access(#result:_ @string:19:14, -2, 16, 2, ?base:_ @string:19:20)
    foreign lpvm access(#result:_ @string:19:14, 6, 16, 2, ?range:range @string:19:28)


string > public (0 calls)
0: string(str:c_string @string:28:16, ?#result:_ @string:28:5):
    length(str @string:29:19, ?tmp#0 @string:29:12)
    =(?len @string:29:6, tmp#0)
    if {=(len @string:30:15, 0 @string:30:21)::

        empty(?tmp#2 @string:30:26)
        foreign llvm move(tmp#2, ?tmp#1)
    else::
        if {=(len @string:31:15, 1 @string:31:21)::

            foreign lpvm access(str @string:31:56, 0 @string:31:61, 1 @string:31:64, 0 @string:31:67, ?tmp#5 @string:31:36)
            singleton(tmp#5, ?tmp#4 @string:31:26)
            foreign llvm move(tmp#4, ?tmp#3)
        else::
            buffer(len @string:32:33, str @string:32:38, ?tmp#6 @string:32:26)
            foreign llvm move(tmp#6, ?tmp#3)

        }
        foreign llvm move(tmp#3 @string:31:15, ?tmp#1)

    }
    =(?s @string:30:6, tmp#1 @string:30:15)
    foreign llvm move(s @string:28:34, ?#result @string:28:5)
string > public (0 calls)
1: string(c:char @string:37:16, ?#result:_ @string:37:5):
    singleton(c @string:37:38, ?tmp#0 @string:37:28)
    foreign llvm move(tmp#0, ?#result @string:37:5)


~= > public (0 calls)
0: ~=(x:_ @string:116:10, y:_ @string:116:18, ?#result:bool @string:116:5):
    <=>(x @string:116:31, y @string:116:39, ?tmp#1 @string:116:31)
    equal(?tmp#2 @string:116:46)
    ~=(tmp#1, tmp#2, ?tmp#0 @string:116:30)
    foreign llvm move(tmp#0, ?#result @string:116:5)

LLVM code       : None

Types: **** Validating parameter types in module wybe.string
Types: Validating def of ,,
Types: Checking type _ of param x:_
Types: Param is x:wybe.string
Types: Checking type _ of param y:_
Types: Param is y:wybe.string
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.string
Types: Validating def of <
Types: Checking type _ of param x:_
Types: Param is x:wybe.string
Types: Checking type _ of param y:_
Types: Param is y:wybe.string
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of <=
Types: Checking type _ of param x:_
Types: Param is x:wybe.string
Types: Checking type _ of param y:_
Types: Param is y:wybe.string
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of <=>
Types: Checking type _ of param x:_
Types: Param is x:wybe.string
Types: Checking type _ of param y:_
Types: Param is y:wybe.string
Types: Checking type comparison of param ?#result:comparison
Types: Param is ?#result:wybe.comparison
Types: Validating def of =
Types: Checking type _ of param x:_
Types: Param is x:wybe.string
Types: Checking type _ of param y:_
Types: Param is y:wybe.string
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of >
Types: Checking type _ of param x:_
Types: Param is x:wybe.string
Types: Checking type _ of param y:_
Types: Param is y:wybe.string
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of >=
Types: Checking type _ of param x:_
Types: Param is x:wybe.string
Types: Checking type _ of param y:_
Types: Param is y:wybe.string
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: Validating def of []
Types: Checking type _ of param s:_
Types: Param is s:wybe.string
Types: Checking type int of param idx:int
Types: Param is idx:wybe.int
Types: Checking type char of param ?c:char
Types: Param is ?c:wybe.char
Types: Validating def of []
Types: Checking type _ of param s:_
Types: Param is s:wybe.string
Types: Checking type range of param r:range
Types: Param is r:wybe.range
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.string
Types: Validating def of [|]
Types: Checking type char of param ?head:char
Types: Param is ?head:wybe.char
Types: Checking type _ of param ?tail:_
Types: Param is ?tail:wybe.string
Types: Checking type _ of param s:_
Types: Param is s:wybe.string
Types: Validating def of base
Types: Checking type _ of param #rec:_
Types: Param is #rec:wybe.string
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.string
Types: Validating def of base
Types: Checking type _ of param !#rec:_
Types: Param is !#rec:wybe.string
Types: Checking type _ of param #field:_
Types: Param is #field:wybe.string
Types: Validating def of buffer
Types: Checking type int of param len:int
Types: Param is len:wybe.int
Types: Checking type c_string of param raw:c_string
Types: Param is raw:wybe.c_string
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.string
Types: Validating def of buffer
Types: Checking type int of param ?len:int
Types: Param is ?len:wybe.int
Types: Checking type c_string of param ?raw:c_string
Types: Param is ?raw:wybe.c_string
Types: Checking type _ of param #result:_
Types: Param is #result:wybe.string
Types: Validating def of c
Types: Checking type _ of param #rec:_
Types: Param is #rec:wybe.string
Types: Checking type char of param ?#result:char
Types: Param is ?#result:wybe.char
Types: Validating def of c
Types: Checking type _ of param !#rec:_
Types: Param is !#rec:wybe.string
Types: Checking type char of param #field:char
Types: Param is #field:wybe.char
Types: Validating def of c_string
Types: Checking type _ of param s:_
Types: Param is s:wybe.string
Types: Checking type c_string of param ?#result:c_string
Types: Param is ?#result:wybe.c_string
Types: Validating def of concat
Types: Checking type _ of param left:_
Types: Param is left:wybe.string
Types: Checking type _ of param right:_
Types: Param is right:wybe.string
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.string
Types: Validating def of concat
Types: Checking type _ of param ?left:_
Types: Param is ?left:wybe.string
Types: Checking type _ of param ?right:_
Types: Param is ?right:wybe.string
Types: Checking type _ of param #result:_
Types: Param is #result:wybe.string
Types: Validating def of empty
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.string
Types: Validating def of fixed_range_size
Types: Checking type int of param hi:int
Types: Param is hi:wybe.int
Types: Checking type range of param r:range
Types: Param is r:wybe.range
Types: Checking type int of param ?sz:int
Types: Param is ?sz:wybe.int
Types: Validating def of left
Types: Checking type _ of param #rec:_
Types: Param is #rec:wybe.string
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.string
Types: Validating def of left
Types: Checking type _ of param !#rec:_
Types: Param is !#rec:wybe.string
Types: Checking type _ of param #field:_
Types: Param is #field:wybe.string
Types: Validating def of len
Types: Checking type _ of param #rec:_
Types: Param is #rec:wybe.string
Types: Checking type int of param ?#result:int
Types: Param is ?#result:wybe.int
Types: Validating def of len
Types: Checking type _ of param !#rec:_
Types: Param is !#rec:wybe.string
Types: Checking type int of param #field:int
Types: Param is #field:wybe.int
Types: Validating def of length
Types: Checking type _ of param s:_
Types: Param is s:wybe.string
Types: Checking type int of param ?#result:int
Types: Param is ?#result:wybe.int
Types: Validating def of pack
Types: Checking type _ of param s:_
Types: Param is s:wybe.string
Types: Checking type c_string of param !raw:c_string
Types: Param is !raw:wybe.c_string
Types: Checking type int of param size:int
Types: Param is size:wybe.int
Types: Checking type int of param !offset:int
Types: Param is !offset:wybe.int
Types: Validating def of print
Types: Checking type _ of param x:_
Types: Param is x:wybe.string
Types: Validating def of println
Types: Checking type _ of param x:_
Types: Param is x:wybe.string
Types: Validating def of range
Types: Checking type _ of param #rec:_
Types: Param is #rec:wybe.string
Types: Checking type range of param ?#result:range
Types: Param is ?#result:wybe.range
Types: Validating def of range
Types: Checking type _ of param !#rec:_
Types: Param is !#rec:wybe.string
Types: Checking type range of param #field:range
Types: Param is #field:wybe.range
Types: Validating def of raw
Types: Checking type _ of param #rec:_
Types: Param is #rec:wybe.string
Types: Checking type c_string of param ?#result:c_string
Types: Param is ?#result:wybe.c_string
Types: Validating def of raw
Types: Checking type _ of param !#rec:_
Types: Param is !#rec:wybe.string
Types: Checking type c_string of param #field:c_string
Types: Param is #field:wybe.c_string
Types: Validating def of read
Types: Checking type _ of param ?x:_
Types: Param is ?x:wybe.string
Types: Validating def of right
Types: Checking type _ of param #rec:_
Types: Param is #rec:wybe.string
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.string
Types: Validating def of right
Types: Checking type _ of param !#rec:_
Types: Param is !#rec:wybe.string
Types: Checking type _ of param #field:_
Types: Param is #field:wybe.string
Types: Validating def of singleton
Types: Checking type char of param c:char
Types: Param is c:wybe.char
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.string
Types: Validating def of singleton
Types: Checking type char of param ?c:char
Types: Param is ?c:wybe.char
Types: Checking type _ of param #result:_
Types: Param is #result:wybe.string
Types: Validating def of slice
Types: Checking type _ of param base:_
Types: Param is base:wybe.string
Types: Checking type range of param range:range
Types: Param is range:wybe.range
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.string
Types: Validating def of slice
Types: Checking type _ of param ?base:_
Types: Param is ?base:wybe.string
Types: Checking type range of param ?range:range
Types: Param is ?range:wybe.range
Types: Checking type _ of param #result:_
Types: Param is #result:wybe.string
Types: Validating def of string
Types: Checking type c_string of param str:c_string
Types: Param is str:wybe.c_string
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.string
Types: Validating def of string
Types: Checking type char of param c:char
Types: Param is c:wybe.char
Types: Checking type _ of param ?#result:_
Types: Param is ?#result:wybe.string
Types: Validating def of ~=
Types: Checking type _ of param x:_
Types: Param is x:wybe.string
Types: Checking type _ of param y:_
Types: Param is y:wybe.string
Types: Checking type bool of param ?#result:bool
Types: Param is ?#result:wybe.bool
Types: **** Re-exiting module wybe.string
Types: **** Type checking modules wybe.string
Types: **** Strongly connected components:
Types:     wybe.string.slice
Types:     wybe.string.singleton
Types:     wybe.string.right
Types:     wybe.string.raw
Types:     wybe.string.range
Types:     wybe.string.len
Types:     wybe.string.left
Types:     wybe.string.empty
Types:     wybe.string.concat
Types:     wybe.string.c
Types:     wybe.string.buffer
Types:     wybe.string.base
Types:     wybe.string.<, wybe.string.<=>, wybe.string.=, wybe.string.>, wybe.string.[|], wybe.string.[], wybe.string.<=, wybe.string.length, wybe.string.fixed_range_size
Types:     wybe.string.string
Types:     wybe.string.read
Types:     wybe.string.>=
Types:     wybe.string.~=
Types:     wybe.string.pack
Types:     wybe.string.c_string
Types:     wybe.string.print
Types:     wybe.string.println
Types:     wybe.string.,,
Types: Type checking non-recursive proc wybe.string.slice
Types: ** Type checking decl of proc slice
Types: found 2 definition(s)
Types: Type checking slice
Types: ** Type checking slice: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm alloc(16, ?#rec:_ @string:19:14)
Types:         foreign lpvm mutate(#rec:_ @string:19:14, ?#rec:_ @string:19:14, 0, 1, 16, 0, base:_ @string:19:20)
Types:         foreign lpvm mutate(#rec:_ @string:19:14, ?#rec:_ @string:19:14, 8, 1, 16, 0, range:range @string:19:28)
Types:         foreign llvm or(#rec:_ @string:19:14, 2, ?#result:_ @string:19:14)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#rec","#result","base","range"]
Types: Recording parameter types: base:wybe.string, range:wybe.range, ?#result:wybe.string
Types:     type of 'base' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable base type constrained to wybe.string
Types:     type of 'range' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable range type constrained to wybe.range
Types:     type of '#result' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm alloc(16, ?#rec:_ @string:19:14)}
Types: Unifying types _ (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Recording casts in {foreign lpvm mutate(#rec:_ @string:19:14, ?#rec:_ @string:19:14, 0, 1, 16, 0, base:_ @string:19:20)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable base type constrained to wybe.string
Types: Recording casts in {foreign lpvm mutate(#rec:_ @string:19:14, ?#rec:_ @string:19:14, 8, 1, 16, 0, range:range @string:19:28)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable range type constrained to wybe.range
Types: Recording casts in {foreign llvm or(#rec:_ @string:19:14, 2, ?#result:_ @string:19:14)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: *** Before calls Typing {#rec::wybe.string, #result::wybe.string, base::wybe.string, range::wybe.range}; {} (with no errors)
Types:   With calls:
Types:   Typing {#rec::wybe.string, #result::wybe.string, base::wybe.string, range::wybe.range}; {} (with no errors)
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr ?#rec:_ @string:19:14
Types:   Type = wybe.string
Types: Type checking foreign lpvm call alloc(64 bit signed, address)
Types: Finding type of expr #rec:_ @string:19:14
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:19:14
Types:   Type = wybe.string
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr base:_ @string:19:20
Types:   Type = wybe.string
Types: Type checking foreign lpvm call mutate(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Finding type of expr #rec:_ @string:19:14
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:19:14
Types:   Type = wybe.string
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr range:range @string:19:28
Types:   Type = wybe.range
Types: Type checking foreign lpvm call mutate(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Finding type of expr #rec:_ @string:19:14
Types:   Type = wybe.string
Types: Finding type of expr 2
Types:   Type = wybe.int
Types: Finding type of expr ?#result:_ @string:19:14
Types:   Type = wybe.string
Types: Type checking foreign llvm call or(address, 64 bit signed, address)
Types: Now mode checking proc slice
Types: bound vars: semipure normal (total) computation binding {base, range}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm alloc(16, ?#rec:_ @string:19:14)
Types: Mode checking foreign call {foreign lpvm alloc(16, ?#rec:_ @string:19:14)}
Types:     with assigned semipure normal (total) computation binding {base, range}, break set = Everything, with resources {}
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr ?#rec:_ @string:19:14
Types:   Type = wybe.string
Types:     types and modes = [wybe.int,?wybe.string]
Types: New instr = {foreign lpvm alloc(16:wybe.int, ?#rec:wybe.string @string:19:14)}
Types: Now assigned = semipure normal (total) computation binding {#rec, base, range}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm mutate(#rec:_ @string:19:14, ?#rec:_ @string:19:14, 0, 1, 16, 0, base:_ @string:19:20)
Types: Mode checking foreign call {foreign lpvm mutate(#rec:_ @string:19:14, ?#rec:_ @string:19:14, 0, 1, 16, 0, base:_ @string:19:20)}
Types:     with assigned semipure normal (total) computation binding {#rec, base, range}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp base:_
Types: Mode check exp resulted in base:_
Types: Finding type of expr #rec:_ @string:19:14
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:19:14
Types:   Type = wybe.string
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr base:_ @string:19:20
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,?wybe.string,wybe.int,wybe.int,wybe.int,wybe.int,wybe.string]
Types: New instr = {foreign lpvm mutate(#rec:wybe.string @string:19:14, ?#rec:wybe.string @string:19:14, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, base:wybe.string @string:19:20)}
Types: Now assigned = semipure normal (total) computation binding {#rec, base, range}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm mutate(#rec:_ @string:19:14, ?#rec:_ @string:19:14, 8, 1, 16, 0, range:range @string:19:28)
Types: Mode checking foreign call {foreign lpvm mutate(#rec:_ @string:19:14, ?#rec:_ @string:19:14, 8, 1, 16, 0, range:range @string:19:28)}
Types:     with assigned semipure normal (total) computation binding {#rec, base, range}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp 8
Types: Mode check exp resulted in 8
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp range:range
Types: Mode check exp resulted in range:range
Types: Finding type of expr #rec:_ @string:19:14
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:19:14
Types:   Type = wybe.string
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr range:range @string:19:28
Types:   Type = wybe.range
Types:     types and modes = [wybe.string,?wybe.string,wybe.int,wybe.int,wybe.int,wybe.int,wybe.range]
Types: New instr = {foreign lpvm mutate(#rec:wybe.string @string:19:14, ?#rec:wybe.string @string:19:14, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, range:wybe.range @string:19:28)}
Types: Now assigned = semipure normal (total) computation binding {#rec, base, range}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm or(#rec:_ @string:19:14, 2, ?#result:_ @string:19:14)
Types: Mode checking foreign call {foreign llvm or(#rec:_ @string:19:14, 2, ?#result:_ @string:19:14)}
Types:     with assigned semipure normal (total) computation binding {#rec, base, range}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp 2
Types: Mode check exp resulted in 2
Types: Mode check exp ?#result:_
Types: Mode check exp resulted in ?#result:_
Types: Finding type of expr #rec:_ @string:19:14
Types:   Type = wybe.string
Types: Finding type of expr 2
Types:   Type = wybe.int
Types: Finding type of expr ?#result:_ @string:19:14
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.int,?wybe.string]
Types: New instr = {foreign llvm or(#rec:wybe.string @string:19:14, 2:wybe.int, ?#result:wybe.string @string:19:14)}
Types: Now assigned = semipure normal (total) computation binding {#rec, #result, base, range}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'slice'
Types: Mode checked body   : [{foreign lpvm alloc(16:wybe.int, ?#rec:wybe.string @string:19:14)} @string:19:14,{foreign lpvm mutate(#rec:wybe.string @string:19:14, ?#rec:wybe.string @string:19:14, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, base:wybe.string @string:19:20)} @string:19:14,{foreign lpvm mutate(#rec:wybe.string @string:19:14, ?#rec:wybe.string @string:19:14, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, range:wybe.range @string:19:28)} @string:19:14,{foreign llvm or(#rec:wybe.string @string:19:14, 2:wybe.int, ?#result:wybe.string @string:19:14)} @string:19:14]
Types: Vars defined by body: semipure normal (total) computation binding {#rec, #result, base, range}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking slice
Types: ** Type checking slice: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign lpvm access(#result:_ @string:19:14, -2, 16, 2, ?base:_ @string:19:20)
Types:         foreign lpvm access(#result:_ @string:19:14, 6, 16, 2, ?range:range @string:19:28)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","base","range","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: ?base:wybe.string, ?range:wybe.range, #result:wybe.string
Types:     type of 'base' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable base type constrained to wybe.string
Types:     type of 'range' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable range type constrained to wybe.range
Types:     type of '#result' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign lpvm access(#result:_ @string:19:14, -2, 16, 2, ?base:_ @string:19:20)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable base type constrained to wybe.string
Types: Recording casts in {foreign lpvm access(#result:_ @string:19:14, 6, 16, 2, ?range:range @string:19:28)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable range type constrained to wybe.range
Types: *** Before calls Typing {#result::wybe.string, base::wybe.string, range::wybe.range, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.string, base::wybe.string, range::wybe.range, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #result:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #result:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #result:_ @string:19:14
Types:   Type = wybe.string
Types: Finding type of expr -2
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 2
Types:   Type = wybe.int
Types: Finding type of expr ?base:_ @string:19:20
Types:   Type = wybe.string
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Finding type of expr #result:_ @string:19:14
Types:   Type = wybe.string
Types: Finding type of expr 6
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 2
Types:   Type = wybe.int
Types: Finding type of expr ?range:range @string:19:28
Types:   Type = wybe.range
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Now mode checking proc slice
Types: bound vars: semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check exp #result:!wybe.int
Types: Mode check exp resulted in #result:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #result:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#result, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#result, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #result:!wybe.int
Types: Mode check exp resulted in #result:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #result:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#result, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#result, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 2:!wybe.int
Types: Mode check exp resulted in 2:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'slice'
Types: Now assigned = semipure test computation binding {#result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#result:_ @string:19:14, -2, 16, 2, ?base:_ @string:19:20)
Types: Mode checking foreign call {foreign lpvm access(#result:_ @string:19:14, -2, 16, 2, ?base:_ @string:19:20)}
Types:     with assigned semipure test computation binding {#result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #result:_
Types: Mode check exp resulted in #result:_
Types: Mode check exp -2
Types: Mode check exp resulted in -2
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 2
Types: Mode check exp resulted in 2
Types: Mode check exp ?base:_
Types: Mode check exp resulted in ?base:_
Types: Finding type of expr #result:_ @string:19:14
Types:   Type = wybe.string
Types: Finding type of expr -2
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 2
Types:   Type = wybe.int
Types: Finding type of expr ?base:_ @string:19:20
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.int,wybe.int,wybe.int,?wybe.string]
Types: New instr = {foreign lpvm access(#result:wybe.string @string:19:14, -2:wybe.int, 16:wybe.int, 2:wybe.int, ?base:wybe.string @string:19:20)}
Types: Now assigned = semipure test computation binding {#result, base, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#result:_ @string:19:14, 6, 16, 2, ?range:range @string:19:28)
Types: Mode checking foreign call {foreign lpvm access(#result:_ @string:19:14, 6, 16, 2, ?range:range @string:19:28)}
Types:     with assigned semipure test computation binding {#result, base, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #result:_
Types: Mode check exp resulted in #result:_
Types: Mode check exp 6
Types: Mode check exp resulted in 6
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 2
Types: Mode check exp resulted in 2
Types: Mode check exp ?range:range
Types: Mode check exp resulted in ?range:range
Types: Finding type of expr #result:_ @string:19:14
Types:   Type = wybe.string
Types: Finding type of expr 6
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 2
Types:   Type = wybe.int
Types: Finding type of expr ?range:range @string:19:28
Types:   Type = wybe.range
Types:     types and modes = [wybe.string,wybe.int,wybe.int,wybe.int,?wybe.range]
Types: New instr = {foreign lpvm access(#result:wybe.string @string:19:14, 6:wybe.int, 16:wybe.int, 2:wybe.int, ?range:wybe.range @string:19:28)}
Types: Now assigned = semipure test computation binding {#result, base, range, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'slice'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign lpvm access(#result:wybe.string @string:19:14, -2:wybe.int, 16:wybe.int, 2:wybe.int, ?base:wybe.string @string:19:20)} @string:19:14,{foreign lpvm access(#result:wybe.string @string:19:14, 6:wybe.int, 16:wybe.int, 2:wybe.int, ?range:wybe.range @string:19:28)} @string:19:14]
Types: Vars defined by body: semipure test computation binding {#result, base, range, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : base, range
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of slice:
Types: 
Types: slice > {inline} (0 calls)
Types: 4: slice(base:wybe.string @string:19:20, range:wybe.range @string:19:28, ?#result:wybe.string @string:19:14):
Types:     foreign lpvm alloc(16:wybe.int, ?#rec:wybe.string @string:19:14)
Types:     foreign lpvm mutate(#rec:wybe.string @string:19:14, ?#rec:wybe.string @string:19:14, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, base:wybe.string @string:19:20)
Types:     foreign lpvm mutate(#rec:wybe.string @string:19:14, ?#rec:wybe.string @string:19:14, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, range:wybe.range @string:19:28)
Types:     foreign llvm or(#rec:wybe.string @string:19:14, 2:wybe.int, ?#result:wybe.string @string:19:14)
Types: 
Types: slice > {test,inline} (0 calls)
Types: 4: slice(?base:wybe.string @string:19:20, ?range:wybe.range @string:19:28, #result:wybe.string @string:19:14):
Types:     (   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign lpvm access(#result:wybe.string @string:19:14, -2:wybe.int, 16:wybe.int, 2:wybe.int, ?base:wybe.string @string:19:20)
Types:     foreign lpvm access(#result:wybe.string @string:19:14, 6:wybe.int, 16:wybe.int, 2:wybe.int, ?range:wybe.range @string:19:28)
Types: Type checking non-recursive proc wybe.string.singleton
Types: ** Type checking decl of proc singleton
Types: found 2 definition(s)
Types: Type checking singleton
Types: ** Type checking singleton: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign llvm move(0:_:!wybe.int @string:21:14, ?#result:_ @string:21:14)
Types:         foreign llvm shl(c:_:!char @string:21:24, 2:!_ @string:21:14, ?#temp:_ @string:21:14)
Types:         foreign llvm or(#temp:_ @string:21:14, #result:_ @string:21:14, ?#result:_ @string:21:14)
Types:         foreign llvm or(#result:_ @string:21:14, 1024:_, ?#result:_ @string:21:14)
Types:         foreign llvm or(#result:_ @string:21:14, 3:_, ?#result:_ @string:21:14)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","#temp","c"]
Types: Recording parameter types: c:wybe.char, ?#result:wybe.string
Types:     type of 'c' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable c type constrained to wybe.char
Types:     type of '#result' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Recording resource types: 
Types: Recording casts in {foreign llvm move(0:_:!wybe.int @string:21:14, ?#result:_ @string:21:14)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying move argument types 0:_:!wybe.int @string:21:14 and ?#result:_ @string:21:14
Types: Finding type of expr 0:_:!wybe.int @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr ?#result:_ @string:21:14
Types:   Type = wybe.string
Types: Unifying types wybe.string (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Recording casts in {foreign llvm shl(c:_:!char @string:21:24, 2:!_ @string:21:14, ?#temp:_ @string:21:14)}
Types: Unifying types char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Variable c type constrained to wybe.char
Types: Unifying types _ (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #temp type constrained to wybe.string
Types: Recording casts in {foreign llvm or(#temp:_ @string:21:14, #result:_ @string:21:14, ?#result:_ @string:21:14)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #temp type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Recording casts in {foreign llvm or(#result:_ @string:21:14, 1024:_, ?#result:_ @string:21:14)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Recording casts in {foreign llvm or(#result:_ @string:21:14, 3:_, ?#result:_ @string:21:14)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: *** Before calls Typing {#result::wybe.string, #temp::wybe.string, c::wybe.char}; {} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.string, #temp::wybe.string, c::wybe.char}; {} (with no errors)
Types: Finding type of expr 0:_:!wybe.int @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr ?#result:_ @string:21:14
Types:   Type = wybe.string
Types: Type checking foreign llvm call move(address, address)
Types: Finding type of expr c:_:!char @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr 2:!_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr ?#temp:_ @string:21:14
Types:   Type = wybe.string
Types: Type checking foreign llvm call shl(address, address, address)
Types: Finding type of expr #temp:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr #result:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr ?#result:_ @string:21:14
Types:   Type = wybe.string
Types: Type checking foreign llvm call or(address, address, address)
Types: Finding type of expr #result:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr 1024:_
Types:   Type = wybe.string
Types: Finding type of expr ?#result:_ @string:21:14
Types:   Type = wybe.string
Types: Type checking foreign llvm call or(address, address, address)
Types: Finding type of expr #result:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr 3:_
Types:   Type = wybe.string
Types: Finding type of expr ?#result:_ @string:21:14
Types:   Type = wybe.string
Types: Type checking foreign llvm call or(address, address, address)
Types: Now mode checking proc singleton
Types: bound vars: semipure normal (total) computation binding {c}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(0:_:!wybe.int @string:21:14, ?#result:_ @string:21:14)
Types: Mode checking foreign call {foreign llvm move(0:_:!wybe.int @string:21:14, ?#result:_ @string:21:14)}
Types:     with assigned semipure normal (total) computation binding {c}, break set = Everything, with resources {}
Types: Mode check exp 0:_:!wybe.int
Types: Mode check exp resulted in 0:_:!wybe.int
Types: Mode check exp ?#result:_
Types: Mode check exp resulted in ?#result:_
Types: Finding type of expr 0:_:!wybe.int @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr ?#result:_ @string:21:14
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,?wybe.string]
Types: New instr = {foreign llvm move(0:wybe.string:!wybe.int @string:21:14, ?#result:wybe.string @string:21:14)}
Types: Now assigned = semipure normal (total) computation binding {#result, c}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm shl(c:_:!char @string:21:24, 2:!_ @string:21:14, ?#temp:_ @string:21:14)
Types: Mode checking foreign call {foreign llvm shl(c:_:!char @string:21:24, 2:!_ @string:21:14, ?#temp:_ @string:21:14)}
Types:     with assigned semipure normal (total) computation binding {#result, c}, break set = Everything, with resources {}
Types: Mode check exp c:_:!char
Types: Mode check exp resulted in c:_:!char
Types: Mode check exp 2:!_
Types: Mode check exp resulted in 2:!_
Types: Mode check exp ?#temp:_
Types: Mode check exp resulted in ?#temp:_
Types: Finding type of expr c:_:!char @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr 2:!_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr ?#temp:_ @string:21:14
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.string,?wybe.string]
Types: New instr = {foreign llvm shl(c:wybe.string:!char @string:21:24, 2:!wybe.string @string:21:14, ?#temp:wybe.string @string:21:14)}
Types: Now assigned = semipure normal (total) computation binding {#result, #temp, c}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm or(#temp:_ @string:21:14, #result:_ @string:21:14, ?#result:_ @string:21:14)
Types: Mode checking foreign call {foreign llvm or(#temp:_ @string:21:14, #result:_ @string:21:14, ?#result:_ @string:21:14)}
Types:     with assigned semipure normal (total) computation binding {#result, #temp, c}, break set = Everything, with resources {}
Types: Mode check exp #temp:_
Types: Mode check exp resulted in #temp:_
Types: Mode check exp #result:_
Types: Mode check exp resulted in #result:_
Types: Mode check exp ?#result:_
Types: Mode check exp resulted in ?#result:_
Types: Finding type of expr #temp:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr #result:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr ?#result:_ @string:21:14
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.string,?wybe.string]
Types: New instr = {foreign llvm or(#temp:wybe.string @string:21:14, #result:wybe.string @string:21:14, ?#result:wybe.string @string:21:14)}
Types: Now assigned = semipure normal (total) computation binding {#result, #temp, c}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm or(#result:_ @string:21:14, 1024:_, ?#result:_ @string:21:14)
Types: Mode checking foreign call {foreign llvm or(#result:_ @string:21:14, 1024:_, ?#result:_ @string:21:14)}
Types:     with assigned semipure normal (total) computation binding {#result, #temp, c}, break set = Everything, with resources {}
Types: Mode check exp #result:_
Types: Mode check exp resulted in #result:_
Types: Mode check exp 1024:_
Types: Mode check exp resulted in 1024:_
Types: Mode check exp ?#result:_
Types: Mode check exp resulted in ?#result:_
Types: Finding type of expr #result:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr 1024:_
Types:   Type = wybe.string
Types: Finding type of expr ?#result:_ @string:21:14
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.string,?wybe.string]
Types: New instr = {foreign llvm or(#result:wybe.string @string:21:14, 1024:wybe.string, ?#result:wybe.string @string:21:14)}
Types: Now assigned = semipure normal (total) computation binding {#result, #temp, c}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm or(#result:_ @string:21:14, 3:_, ?#result:_ @string:21:14)
Types: Mode checking foreign call {foreign llvm or(#result:_ @string:21:14, 3:_, ?#result:_ @string:21:14)}
Types:     with assigned semipure normal (total) computation binding {#result, #temp, c}, break set = Everything, with resources {}
Types: Mode check exp #result:_
Types: Mode check exp resulted in #result:_
Types: Mode check exp 3:_
Types: Mode check exp resulted in 3:_
Types: Mode check exp ?#result:_
Types: Mode check exp resulted in ?#result:_
Types: Finding type of expr #result:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr 3:_
Types:   Type = wybe.string
Types: Finding type of expr ?#result:_ @string:21:14
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.string,?wybe.string]
Types: New instr = {foreign llvm or(#result:wybe.string @string:21:14, 3:wybe.string, ?#result:wybe.string @string:21:14)}
Types: Now assigned = semipure normal (total) computation binding {#result, #temp, c}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'singleton'
Types: Mode checked body   : [{foreign llvm move(0:wybe.string:!wybe.int @string:21:14, ?#result:wybe.string @string:21:14)} @string:21:14,{foreign llvm shl(c:wybe.string:!char @string:21:24, 2:!wybe.string @string:21:14, ?#temp:wybe.string @string:21:14)} @string:21:14,{foreign llvm or(#temp:wybe.string @string:21:14, #result:wybe.string @string:21:14, ?#result:wybe.string @string:21:14)} @string:21:14,{foreign llvm or(#result:wybe.string @string:21:14, 1024:wybe.string, ?#result:wybe.string @string:21:14)} @string:21:14,{foreign llvm or(#result:wybe.string @string:21:14, 3:wybe.string, ?#result:wybe.string @string:21:14)} @string:21:14]
Types: Vars defined by body: semipure normal (total) computation binding {#result, #temp, c}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking singleton
Types: ** Type checking singleton: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign llvm lshr(#result:_ @string:21:14, 2:_ @string:21:14, ?#temp:_ @string:21:14)
Types:         foreign llvm and(#temp:_ @string:21:14, 255:_ @string:21:14, ?#temp2:_ @string:21:14)
Types:         foreign lpvm cast(#temp2:_ @string:21:14, ?c:char @string:21:24)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","#temp","#temp2","c","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: ?c:wybe.char, #result:wybe.string
Types:     type of 'c' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable c type constrained to wybe.char
Types:     type of '#result' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign llvm lshr(#result:_ @string:21:14, 2:_ @string:21:14, ?#temp:_ @string:21:14)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #temp type constrained to wybe.string
Types: Recording casts in {foreign llvm and(#temp:_ @string:21:14, 255:_ @string:21:14, ?#temp2:_ @string:21:14)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #temp type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #temp2 type constrained to wybe.string
Types: Recording casts in {foreign lpvm cast(#temp2:_ @string:21:14, ?c:char @string:21:24)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #temp2 type constrained to wybe.string
Types: Unifying types char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Variable c type constrained to wybe.char
Types: *** Before calls Typing {#result::wybe.string, #temp::wybe.string, #temp2::wybe.string, c::wybe.char, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.string, #temp::wybe.string, #temp2::wybe.string, c::wybe.char, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #result:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #result:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #result:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr 2:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr ?#temp:_ @string:21:14
Types:   Type = wybe.string
Types: Type checking foreign llvm call lshr(address, address, address)
Types: Finding type of expr #temp:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr 255:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr ?#temp2:_ @string:21:14
Types:   Type = wybe.string
Types: Type checking foreign llvm call and(address, address, address)
Types: Finding type of expr #temp2:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr ?c:char @string:21:24
Types:   Type = wybe.char
Types: Type checking foreign lpvm call cast(address, 8 bit unsigned)
Types: Now mode checking proc singleton
Types: bound vars: semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check exp #result:!wybe.int
Types: Mode check exp resulted in #result:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #result:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#result, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#result, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #result:!wybe.int
Types: Mode check exp resulted in #result:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #result:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#result, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#result, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 3:!wybe.int
Types: Mode check exp resulted in 3:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'singleton'
Types: Now assigned = semipure test computation binding {#result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm lshr(#result:_ @string:21:14, 2:_ @string:21:14, ?#temp:_ @string:21:14)
Types: Mode checking foreign call {foreign llvm lshr(#result:_ @string:21:14, 2:_ @string:21:14, ?#temp:_ @string:21:14)}
Types:     with assigned semipure test computation binding {#result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #result:_
Types: Mode check exp resulted in #result:_
Types: Mode check exp 2:_
Types: Mode check exp resulted in 2:_
Types: Mode check exp ?#temp:_
Types: Mode check exp resulted in ?#temp:_
Types: Finding type of expr #result:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr 2:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr ?#temp:_ @string:21:14
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.string,?wybe.string]
Types: New instr = {foreign llvm lshr(#result:wybe.string @string:21:14, 2:wybe.string @string:21:14, ?#temp:wybe.string @string:21:14)}
Types: Now assigned = semipure test computation binding {#result, #temp, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#temp:_ @string:21:14, 255:_ @string:21:14, ?#temp2:_ @string:21:14)
Types: Mode checking foreign call {foreign llvm and(#temp:_ @string:21:14, 255:_ @string:21:14, ?#temp2:_ @string:21:14)}
Types:     with assigned semipure test computation binding {#result, #temp, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #temp:_
Types: Mode check exp resulted in #temp:_
Types: Mode check exp 255:_
Types: Mode check exp resulted in 255:_
Types: Mode check exp ?#temp2:_
Types: Mode check exp resulted in ?#temp2:_
Types: Finding type of expr #temp:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr 255:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr ?#temp2:_ @string:21:14
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.string,?wybe.string]
Types: New instr = {foreign llvm and(#temp:wybe.string @string:21:14, 255:wybe.string @string:21:14, ?#temp2:wybe.string @string:21:14)}
Types: Now assigned = semipure test computation binding {#result, #temp, #temp2, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm cast(#temp2:_ @string:21:14, ?c:char @string:21:24)
Types: Mode checking foreign call {foreign lpvm cast(#temp2:_ @string:21:14, ?c:char @string:21:24)}
Types:     with assigned semipure test computation binding {#result, #temp, #temp2, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #temp2:_
Types: Mode check exp resulted in #temp2:_
Types: Mode check exp ?c:char
Types: Mode check exp resulted in ?c:char
Types: Finding type of expr #temp2:_ @string:21:14
Types:   Type = wybe.string
Types: Finding type of expr ?c:char @string:21:24
Types:   Type = wybe.char
Types:     types and modes = [wybe.string,?wybe.char]
Types: New instr = {foreign lpvm cast(#temp2:wybe.string @string:21:14, ?c:wybe.char @string:21:24)}
Types: Now assigned = semipure test computation binding {#result, #temp, #temp2, c, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'singleton'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign llvm lshr(#result:wybe.string @string:21:14, 2:wybe.string @string:21:14, ?#temp:wybe.string @string:21:14)} @string:21:24,{foreign llvm and(#temp:wybe.string @string:21:14, 255:wybe.string @string:21:14, ?#temp2:wybe.string @string:21:14)} @string:21:14,{foreign lpvm cast(#temp2:wybe.string @string:21:14, ?c:wybe.char @string:21:24)} @string:21:24]
Types: Vars defined by body: semipure test computation binding {#result, #temp, #temp2, c, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : c
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of singleton:
Types: 
Types: singleton > {inline} (0 calls)
Types: 4: singleton(c:wybe.char @string:21:24, ?#result:wybe.string @string:21:14):
Types:     foreign llvm move(0:wybe.string:!wybe.int @string:21:14, ?#result:wybe.string @string:21:14)
Types:     foreign llvm shl(c:wybe.string:!char @string:21:24, 2:!wybe.string @string:21:14, ?#temp:wybe.string @string:21:14)
Types:     foreign llvm or(#temp:wybe.string @string:21:14, #result:wybe.string @string:21:14, ?#result:wybe.string @string:21:14)
Types:     foreign llvm or(#result:wybe.string @string:21:14, 1024:wybe.string, ?#result:wybe.string @string:21:14)
Types:     foreign llvm or(#result:wybe.string @string:21:14, 3:wybe.string, ?#result:wybe.string @string:21:14)
Types: 
Types: singleton > {test,inline} (0 calls)
Types: 4: singleton(?c:wybe.char @string:21:24, #result:wybe.string @string:21:14):
Types:     (   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign llvm lshr(#result:wybe.string @string:21:14, 2:wybe.string @string:21:14, ?#temp:wybe.string @string:21:14)
Types:     foreign llvm and(#temp:wybe.string @string:21:14, 255:wybe.string @string:21:14, ?#temp2:wybe.string @string:21:14)
Types:     foreign lpvm cast(#temp2:wybe.string @string:21:14, ?c:wybe.char @string:21:24)
Types: Type checking non-recursive proc wybe.string.right
Types: ** Type checking decl of proc right
Types: found 2 definition(s)
Types: Type checking right
Types: ** Type checking right: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign lpvm access(#rec:_ @string:17:29, 7, 16, 1, ?#result:_ @string:17:29)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#rec","#result","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: #rec:wybe.string, ?#result:wybe.string
Types:     type of '#rec' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types:     type of '#result' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign lpvm access(#rec:_ @string:17:29, 7, 16, 1, ?#result:_ @string:17:29)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: *** Before calls Typing {#rec::wybe.string, #result::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#rec::wybe.string, #result::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:_ @string:17:29
Types:   Type = wybe.string
Types: Finding type of expr 7
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr ?#result:_ @string:17:29
Types:   Type = wybe.string
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Now mode checking proc right
Types: bound vars: semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'right'
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#rec:_ @string:17:29, 7, 16, 1, ?#result:_ @string:17:29)
Types: Mode checking foreign call {foreign lpvm access(#rec:_ @string:17:29, 7, 16, 1, ?#result:_ @string:17:29)}
Types:     with assigned semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp 7
Types: Mode check exp resulted in 7
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp ?#result:_
Types: Mode check exp resulted in ?#result:_
Types: Finding type of expr #rec:_ @string:17:29
Types:   Type = wybe.string
Types: Finding type of expr 7
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr ?#result:_ @string:17:29
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.int,wybe.int,wybe.int,?wybe.string]
Types: New instr = {foreign lpvm access(#rec:wybe.string @string:17:29, 7:wybe.int, 16:wybe.int, 1:wybe.int, ?#result:wybe.string @string:17:29)}
Types: Now assigned = semipure test computation binding {#rec, #result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'right'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign lpvm access(#rec:wybe.string @string:17:29, 7:wybe.int, 16:wybe.int, 1:wybe.int, ?#result:wybe.string @string:17:29)} @string:17:29]
Types: Vars defined by body: semipure test computation binding {#rec, #result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking right
Types: ** Type checking right: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign lpvm mutate(#rec:_ @string:17:29, ?#rec:_ @string:17:29, 7, 0, 16, 1, #field)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#field","#rec","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: !#rec:wybe.string, #field:wybe.string
Types:     type of '#rec' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types:     type of '#field' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #field type constrained to wybe.string
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign lpvm mutate(#rec:_ @string:17:29, ?#rec:_ @string:17:29, 7, 0, 16, 1, #field)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: *** Before calls Typing {#field::wybe.string, #rec::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#field::wybe.string, #rec::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:_ @string:17:29
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:17:29
Types:   Type = wybe.string
Types: Finding type of expr 7
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.string
Types: Type checking foreign lpvm call mutate(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Now mode checking proc right
Types: bound vars: semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'right'
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm mutate(#rec:_ @string:17:29, ?#rec:_ @string:17:29, 7, 0, 16, 1, #field)
Types: Mode checking foreign call {foreign lpvm mutate(#rec:_ @string:17:29, ?#rec:_ @string:17:29, 7, 0, 16, 1, #field)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp 7
Types: Mode check exp resulted in 7
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp #field
Types: Mode check exp resulted in #field
Types: Finding type of expr #rec:_ @string:17:29
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:17:29
Types:   Type = wybe.string
Types: Finding type of expr 7
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,?wybe.string,wybe.int,wybe.int,wybe.int,wybe.int,wybe.string]
Types: New instr = {foreign lpvm mutate(#rec:wybe.string @string:17:29, ?#rec:wybe.string @string:17:29, 7:wybe.int, 0:wybe.int, 16:wybe.int, 1:wybe.int, #field:wybe.string)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'right'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign lpvm mutate(#rec:wybe.string @string:17:29, ?#rec:wybe.string @string:17:29, 7:wybe.int, 0:wybe.int, 16:wybe.int, 1:wybe.int, #field:wybe.string)} @string:17:29]
Types: Vars defined by body: semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : #rec
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of right:
Types: 
Types: right > {test,inline} (0 calls)
Types: 4: right(#rec:wybe.string @string:17:29, ?#result:wybe.string @string:17:29):
Types:     (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign lpvm access(#rec:wybe.string @string:17:29, 7:wybe.int, 16:wybe.int, 1:wybe.int, ?#result:wybe.string @string:17:29)
Types: 
Types: right > {test,inline} (0 calls)
Types: 4: right(!#rec:wybe.string @string:17:29, #field:wybe.string @string:17:29):
Types:     (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign lpvm mutate(#rec:wybe.string @string:17:29, ?#rec:wybe.string @string:17:29, 7:wybe.int, 0:wybe.int, 16:wybe.int, 1:wybe.int, #field:wybe.string)
Types: Type checking non-recursive proc wybe.string.raw
Types: ** Type checking decl of proc raw
Types: found 2 definition(s)
Types: Type checking raw
Types: ** Type checking raw: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign lpvm access(#rec:_ @string:14:30, 8, 16, 0, ?#result:c_string @string:14:30)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#rec","#result","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: #rec:wybe.string, ?#result:wybe.c_string
Types:     type of '#rec' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types:     type of '#result' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable #result type constrained to wybe.c_string
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign lpvm access(#rec:_ @string:14:30, 8, 16, 0, ?#result:c_string @string:14:30)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types c_string (-> wybe.c_string) and wybe.c_string (-> wybe.c_string)
Types:   Unification yields wybe.c_string
Types: Variable #result type constrained to wybe.c_string
Types: *** Before calls Typing {#rec::wybe.string, #result::wybe.c_string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#rec::wybe.string, #result::wybe.c_string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:_ @string:14:30
Types:   Type = wybe.string
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?#result:c_string @string:14:30
Types:   Type = wybe.c_string
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Now mode checking proc raw
Types: bound vars: semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 0:!wybe.int
Types: Mode check exp resulted in 0:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'raw'
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#rec:_ @string:14:30, 8, 16, 0, ?#result:c_string @string:14:30)
Types: Mode checking foreign call {foreign lpvm access(#rec:_ @string:14:30, 8, 16, 0, ?#result:c_string @string:14:30)}
Types:     with assigned semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp 8
Types: Mode check exp resulted in 8
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?#result:c_string
Types: Mode check exp resulted in ?#result:c_string
Types: Finding type of expr #rec:_ @string:14:30
Types:   Type = wybe.string
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?#result:c_string @string:14:30
Types:   Type = wybe.c_string
Types:     types and modes = [wybe.string,wybe.int,wybe.int,wybe.int,?wybe.c_string]
Types: New instr = {foreign lpvm access(#rec:wybe.string @string:14:30, 8:wybe.int, 16:wybe.int, 0:wybe.int, ?#result:wybe.c_string @string:14:30)}
Types: Now assigned = semipure test computation binding {#rec, #result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'raw'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign lpvm access(#rec:wybe.string @string:14:30, 8:wybe.int, 16:wybe.int, 0:wybe.int, ?#result:wybe.c_string @string:14:30)} @string:14:30]
Types: Vars defined by body: semipure test computation binding {#rec, #result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking raw
Types: ** Type checking raw: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign lpvm {noalias} mutate(#rec:_ @string:14:30, ?#rec:_ @string:14:30, 8, 0, 16, 0, #field)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#field","#rec","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: !#rec:wybe.string, #field:wybe.c_string
Types:     type of '#rec' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types:     type of '#field' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable #field type constrained to wybe.c_string
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign lpvm {noalias} mutate(#rec:_ @string:14:30, ?#rec:_ @string:14:30, 8, 0, 16, 0, #field)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: *** Before calls Typing {#field::wybe.c_string, #rec::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#field::wybe.c_string, #rec::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:_ @string:14:30
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:14:30
Types:   Type = wybe.string
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.c_string
Types: Type checking foreign lpvm call mutate noalias(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Now mode checking proc raw
Types: bound vars: semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 0:!wybe.int
Types: Mode check exp resulted in 0:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'raw'
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm {noalias} mutate(#rec:_ @string:14:30, ?#rec:_ @string:14:30, 8, 0, 16, 0, #field)
Types: Mode checking foreign call {foreign lpvm {noalias} mutate(#rec:_ @string:14:30, ?#rec:_ @string:14:30, 8, 0, 16, 0, #field)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp 8
Types: Mode check exp resulted in 8
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp #field
Types: Mode check exp resulted in #field
Types: Finding type of expr #rec:_ @string:14:30
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:14:30
Types:   Type = wybe.string
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.c_string
Types:     types and modes = [wybe.string,?wybe.string,wybe.int,wybe.int,wybe.int,wybe.int,wybe.c_string]
Types: New instr = {foreign lpvm {noalias} mutate(#rec:wybe.string @string:14:30, ?#rec:wybe.string @string:14:30, 8:wybe.int, 0:wybe.int, 16:wybe.int, 0:wybe.int, #field:wybe.c_string)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'raw'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign lpvm {noalias} mutate(#rec:wybe.string @string:14:30, ?#rec:wybe.string @string:14:30, 8:wybe.int, 0:wybe.int, 16:wybe.int, 0:wybe.int, #field:wybe.c_string)} @string:14:30]
Types: Vars defined by body: semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : #rec
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of raw:
Types: 
Types: raw > {test,inline} (0 calls)
Types: 4: raw(#rec:wybe.string @string:14:30, ?#result:wybe.c_string @string:14:30):
Types:     (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign lpvm access(#rec:wybe.string @string:14:30, 8:wybe.int, 16:wybe.int, 0:wybe.int, ?#result:wybe.c_string @string:14:30)
Types: 
Types: raw > {test,inline} (0 calls)
Types: 4: raw(!#rec:wybe.string @string:14:30, #field:wybe.c_string @string:14:30):
Types:     (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign lpvm {noalias} mutate(#rec:wybe.string @string:14:30, ?#rec:wybe.string @string:14:30, 8:wybe.int, 0:wybe.int, 16:wybe.int, 0:wybe.int, #field:wybe.c_string)
Types: Type checking non-recursive proc wybe.string.range
Types: ** Type checking decl of proc range
Types: found 2 definition(s)
Types: Type checking range
Types: ** Type checking range: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign lpvm access(#rec:_ @string:19:28, 6, 16, 2, ?#result:range @string:19:28)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#rec","#result","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: #rec:wybe.string, ?#result:wybe.range
Types:     type of '#rec' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types:     type of '#result' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #result type constrained to wybe.range
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign lpvm access(#rec:_ @string:19:28, 6, 16, 2, ?#result:range @string:19:28)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types range (-> wybe.range) and wybe.range (-> wybe.range)
Types:   Unification yields wybe.range
Types: Variable #result type constrained to wybe.range
Types: *** Before calls Typing {#rec::wybe.string, #result::wybe.range, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#rec::wybe.string, #result::wybe.range, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:_ @string:19:28
Types:   Type = wybe.string
Types: Finding type of expr 6
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 2
Types:   Type = wybe.int
Types: Finding type of expr ?#result:range @string:19:28
Types:   Type = wybe.range
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Now mode checking proc range
Types: bound vars: semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 2:!wybe.int
Types: Mode check exp resulted in 2:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'range'
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#rec:_ @string:19:28, 6, 16, 2, ?#result:range @string:19:28)
Types: Mode checking foreign call {foreign lpvm access(#rec:_ @string:19:28, 6, 16, 2, ?#result:range @string:19:28)}
Types:     with assigned semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp 6
Types: Mode check exp resulted in 6
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 2
Types: Mode check exp resulted in 2
Types: Mode check exp ?#result:range
Types: Mode check exp resulted in ?#result:range
Types: Finding type of expr #rec:_ @string:19:28
Types:   Type = wybe.string
Types: Finding type of expr 6
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 2
Types:   Type = wybe.int
Types: Finding type of expr ?#result:range @string:19:28
Types:   Type = wybe.range
Types:     types and modes = [wybe.string,wybe.int,wybe.int,wybe.int,?wybe.range]
Types: New instr = {foreign lpvm access(#rec:wybe.string @string:19:28, 6:wybe.int, 16:wybe.int, 2:wybe.int, ?#result:wybe.range @string:19:28)}
Types: Now assigned = semipure test computation binding {#rec, #result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'range'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign lpvm access(#rec:wybe.string @string:19:28, 6:wybe.int, 16:wybe.int, 2:wybe.int, ?#result:wybe.range @string:19:28)} @string:19:28]
Types: Vars defined by body: semipure test computation binding {#rec, #result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking range
Types: ** Type checking range: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign lpvm mutate(#rec:_ @string:19:28, ?#rec:_ @string:19:28, 6, 0, 16, 2, #field)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#field","#rec","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: !#rec:wybe.string, #field:wybe.range
Types:     type of '#rec' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types:     type of '#field' is wybe.range
Types: Unifying types wybe.range (-> wybe.range) and any (-> any)
Types:   Unification yields wybe.range
Types: Variable #field type constrained to wybe.range
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign lpvm mutate(#rec:_ @string:19:28, ?#rec:_ @string:19:28, 6, 0, 16, 2, #field)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: *** Before calls Typing {#field::wybe.range, #rec::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#field::wybe.range, #rec::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:_ @string:19:28
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:19:28
Types:   Type = wybe.string
Types: Finding type of expr 6
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 2
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.range
Types: Type checking foreign lpvm call mutate(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Now mode checking proc range
Types: bound vars: semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 2:!wybe.int
Types: Mode check exp resulted in 2:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'range'
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm mutate(#rec:_ @string:19:28, ?#rec:_ @string:19:28, 6, 0, 16, 2, #field)
Types: Mode checking foreign call {foreign lpvm mutate(#rec:_ @string:19:28, ?#rec:_ @string:19:28, 6, 0, 16, 2, #field)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp 6
Types: Mode check exp resulted in 6
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 2
Types: Mode check exp resulted in 2
Types: Mode check exp #field
Types: Mode check exp resulted in #field
Types: Finding type of expr #rec:_ @string:19:28
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:19:28
Types:   Type = wybe.string
Types: Finding type of expr 6
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 2
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.range
Types:     types and modes = [wybe.string,?wybe.string,wybe.int,wybe.int,wybe.int,wybe.int,wybe.range]
Types: New instr = {foreign lpvm mutate(#rec:wybe.string @string:19:28, ?#rec:wybe.string @string:19:28, 6:wybe.int, 0:wybe.int, 16:wybe.int, 2:wybe.int, #field:wybe.range)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'range'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign lpvm mutate(#rec:wybe.string @string:19:28, ?#rec:wybe.string @string:19:28, 6:wybe.int, 0:wybe.int, 16:wybe.int, 2:wybe.int, #field:wybe.range)} @string:19:28]
Types: Vars defined by body: semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : #rec
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of range:
Types: 
Types: range > {test,inline} (0 calls)
Types: 4: range(#rec:wybe.string @string:19:28, ?#result:wybe.range @string:19:28):
Types:     (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign lpvm access(#rec:wybe.string @string:19:28, 6:wybe.int, 16:wybe.int, 2:wybe.int, ?#result:wybe.range @string:19:28)
Types: 
Types: range > {test,inline} (0 calls)
Types: 4: range(!#rec:wybe.string @string:19:28, #field:wybe.range @string:19:28):
Types:     (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign lpvm mutate(#rec:wybe.string @string:19:28, ?#rec:wybe.string @string:19:28, 6:wybe.int, 0:wybe.int, 16:wybe.int, 2:wybe.int, #field:wybe.range)
Types: Type checking non-recursive proc wybe.string.len
Types: ** Type checking decl of proc len
Types: found 2 definition(s)
Types: Type checking len
Types: ** Type checking len: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign lpvm access(#rec:_ @string:14:21, 0, 16, 0, ?#result:int @string:14:21)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#rec","#result","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: #rec:wybe.string, ?#result:wybe.int
Types:     type of '#rec' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types:     type of '#result' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign lpvm access(#rec:_ @string:14:21, 0, 16, 0, ?#result:int @string:14:21)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable #result type constrained to wybe.int
Types: *** Before calls Typing {#rec::wybe.string, #result::wybe.int, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#rec::wybe.string, #result::wybe.int, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:_ @string:14:21
Types:   Type = wybe.string
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?#result:int @string:14:21
Types:   Type = wybe.int
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed)
Types: Now mode checking proc len
Types: bound vars: semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 0:!wybe.int
Types: Mode check exp resulted in 0:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'len'
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#rec:_ @string:14:21, 0, 16, 0, ?#result:int @string:14:21)
Types: Mode checking foreign call {foreign lpvm access(#rec:_ @string:14:21, 0, 16, 0, ?#result:int @string:14:21)}
Types:     with assigned semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?#result:int
Types: Mode check exp resulted in ?#result:int
Types: Finding type of expr #rec:_ @string:14:21
Types:   Type = wybe.string
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?#result:int @string:14:21
Types:   Type = wybe.int
Types:     types and modes = [wybe.string,wybe.int,wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign lpvm access(#rec:wybe.string @string:14:21, 0:wybe.int, 16:wybe.int, 0:wybe.int, ?#result:wybe.int @string:14:21)}
Types: Now assigned = semipure test computation binding {#rec, #result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'len'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign lpvm access(#rec:wybe.string @string:14:21, 0:wybe.int, 16:wybe.int, 0:wybe.int, ?#result:wybe.int @string:14:21)} @string:14:21]
Types: Vars defined by body: semipure test computation binding {#rec, #result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking len
Types: ** Type checking len: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign lpvm mutate(#rec:_ @string:14:21, ?#rec:_ @string:14:21, 0, 0, 16, 0, #field)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#field","#rec","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: !#rec:wybe.string, #field:wybe.int
Types:     type of '#rec' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types:     type of '#field' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable #field type constrained to wybe.int
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign lpvm mutate(#rec:_ @string:14:21, ?#rec:_ @string:14:21, 0, 0, 16, 0, #field)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: *** Before calls Typing {#field::wybe.int, #rec::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#field::wybe.int, #rec::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:_ @string:14:21
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:14:21
Types:   Type = wybe.string
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.int
Types: Type checking foreign lpvm call mutate(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed)
Types: Now mode checking proc len
Types: bound vars: semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 0:!wybe.int
Types: Mode check exp resulted in 0:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'len'
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm mutate(#rec:_ @string:14:21, ?#rec:_ @string:14:21, 0, 0, 16, 0, #field)
Types: Mode checking foreign call {foreign lpvm mutate(#rec:_ @string:14:21, ?#rec:_ @string:14:21, 0, 0, 16, 0, #field)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp #field
Types: Mode check exp resulted in #field
Types: Finding type of expr #rec:_ @string:14:21
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:14:21
Types:   Type = wybe.string
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.int
Types:     types and modes = [wybe.string,?wybe.string,wybe.int,wybe.int,wybe.int,wybe.int,wybe.int]
Types: New instr = {foreign lpvm mutate(#rec:wybe.string @string:14:21, ?#rec:wybe.string @string:14:21, 0:wybe.int, 0:wybe.int, 16:wybe.int, 0:wybe.int, #field:wybe.int)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'len'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign lpvm mutate(#rec:wybe.string @string:14:21, ?#rec:wybe.string @string:14:21, 0:wybe.int, 0:wybe.int, 16:wybe.int, 0:wybe.int, #field:wybe.int)} @string:14:21]
Types: Vars defined by body: semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : #rec
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of len:
Types: 
Types: len > {test,inline} (0 calls)
Types: 4: len(#rec:wybe.string @string:14:21, ?#result:wybe.int @string:14:21):
Types:     (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign lpvm access(#rec:wybe.string @string:14:21, 0:wybe.int, 16:wybe.int, 0:wybe.int, ?#result:wybe.int @string:14:21)
Types: 
Types: len > {test,inline} (0 calls)
Types: 4: len(!#rec:wybe.string @string:14:21, #field:wybe.int @string:14:21):
Types:     (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign lpvm mutate(#rec:wybe.string @string:14:21, ?#rec:wybe.string @string:14:21, 0:wybe.int, 0:wybe.int, 16:wybe.int, 0:wybe.int, #field:wybe.int)
Types: Type checking non-recursive proc wybe.string.left
Types: ** Type checking decl of proc left
Types: found 2 definition(s)
Types: Type checking left
Types: ** Type checking left: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign lpvm access(#rec:_ @string:17:21, -1, 16, 1, ?#result:_ @string:17:21)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#rec","#result","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: #rec:wybe.string, ?#result:wybe.string
Types:     type of '#rec' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types:     type of '#result' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign lpvm access(#rec:_ @string:17:21, -1, 16, 1, ?#result:_ @string:17:21)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: *** Before calls Typing {#rec::wybe.string, #result::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#rec::wybe.string, #result::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:_ @string:17:21
Types:   Type = wybe.string
Types: Finding type of expr -1
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr ?#result:_ @string:17:21
Types:   Type = wybe.string
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Now mode checking proc left
Types: bound vars: semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'left'
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#rec:_ @string:17:21, -1, 16, 1, ?#result:_ @string:17:21)
Types: Mode checking foreign call {foreign lpvm access(#rec:_ @string:17:21, -1, 16, 1, ?#result:_ @string:17:21)}
Types:     with assigned semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp -1
Types: Mode check exp resulted in -1
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp ?#result:_
Types: Mode check exp resulted in ?#result:_
Types: Finding type of expr #rec:_ @string:17:21
Types:   Type = wybe.string
Types: Finding type of expr -1
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr ?#result:_ @string:17:21
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.int,wybe.int,wybe.int,?wybe.string]
Types: New instr = {foreign lpvm access(#rec:wybe.string @string:17:21, -1:wybe.int, 16:wybe.int, 1:wybe.int, ?#result:wybe.string @string:17:21)}
Types: Now assigned = semipure test computation binding {#rec, #result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'left'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign lpvm access(#rec:wybe.string @string:17:21, -1:wybe.int, 16:wybe.int, 1:wybe.int, ?#result:wybe.string @string:17:21)} @string:17:21]
Types: Vars defined by body: semipure test computation binding {#rec, #result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking left
Types: ** Type checking left: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign lpvm mutate(#rec:_ @string:17:21, ?#rec:_ @string:17:21, -1, 0, 16, 1, #field)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#field","#rec","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: !#rec:wybe.string, #field:wybe.string
Types:     type of '#rec' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types:     type of '#field' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #field type constrained to wybe.string
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign lpvm mutate(#rec:_ @string:17:21, ?#rec:_ @string:17:21, -1, 0, 16, 1, #field)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: *** Before calls Typing {#field::wybe.string, #rec::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#field::wybe.string, #rec::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:_ @string:17:21
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:17:21
Types:   Type = wybe.string
Types: Finding type of expr -1
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.string
Types: Type checking foreign lpvm call mutate(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Now mode checking proc left
Types: bound vars: semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'left'
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm mutate(#rec:_ @string:17:21, ?#rec:_ @string:17:21, -1, 0, 16, 1, #field)
Types: Mode checking foreign call {foreign lpvm mutate(#rec:_ @string:17:21, ?#rec:_ @string:17:21, -1, 0, 16, 1, #field)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp -1
Types: Mode check exp resulted in -1
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp #field
Types: Mode check exp resulted in #field
Types: Finding type of expr #rec:_ @string:17:21
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:17:21
Types:   Type = wybe.string
Types: Finding type of expr -1
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,?wybe.string,wybe.int,wybe.int,wybe.int,wybe.int,wybe.string]
Types: New instr = {foreign lpvm mutate(#rec:wybe.string @string:17:21, ?#rec:wybe.string @string:17:21, -1:wybe.int, 0:wybe.int, 16:wybe.int, 1:wybe.int, #field:wybe.string)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'left'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign lpvm mutate(#rec:wybe.string @string:17:21, ?#rec:wybe.string @string:17:21, -1:wybe.int, 0:wybe.int, 16:wybe.int, 1:wybe.int, #field:wybe.string)} @string:17:21]
Types: Vars defined by body: semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : #rec
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of left:
Types: 
Types: left > {test,inline} (0 calls)
Types: 4: left(#rec:wybe.string @string:17:21, ?#result:wybe.string @string:17:21):
Types:     (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign lpvm access(#rec:wybe.string @string:17:21, -1:wybe.int, 16:wybe.int, 1:wybe.int, ?#result:wybe.string @string:17:21)
Types: 
Types: left > {test,inline} (0 calls)
Types: 4: left(!#rec:wybe.string @string:17:21, #field:wybe.string @string:17:21):
Types:     (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign lpvm mutate(#rec:wybe.string @string:17:21, ?#rec:wybe.string @string:17:21, -1:wybe.int, 0:wybe.int, 16:wybe.int, 1:wybe.int, #field:wybe.string)
Types: Type checking non-recursive proc wybe.string.empty
Types: ** Type checking decl of proc empty
Types: found 1 definition(s)
Types: Type checking empty
Types: ** Type checking empty: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm cast(0:!_, ?#result)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result"]
Types: Recording parameter types: ?#result:wybe.string
Types:     type of '#result' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm cast(0:!_, ?#result)}
Types: *** Before calls Typing {#result::wybe.string}; {} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.string}; {} (with no errors)
Types: Finding type of expr 0:!_
Types:   Type = wybe.string
Types: Finding type of expr ?#result
Types:   Type = wybe.string
Types: Type checking foreign lpvm call cast(address, address)
Types: Now mode checking proc empty
Types: bound vars: semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm cast(0:!_, ?#result)
Types: Mode checking foreign call {foreign lpvm cast(0:!_, ?#result)}
Types:     with assigned semipure normal (total) computation binding {}, break set = Everything, with resources {}
Types: Mode check exp 0:!_
Types: Mode check exp resulted in 0:!_
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr 0:!_
Types:   Type = wybe.string
Types: Finding type of expr ?#result
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,?wybe.string]
Types: New instr = {foreign lpvm cast(0:!wybe.string, ?#result:wybe.string)}
Types: Now assigned = semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'empty'
Types: Mode checked body   : [{foreign lpvm cast(0:!wybe.string, ?#result:wybe.string)}]
Types: Vars defined by body: semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of empty:
Types: 
Types: empty > {inline} (0 calls)
Types: 4: empty(?#result:wybe.string @string:12:14):
Types:     foreign lpvm cast(0:!wybe.string, ?#result:wybe.string)
Types: Type checking non-recursive proc wybe.string.concat
Types: ** Type checking decl of proc concat
Types: found 2 definition(s)
Types: Type checking concat
Types: ** Type checking concat: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm alloc(16, ?#rec:_ @string:17:14)
Types:         foreign lpvm mutate(#rec:_ @string:17:14, ?#rec:_ @string:17:14, 0, 1, 16, 0, left:_ @string:17:21)
Types:         foreign lpvm mutate(#rec:_ @string:17:14, ?#rec:_ @string:17:14, 8, 1, 16, 0, right:_ @string:17:29)
Types:         foreign llvm or(#rec:_ @string:17:14, 1, ?#result:_ @string:17:14)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#rec","#result","left","right"]
Types: Recording parameter types: left:wybe.string, right:wybe.string, ?#result:wybe.string
Types:     type of 'left' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable left type constrained to wybe.string
Types:     type of 'right' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable right type constrained to wybe.string
Types:     type of '#result' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm alloc(16, ?#rec:_ @string:17:14)}
Types: Unifying types _ (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Recording casts in {foreign lpvm mutate(#rec:_ @string:17:14, ?#rec:_ @string:17:14, 0, 1, 16, 0, left:_ @string:17:21)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable left type constrained to wybe.string
Types: Recording casts in {foreign lpvm mutate(#rec:_ @string:17:14, ?#rec:_ @string:17:14, 8, 1, 16, 0, right:_ @string:17:29)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable right type constrained to wybe.string
Types: Recording casts in {foreign llvm or(#rec:_ @string:17:14, 1, ?#result:_ @string:17:14)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: *** Before calls Typing {#rec::wybe.string, #result::wybe.string, left::wybe.string, right::wybe.string}; {} (with no errors)
Types:   With calls:
Types:   Typing {#rec::wybe.string, #result::wybe.string, left::wybe.string, right::wybe.string}; {} (with no errors)
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr ?#rec:_ @string:17:14
Types:   Type = wybe.string
Types: Type checking foreign lpvm call alloc(64 bit signed, address)
Types: Finding type of expr #rec:_ @string:17:14
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:17:14
Types:   Type = wybe.string
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr left:_ @string:17:21
Types:   Type = wybe.string
Types: Type checking foreign lpvm call mutate(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Finding type of expr #rec:_ @string:17:14
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:17:14
Types:   Type = wybe.string
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr right:_ @string:17:29
Types:   Type = wybe.string
Types: Type checking foreign lpvm call mutate(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Finding type of expr #rec:_ @string:17:14
Types:   Type = wybe.string
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr ?#result:_ @string:17:14
Types:   Type = wybe.string
Types: Type checking foreign llvm call or(address, 64 bit signed, address)
Types: Now mode checking proc concat
Types: bound vars: semipure normal (total) computation binding {left, right}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm alloc(16, ?#rec:_ @string:17:14)
Types: Mode checking foreign call {foreign lpvm alloc(16, ?#rec:_ @string:17:14)}
Types:     with assigned semipure normal (total) computation binding {left, right}, break set = Everything, with resources {}
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr ?#rec:_ @string:17:14
Types:   Type = wybe.string
Types:     types and modes = [wybe.int,?wybe.string]
Types: New instr = {foreign lpvm alloc(16:wybe.int, ?#rec:wybe.string @string:17:14)}
Types: Now assigned = semipure normal (total) computation binding {#rec, left, right}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm mutate(#rec:_ @string:17:14, ?#rec:_ @string:17:14, 0, 1, 16, 0, left:_ @string:17:21)
Types: Mode checking foreign call {foreign lpvm mutate(#rec:_ @string:17:14, ?#rec:_ @string:17:14, 0, 1, 16, 0, left:_ @string:17:21)}
Types:     with assigned semipure normal (total) computation binding {#rec, left, right}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp left:_
Types: Mode check exp resulted in left:_
Types: Finding type of expr #rec:_ @string:17:14
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:17:14
Types:   Type = wybe.string
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr left:_ @string:17:21
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,?wybe.string,wybe.int,wybe.int,wybe.int,wybe.int,wybe.string]
Types: New instr = {foreign lpvm mutate(#rec:wybe.string @string:17:14, ?#rec:wybe.string @string:17:14, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, left:wybe.string @string:17:21)}
Types: Now assigned = semipure normal (total) computation binding {#rec, left, right}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm mutate(#rec:_ @string:17:14, ?#rec:_ @string:17:14, 8, 1, 16, 0, right:_ @string:17:29)
Types: Mode checking foreign call {foreign lpvm mutate(#rec:_ @string:17:14, ?#rec:_ @string:17:14, 8, 1, 16, 0, right:_ @string:17:29)}
Types:     with assigned semipure normal (total) computation binding {#rec, left, right}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp 8
Types: Mode check exp resulted in 8
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp right:_
Types: Mode check exp resulted in right:_
Types: Finding type of expr #rec:_ @string:17:14
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:17:14
Types:   Type = wybe.string
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr right:_ @string:17:29
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,?wybe.string,wybe.int,wybe.int,wybe.int,wybe.int,wybe.string]
Types: New instr = {foreign lpvm mutate(#rec:wybe.string @string:17:14, ?#rec:wybe.string @string:17:14, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, right:wybe.string @string:17:29)}
Types: Now assigned = semipure normal (total) computation binding {#rec, left, right}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm or(#rec:_ @string:17:14, 1, ?#result:_ @string:17:14)
Types: Mode checking foreign call {foreign llvm or(#rec:_ @string:17:14, 1, ?#result:_ @string:17:14)}
Types:     with assigned semipure normal (total) computation binding {#rec, left, right}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp ?#result:_
Types: Mode check exp resulted in ?#result:_
Types: Finding type of expr #rec:_ @string:17:14
Types:   Type = wybe.string
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr ?#result:_ @string:17:14
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.int,?wybe.string]
Types: New instr = {foreign llvm or(#rec:wybe.string @string:17:14, 1:wybe.int, ?#result:wybe.string @string:17:14)}
Types: Now assigned = semipure normal (total) computation binding {#rec, #result, left, right}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'concat'
Types: Mode checked body   : [{foreign lpvm alloc(16:wybe.int, ?#rec:wybe.string @string:17:14)} @string:17:14,{foreign lpvm mutate(#rec:wybe.string @string:17:14, ?#rec:wybe.string @string:17:14, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, left:wybe.string @string:17:21)} @string:17:14,{foreign lpvm mutate(#rec:wybe.string @string:17:14, ?#rec:wybe.string @string:17:14, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, right:wybe.string @string:17:29)} @string:17:14,{foreign llvm or(#rec:wybe.string @string:17:14, 1:wybe.int, ?#result:wybe.string @string:17:14)} @string:17:14]
Types: Vars defined by body: semipure normal (total) computation binding {#rec, #result, left, right}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking concat
Types: ** Type checking concat: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign lpvm access(#result:_ @string:17:14, -1, 16, 1, ?left:_ @string:17:21)
Types:         foreign lpvm access(#result:_ @string:17:14, 7, 16, 1, ?right:_ @string:17:29)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","left","right","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: ?left:wybe.string, ?right:wybe.string, #result:wybe.string
Types:     type of 'left' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable left type constrained to wybe.string
Types:     type of 'right' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable right type constrained to wybe.string
Types:     type of '#result' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign lpvm access(#result:_ @string:17:14, -1, 16, 1, ?left:_ @string:17:21)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable left type constrained to wybe.string
Types: Recording casts in {foreign lpvm access(#result:_ @string:17:14, 7, 16, 1, ?right:_ @string:17:29)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable right type constrained to wybe.string
Types: *** Before calls Typing {#result::wybe.string, left::wybe.string, right::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.string, left::wybe.string, right::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #result:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #result:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #result:_ @string:17:14
Types:   Type = wybe.string
Types: Finding type of expr -1
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr ?left:_ @string:17:21
Types:   Type = wybe.string
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Finding type of expr #result:_ @string:17:14
Types:   Type = wybe.string
Types: Finding type of expr 7
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr ?right:_ @string:17:29
Types:   Type = wybe.string
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Now mode checking proc concat
Types: bound vars: semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check exp #result:!wybe.int
Types: Mode check exp resulted in #result:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #result:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#result, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#result, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #result:!wybe.int
Types: Mode check exp resulted in #result:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #result:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#result, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#result, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'concat'
Types: Now assigned = semipure test computation binding {#result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#result:_ @string:17:14, -1, 16, 1, ?left:_ @string:17:21)
Types: Mode checking foreign call {foreign lpvm access(#result:_ @string:17:14, -1, 16, 1, ?left:_ @string:17:21)}
Types:     with assigned semipure test computation binding {#result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #result:_
Types: Mode check exp resulted in #result:_
Types: Mode check exp -1
Types: Mode check exp resulted in -1
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp ?left:_
Types: Mode check exp resulted in ?left:_
Types: Finding type of expr #result:_ @string:17:14
Types:   Type = wybe.string
Types: Finding type of expr -1
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr ?left:_ @string:17:21
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.int,wybe.int,wybe.int,?wybe.string]
Types: New instr = {foreign lpvm access(#result:wybe.string @string:17:14, -1:wybe.int, 16:wybe.int, 1:wybe.int, ?left:wybe.string @string:17:21)}
Types: Now assigned = semipure test computation binding {#result, left, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#result:_ @string:17:14, 7, 16, 1, ?right:_ @string:17:29)
Types: Mode checking foreign call {foreign lpvm access(#result:_ @string:17:14, 7, 16, 1, ?right:_ @string:17:29)}
Types:     with assigned semipure test computation binding {#result, left, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #result:_
Types: Mode check exp resulted in #result:_
Types: Mode check exp 7
Types: Mode check exp resulted in 7
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp ?right:_
Types: Mode check exp resulted in ?right:_
Types: Finding type of expr #result:_ @string:17:14
Types:   Type = wybe.string
Types: Finding type of expr 7
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr ?right:_ @string:17:29
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.int,wybe.int,wybe.int,?wybe.string]
Types: New instr = {foreign lpvm access(#result:wybe.string @string:17:14, 7:wybe.int, 16:wybe.int, 1:wybe.int, ?right:wybe.string @string:17:29)}
Types: Now assigned = semipure test computation binding {#result, left, right, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'concat'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign lpvm access(#result:wybe.string @string:17:14, -1:wybe.int, 16:wybe.int, 1:wybe.int, ?left:wybe.string @string:17:21)} @string:17:14,{foreign lpvm access(#result:wybe.string @string:17:14, 7:wybe.int, 16:wybe.int, 1:wybe.int, ?right:wybe.string @string:17:29)} @string:17:14]
Types: Vars defined by body: semipure test computation binding {#result, left, right, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : left, right
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of concat:
Types: 
Types: concat > {inline} (0 calls)
Types: 4: concat(left:wybe.string @string:17:21, right:wybe.string @string:17:29, ?#result:wybe.string @string:17:14):
Types:     foreign lpvm alloc(16:wybe.int, ?#rec:wybe.string @string:17:14)
Types:     foreign lpvm mutate(#rec:wybe.string @string:17:14, ?#rec:wybe.string @string:17:14, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, left:wybe.string @string:17:21)
Types:     foreign lpvm mutate(#rec:wybe.string @string:17:14, ?#rec:wybe.string @string:17:14, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, right:wybe.string @string:17:29)
Types:     foreign llvm or(#rec:wybe.string @string:17:14, 1:wybe.int, ?#result:wybe.string @string:17:14)
Types: 
Types: concat > {test,inline} (0 calls)
Types: 4: concat(?left:wybe.string @string:17:21, ?right:wybe.string @string:17:29, #result:wybe.string @string:17:14):
Types:     (   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 1:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign lpvm access(#result:wybe.string @string:17:14, -1:wybe.int, 16:wybe.int, 1:wybe.int, ?left:wybe.string @string:17:21)
Types:     foreign lpvm access(#result:wybe.string @string:17:14, 7:wybe.int, 16:wybe.int, 1:wybe.int, ?right:wybe.string @string:17:29)
Types: Type checking non-recursive proc wybe.string.c
Types: ** Type checking decl of proc c
Types: found 2 definition(s)
Types: Type checking c
Types: ** Type checking c: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign llvm lshr(#rec:_ @string:21:24, 2:_ @string:21:24, ?#rec:_ @string:21:24)
Types:         foreign llvm and(#rec:_ @string:21:24, 255:_ @string:21:24, ?#field:_ @string:21:24)
Types:         foreign lpvm cast(#field:_ @string:21:24, ?#result:char @string:21:24)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#field","#rec","#result","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: #rec:wybe.string, ?#result:wybe.char
Types:     type of '#rec' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types:     type of '#result' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable #result type constrained to wybe.char
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign llvm lshr(#rec:_ @string:21:24, 2:_ @string:21:24, ?#rec:_ @string:21:24)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Recording casts in {foreign llvm and(#rec:_ @string:21:24, 255:_ @string:21:24, ?#field:_ @string:21:24)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #field type constrained to wybe.string
Types: Recording casts in {foreign lpvm cast(#field:_ @string:21:24, ?#result:char @string:21:24)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #field type constrained to wybe.string
Types: Unifying types char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Variable #result type constrained to wybe.char
Types: *** Before calls Typing {#field::wybe.string, #rec::wybe.string, #result::wybe.char, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#field::wybe.string, #rec::wybe.string, #result::wybe.char, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr 2:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:21:24
Types:   Type = wybe.string
Types: Type checking foreign llvm call lshr(address, address, address)
Types: Finding type of expr #rec:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr 255:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr ?#field:_ @string:21:24
Types:   Type = wybe.string
Types: Type checking foreign llvm call and(address, address, address)
Types: Finding type of expr #field:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr ?#result:char @string:21:24
Types:   Type = wybe.char
Types: Type checking foreign lpvm call cast(address, 8 bit unsigned)
Types: Now mode checking proc c
Types: bound vars: semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 3:!wybe.int
Types: Mode check exp resulted in 3:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'c'
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm lshr(#rec:_ @string:21:24, 2:_ @string:21:24, ?#rec:_ @string:21:24)
Types: Mode checking foreign call {foreign llvm lshr(#rec:_ @string:21:24, 2:_ @string:21:24, ?#rec:_ @string:21:24)}
Types:     with assigned semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp 2:_
Types: Mode check exp resulted in 2:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Finding type of expr #rec:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr 2:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:21:24
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.string,?wybe.string]
Types: New instr = {foreign llvm lshr(#rec:wybe.string @string:21:24, 2:wybe.string @string:21:24, ?#rec:wybe.string @string:21:24)}
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#rec:_ @string:21:24, 255:_ @string:21:24, ?#field:_ @string:21:24)
Types: Mode checking foreign call {foreign llvm and(#rec:_ @string:21:24, 255:_ @string:21:24, ?#field:_ @string:21:24)}
Types:     with assigned semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp 255:_
Types: Mode check exp resulted in 255:_
Types: Mode check exp ?#field:_
Types: Mode check exp resulted in ?#field:_
Types: Finding type of expr #rec:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr 255:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr ?#field:_ @string:21:24
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.string,?wybe.string]
Types: New instr = {foreign llvm and(#rec:wybe.string @string:21:24, 255:wybe.string @string:21:24, ?#field:wybe.string @string:21:24)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm cast(#field:_ @string:21:24, ?#result:char @string:21:24)
Types: Mode checking foreign call {foreign lpvm cast(#field:_ @string:21:24, ?#result:char @string:21:24)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #field:_
Types: Mode check exp resulted in #field:_
Types: Mode check exp ?#result:char
Types: Mode check exp resulted in ?#result:char
Types: Finding type of expr #field:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr ?#result:char @string:21:24
Types:   Type = wybe.char
Types:     types and modes = [wybe.string,?wybe.char]
Types: New instr = {foreign lpvm cast(#field:wybe.string @string:21:24, ?#result:wybe.char @string:21:24)}
Types: Now assigned = semipure test computation binding {#field, #rec, #result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'c'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign llvm lshr(#rec:wybe.string @string:21:24, 2:wybe.string @string:21:24, ?#rec:wybe.string @string:21:24)} @string:21:24,{foreign llvm and(#rec:wybe.string @string:21:24, 255:wybe.string @string:21:24, ?#field:wybe.string @string:21:24)} @string:21:24,{foreign lpvm cast(#field:wybe.string @string:21:24, ?#result:wybe.char @string:21:24)} @string:21:24]
Types: Vars defined by body: semipure test computation binding {#field, #rec, #result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking c
Types: ** Type checking c: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign llvm and(#rec:_ @string:21:24, -1021:_ @string:21:24, ?#rec:_ @string:21:24)
Types:         foreign llvm shl(#field:_:!char @string:21:24, 2:!_ @string:21:24, ?#temp:_ @string:21:24)
Types:         foreign llvm or(#temp:_ @string:21:24, #rec:_ @string:21:24, ?#rec:_ @string:21:24)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#field","#rec","#temp","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: !#rec:wybe.string, #field:wybe.char
Types:     type of '#rec' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types:     type of '#field' is wybe.char
Types: Unifying types wybe.char (-> wybe.char) and any (-> any)
Types:   Unification yields wybe.char
Types: Variable #field type constrained to wybe.char
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign llvm and(#rec:_ @string:21:24, -1021:_ @string:21:24, ?#rec:_ @string:21:24)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Recording casts in {foreign llvm shl(#field:_:!char @string:21:24, 2:!_ @string:21:24, ?#temp:_ @string:21:24)}
Types: Unifying types char (-> wybe.char) and wybe.char (-> wybe.char)
Types:   Unification yields wybe.char
Types: Variable #field type constrained to wybe.char
Types: Unifying types _ (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #temp type constrained to wybe.string
Types: Recording casts in {foreign llvm or(#temp:_ @string:21:24, #rec:_ @string:21:24, ?#rec:_ @string:21:24)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #temp type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: *** Before calls Typing {#field::wybe.char, #rec::wybe.string, #temp::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#field::wybe.char, #rec::wybe.string, #temp::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr -1021:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:21:24
Types:   Type = wybe.string
Types: Type checking foreign llvm call and(address, address, address)
Types: Finding type of expr #field:_:!char @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr 2:!_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr ?#temp:_ @string:21:24
Types:   Type = wybe.string
Types: Type checking foreign llvm call shl(address, address, address)
Types: Finding type of expr #temp:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr #rec:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:21:24
Types:   Type = wybe.string
Types: Type checking foreign llvm call or(address, address, address)
Types: Now mode checking proc c
Types: bound vars: semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 3:!wybe.int
Types: Mode check exp resulted in 3:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'c'
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#rec:_ @string:21:24, -1021:_ @string:21:24, ?#rec:_ @string:21:24)
Types: Mode checking foreign call {foreign llvm and(#rec:_ @string:21:24, -1021:_ @string:21:24, ?#rec:_ @string:21:24)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp -1021:_
Types: Mode check exp resulted in -1021:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Finding type of expr #rec:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr -1021:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:21:24
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.string,?wybe.string]
Types: New instr = {foreign llvm and(#rec:wybe.string @string:21:24, -1021:wybe.string @string:21:24, ?#rec:wybe.string @string:21:24)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm shl(#field:_:!char @string:21:24, 2:!_ @string:21:24, ?#temp:_ @string:21:24)
Types: Mode checking foreign call {foreign llvm shl(#field:_:!char @string:21:24, 2:!_ @string:21:24, ?#temp:_ @string:21:24)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #field:_:!char
Types: Mode check exp resulted in #field:_:!char
Types: Mode check exp 2:!_
Types: Mode check exp resulted in 2:!_
Types: Mode check exp ?#temp:_
Types: Mode check exp resulted in ?#temp:_
Types: Finding type of expr #field:_:!char @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr 2:!_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr ?#temp:_ @string:21:24
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.string,?wybe.string]
Types: New instr = {foreign llvm shl(#field:wybe.string:!char @string:21:24, 2:!wybe.string @string:21:24, ?#temp:wybe.string @string:21:24)}
Types: Now assigned = semipure test computation binding {#field, #rec, #temp, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm or(#temp:_ @string:21:24, #rec:_ @string:21:24, ?#rec:_ @string:21:24)
Types: Mode checking foreign call {foreign llvm or(#temp:_ @string:21:24, #rec:_ @string:21:24, ?#rec:_ @string:21:24)}
Types:     with assigned semipure test computation binding {#field, #rec, #temp, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #temp:_
Types: Mode check exp resulted in #temp:_
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Finding type of expr #temp:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr #rec:_ @string:21:24
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:21:24
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.string,?wybe.string]
Types: New instr = {foreign llvm or(#temp:wybe.string @string:21:24, #rec:wybe.string @string:21:24, ?#rec:wybe.string @string:21:24)}
Types: Now assigned = semipure test computation binding {#field, #rec, #temp, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'c'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign llvm and(#rec:wybe.string @string:21:24, -1021:wybe.string @string:21:24, ?#rec:wybe.string @string:21:24)} @string:21:24,{foreign llvm shl(#field:wybe.string:!char @string:21:24, 2:!wybe.string @string:21:24, ?#temp:wybe.string @string:21:24)} @string:21:24,{foreign llvm or(#temp:wybe.string @string:21:24, #rec:wybe.string @string:21:24, ?#rec:wybe.string @string:21:24)} @string:21:24]
Types: Vars defined by body: semipure test computation binding {#field, #rec, #temp, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : #rec
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of c:
Types: 
Types: c > {test,inline} (0 calls)
Types: 4: c(#rec:wybe.string @string:21:24, ?#result:wybe.char @string:21:24):
Types:     (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign llvm lshr(#rec:wybe.string @string:21:24, 2:wybe.string @string:21:24, ?#rec:wybe.string @string:21:24)
Types:     foreign llvm and(#rec:wybe.string @string:21:24, 255:wybe.string @string:21:24, ?#field:wybe.string @string:21:24)
Types:     foreign lpvm cast(#field:wybe.string @string:21:24, ?#result:wybe.char @string:21:24)
Types: 
Types: c > {test,inline} (0 calls)
Types: 4: c(!#rec:wybe.string @string:21:24, #field:wybe.char @string:21:24):
Types:     (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 3:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign llvm and(#rec:wybe.string @string:21:24, -1021:wybe.string @string:21:24, ?#rec:wybe.string @string:21:24)
Types:     foreign llvm shl(#field:wybe.string:!char @string:21:24, 2:!wybe.string @string:21:24, ?#temp:wybe.string @string:21:24)
Types:     foreign llvm or(#temp:wybe.string @string:21:24, #rec:wybe.string @string:21:24, ?#rec:wybe.string @string:21:24)
Types: Type checking non-recursive proc wybe.string.buffer
Types: ** Type checking decl of proc buffer
Types: found 2 definition(s)
Types: Type checking buffer
Types: ** Type checking buffer: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         foreign lpvm alloc(16, ?#rec:_ @string:14:14)
Types:         foreign lpvm mutate(#rec:_ @string:14:14, ?#rec:_ @string:14:14, 0, 1, 16, 0, len:int @string:14:21)
Types:         foreign lpvm mutate(#rec:_ @string:14:14, ?#rec:_ @string:14:14, 8, 1, 16, 0, raw:c_string @string:14:30)
Types:         foreign llvm or(#rec:_ @string:14:14, 0, ?#result:_ @string:14:14)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#rec","#result","len","raw"]
Types: Recording parameter types: len:wybe.int, raw:wybe.c_string, ?#result:wybe.string
Types:     type of 'len' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable len type constrained to wybe.int
Types:     type of 'raw' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable raw type constrained to wybe.c_string
Types:     type of '#result' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Recording resource types: 
Types: Recording casts in {foreign lpvm alloc(16, ?#rec:_ @string:14:14)}
Types: Unifying types _ (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Recording casts in {foreign lpvm mutate(#rec:_ @string:14:14, ?#rec:_ @string:14:14, 0, 1, 16, 0, len:int @string:14:21)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable len type constrained to wybe.int
Types: Recording casts in {foreign lpvm mutate(#rec:_ @string:14:14, ?#rec:_ @string:14:14, 8, 1, 16, 0, raw:c_string @string:14:30)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types c_string (-> wybe.c_string) and wybe.c_string (-> wybe.c_string)
Types:   Unification yields wybe.c_string
Types: Variable raw type constrained to wybe.c_string
Types: Recording casts in {foreign llvm or(#rec:_ @string:14:14, 0, ?#result:_ @string:14:14)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: *** Before calls Typing {#rec::wybe.string, #result::wybe.string, len::wybe.int, raw::wybe.c_string}; {} (with no errors)
Types:   With calls:
Types:   Typing {#rec::wybe.string, #result::wybe.string, len::wybe.int, raw::wybe.c_string}; {} (with no errors)
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr ?#rec:_ @string:14:14
Types:   Type = wybe.string
Types: Type checking foreign lpvm call alloc(64 bit signed, address)
Types: Finding type of expr #rec:_ @string:14:14
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:14:14
Types:   Type = wybe.string
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr len:int @string:14:21
Types:   Type = wybe.int
Types: Type checking foreign lpvm call mutate(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr #rec:_ @string:14:14
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:14:14
Types:   Type = wybe.string
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr raw:c_string @string:14:30
Types:   Type = wybe.c_string
Types: Type checking foreign lpvm call mutate(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Finding type of expr #rec:_ @string:14:14
Types:   Type = wybe.string
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?#result:_ @string:14:14
Types:   Type = wybe.string
Types: Type checking foreign llvm call or(address, 64 bit signed, address)
Types: Now mode checking proc buffer
Types: bound vars: semipure normal (total) computation binding {len, raw}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm alloc(16, ?#rec:_ @string:14:14)
Types: Mode checking foreign call {foreign lpvm alloc(16, ?#rec:_ @string:14:14)}
Types:     with assigned semipure normal (total) computation binding {len, raw}, break set = Everything, with resources {}
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr ?#rec:_ @string:14:14
Types:   Type = wybe.string
Types:     types and modes = [wybe.int,?wybe.string]
Types: New instr = {foreign lpvm alloc(16:wybe.int, ?#rec:wybe.string @string:14:14)}
Types: Now assigned = semipure normal (total) computation binding {#rec, len, raw}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm mutate(#rec:_ @string:14:14, ?#rec:_ @string:14:14, 0, 1, 16, 0, len:int @string:14:21)
Types: Mode checking foreign call {foreign lpvm mutate(#rec:_ @string:14:14, ?#rec:_ @string:14:14, 0, 1, 16, 0, len:int @string:14:21)}
Types:     with assigned semipure normal (total) computation binding {#rec, len, raw}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp len:int
Types: Mode check exp resulted in len:int
Types: Finding type of expr #rec:_ @string:14:14
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:14:14
Types:   Type = wybe.string
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr len:int @string:14:21
Types:   Type = wybe.int
Types:     types and modes = [wybe.string,?wybe.string,wybe.int,wybe.int,wybe.int,wybe.int,wybe.int]
Types: New instr = {foreign lpvm mutate(#rec:wybe.string @string:14:14, ?#rec:wybe.string @string:14:14, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, len:wybe.int @string:14:21)}
Types: Now assigned = semipure normal (total) computation binding {#rec, len, raw}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm mutate(#rec:_ @string:14:14, ?#rec:_ @string:14:14, 8, 1, 16, 0, raw:c_string @string:14:30)
Types: Mode checking foreign call {foreign lpvm mutate(#rec:_ @string:14:14, ?#rec:_ @string:14:14, 8, 1, 16, 0, raw:c_string @string:14:30)}
Types:     with assigned semipure normal (total) computation binding {#rec, len, raw}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp 8
Types: Mode check exp resulted in 8
Types: Mode check exp 1
Types: Mode check exp resulted in 1
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp raw:c_string
Types: Mode check exp resulted in raw:c_string
Types: Finding type of expr #rec:_ @string:14:14
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:14:14
Types:   Type = wybe.string
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 1
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr raw:c_string @string:14:30
Types:   Type = wybe.c_string
Types:     types and modes = [wybe.string,?wybe.string,wybe.int,wybe.int,wybe.int,wybe.int,wybe.c_string]
Types: New instr = {foreign lpvm mutate(#rec:wybe.string @string:14:14, ?#rec:wybe.string @string:14:14, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, raw:wybe.c_string @string:14:30)}
Types: Now assigned = semipure normal (total) computation binding {#rec, len, raw}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm or(#rec:_ @string:14:14, 0, ?#result:_ @string:14:14)
Types: Mode checking foreign call {foreign llvm or(#rec:_ @string:14:14, 0, ?#result:_ @string:14:14)}
Types:     with assigned semipure normal (total) computation binding {#rec, len, raw}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?#result:_
Types: Mode check exp resulted in ?#result:_
Types: Finding type of expr #rec:_ @string:14:14
Types:   Type = wybe.string
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?#result:_ @string:14:14
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.int,?wybe.string]
Types: New instr = {foreign llvm or(#rec:wybe.string @string:14:14, 0:wybe.int, ?#result:wybe.string @string:14:14)}
Types: Now assigned = semipure normal (total) computation binding {#rec, #result, len, raw}, break set = Everything, with resources {}
Types: Mode check end of Det proc 'buffer'
Types: Mode checked body   : [{foreign lpvm alloc(16:wybe.int, ?#rec:wybe.string @string:14:14)} @string:14:14,{foreign lpvm mutate(#rec:wybe.string @string:14:14, ?#rec:wybe.string @string:14:14, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, len:wybe.int @string:14:21)} @string:14:14,{foreign lpvm mutate(#rec:wybe.string @string:14:14, ?#rec:wybe.string @string:14:14, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, raw:wybe.c_string @string:14:30)} @string:14:14,{foreign llvm or(#rec:wybe.string @string:14:14, 0:wybe.int, ?#result:wybe.string @string:14:14)} @string:14:14]
Types: Vars defined by body: semipure normal (total) computation binding {#rec, #result, len, raw}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking buffer
Types: ** Type checking buffer: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign lpvm access(#result:_ @string:14:14, 0, 16, 0, ?len:int @string:14:21)
Types:         foreign lpvm access(#result:_ @string:14:14, 8, 16, 0, ?raw:c_string @string:14:30)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","len","raw","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: ?len:wybe.int, ?raw:wybe.c_string, #result:wybe.string
Types:     type of 'len' is wybe.int
Types: Unifying types wybe.int (-> wybe.int) and any (-> any)
Types:   Unification yields wybe.int
Types: Variable len type constrained to wybe.int
Types:     type of 'raw' is wybe.c_string
Types: Unifying types wybe.c_string (-> wybe.c_string) and any (-> any)
Types:   Unification yields wybe.c_string
Types: Variable raw type constrained to wybe.c_string
Types:     type of '#result' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign lpvm access(#result:_ @string:14:14, 0, 16, 0, ?len:int @string:14:21)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types int (-> wybe.int) and wybe.int (-> wybe.int)
Types:   Unification yields wybe.int
Types: Variable len type constrained to wybe.int
Types: Recording casts in {foreign lpvm access(#result:_ @string:14:14, 8, 16, 0, ?raw:c_string @string:14:30)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Unifying types c_string (-> wybe.c_string) and wybe.c_string (-> wybe.c_string)
Types:   Unification yields wybe.c_string
Types: Variable raw type constrained to wybe.c_string
Types: *** Before calls Typing {#result::wybe.string, len::wybe.int, raw::wybe.c_string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#result::wybe.string, len::wybe.int, raw::wybe.c_string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #result:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #result:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #result:_ @string:14:14
Types:   Type = wybe.string
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?len:int @string:14:21
Types:   Type = wybe.int
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr #result:_ @string:14:14
Types:   Type = wybe.string
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?raw:c_string @string:14:30
Types:   Type = wybe.c_string
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Now mode checking proc buffer
Types: bound vars: semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#result}, break set = Everything, with resources {}
Types: Mode check exp #result:!wybe.int
Types: Mode check exp resulted in #result:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #result:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#result, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#result, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #result:!wybe.int
Types: Mode check exp resulted in #result:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #result:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#result, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#result, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 0:!wybe.int
Types: Mode check exp resulted in 0:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 0:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'buffer'
Types: Now assigned = semipure test computation binding {#result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#result:_ @string:14:14, 0, 16, 0, ?len:int @string:14:21)
Types: Mode checking foreign call {foreign lpvm access(#result:_ @string:14:14, 0, 16, 0, ?len:int @string:14:21)}
Types:     with assigned semipure test computation binding {#result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #result:_
Types: Mode check exp resulted in #result:_
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?len:int
Types: Mode check exp resulted in ?len:int
Types: Finding type of expr #result:_ @string:14:14
Types:   Type = wybe.string
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?len:int @string:14:21
Types:   Type = wybe.int
Types:     types and modes = [wybe.string,wybe.int,wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign lpvm access(#result:wybe.string @string:14:14, 0:wybe.int, 16:wybe.int, 0:wybe.int, ?len:wybe.int @string:14:21)}
Types: Now assigned = semipure test computation binding {#result, len, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#result:_ @string:14:14, 8, 16, 0, ?raw:c_string @string:14:30)
Types: Mode checking foreign call {foreign lpvm access(#result:_ @string:14:14, 8, 16, 0, ?raw:c_string @string:14:30)}
Types:     with assigned semipure test computation binding {#result, len, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #result:_
Types: Mode check exp resulted in #result:_
Types: Mode check exp 8
Types: Mode check exp resulted in 8
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp ?raw:c_string
Types: Mode check exp resulted in ?raw:c_string
Types: Finding type of expr #result:_ @string:14:14
Types:   Type = wybe.string
Types: Finding type of expr 8
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr ?raw:c_string @string:14:30
Types:   Type = wybe.c_string
Types:     types and modes = [wybe.string,wybe.int,wybe.int,wybe.int,?wybe.c_string]
Types: New instr = {foreign lpvm access(#result:wybe.string @string:14:14, 8:wybe.int, 16:wybe.int, 0:wybe.int, ?raw:wybe.c_string @string:14:30)}
Types: Now assigned = semipure test computation binding {#result, len, raw, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'buffer'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign lpvm access(#result:wybe.string @string:14:14, 0:wybe.int, 16:wybe.int, 0:wybe.int, ?len:wybe.int @string:14:21)} @string:14:14,{foreign lpvm access(#result:wybe.string @string:14:14, 8:wybe.int, 16:wybe.int, 0:wybe.int, ?raw:wybe.c_string @string:14:30)} @string:14:14]
Types: Vars defined by body: semipure test computation binding {#result, len, raw, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : len, raw
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of buffer:
Types: 
Types: buffer > {inline} (0 calls)
Types: 4: buffer(len:wybe.int @string:14:21, raw:wybe.c_string @string:14:30, ?#result:wybe.string @string:14:14):
Types:     foreign lpvm alloc(16:wybe.int, ?#rec:wybe.string @string:14:14)
Types:     foreign lpvm mutate(#rec:wybe.string @string:14:14, ?#rec:wybe.string @string:14:14, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, len:wybe.int @string:14:21)
Types:     foreign lpvm mutate(#rec:wybe.string @string:14:14, ?#rec:wybe.string @string:14:14, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, raw:wybe.c_string @string:14:30)
Types:     foreign llvm or(#rec:wybe.string @string:14:14, 0:wybe.int, ?#result:wybe.string @string:14:14)
Types: 
Types: buffer > {test,inline} (0 calls)
Types: 4: buffer(?len:wybe.int @string:14:21, ?raw:wybe.c_string @string:14:30, #result:wybe.string @string:14:14):
Types:     (   foreign llvm icmp_uge(#result:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#result:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 0:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign lpvm access(#result:wybe.string @string:14:14, 0:wybe.int, 16:wybe.int, 0:wybe.int, ?len:wybe.int @string:14:21)
Types:     foreign lpvm access(#result:wybe.string @string:14:14, 8:wybe.int, 16:wybe.int, 0:wybe.int, ?raw:wybe.c_string @string:14:30)
Types: Type checking non-recursive proc wybe.string.base
Types: ** Type checking decl of proc base
Types: found 2 definition(s)
Types: Type checking base
Types: ** Type checking base: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign lpvm access(#rec:_ @string:19:20, -2, 16, 2, ?#result:_ @string:19:20)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#rec","#result","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: #rec:wybe.string, ?#result:wybe.string
Types:     type of '#rec' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types:     type of '#result' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign lpvm access(#rec:_ @string:19:20, -2, 16, 2, ?#result:_ @string:19:20)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #result type constrained to wybe.string
Types: *** Before calls Typing {#rec::wybe.string, #result::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#rec::wybe.string, #result::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:_ @string:19:20
Types:   Type = wybe.string
Types: Finding type of expr -2
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 2
Types:   Type = wybe.int
Types: Finding type of expr ?#result:_ @string:19:20
Types:   Type = wybe.string
Types: Type checking foreign lpvm call access(address, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Now mode checking proc base
Types: bound vars: semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 2:!wybe.int
Types: Mode check exp resulted in 2:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'base'
Types: Now assigned = semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm access(#rec:_ @string:19:20, -2, 16, 2, ?#result:_ @string:19:20)
Types: Mode checking foreign call {foreign lpvm access(#rec:_ @string:19:20, -2, 16, 2, ?#result:_ @string:19:20)}
Types:     with assigned semipure test computation binding {#rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp -2
Types: Mode check exp resulted in -2
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 2
Types: Mode check exp resulted in 2
Types: Mode check exp ?#result:_
Types: Mode check exp resulted in ?#result:_
Types: Finding type of expr #rec:_ @string:19:20
Types:   Type = wybe.string
Types: Finding type of expr -2
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 2
Types:   Type = wybe.int
Types: Finding type of expr ?#result:_ @string:19:20
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,wybe.int,wybe.int,wybe.int,?wybe.string]
Types: New instr = {foreign lpvm access(#rec:wybe.string @string:19:20, -2:wybe.int, 16:wybe.int, 2:wybe.int, ?#result:wybe.string @string:19:20)}
Types: Now assigned = semipure test computation binding {#rec, #result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'base'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign lpvm access(#rec:wybe.string @string:19:20, -2:wybe.int, 16:wybe.int, 2:wybe.int, ?#result:wybe.string @string:19:20)} @string:19:20]
Types: Vars defined by body: semipure test computation binding {#rec, #result, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: Type checking base
Types: ** Type checking base: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types: Finding type of expr tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Finding type of expr tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types:    containing calls: 
Types:         foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:         foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:         foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:         foreign lpvm mutate(#rec:_ @string:19:20, ?#rec:_ @string:19:20, -2, 0, 16, 2, #field)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#field","#rec","tmp#0","tmp#1","tmp#2"]
Types: Recording parameter types: !#rec:wybe.string, #field:wybe.string
Types:     type of '#rec' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types:     type of '#field' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable #field type constrained to wybe.string
Types: Recording resource types: 
Types: Recording casts in {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#0 type constrained to any
Types: Recording casts in {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Unifying types any (-> any) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Recording casts in {foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#2 type constrained to any
Types: Unifying types any (-> any) and any (-> any)
Types:   Unification yields any
Types: Variable tmp#1 type constrained to any
Types: Recording casts in {foreign lpvm mutate(#rec:_ @string:19:20, ?#rec:_ @string:19:20, -2, 0, 16, 2, #field)}
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: Unifying types _ (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Variable #rec type constrained to wybe.string
Types: *** Before calls Typing {#field::wybe.string, #rec::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types:   With calls:
Types:   Typing {#field::wybe.string, #rec::wybe.string, tmp#0::any, tmp#1::any, tmp#2::any}; {} (with no errors)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_uge(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Type checking foreign llvm call and(64 bit signed, 64 bit signed, 64 bit signed)
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types: Type checking foreign llvm call icmp_eq(64 bit signed, 64 bit signed, 1 bit unsigned)
Types: Finding type of expr #rec:_ @string:19:20
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:19:20
Types:   Type = wybe.string
Types: Finding type of expr -2
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 2
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.string
Types: Type checking foreign lpvm call mutate(address, address, 64 bit signed, 64 bit signed, 64 bit signed, 64 bit signed, address)
Types: Now mode checking proc base
Types: bound vars: semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check stmt (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:                 & testbool tmp#0:!wybe.bool
Types:                 & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:                 & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:                 & testbool tmp#1:!wybe.bool)
Types: Mode checking conjunction {(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)}
Types: Mode check stmt foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types:     with assigned semipure normal (total) computation binding {#field, #rec}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 1:!wybe.int
Types: Mode check exp resulted in 1:!wybe.int
Types: Mode check exp ?tmp#0:!wybe.bool
Types: Mode check exp resulted in ?tmp#0:!wybe.bool
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 1:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#0:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)}
Types: Now assigned = semipure normal (total) computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#0:!wybe.bool
Types: Mode checking test tmp#0:!wybe.bool
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types: Mode checking foreign call {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0}, break set = Everything, with resources {}
Types: Mode check exp #rec:!wybe.int
Types: Mode check exp resulted in #rec:!wybe.int
Types: Mode check exp 3:wybe.int
Types: Mode check exp resulted in 3:wybe.int
Types: Mode check exp ?tmp#2:!wybe.int
Types: Mode check exp resulted in ?tmp#2:!wybe.int
Types: Finding type of expr #rec:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 3:wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#2:!wybe.int
Types:   Type = wybe.int
Types:     types and modes = [wybe.int,wybe.int,?wybe.int]
Types: New instr = {foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types: Mode checking foreign call {foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp tmp#2:!wybe.int
Types: Mode check exp resulted in tmp#2:!wybe.int
Types: Mode check exp 2:!wybe.int
Types: Mode check exp resulted in 2:!wybe.int
Types: Mode check exp ?tmp#1:!wybe.bool
Types: Mode check exp resulted in ?tmp#1:!wybe.bool
Types: Finding type of expr tmp#2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr 2:!wybe.int
Types:   Type = wybe.int
Types: Finding type of expr ?tmp#1:!wybe.bool
Types:   Type = wybe.bool
Types:     types and modes = [wybe.int,wybe.int,?wybe.bool]
Types: New instr = {foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt testbool tmp#1:!wybe.bool
Types: Mode checking test tmp#1:!wybe.bool
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'base'
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check stmt foreign lpvm mutate(#rec:_ @string:19:20, ?#rec:_ @string:19:20, -2, 0, 16, 2, #field)
Types: Mode checking foreign call {foreign lpvm mutate(#rec:_ @string:19:20, ?#rec:_ @string:19:20, -2, 0, 16, 2, #field)}
Types:     with assigned semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check exp #rec:_
Types: Mode check exp resulted in #rec:_
Types: Mode check exp ?#rec:_
Types: Mode check exp resulted in ?#rec:_
Types: Mode check exp -2
Types: Mode check exp resulted in -2
Types: Mode check exp 0
Types: Mode check exp resulted in 0
Types: Mode check exp 16
Types: Mode check exp resulted in 16
Types: Mode check exp 2
Types: Mode check exp resulted in 2
Types: Mode check exp #field
Types: Mode check exp resulted in #field
Types: Finding type of expr #rec:_ @string:19:20
Types:   Type = wybe.string
Types: Finding type of expr ?#rec:_ @string:19:20
Types:   Type = wybe.string
Types: Finding type of expr -2
Types:   Type = wybe.int
Types: Finding type of expr 0
Types:   Type = wybe.int
Types: Finding type of expr 16
Types:   Type = wybe.int
Types: Finding type of expr 2
Types:   Type = wybe.int
Types: Finding type of expr #field
Types:   Type = wybe.string
Types:     types and modes = [wybe.string,?wybe.string,wybe.int,wybe.int,wybe.int,wybe.int,wybe.string]
Types: New instr = {foreign lpvm mutate(#rec:wybe.string @string:19:20, ?#rec:wybe.string @string:19:20, -2:wybe.int, 0:wybe.int, 16:wybe.int, 2:wybe.int, #field:wybe.string)}
Types: Now assigned = semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Mode check end of SemiDet proc 'base'
Types: Mode checked body   : [{(   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)},{foreign lpvm mutate(#rec:wybe.string @string:19:20, ?#rec:wybe.string @string:19:20, -2:wybe.int, 0:wybe.int, 16:wybe.int, 2:wybe.int, #field:wybe.string)} @string:19:20]
Types: Vars defined by body: semipure test computation binding {#field, #rec, tmp#0, tmp#1, tmp#2}, break set = Everything, with resources {}
Types: Output parameters   : #rec
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of base:
Types: 
Types: base > {test,inline} (0 calls)
Types: 4: base(#rec:wybe.string @string:19:20, ?#result:wybe.string @string:19:20):
Types:     (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign lpvm access(#rec:wybe.string @string:19:20, -2:wybe.int, 16:wybe.int, 2:wybe.int, ?#result:wybe.string @string:19:20)
Types: 
Types: base > {test,inline} (0 calls)
Types: 4: base(!#rec:wybe.string @string:19:20, #field:wybe.string @string:19:20):
Types:     (   foreign llvm icmp_uge(#rec:!wybe.int, 1:!wybe.int, ?tmp#0:!wybe.bool)
Types:     & testbool tmp#0:!wybe.bool
Types:     & foreign llvm and(#rec:!wybe.int, 3:wybe.int, ?tmp#2:!wybe.int)
Types:     & foreign llvm icmp_eq(tmp#2:!wybe.int, 2:!wybe.int, ?tmp#1:!wybe.bool)
Types:     & testbool tmp#1:!wybe.bool)
Types:     foreign lpvm mutate(#rec:wybe.string @string:19:20, ?#rec:wybe.string @string:19:20, -2:wybe.int, 0:wybe.int, 16:wybe.int, 2:wybe.int, #field:wybe.string)
Types: **** Type checking recursive procs wybe.string.<, wybe.string.<=>, wybe.string.=, wybe.string.>, wybe.string.[|], wybe.string.[], wybe.string.<=, wybe.string.length, wybe.string.fixed_range_size
Types: ** Type checking decl of proc <
Types: found 1 definition(s)
Types: Type checking <
Types: ** Type checking <: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
Types:         equal(?tmp#2 @string:119:44)
Types:         <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
Types:         foreign llvm move(tmp#0, ?#result @string:119:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","tmp#0","tmp#1","tmp#2","x","y"]
Types: Recording parameter types: x:wybe.string, y:wybe.string, ?#result:wybe.bool
Types:     type of 'x' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable x type constrained to wybe.string
Types:     type of 'y' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable y type constrained to wybe.string
Types:     type of '#result' is wybe.bool
Types: Unifying types wybe.bool (-> wybe.bool) and any (-> any)
Types:   Unification yields wybe.bool
Types: Variable #result type constrained to wybe.bool
Types: Recording resource types: 
Types: Recording casts in {<=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)}
Types: Recording casts in {equal(?tmp#2 @string:119:44)}
Types: Recording casts in {<(tmp#1, tmp#2, ?tmp#0 @string:119:29)}
Types: Recording casts in {foreign llvm move(tmp#0, ?#result @string:119:5)}
Types: Unifying move argument types tmp#0 and ?#result @string:119:5
Types: Finding type of expr tmp#0
Types:   Type = 0
Types: Finding type of expr ?#result @string:119:5
Types:   Type = wybe.bool
Types: Type variable 0 is bound to Nothing
Types: Unifying types 0 (-> 0) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: *** Before calls Typing {#result::wybe.bool, tmp#0::0, x::wybe.string, y::wybe.string}; {0::wybe.bool} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {<=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)} @string:119:30, typingInfos = [wybe.char.<=><0>(wybe.char,wybe.char,?wybe.comparison),wybe.int.<=><0>(wybe.int,wybe.int,?wybe.comparison),wybe.string.<=><0>(wybe.string,wybe.string,?wybe.comparison)]}
Types:     StmtTypings {typingStmt = {equal(?tmp#2 @string:119:44)} @string:119:44, typingInfos = [wybe.comparison.equal<0>(?wybe.comparison)]}
Types:     StmtTypings {typingStmt = {<(tmp#1, tmp#2, ?tmp#0 @string:119:29)} @string:119:29, typingInfos = [wybe.c_string.<<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.<<0>(wybe.char,wybe.char,?wybe.bool),wybe.comparison.<<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool),wybe.string.<<0>(wybe.string,wybe.string,?wybe.bool)]}Typing {#result::wybe.bool, tmp#0::0, x::wybe.string, y::wybe.string}; {0::wybe.bool} (with no errors)
Types: Type checking call {<=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)} @string:119:30
Types: Candidate types:
Types:     wybe.char.<=><0>(wybe.char,wybe.char,?wybe.comparison)
Types:     wybe.int.<=><0>(wybe.int,wybe.int,?wybe.comparison)
Types:     wybe.string.<=><0>(wybe.string,wybe.string,?wybe.comparison)
Types: Finding type of expr x @string:119:30
Types:   Type = wybe.string
Types: Finding type of expr y @string:119:38
Types:   Type = wybe.string
Types: Finding type of expr ?tmp#1 @string:119:30
Types:   Type = 1
Types: Actual types: [wybe.string,wybe.string,1]
Types: Matching types [wybe.string,wybe.string,1] with wybe.char.<=><0>(wybe.char,wybe.char,?wybe.comparison)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.string (-> wybe.string) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 30): Type error in call to <=>, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.string (-> wybe.string) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 30): Type error in call to <=>, argument 2]
Types:   Unification yields XXX
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.string,wybe.string,1] with wybe.int.<=><0>(wybe.int,wybe.int,?wybe.comparison)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.string (-> wybe.string) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 30): Type error in call to <=>, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.string (-> wybe.string) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 30): Type error in call to <=>, argument 2]
Types:   Unification yields XXX
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.string,wybe.string,1] with wybe.string.<=><0>(wybe.string,wybe.string,?wybe.comparison)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.string (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Unifying types wybe.string (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Type variable 1 is bound to Nothing
Types: Unifying types 1 (-> 1) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Valid types = [Typing {#result::wybe.bool, tmp#0::0, tmp#1::1, x::wybe.string, y::wybe.string}; {0::wybe.bool, 1::wybe.comparison} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.bool, tmp#0::0, tmp#1::1, x::wybe.string, y::wybe.string}; {0::wybe.bool, 1::wybe.comparison} (with no errors)
Types: Type checking call {equal(?tmp#2 @string:119:44)} @string:119:44
Types: Candidate types:
Types:     wybe.comparison.equal<0>(?wybe.comparison)
Types: Finding type of expr ?tmp#2 @string:119:44
Types:   Type = 2
Types: Actual types: [2]
Types: Matching types [2] with wybe.comparison.equal<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Type variable 2 is bound to Nothing
Types: Unifying types 2 (-> 2) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Valid types = [Typing {#result::wybe.bool, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.string, y::wybe.string}; {0::wybe.bool, 1::wybe.comparison, 2::wybe.comparison} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.bool, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.string, y::wybe.string}; {0::wybe.bool, 1::wybe.comparison, 2::wybe.comparison} (with no errors)
Types: Type checking call {<(tmp#1, tmp#2, ?tmp#0 @string:119:29)} @string:119:29
Types: Candidate types:
Types:     wybe.c_string.<<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types:     wybe.char.<<0>(wybe.char,wybe.char,?wybe.bool)
Types:     wybe.comparison.<<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)
Types:     wybe.string.<<0>(wybe.string,wybe.string,?wybe.bool)
Types: Finding type of expr tmp#1
Types: Type variable 1 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr tmp#2
Types: Type variable 2 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0 @string:119:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Actual types: [wybe.comparison,wybe.comparison,wybe.bool]
Types: Matching types [wybe.comparison,wybe.comparison,wybe.bool] with wybe.c_string.<<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 29): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 29): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.comparison,wybe.comparison,wybe.bool] with wybe.char.<<0>(wybe.char,wybe.char,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 29): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 29): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.comparison,wybe.comparison,wybe.bool] with wybe.comparison.<<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.comparison,wybe.comparison,wybe.bool] with wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 29): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 29): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.comparison,wybe.comparison,wybe.bool] with wybe.string.<<0>(wybe.string,wybe.string,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.string (-> wybe.string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 29): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.string (-> wybe.string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 29): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Valid types = [Typing {#result::wybe.bool, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.string, y::wybe.string}; {0::wybe.bool, 1::wybe.comparison, 2::wybe.comparison} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.bool, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.string, y::wybe.string}; {0::wybe.bool, 1::wybe.comparison, 2::wybe.comparison} (with no errors)
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @string:119:5
Types:   Type = wybe.bool
Types: Type checking foreign llvm call move(1 bit unsigned, 1 bit unsigned)
Types: Now mode checking proc <
Types: bound vars: semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check stmt <=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)
Types: Mode checking call   : {<=>(x @string:119:30, y @string:119:38, ?tmp#1 @string:119:30)}
Types:     with assigned    : semipure normal (total) computation binding {x, y}, break set = Everything, with resources {}
Types: Mode check exp x
Types: Mode check exp resulted in x
Types: Mode check exp y
Types: Mode check exp resulted in y
Types: Mode check exp ?tmp#1
Types: Mode check exp resulted in ?tmp#1
Types: Finding type of expr x @string:119:30
Types:   Type = wybe.string
Types: Finding type of expr y @string:119:38
Types:   Type = wybe.string
Types: Finding type of expr ?tmp#1 @string:119:30
Types: Type variable 1 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     actual types     : [wybe.string,wybe.string,wybe.comparison]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.string,wybe.string,wybe.comparison] with wybe.char.<=><0>(wybe.char,wybe.char,?wybe.comparison)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.string (-> wybe.string) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 30): Type error in call to <=>, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.string (-> wybe.string) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 30): Type error in call to <=>, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.string,wybe.string,wybe.comparison] with wybe.int.<=><0>(wybe.int,wybe.int,?wybe.comparison)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.string (-> wybe.string) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 30): Type error in call to <=>, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.string (-> wybe.string) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 30): Type error in call to <=>, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.string,wybe.string,wybe.comparison] with wybe.string.<=><0>(wybe.string,wybe.string,?wybe.comparison)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.string (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Unifying types wybe.string (-> wybe.string) and wybe.string (-> wybe.string)
Types:   Unification yields wybe.string
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Type-correct modes   : [(wybe.string.<=><0>(wybe.string,wybe.string,?wybe.comparison),Typing {#result::wybe.bool, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.string, y::wybe.string}; {0::wybe.bool, 1::wybe.comparison, 2::wybe.comparison} (with no errors))]
Types: Possible mode matches: [(wybe.string.<=><0>(wybe.string,wybe.string,?wybe.comparison),Typing {#result::wybe.bool, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.string, y::wybe.string}; {0::wybe.bool, 1::wybe.comparison, 2::wybe.comparison} (with no errors))]
Types: Exact mode matches: [(wybe.string.<=><0>(wybe.string,wybe.string,?wybe.comparison),Typing {#result::wybe.bool, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.string, y::wybe.string}; {0::wybe.bool, 1::wybe.comparison, 2::wybe.comparison} (with no errors))]
Types: Finding type of expr x @string:119:30
Types:   Type = wybe.string
Types: Finding type of expr y @string:119:38
Types:   Type = wybe.string
Types: Finding type of expr ?tmp#1 @string:119:30
Types: Type variable 1 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finalising call    :  {wybe.string.<0><=>(x:wybe.string @string:119:30, y:wybe.string @string:119:38, ?tmp#1:wybe.comparison @string:119:30)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.string.<0><=>(x:wybe.string @string:119:30, y:wybe.string @string:119:38, ?tmp#1:wybe.comparison @string:119:30)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<'
Types: Now assigned = semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check stmt equal(?tmp#2 @string:119:44)
Types: Mode checking call   : {equal(?tmp#2 @string:119:44)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#1, x, y}, break set = Everything, with resources {}
Types: Mode check exp ?tmp#2
Types: Mode check exp resulted in ?tmp#2
Types: Finding type of expr ?tmp#2 @string:119:44
Types: Type variable 2 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types:     actual types     : [wybe.comparison]
Types:     actual modes     : [(ParamOut,False,Nothing)]
Types: Matching types [wybe.comparison] with wybe.comparison.equal<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Type-correct modes   : [(wybe.comparison.equal<0>(?wybe.comparison),Typing {#result::wybe.bool, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.string, y::wybe.string}; {0::wybe.bool, 1::wybe.comparison, 2::wybe.comparison} (with no errors))]
Types: Possible mode matches: [(wybe.comparison.equal<0>(?wybe.comparison),Typing {#result::wybe.bool, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.string, y::wybe.string}; {0::wybe.bool, 1::wybe.comparison, 2::wybe.comparison} (with no errors))]
Types: Exact mode matches: [(wybe.comparison.equal<0>(?wybe.comparison),Typing {#result::wybe.bool, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.string, y::wybe.string}; {0::wybe.bool, 1::wybe.comparison, 2::wybe.comparison} (with no errors))]
Types: Finding type of expr ?tmp#2 @string:119:44
Types: Type variable 2 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finalising call    :  {wybe.comparison.<0>equal(?tmp#2:wybe.comparison @string:119:44)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"tmp#1", "x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.comparison.<0>equal(?tmp#2:wybe.comparison @string:119:44)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<'
Types: Now assigned = semipure normal (total) computation binding {tmp#1, tmp#2, x, y}, break set = Everything, with resources {}
Types: Mode check stmt <(tmp#1, tmp#2, ?tmp#0 @string:119:29)
Types: Mode checking call   : {<(tmp#1, tmp#2, ?tmp#0 @string:119:29)}
Types:     with assigned    : semipure normal (total) computation binding {tmp#1, tmp#2, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#1
Types: Mode check exp resulted in tmp#1
Types: Mode check exp tmp#2
Types: Mode check exp resulted in tmp#2
Types: Mode check exp ?tmp#0
Types: Mode check exp resulted in ?tmp#0
Types: Finding type of expr tmp#1
Types: Type variable 1 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr tmp#2
Types: Type variable 2 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0 @string:119:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types:     actual types     : [wybe.comparison,wybe.comparison,wybe.bool]
Types:     actual modes     : [(ParamIn,True,Nothing),(ParamIn,True,Nothing),(ParamOut,False,Nothing)]
Types: Matching types [wybe.comparison,wybe.comparison,wybe.bool] with wybe.c_string.<<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 29): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 29): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.comparison,wybe.comparison,wybe.bool] with wybe.char.<<0>(wybe.char,wybe.char,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 29): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 29): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.comparison,wybe.comparison,wybe.bool] with wybe.comparison.<<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.comparison,wybe.comparison,wybe.bool] with wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 29): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 29): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Matching types [wybe.comparison,wybe.comparison,wybe.bool] with wybe.string.<<0>(wybe.string,wybe.string,?wybe.bool)
Types: Call arity 3; proc arity 3 - 3
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.string (-> wybe.string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 29): Type error in call to <, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.string (-> wybe.string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 119, column 29): Type error in call to <, argument 2]
Types:   Unification yields XXX
Types: Unifying types wybe.bool (-> wybe.bool) and wybe.bool (-> wybe.bool)
Types:   Unification yields wybe.bool
Types: Type-correct modes   : [(wybe.comparison.<<0>(wybe.comparison,wybe.comparison,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.string, y::wybe.string}; {0::wybe.bool, 1::wybe.comparison, 2::wybe.comparison} (with no errors))]
Types: Possible mode matches: [(wybe.comparison.<<0>(wybe.comparison,wybe.comparison,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.string, y::wybe.string}; {0::wybe.bool, 1::wybe.comparison, 2::wybe.comparison} (with no errors))]
Types: Exact mode matches: [(wybe.comparison.<<0>(wybe.comparison,wybe.comparison,?wybe.bool),Typing {#result::wybe.bool, tmp#0::0, tmp#1::1, tmp#2::2, x::wybe.string, y::wybe.string}; {0::wybe.bool, 1::wybe.comparison, 2::wybe.comparison} (with no errors))]
Types: Finding type of expr tmp#1
Types: Type variable 1 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr tmp#2
Types: Type variable 2 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr ?tmp#0 @string:119:29
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finalising call    :  {wybe.comparison.<0><(tmp#1:wybe.comparison, tmp#2:wybe.comparison, ?tmp#0:wybe.bool @string:119:29)}
Types: Input resources    :  {}
Types: Output resources   :  {}
Types: Specials in call   :  {}
Types: Available vars     :  {"tmp#1", "tmp#2", "x", "y"}
Types: Available resources:  {}
Types: Generated special stmts = []
Types: New instr = {wybe.comparison.<0><(tmp#1:wybe.comparison, tmp#2:wybe.comparison, ?tmp#0:wybe.bool @string:119:29)}
Types: Generated extra stmts = []
Types: Mode check end of Det proc '<'
Types: Now assigned = semipure normal (total) computation binding {tmp#0, tmp#1, tmp#2, x, y}, break set = Everything, with resources {}
Types: Mode check stmt foreign llvm move(tmp#0, ?#result @string:119:5)
Types: Mode checking foreign call {foreign llvm move(tmp#0, ?#result @string:119:5)}
Types:     with assigned semipure normal (total) computation binding {tmp#0, tmp#1, tmp#2, x, y}, break set = Everything, with resources {}
Types: Mode check exp tmp#0
Types: Mode check exp resulted in tmp#0
Types: Mode check exp ?#result
Types: Mode check exp resulted in ?#result
Types: Finding type of expr tmp#0
Types: Type variable 0 is bound to Just wybe.bool
Types:   Type = wybe.bool
Types: Finding type of expr ?#result @string:119:5
Types:   Type = wybe.bool
Types:     types and modes = [wybe.bool,?wybe.bool]
Types: New instr = {foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @string:119:5)}
Types: Now assigned = semipure normal (total) computation binding {#result, tmp#0, tmp#1, tmp#2, x, y}, break set = Everything, with resources {}
Types: Mode check end of Det proc '<'
Types: Mode checked body   : [{wybe.string.<0><=>(x:wybe.string @string:119:30, y:wybe.string @string:119:38, ?tmp#1:wybe.comparison @string:119:30)} @string:119:30,{wybe.comparison.<0>equal(?tmp#2:wybe.comparison @string:119:44)} @string:119:44,{wybe.comparison.<0><(tmp#1:wybe.comparison, tmp#2:wybe.comparison, ?tmp#0:wybe.bool @string:119:29)} @string:119:29,{foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @string:119:5)} @string:119:5]
Types: Vars defined by body: semipure normal (total) computation binding {#result, tmp#0, tmp#1, tmp#2, x, y}, break set = Everything, with resources {}
Types: Output parameters   : #result
Types: Output resources    : 
Types: ===== NO Need to check again.
Types: ** New definition of <:
Types: 
Types: < > public (0 calls)
Types: 4: <(x:wybe.string @string:119:10, y:wybe.string @string:119:17, ?#result:wybe.bool @string:119:5):
Types:     wybe.string.<0><=>(x:wybe.string @string:119:30, y:wybe.string @string:119:38, ?tmp#1:wybe.comparison @string:119:30)
Types:     wybe.comparison.<0>equal(?tmp#2:wybe.comparison @string:119:44)
Types:     wybe.comparison.<0><(tmp#1:wybe.comparison, tmp#2:wybe.comparison, ?tmp#0:wybe.bool @string:119:29)
Types:     foreign llvm move(tmp#0:wybe.bool, ?#result:wybe.bool @string:119:5)
Types: ** Type checking decl of proc <=>
Types: found 1 definition(s)
Types: Type checking <=>
Types: ** Type checking <=>: Typing {}; {} (with no errors)
Types:    with resources: fromList []
Types:    containing calls: 
Types:         equal(?tmp#0 @string:126:10)
Types:         =(?c @string:126:6, tmp#0)
Types:         foreign llvm move(x @string:127:16, ?tmp#1)
Types:         foreign llvm move(y @string:127:26, ?tmp#2)
Types:         [|](?cx @string:127:10, ?tmp#1, tmp#1)
Types:         [|](?cy @string:127:20, ?tmp#2, tmp#2)
Types:         <(cx @string:128:14, cy @string:128:19)
Types:         lesser(?tmp#3 @string:128:30)
Types:         =(?c @string:128:26, tmp#3)
Types:         >(cx @string:129:14, cy @string:129:19)
Types:         greater(?tmp#4 @string:129:30)
Types:         =(?c @string:129:26, tmp#4)
Types:         equal(?tmp#5 @string:132:14)
Types:         =(c @string:132:10, tmp#5)
Types:         length(x @string:133:22, ?tmp#6 @string:133:15)
Types:         =(?lx @string:133:10, tmp#6)
Types:         length(y @string:134:22, ?tmp#7 @string:134:15)
Types:         =(?ly @string:134:10, tmp#7)
Types:         <(lx @string:135:14, ly @string:135:19)
Types:         lesser(?tmp#8 @string:135:30)
Types:         =(?c @string:135:26, tmp#8)
Types:         >(lx @string:135:39, ly @string:135:44)
Types:         greater(?tmp#9 @string:135:55)
Types:         =(?c @string:135:51, tmp#9)
Types:         foreign llvm move(c @string:125:38, ?#result @string:125:5)
Types:    and defaults: 
Types:    with assigned vars: fromList ["#result","c","cx","cy","lx","ly","tmp#0","tmp#1","tmp#2","tmp#3","tmp#4","tmp#5","tmp#6","tmp#7","tmp#8","tmp#9","x","y"]
Types: Recording parameter types: x:wybe.string, y:wybe.string, ?#result:wybe.comparison
Types:     type of 'x' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable x type constrained to wybe.string
Types:     type of 'y' is wybe.string
Types: Unifying types wybe.string (-> wybe.string) and any (-> any)
Types:   Unification yields wybe.string
Types: Variable y type constrained to wybe.string
Types:     type of '#result' is wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and any (-> any)
Types:   Unification yields wybe.comparison
Types: Variable #result type constrained to wybe.comparison
Types: Recording resource types: 
Types: Recording casts in {equal(?tmp#0 @string:126:10)}
Types: Recording casts in {=(?c @string:126:6, tmp#0)}
Types: Recording casts in {foreign llvm move(x @string:127:16, ?tmp#1)}
Types: Unifying move argument types x @string:127:16 and ?tmp#1
Types: Finding type of expr x @string:127:16
Types:   Type = wybe.string
Types: Finding type of expr ?tmp#1
Types:   Type = 0
Types: Type variable 0 is bound to Nothing
Types: Unifying types wybe.string (-> wybe.string) and 0 (-> 0)
Types:   Unification yields wybe.string
Types: Recording casts in {foreign llvm move(y @string:127:26, ?tmp#2)}
Types: Unifying move argument types y @string:127:26 and ?tmp#2
Types: Finding type of expr y @string:127:26
Types:   Type = wybe.string
Types: Finding type of expr ?tmp#2
Types:   Type = 1
Types: Type variable 1 is bound to Nothing
Types: Unifying types wybe.string (-> wybe.string) and 1 (-> 1)
Types:   Unification yields wybe.string
Types: Recording casts in {[|](?cx @string:127:10, ?tmp#1, tmp#1)}
Types: Recording casts in {[|](?cy @string:127:20, ?tmp#2, tmp#2)}
Types: Recording casts in {<(cx @string:128:14, cy @string:128:19)}
Types: Recording casts in {lesser(?tmp#3 @string:128:30)}
Types: Recording casts in {=(?c @string:128:26, tmp#3)}
Types: Recording casts in {>(cx @string:129:14, cy @string:129:19)}
Types: Recording casts in {greater(?tmp#4 @string:129:30)}
Types: Recording casts in {=(?c @string:129:26, tmp#4)}
Types: Recording casts in {equal(?tmp#5 @string:132:14)}
Types: Recording casts in {=(c @string:132:10, tmp#5)}
Types: Recording casts in {length(x @string:133:22, ?tmp#6 @string:133:15)}
Types: Recording casts in {=(?lx @string:133:10, tmp#6)}
Types: Recording casts in {length(y @string:134:22, ?tmp#7 @string:134:15)}
Types: Recording casts in {=(?ly @string:134:10, tmp#7)}
Types: Recording casts in {<(lx @string:135:14, ly @string:135:19)}
Types: Recording casts in {lesser(?tmp#8 @string:135:30)}
Types: Recording casts in {=(?c @string:135:26, tmp#8)}
Types: Recording casts in {>(lx @string:135:39, ly @string:135:44)}
Types: Recording casts in {greater(?tmp#9 @string:135:55)}
Types: Recording casts in {=(?c @string:135:51, tmp#9)}
Types: Recording casts in {foreign llvm move(c @string:125:38, ?#result @string:125:5)}
Types: Unifying move argument types c @string:125:38 and ?#result @string:125:5
Types: Finding type of expr c @string:125:38
Types:   Type = 2
Types: Finding type of expr ?#result @string:125:5
Types:   Type = wybe.comparison
Types: Type variable 2 is bound to Nothing
Types: Unifying types 2 (-> 2) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: *** Before calls Typing {#result::wybe.comparison, c::2, tmp#1::0, tmp#2::1, x::wybe.string, y::wybe.string}; {0::wybe.string, 1::wybe.string, 2::wybe.comparison} (with no errors)
Types:   With calls:
Types:   StmtTypings {typingStmt = {equal(?tmp#0 @string:126:10)} @string:126:10, typingInfos = [wybe.comparison.equal<0>(?wybe.comparison)]}
Types:     StmtTypings {typingStmt = {=(?c @string:126:6, tmp#0)} @string:126:6, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),wybe.range.=<0>(wybe.range,wybe.range,?wybe.bool),wybe.string.=<0>(wybe.string,wybe.string,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {[|](?cx @string:127:10, ?tmp#1, tmp#1)} @string:127:10, typingInfos = [wybe.c_string.[|]<0>(?wybe.char,?wybe.c_string,wybe.c_string,?wybe.bool),wybe.range.[|]<0>(?wybe.int,?wybe.range,wybe.range,?wybe.bool),{test} wybe.string.[|]<0>(?wybe.char,?wybe.string,wybe.string)]}
Types:     StmtTypings {typingStmt = {[|](?cy @string:127:20, ?tmp#2, tmp#2)} @string:127:20, typingInfos = [wybe.c_string.[|]<0>(?wybe.char,?wybe.c_string,wybe.c_string,?wybe.bool),wybe.range.[|]<0>(?wybe.int,?wybe.range,wybe.range,?wybe.bool),{test} wybe.string.[|]<0>(?wybe.char,?wybe.string,wybe.string)]}
Types:     StmtTypings {typingStmt = {<(cx @string:128:14, cy @string:128:19)} @string:128:14, typingInfos = [wybe.c_string.<<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.<<0>(wybe.char,wybe.char,?wybe.bool),wybe.comparison.<<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool),wybe.string.<<0>(wybe.string,wybe.string,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {lesser(?tmp#3 @string:128:30)} @string:128:30, typingInfos = [wybe.comparison.lesser<0>(?wybe.comparison)]}
Types:     StmtTypings {typingStmt = {=(?c @string:128:26, tmp#3)} @string:128:26, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),wybe.range.=<0>(wybe.range,wybe.range,?wybe.bool),wybe.string.=<0>(wybe.string,wybe.string,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {>(cx @string:129:14, cy @string:129:19)} @string:129:14, typingInfos = [wybe.c_string.><0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.><0>(wybe.char,wybe.char,?wybe.bool),wybe.comparison.><0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.><0>(wybe.int,wybe.int,?wybe.bool),wybe.string.><0>(wybe.string,wybe.string,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {greater(?tmp#4 @string:129:30)} @string:129:30, typingInfos = [wybe.comparison.greater<0>(?wybe.comparison)]}
Types:     StmtTypings {typingStmt = {=(?c @string:129:26, tmp#4)} @string:129:26, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),wybe.range.=<0>(wybe.range,wybe.range,?wybe.bool),wybe.string.=<0>(wybe.string,wybe.string,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {equal(?tmp#5 @string:132:14)} @string:132:14, typingInfos = [wybe.comparison.equal<0>(?wybe.comparison)]}
Types:     StmtTypings {typingStmt = {=(c @string:132:10, tmp#5)} @string:132:10, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),wybe.range.=<0>(wybe.range,wybe.range,?wybe.bool),wybe.string.=<0>(wybe.string,wybe.string,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {length(x @string:133:22, ?tmp#6 @string:133:15)} @string:133:15, typingInfos = [wybe.c_string.length<0>(wybe.c_string,?wybe.int),wybe.string.length<0>(wybe.string,?wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?lx @string:133:10, tmp#6)} @string:133:10, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),wybe.range.=<0>(wybe.range,wybe.range,?wybe.bool),wybe.string.=<0>(wybe.string,wybe.string,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {length(y @string:134:22, ?tmp#7 @string:134:15)} @string:134:15, typingInfos = [wybe.c_string.length<0>(wybe.c_string,?wybe.int),wybe.string.length<0>(wybe.string,?wybe.int)]}
Types:     StmtTypings {typingStmt = {=(?ly @string:134:10, tmp#7)} @string:134:10, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),wybe.range.=<0>(wybe.range,wybe.range,?wybe.bool),wybe.string.=<0>(wybe.string,wybe.string,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {<(lx @string:135:14, ly @string:135:19)} @string:135:14, typingInfos = [wybe.c_string.<<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.<<0>(wybe.char,wybe.char,?wybe.bool),wybe.comparison.<<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.<<0>(wybe.int,wybe.int,?wybe.bool),wybe.string.<<0>(wybe.string,wybe.string,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {lesser(?tmp#8 @string:135:30)} @string:135:30, typingInfos = [wybe.comparison.lesser<0>(?wybe.comparison)]}
Types:     StmtTypings {typingStmt = {=(?c @string:135:26, tmp#8)} @string:135:26, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),wybe.range.=<0>(wybe.range,wybe.range,?wybe.bool),wybe.string.=<0>(wybe.string,wybe.string,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {>(lx @string:135:39, ly @string:135:44)} @string:135:39, typingInfos = [wybe.c_string.><0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.><0>(wybe.char,wybe.char,?wybe.bool),wybe.comparison.><0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.><0>(wybe.int,wybe.int,?wybe.bool),wybe.string.><0>(wybe.string,wybe.string,?wybe.bool)]}
Types:     StmtTypings {typingStmt = {greater(?tmp#9 @string:135:55)} @string:135:55, typingInfos = [wybe.comparison.greater<0>(?wybe.comparison)]}
Types:     StmtTypings {typingStmt = {=(?c @string:135:51, tmp#9)} @string:135:51, typingInfos = [wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool),wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool),wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool),wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool),wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool),wybe.range.=<0>(wybe.range,wybe.range,?wybe.bool),wybe.string.=<0>(wybe.string,wybe.string,?wybe.bool)]}Typing {#result::wybe.comparison, c::2, tmp#1::0, tmp#2::1, x::wybe.string, y::wybe.string}; {0::wybe.string, 1::wybe.string, 2::wybe.comparison} (with no errors)
Types: Type checking call {equal(?tmp#0 @string:126:10)} @string:126:10
Types: Candidate types:
Types:     wybe.comparison.equal<0>(?wybe.comparison)
Types: Finding type of expr ?tmp#0 @string:126:10
Types:   Type = 3
Types: Actual types: [3]
Types: Matching types [3] with wybe.comparison.equal<0>(?wybe.comparison)
Types: Call arity 1; proc arity 1 - 1
Types: Filling  0 optional arguments
Types: Type variable 3 is bound to Nothing
Types: Unifying types 3 (-> 3) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Valid types = [Typing {#result::wybe.comparison, c::2, tmp#0::3, tmp#1::0, tmp#2::1, x::wybe.string, y::wybe.string}; {0::wybe.string, 1::wybe.string, 2::wybe.comparison, 3::wybe.comparison} (with no errors)]
Types: Resulting typing = Typing {#result::wybe.comparison, c::2, tmp#0::3, tmp#1::0, tmp#2::1, x::wybe.string, y::wybe.string}; {0::wybe.string, 1::wybe.string, 2::wybe.comparison, 3::wybe.comparison} (with no errors)
Types: Type checking call {=(?c @string:126:6, tmp#0)} @string:126:6
Types: Candidate types:
Types:     wybe.bool.=<0>(wybe.bool,wybe.bool,?wybe.bool)
Types:     wybe.c_string.=<0>(wybe.c_string,wybe.c_string,?wybe.bool)
Types:     wybe.char.=<0>(wybe.char,wybe.char,?wybe.bool)
Types:     wybe.comparison.=<0>(wybe.comparison,wybe.comparison,?wybe.bool)
Types:     wybe.int.=<0>(wybe.int,wybe.int,?wybe.bool)
Types:     wybe.range.=<0>(wybe.range,wybe.range,?wybe.bool)
Types:     wybe.string.=<0>(wybe.string,wybe.string,?wybe.bool)
Types: Finding type of expr ?c @string:126:6
Types: Type variable 2 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Finding type of expr tmp#0
Types: Type variable 3 is bound to Just wybe.comparison
Types:   Type = wybe.comparison
Types: Actual types: [wybe.comparison,wybe.comparison]
Types: Matching types [wybe.comparison,wybe.comparison] with {test} wybe.bool.=<0>(wybe.bool,wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 126, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.bool (-> wybe.bool)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 126, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.comparison,wybe.comparison] with {test} wybe.c_string.=<0>(wybe.c_string,wybe.c_string)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 126, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.c_string (-> wybe.c_string)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 126, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.comparison,wybe.comparison] with {test} wybe.char.=<0>(wybe.char,wybe.char)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 126, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.char (-> wybe.char)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 126, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.comparison,wybe.comparison] with {test} wybe.comparison.=<0>(wybe.comparison,wybe.comparison)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.comparison (-> wybe.comparison)
Types:   Unification yields wybe.comparison
Types: Matching types [wybe.comparison,wybe.comparison] with {test} wybe.int.=<0>(wybe.int,wybe.int)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 126, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.int (-> wybe.int)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 126, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Types: Matching types [wybe.comparison,wybe.comparison] with wybe.range.=<0>(wybe.range,wybe.range,?wybe.bool)
Types: Call arity 2; proc arity 2 - 2
Types: Filling  0 optional arguments
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 126, column 6): Type error in call to =, argument 1]
Types:   Unification yields XXX
Types: Unifying types wybe.comparison (-> wybe.comparison) and wybe.range (-> wybe.range)
Types: Recording error(s): [Error Just "/Users/schachte/research/mine/wybe/wybelibs/wybe/string.wybe" (line 126, column 6): Type error in call to =, argument 2]
Types:   Unification yields XXX
Internal error: unifyTypeList arguments don't align:  defs = [False]; ctypes = []; ptypes = [wybe.bool]
CallStack (from HasCallStack):
  error, called at src/AST.hs:4241:17 in main:AST
