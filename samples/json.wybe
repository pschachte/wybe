use wybe.float
use logging

pub constructors jobject(list(pair)) 
               | jstring(string) 
               | jbool(bool) 
               | jnumber(float) 
               | jlist(list(_)) 
               | jnull
    
pub def {test} (a:_ = b:_) { 
    foreign lpvm cast(a):int = foreign lpvm cast(b):int
}

pub type pair {
    ## pair type
    # A pair contianing a key and value.
    pub pair(key:string, value:json)
}

resource tokens:string

## parse/2
# Parse a string into a JSON value. 
# Fails if the string cannot be parsed.
pub def {test} parse(tokens:string, ?json:_) {
    use tokens in {
        !space
        !json(?json)
    }
}

## char/2
# Parse a single character from the input string.
def {test} char(?c:char) use !tokens {
    tokens = [?c | ?tokens]
}

## literal/2
# Parse a character literal followed by whitespace.
def {test} literal(c:char) use !tokens {
    !char(c)
    !space
}

## literal/2
# Parse a string literal followed by whitespace.
def {test} literal(str:string) use !tokens {
    for ?c in str {
        !char(c)
    }
    !space
}

## space/1
# Parse zero or more whitespace characters from the input.
def space() use !tokens {
    !char(?c) & (c = ' ' | c = '\n' | c = '\r' | c = '\t')
  | pass
}

## json/1
# Parse a JSON object followed by whitespace.
def {test} json(?j:_) use !tokens {
    !object(?j) 
  | !string(?str) & ?j = jstring(str)
  | !bool(?j)
  | !number(?j)
  | !list(?j)
  | !null & ?j = jnull
}

## sequence/5
# Parse a comma-separated sequence of things, with a preceding and 
# following character, followed by whitespace.
def {test} sequence(before:char, parse_item:{resource,test}(?X), ?xs:list(X), after:char) use !tokens {
    !literal(before)
    if { parse_item(?x) :: 
        !sequence_tail(parse_item, ?xs)
        ?xs = [x | xs]
      | else :: 
        ?xs = []
    }
    !literal(after)
}

## sequence_tail/3
# Parse the tail of a sequnece. Helper for sequence/2.
def {test} sequence_tail(parse_item:{resource,test}(?X), ?xs:list(X)) use !tokens {
    if { !literal(',') ::
        !parse_item(?x)
        !sequence_tail(parse_item, ?xs)
        ?xs = [x | xs]
      | else ::
        ?xs = []
    }
}

## object/2
# Parse a JSON object, followed by whitespace.
def {test} object(?obj:_) use !tokens {
    !sequence('{', {test,resource}{
        !string(?key)
        !literal(':')
        !json(?value)
        ?@ = pair(key, value)
    }, ?ps, '}')
    ?obj = jobject(ps)
}

## string/2
# Parse a string, followed by whitespace.
def {test} string(?str:string) use !tokens {
    !char('\"')
    !string_tail(?str)
    ?str = string(c_string(str))
}

## string_tail/2
# Parse the tail of a string. Helper for string/2.
def {test} string_tail(?str:string) use !tokens {
    !literal('\"')
    ?str = ""
  | !char(?c)
    if { c:char = '\\' :: 
        !char(?c)
        if { c = '"' :: pass
           | c = '\\' :: pass
           | c = '/' :: pass
           | c = 'b' :: ?c = '\b'
           | c = 'f' :: ?c = '\f'
           | c = 'n' :: ?c = '\n'
           | c = 'r' :: ?c = '\r'
           | c = 't' :: ?c = '\t'
           | else :: fail
        }
    }
    !string_tail(?str:string)
    # this should work...
    # ?str = [c | str]
    ?str = string(c) ,, str
}

## bool/2
# Parse a JSON Boolean, followed by whitespace.
def {test} bool(?bool:_) use !tokens {
    !literal("false")
    ?bool = jbool(false)
  | !literal("true")
    ?bool = jbool(true)
}

## number/2
# Parse a JSON number, followed by whitespace.
def {test} number(?number:_) use !tokens {
    !digit(?n)
    !digits(_, !n)
    if { !char('.') ::
        !digit(?f)
        !digits(?len, !f)
        !n += f / power(10.0, len)
    }
    if { { !char('e') | !char('E') } ::
        !digit(?e)
        !digits(_, !e)
        !n *= power(10.0, e)
    }
    !space
    ?number = jnumber(n)
}

## digits/3
# Parse a sequence of digits, outputting the number of digits parsed
def {test} digits(?len:float, !n:float) use !tokens {
    !digit(?d)
    ?n = n * 10.0 + d
    !digits(?len, !n)
    !len += 1.0
  | ?len = 1.0
}

## digits/3
# Parse a single digit
def {test} digit(?d:float) use !tokens {
    !char(?c)
    '0' <= c & c <= '9'
    ?d = foreign llvm sitofp(ord(c) - ord('0'):int)
}

## list/2
# Parse a JSON list, followed by whitespace.
def {test} list(?list:_) use !tokens {
    !sequence('[', json, ?js, ']')
    ?list = jlist(js)
}

## null/2
# Parse a JSON null, followed by whitespace.
def {test} null() use !tokens {
    !literal("null")
}

pub def print(x:_) use !io {
    !print(0, x)
    !nl
}

def print(ind:int, x:_) use !io {
    case x in {
        jobject(?pairs) :: 
        !print_list('{', {resource}{
            !indent(@1)
            !escape(@2^key)
            !print(": ")
            !print(@1, @2^value)
        }, ind, pairs, '}')
      | jlist(?list) :: 
        !print_list('[', {resource}{
            !indent(@1)
            !print(@1, @2)
        }, ind, list, ']')
      | jstring(?s) :: !escape(s)
      | jbool(?b) :: !print(b)
      | jnumber(?n) :: !print(n)
      | else :: !print("null")
    }
}

def indent(ind:int) use !io {
    ind <= 0
  | !print("  ")
    !indent(ind - 1)
}

def escape(s:string) use !io {
    !print('"')
    for ?c in s {
        if { c = '"' :: !print("\\\"")
           | c = '\\' :: !print("\\\\")
           | c = '\b' :: !print("\\b")
           | c = '\f' :: !print("\\f")
           | c = '\n' :: !print("\\n")
           | c = '\r' :: !print("\\r")
           | c = '\t' :: !print("\\t")
           | else :: !print(c)
        }
    }
    !print('"')
}

def print_list(start:char, printer:{resource}(int, X), ind:int, xs:list(X), end:char) use !io {
    !print(start)
    if { [?x | ?xs] = xs :: 
        !nl
        !printer(ind + 1, x)
        for ?x in xs {
            !println(',')
            !printer(ind + 1, x)
        }
        !nl
        !indent(ind)
    }
    !print(end)
}

?str = "{\"a\": [1, 1.2, 1e2, false, null], \"abc\ndef\": true}"

!print("Attempting to parse ")
!escape(str)
!nl

if { parse(str, ?json) :: 
    !println("Successfully parsed!")
    !print(json) 
  | else :: 
    !error("failed to parse :(") 
}