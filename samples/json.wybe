pub constructors jobject(list(pair)) | jstring(string) | jbool(bool) | jnumber(float) | jlist(list(_)) | jnull
    
pub def {test} (a:_ = b:_) { foreign lpvm cast(a):int = foreign lpvm cast(b):int }

pub type pair {
    ## pair type
    # A pair contianing a key and value.
    pub pair(key:string, value:json)
}

## parse/2
# Parse a string into a JSON value. 
# Fails if the string cannot be parsed.
pub def {test} parse(s:string, ?json:_) {
    space(!s)
    json(!s, ?json)
}

## char/2
# Parse a single character from the input string.
# Fails if the first character of the string is not said character.
def {test} char(c:char, !s:string) {
    # this is necessary because the uncons may fail, but the failure overwrites s
    # [c | ?s] = s
    [c | ?s_] = s
    ?s = s_
}


## space/1
# Parse zero or more whitespace characters from the input.
def space(!s:string) {
    if { { char(' ', !s) | char('\n', !s) | char('\r', !s) | char('\t', !s) } :: 
        space(!s) 
    }
}

## char_token/2
# Parse a character followed by whitespace.
def {test} char_token(c:char, !s:string) {
    char(c, !s)
    space(!s)
}

## string_token/2
# Parse a string literal followed by whitespace.
def {test} string_token(str:string, !s:string) {
    for ?c in str {
        char(c, !s)
    }
    space(!s)
}

## json/1
# Parse a JSON object followed by whitespace.
def {test} json(!s:string, ?j:_) {
    object(!s, ?j)
  | string(!s, ?str) & ?j = jstring(str)
  | bool(!s, ?j)
  | number(!s, ?j)
  | list(!s, ?j)
  | null(!s) & ?j = jnull
}

## sequence/5
# Parse a comma-separated sequence of things, with a preceding and 
# following character, followed by whitespace.
def {test} sequence(before:char, parse:{test}(!string, ?X), !s:string, ?xs:list(X), after:char) {
    char_token(before, !s)
    if { parse(!s, ?x) :: 
        sequence_tail(parse, !s, ?xs)
        ?xs = [x | xs]
      | else :: 
        ?xs = []
    }
    char_token(after, !s)
}

## sequence_tail/3
# Parse the tail of a sequnece. Helper for sequence/2.
def {test} sequence_tail(parse:{test}(!string, ?X), !s:string, ?xs:list(X)) {
    if { char_token(',', !s) ::
        parse(!s, ?x)
        sequence_tail(parse, !s, ?xs)
        ?xs = [x | xs]
    | else ::
        ?xs = []
    }
}

## object/2
# Parse a JSON object, followed by whitespace.
def {test} object(!s:string, ?obj:_) {
    sequence('{', {test}{
        string(!@1, ?key)
        char_token(':', !@1)
        json(!@1, ?value)
        ?@2 = pair(key, value)
    }, !s, ?ps, '}')
    ?obj = jobject(ps)
}

## string/2
# Parse a string, followed by whitespace.
def {test} string(!s:string, ?str:string) {
    char('\"', !s)
    string_tail(!s, ?str)
    ?str = string(c_string(str))
}

## string_tail/2
# Parse the tail of a string. Helper for string/2.
def {test} string_tail(!s:string, ?str:string) {
    char_token('\"', !s)
    ?str = ""
  | [?c | ?s] = s
    if { c = '\\' :: 
        [?c | ?s] = s
        if { c = '"' :: pass
           | c = '\\' :: pass
           | c = '/' :: pass
           | c = 'b' :: ?c = '\b'
           | c = 'f' :: ?c = '\f'
           | c = 'n' :: ?c = '\n'
           | c = 'r' :: ?c = '\r'
           | c = 't' :: ?c = '\t'
           | else :: fail
        }
    }
    string_tail(!s, ?str)
    ?str = [c | str]
}

## bool/2
# Parse a JSON Boolean, followed by whitespace.
def {test} bool(!s:string, ?bool:_) {
    string_token("false", !s)
    ?bool = jbool(false)
  | string_token("true", !s)
    ?bool = jbool(true)
}

## number/2
# Parse a JSON number, followed by whitespace.
def {test} number(!s:string, ?number:_) {
    digit(!s, ?n)
    digits(!s, _, !n)
    if { char('.', !s) ::
        digit(!s, ?f)
        digits(!s, ?len, !f)
        !n += f / power(10.0, len)
    }
    if { { char('e', !s) | char('E', !s) } ::
        digit(!s, ?e)
        digits(!s, _, !e)
        !n *= power(10.0, e)
    }
    space(!s)
    ?number = jnumber(n)
}

## digits/3
# Parse a sequence of digits, outputting the number of digits parsed
def {test} digits(!s:string, ?len:float, !n:float) {
    digit(!s, ?d)
    ?n = n * 10.0 + d
    digits(!s, ?len, !n)
    !len += 1.0
  | ?len = 1.0
}

## digits/3
# Parse a single digit digits
def {test} digit(!s:string, ?d:float) {
    [?c | ?rest] = s
    '0' <= c & c <= '9'
    ?s = rest
    ?d = float(ord(c) - ord('0'))
}

## list/2
# Parse a JSON list, followed by whitespace.
def {test} list(!s:string, ?list:_) {
    sequence('[', json, !s, ?js, ']')
    ?list = jlist(js)
}

## null/2
# Parse a JSON null, followed by whitespace.
def {test} null(!s:string) {
    string_token("null", !s)
}

pub def print(x:_) use !io {
    !print(0, x)
    !nl
}

def print(ind:int, p:pair) use !io {
    !indent(ind)
    !escape(p^key)
    !print(": ")
    !print(ind + 1, p^value)
}

def escape(s:string) use !io {
    !print('"')
    for ?c in s {
        if { c = '"' :: !print("\\\"")
           | c = '\\' :: !print("\\\\")
           | c = '\b' :: !print("\\b")
           | c = '\f' :: !print("\\f")
           | c = '\n' :: !print("\\n")
           | c = '\r' :: !print("\\r")
           | c = '\t' :: !print("\\t")
           | else :: !print(c)
        }
    }
    !print('"')
}

def print_list(start:char, printer:{resource}(int, X), ind:int, xs:list(X), end:char) use !io {
    !print(start)
    if { [?x | ?xs] = xs :: 
        !nl
        !printer(ind + 1, x)
        for ?x in xs {
            !println(',')
            !printer(ind + 1, x)
        }
        !nl
        !indent(ind)
    }
    !print(end)
}

def print(ind:int, x:_) use !io {
    case x in {
        jobject(?pairs) :: 
        !print_list('{', print, ind, pairs, '}')
      | jlist(?list) :: 
        !print_list('[', {resource}{
            !indent(@1)
            !print(@1, @2)
        }, ind, list, ']')
      | jstring(?s) :: 
        !escape(s)
      | jbool(?b) :: 
        !print(b)
      | jnumber(?n) :: 
        !print(n)
      | else :: 
        !print("null")
    }
}

def indent(ind:int) use !io {
    for _ in 0..ind {
        !print("  ")
    }
}

?s = "{\"ab\\nc\" : [false, true, 123.098, 123, 123.456e10], \"def\": null}"
if { parse(!s, ?j) :: 
    !print(j) 
   | else :: 
    !error("failed to parse") 
}