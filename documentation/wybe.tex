%  Emacs    : -*- latex -*-
%  File     : design.tex
%  RCS      : $Id: design.tex,v 1.14 2008/11/19 22:50:59 schachte Exp $
%  Author   : Peter Schachte
%  Origin   : Fri Mar 28 19:36:48 2003
%  Purpose  : Discussion document on design of new language
%  Copyright: © 2003 Peter Schachte.  All rights reserved.
%

\documentclass{article}
\usepackage{a4wide}
\usepackage{xspace}
\usepackage{fancyvrb}
%\usepackage{ensuremath}

\newcommand{\lang}{\textsf{Wybe}\xspace}
\newcommand{\Lang}{\textsf{Wybe}\xspace}

\newcommand{\ie}{\emph{i.e.}\xspace}
\newcommand{\eg}{\emph{e.g.}\xspace}
\newcommand{\Ie}{\emph{I.e.}\xspace}
\newcommand{\Eg}{\emph{E.g.}\xspace}
\newcommand{\etc}{\emph{etc}}

\newcommand{\nyi}[1]{\underline{#1} \emph{(not yet implemented)}}
\newcommand{\tbi}[1]{(\underline{Currently}, #1).}
\newcommand{\possible}[1]{\emph{Possible improvement:} \underline{#1}}

\newcommand{\tuple}[1]{\ensuremath{\langle#1\rangle}}

\title{The \Lang Programming Language}
\author{Peter Schachte}
\begin{document}
\maketitle
\noindent
The aim of the \lang programming language is to be simple, easy-to-learn,
and easy-to-use, while supporting large teams in producing maintainable
efficient programs.
It encourages designs with low coupling and high cohesion, and takes
the best aspects of both declarative and imperative programming, in
particular taking ideas from procedural, object-oriented, functional,
and logic programming languages.


\section{Lexical structure}
\label{sec:Lexical structure}

Comments begin with a hash (\#) character and continue until the end of
the line.

Identifiers are sequences of letters, digits, and underscore characters
not beginning with a digit.  Numbers follow C's syntax, except that
they may contain (but not begin with) underscore characters (\verb+_+),
which are ignored, and can be used to make large numbers easier for
humans to read.

Operator symbols consist of any sequence of one or
more of the following characters:  
\begin{center}
\verb'~ @ $ % ^ & + - * / = | \ : ; < > .'
\end{center}
Any sequence of any of these characters plus any parenthesis, bracket,
or brace characters, written between backquote characters
(\verb+`+) is \nyi{an ordinary identifier}.  That is, surrounding an
operator with backquotes allows it to be used as an identifier.

String literals follow orthodox syntax:  they begin and end with a
double quote character (\verb|"|).  Inside the string, the following
sequences have the specified special meaning:

\begin{center}
\begin{tabular}{|c|l|}
  \hline \textbf{sequence} & \textbf{meaning} \\
  \hline \verb+\a+ & alert/bell (ascii code \verb+0x07+) \\
  \hline \verb+\b+ & backspace (ascii code \verb+0x08+) \\
  \hline \verb+\e+ & escape (ascii code \verb+0x1B+) \\
  \hline \verb+\f+ & formfeed (ascii code \verb+0x0C+) \\
  \hline \verb+\n+ & newline (ascii code \verb+0x0A+) \\
  \hline \verb+\r+ & carriage return (ascii code \verb+0x0D+) \\
  \hline \verb+\t+ & horizontal tab (ascii code \verb+0x09+) \\
  \hline \verb+\u+\emph{hhhh} &
         \nyi{the unicode character with code \texttt{0x}\emph{hhhh}
         (where \emph{h} is a hex digit)}  \\
  \hline \verb+\U+\emph{hhhhhhh} &
         \nyi{the unicode character \texttt{0x}\emph{hhhhhhhh}
         (where \emph{h} is a hex digit)} \\
  \hline \verb+\v+ & vertical tab (ascii code \verb+0x0B+) \\
  \hline \verb+\x+\emph{hh} &
         the character \texttt{0x}\emph{hh} (where \emph{h} is a hex digit) \\
  \hline \verb+\(+\emph{expr}\verb+)+ & the value of expression \emph{expr} as a string (for any expression \emph{expr}) \\
  \hline \verb+\+\emph{c} & the character \emph{c} (for any other character \emph{c}) \\
\hline
\end{tabular}
\end{center}
To include a double quote or backslash (\verb+\+) character in a string,
precede it with a backslash.

Character constants begin and end with a single quote, but can only contain
a single character.
All the character escapes for strings can be used in character constants,
except for \verb+\(+\emph{expr}\verb+)+.


\section{Syntax}
\label{sec:Syntax}
The primary syntactic building blocks of \lang programs are statements
and expressions.
In this section, we will discuss their syntax;
their meaning and the relationship between them will be
discussed in Section~\ref{sec:Statements and expressions}.

Both statements and expressions have the same usual syntax:
\begin{center}
  \emph{name}\texttt{(}\emph{expr$_1$},\ldots,\emph{expr$_n$}\texttt{)},
\end{center}
where \emph{name} is an identifier naming the procedure called by
the statement or the function called by the expression,
and there are any number of
expression arguments, separated by commas.
If there are no enclosed expressions (i.e., $n=0$), then the
empty parentheses are omitted.
Note that the open parentheses, if present, must immediately follow the
name, with no intervening whitespace.

To make code more readable and convenient, \lang provides
several special syntactic forms.
All of these forms are simply syntactic sugar, and can always be
written as the equivalent code in the usual syntax shown above.

First, operator symbols can be used as infix or prefix operators (there
are no postfix operators, aside from function call and indexing).
It is not necessary to explicitly declare operators; any 
operator symbols can be used by the programmer.
Operator precedence and associativity are determined by the fixity
(prefix or infix) and the final character of the operator, as follows:
% all operator characters:  ~ @ $ % ^ & + - * / = | \ : ; < > .
\begin{center}
  \begin{tabular}{|c|c|c|c|}
    \hline
    \textbf{token} &
    \textbf{fixity} &
    \textbf{associativity} &
    \textbf{precedence} \\
    \hline
    \emph{identifier, string, or number} &
    non-operator &
    non-associative &
    16 \\
    \hline
    \emph{bracketed expression} &
    non-operator &
    non-associative &
    16 \\
    \hline
    \verb'.' \emph{(a single period)} &
    infix &
    left &
    15 \\
    \hline
    \verb'(' \ldots \verb+)+ \emph{(application)} &
    postfix &
    left &
    15 \\
    \hline
    \verb'[' \ldots \verb+]+ \emph{(indexing)} &
    postfix &
    left &
    15 \\
    \hline
    \verb'?' \emph{or} \verb'!' &
    prefix &
    non-associative &
    14 \\
    \hline
    \verb':' \emph{(a single colon)} &
    infix &
    non-associative &
    13 \\
    \hline
    \emph{any other operator} &
    % \verb'~' \quad \verb'@' \quad \verb'$' \quad \verb'%' \quad \verb'&' \quad \verb'=',
    % \verb'*' \quad \verb'/' \quad \verb'-' \quad \verb'+' &
    prefix &
    non-associative &
    12 \\
    \hline
    \emph{operator ending with} \verb'^' \emph{or} \verb'@' &
    infix &
    non-associative &
    11 \\
    \hline
    \emph{operator ending with} \verb'*' \emph{or} \verb'/' \emph{or} \verb'%' &
    infix &
    left &
    10 \\
    \hline
    \emph{operator ending with} \verb'-' \emph{or} \verb'+' &
    infix &
    left &
    9 \\
    \hline
    \emph{operator ending with} \verb'.' &
    infix &
    left &
    8 \\
    \hline
    \emph{operator ending with} \verb'%' \emph{or} \verb'$' &
    infix &
    right &
    7 \\
    \hline
    \emph{operator ending with} \verb'\' \emph{or} \verb'~' &
    infix &
    left &
    6 \\
    \hline
    \emph{operator ending with} \verb'<' \emph{or} \verb'>' &
    infix &
    non-associative &
    5 \\
    \hline
    \emph{operator ending with} \verb'&' &
    infix &
    left &
    4 \\
    \hline
    \emph{operator ending with} \verb'|' &
    infix &
    left &
    3 \\
    \hline
    \emph{operator ending with} \verb'=' &
    infix &
    right &
    2 \\
    \hline
    \emph{operator ending with} \verb':' &
    infix &
    right &
    1 \\
    % \hline
    % \verb',' \emph{(a single comma)} &
    % infix &
    % associative &
    % 0 \\
    \hline
    \emph{declared distfix operator} &
    distfix &
    non-associative &
    0 \\
    \hline
    \emph{operator ending with} \verb';' &
    infix &
    left &
    -1 \\
    \hline
  \end{tabular}
\end{center}

Bracketed expressions, those surrounded by parentheses, square brackets, or
braces, are treated differently depending on whether they are preceded by
whitespace.

If the bracketed expression $e$ is immediately preceded by an identifier,
string, number, or bracketed expression $d$, with no intervening whitespace,
then $e$ is expected to be at precedence 0.
That is, it is a comma-separated sequence of precedence 1 expressions, and
is interpreted as an expression $b(d, e_1,\ldots,e_n)$, where $b$ is
either \verb+`(...)`+, \verb+`[...]`+, or \verb+`{...}`+, depending on
whether the expression is surrounded by parentheses, brackets, or braces,
and the $e_1,\ldots,e_n$ are the expressions separated by commas.

If the bracketed expression \emph{is} preceded by whitespace, then it is
treated as an expression in its own right, rather than as a postfix
operator.
Following whitespace, a single expression at precedence 1 or above
surrounded by parentheses are interpreted as the enclosed expression.
This is simply used for grouping.
A sequence of expressions at precedence 1 or above surrounded by
square brackets and separated by
commas optionally ending with a vertical bar and a final expression,
are interpreted as a list.
For example, \verb+[a,b,c|d]+ is interpreted as
\verb+`[|]`(a,`[|]`(b,`[|]`(c,d)))+.
If the \verb+|d+ part is omitted, it defaults to \verb+[]+.

The \texttt{::} operator denotes lambda abstraction, along the lines
of Haskell.
That is, \texttt{p(?x) :: q(x)} denotes the partial function that matches
input against \texttt{p(?x)}; if that match succeeds, then \texttt{x} is
bound to the appropriate value, and the result of the partial function is
\texttt{q(x)}.
In the special case of an expression like \texttt{a :: b}, if the input
equals \texttt{a}, then the result is \texttt{b}, otherwise the function
fails.

Within braces following whitespace,
one or more \texttt{::} expressions can be specified, separated by
vertical bars, denoting the partial function whose value is the
value of the first \texttt{::} term if it succeeds, otherwise the
value of the second if that succeeds, and so on.
Such an expression denotes a kind of ``active map'', and if all
the left sides of the enclosed \texttt{::} expressions are constants,
it is an ordinary map.
Going one step further, if the elements within the braces are
not \texttt{::} expressions, they are interpreted as \texttt{::}
expressions where the right argument is \texttt{true}.
This in effect makes them sets.
For example, \verb+{a,b,c}+ is interpreted as
\verb+`{,}`(c,`{,}`(b,`{,}`(a,{})))+.

Distfix operators, \ie interspersed operator keywords and expressions,
must be declared before they can be used.
The declaration syntax is as either of the following:
\begin{center}
  \texttt{distfix}
  \emph{ident$_1$} \emph{sep$_1$} \ldots \emph{ident$_n$}
\end{center}
where each of 
\emph{sep}$1$ through \emph{sep}$n-1$ is either \texttt{.} meaning
no intervening expression or \texttt{..} meaning an expression should
come at that point (and e).
For example,
\begin{verbatim}
    distfix if .. then .. else ..
\end{verbatim}

\possible{Introduce ``associative'' operators, which collect all the
  arguments separated by multiple occurrences of the same operator
  into a single call.
  This would allow \texttt{a < b < c < d} to be meaningful, and would
  handle \texttt{a + b + c + d} as a single operation.  It would also
  handle \texttt{\{ a ::\@ b c ; d ::\@ e f g ; h ::\@ i \}} nicely.
  But this requires some kind of varargs facility, which we don't have yet.
}



\section{Statements and expressions}
\label{sec:Statements and expressions}

A \emph{statement} is a \lang construct that has an effect when executed,
and does not have a value.
Effects may include performing input or output, or setting the
value of a variable.
The usual form of a statement is
\begin{center}
  \emph{procname}\texttt{(}\emph{expr},\ldots\texttt{)}
\end{center}
where the \emph{procname}, naming the procedure called, is an identifier,
and there are any number of
expression arguments, separated by commas.

An \emph{expression} is a construct that determines outputs from inputs.
Each expression is either a \emph{variable reference} (described below)
or a call to a \emph{function}, of the form
\begin{center}
  \emph{funcname}\texttt{(}\emph{expr},\ldots\texttt{)}
\end{center}
where \emph{funcname} is the name of the function to be called.

\subsection{Dataflow}
\label{sec:Dataflow}

Each variable reference may either read, write, or modify
(\ie, both read and write) the variable.
This is the \emph{mode} of the reference.
Prefixing a variable name with a \verb+?+ operator specifies that the
variable will be written (without being read); this is an \emph{output} mode.
Prefixing a variable name with a \verb+!+ operator signifies that it
will be read and written, an \emph{input/output} mode.
Unadorned variable names indicate read-only usage, an \emph{input} mode.

Expressions have modes, too.
An expression all of whose arguments are inputs is an input mode,
while one all of whose arguments are outputs is an output mode.
If there is a mix of inputs and outputs, or if any argument is in
input/output mode, the expression is in input/output mode.
This will be discussed further when we address tests.

\subsection{Mode overloading}
\label{sec:Mode overloading}

The mode of a statement is the ordered list of the modes of the arguments
of the statement.
This is specified in the declaration of the procedure.
A statement may have any number of inputs and any number of outputs.

There may be more than one procedure with a given name, as long as
the modes are different.
The mode of the procedure call is used to determine which procedure
with that name is being called.
For example, the procedure \texttt{=} has a mode with the first argument
output and the second input, and another with the first input and
the second output.
Thus \texttt{x} can be assigned the value \texttt{42} with either of the
following statements:
\begin{verbatim}
    ?x = 42
    42 = ?x
\end{verbatim}

\subsection{Defining functions and procedures}
\label{sec:Defining functions and procedures}

Functions and procedures are defined using the following syntaxes:
\begin{center}
  \texttt{func} \emph{name}\texttt{(}%
  \emph{param}\texttt{:}\emph{ptype}, \ldots\texttt{):}\emph{rtype}
  \texttt{=} \textit{expr} \\
  \texttt{proc}
  \emph{name}(\emph{mode} \emph{param}\texttt{:}\emph{ptype}, \ldots)
  \textit{stmt} \ldots \texttt{end}
\end{center}
where \emph{name} and \emph{param} are identifiers,
\emph{ptype} and \emph{rtype} are
argument and result type specifications, respectively, and
each \emph{mode} is either \texttt{?}, \texttt{!}, or nothing,
meaning that that argument is output, input/output, or input only,
respectively.
Any number of parameters can be specified; if no parameters are
specified, the empty parentheses are omitted.
Any \texttt{:}\emph{ptype}s or \texttt{:}\emph{rtype} can be omitted,
in which case the compiler will infer it, provided it is uniquely
determined and the procedure or function is not exported
(see Section~\ref{sec:Exports}).
However, it is considered to be good programming style to include
the declarations.

\subsection{Functions \emph{are} procedures}
\label{sec:Functions are procedures}

A function of $n$ arguments is just a procedure with $n$ input arguments
plus a single output argument.
A statement one of whose arguments is a function call is equivalent to
two (or three) statements.
For example, the statement
\begin{verbatim}
    p(f(x,y))
\end{verbatim}
is equivalent to
\begin{verbatim}
    f(x,y,?temp)
    p(temp).
\end{verbatim}
In fact, this is how \lang implements such a statement.
If the expression is in output mode, the statement for the expression
comes after; for example
\begin{verbatim}
    p(f(?x,?y))
\end{verbatim}
is equivalent to
\begin{verbatim}
    p(?temp)
    f(?x,?y,temp).
\end{verbatim}
Where an expression is in input/output mode, it is equivalent to two
procedure calls; for example
\begin{verbatim}
    p(f(!x,!y))
\end{verbatim}
is equivalent to
\begin{verbatim}
    f(x,y,?temp)
    p(!temp)
    f(?x,?y,temp).
\end{verbatim}

Conversely, any procedure can be called as a function by simply
substituting a call to the procedure with its final argument
omitted for the omitted argument.
Thus
\begin{center}
  \texttt{func} \emph{name}\texttt{(}%
  \emph{param$_1$}\texttt{:}\emph{type$_1$},\ldots,
  \emph{param$_n$}\texttt{:}\emph{type$_n$}\texttt{):}\emph{type}
  \texttt{=} \textit{expr}
\end{center}
is exactly equivalent to
\begin{center}
  \texttt{proc}
  \emph{name}(\emph{param$_1$}\texttt{:}\emph{type$_1$},\ldots,
  \emph{param$_n$}\texttt{:}\emph{type$_n$}, \texttt{?temp:}\emph{type})
  \texttt{?temp =} \emph{expr} \texttt{end} \\
\end{center}
For example, the following is valid:
\begin{verbatim}
    proc succ(x:int, ?y:int) ?y = x + 1 end
    proc succ(?x:int, y:int) ?x = y - 1 end

    proc updown(in, ?out) # out always = in
        ?tmp = succ(in)   # increment in
        tmp = succ(?out)  # decrement tmp
    end
\end{verbatim}

\subsection{Tests}
\label{sec:Tests}

A \emph{test} is a statement that can succeed or fail.
A test is similar to a Boolean expression, except that
none of the outputs of a test are deemed to have been produced
if the test fails; if it succeeds, all the outputs are taken
to have been produced.
A statement sequence fails if any of its statements fails, and
execution does not continue following the failing statement.

The condition of a conditional statement must be a test, as must the parts
of a conjunction, disjunction, or negation.
A conjunction, disjunction, or negation is a test, as is
a call to a test procedure.

Outputs of a test may only be used in contexts where the test
must have succeeded; in particular in the \emph{then} branch of
a conditional or following conjuncts in a conjunction.
Outputs of a negated test can only be used when the negation fails.
Variables that are assigned by all disjuncts in a disjunction, or
all branches of a conditional may also be used, as may variables that
are assigned prior to the conjunction, disjunction, negation, or conditional.
As a convenience, a Boolean expression may be used as a test.

Note that some modes for a procedure name may be tests while others
are not.
A function may also be a test, which indicates a partial function.
A statement is a test iff the called procedure is a test in that mode,
or if any of its arguments is a test.
An expression is a test iff the function is a test in that mode, or
if any subexpression is a test.
A test statement succeeds iff all argument expressions succeed \emph{and}
the procedure call itself succeeds.
An expression succeeds iff all subexpressions succeed and
the function call itself succeeds.
Non-test procedure and function calls are treated as succeeding,
and nested expressions are treated as the conjunction of their
subexpressions.
Thus a disjunction of statements is deemed to succeed if all the
subexpressions of at least one of them succeeds.

Unlike in logic programming, tests in \lang\ are deterministic:
the output bindings of the first successful test are final.
However, \lang\ also supports \nyi{generators}, which are used in loops
and are similar to backtracking in logic programs.

\subsection{Implied modes}
\label{sec:Implied modes}

It is always permitted to supply an input in a mode where an output is
expected, providing the type of that argument permits equality testing.
In this case, the output mode is used to store the result in a temporary
variable, and then the supplied value is tested for equality with the
temporary variable.
As we will see, data constructors are functions that work in forwards
and backwards modes, making these implied modes useful for pattern matching.

\subsection{Selection and iteration statements}
\label{sec:Selection and iteration statements}


The new syntax philosophy is conceptual parsimony, built on relatively
few syntactic elements.

Miscellaneous ideas:
\begin{itemize}
\item Special syntax for manifest constant maps:
  \begin{center}
  \texttt{\{}\textit{key$_1$}\texttt{::}\textit{value$_1$},
  \textit{key$_2$}\texttt{::}\textit{value$_2$}, \ldots\texttt{\}}
  \end{center}
  As a special case, sets can be written as
  \begin{center}
  \texttt{\{}\textit{key$_1$}, \textit{key$_2$}, \ldots\texttt{\}}
  \end{center}

\item Allow use of ``\verb`|`'' as an alternative to ``\verb`,`'' to
  separate set and map items.
  When values involve multiple statements, this is useful because \verb`|`
  has lower precedence than statement separation.
  If ``\verb`|`'' is the first or last thing within curly braces, it is
  ignored, to simplify code layout and avoid the separator vs.\ terminator
  problem.
  

\item Capitalising on this, we use this syntax for case statements:
  \begin{center}
    \texttt{case} \textit{expr} \textit{map}
  \end{center}
  where the values in the \textit{map} are statement sequences. Case
  expressions are similar, but where the values in the \textit{map} are
  expressions.

  One challenge to this is that we want case values to be patterns, which
  can have outputs. This makes maps quite powerful, as matching keys must
  involve pattern matching, \ie, executing code.
  Is this too powerful?

\item Conditional statements and expressions have the syntax
  \begin{center}
    \texttt{if} \textit{map}
  \end{center}
  which is equivalent to \texttt{case true} \textit{map}. For this to be
  meaningful, the semantics of manifest constants maps must be that
  multiple mappings with identical keys are permitted, and the \emph{first}
  mapping for the repeated key is taken.

\item Allow a set of statement sequences to be treated as a closure?
  A singleton set is a deterministic statement sequence (providing its
  statements are det), and multi-element sets are nondet, so ``\verb`|`''
  could be used to separate alternatives in generators.
  This would allow curly brace notation for statement sequences, but
  int means that where a statement sequence is used, it needs to be
  surrounded by braces.
  Perhaps we could coerce a single statement to a singleton statement
  sequence.

\item Either maintain the decision not to have any statement separators, or
  allow separator (semicolon, I assume) to be omitted when its the last
  thing on a line.

\item As a special syntactic case, allow proc calls with a single argument
  to be written without the parentheses surrounding the argument (or with
  them).

\end{itemize}



At the highest (tightest) precedence, \lang has manifest constants, identifiers,
and calls.  A call is written as an identifier followed by an open
parenthesis, a comma-separated argument list, and a close parenthesis.

\textbf{Abandon this:}
At the loosest precedence, \lang supports ``interfix'' operators:
alternating identifiers and terms of higher precedence.  These are
parsed as a term whose constructor is the concatenation of the
identifiers, separated by underscores, with the subterms, in order, as
arguments.


\subsubsection*{Definition}
\begin{Verbatim}
    def foo(x:int, y:int) use io {
        !bar(x)
        !baz(y)
    }
\end{Verbatim}

\begin{Verbatim}
    def hypot(x:int, y:int):int = sqrt(x**2 + y**2)
\end{Verbatim}

\subsubsection*{Selection}
\begin{Verbatim}
        if {
        | prime(x):
            !bar(x)
            !baz(y)
        | else:
            !baz(y)
            !bar(x)
        }
\end{Verbatim}

\begin{Verbatim}
        case x {
        | 0:: !bar(x)
              !baz(y)
        | 1:: !baz(y)
              !bar(x)
        | _:: nop
        }

\end{Verbatim}

\subsubsection*{Looping}
\begin{Verbatim}
        do {stmt1
            while test
            stmt2
        }
\end{Verbatim}




\section{Modules}
\label{sec:Modules}

Each \lang module should be written in a file named
\emph{module}\texttt{.wybe}, where \emph{module} is the name of the module.
Module names may be any valid identifier, except for the special name \verb+_+.
Modules may be nested to any depth, allowing them to fulfill the role
packages play in other languages.
Modules may contain any number of the following things, in any order:
\begin{itemize}
\item Module imports
\item Type definitions
\item (Sub-)modules
\item Function definitions
\item Procedure definitions
\item Resource declarations
\item Statements
\end{itemize}

A module may also be an operating system directory, in which case all
modules in that directory are taken to be its public submodules.  If
the directory contains a \lang source file named \verb+_.wybe+,
this overrides the public importation, allowing the
module to chose which submodules to export, as well as to define its
own top-level procedures, functions, and initialization statements.

\subsection{Exports}
\label{sec:Exports}
Each type, submodule, function, procedure, and resource definition may be
preceded with the modifier '\texttt{public}', in which case, that
element is exported.  Without a \texttt{public} modifier, it is private,
and cannot be used outside that module.

\subsection{Imports}
\label{sec:Imports}
\Lang supports the following varieties of module importation:
\begin{itemize}
\item Module members may be imported such that they can be used without
  module qualification (\texttt{import}), or
  \nyi{so that they can only be used with explicit module qualification}
  (\texttt{use}).
  \tbi{\texttt{use} means import so that it can be used with or without
    module qualification}
\item All public members of a module may be imported
  (\texttt{use} or \texttt{import} \emph{module}),
  or only certain specified members may be imported
  (\texttt{from} \emph{module} \texttt{use} or \texttt{import} \emph{items}).
\item Members may be imported such that they become public members of
  the \emph{importing} module, visible to any module that imports it
  (by preceding the \texttt{use} directive with \texttt{public}) or not.
\end{itemize}
This gives the following eight varieties of importation:

\vspace{1ex}
\begin{center}
  \begin{tabular}{|p{25mm}|p{107mm}|}
    \hline \raggedright
    \texttt{use} \emph{module}
    & Imports everything made public by \emph{module} so that it can be used
    with module qualification.
    \\ \hline \raggedright
    \texttt{import} \emph{module}
    & Imports everything made public by \emph{module} so that it can be used
    with or without module qualification.
    \\ \hline \raggedright
    \texttt{from} \emph{module} \hspace{2em} \texttt{use} \emph{items}
    & Imports the specified items, which must all be made public
    by \emph{module}, so that they
    can be used with module qualification.
    \\ \hline \raggedright
    \texttt{from} \emph{module} \texttt{import} \emph{items}
    & Imports the specified items, which must all be made public
    by \emph{module}, so that they
    can be used with or without module qualification.
    \\ \hline \raggedright
    \texttt{public} \hspace{4em} \texttt{use} \emph{module}
    & Imports everything made public by \emph{module} so that it can be used
    with qualification, and reexport it from the
    importing module as if it were defined there.
    \\ \hline \raggedright
    \texttt{public} \hspace{4em} \texttt{import} \emph{module}
    & Imports everything made public by \emph{module} so that it can be used
    with or without module qualification, and reexport it from the
    importing module as if it were defined there.
    \\ \hline \raggedright
    \texttt{public} \hspace{4em} \texttt{from} \emph{module} \hspace{2em} 
    \texttt{use} \emph{items}
    & Imports the specified items, which must all be made public by
    \emph{module}, so that they
    can only be used with module qualification, and reexport
    them from the importing module as if they were defined there.
    \\ \hline \raggedright
    \texttt{public} \hspace{4em} \texttt{from} \emph{module}
    \texttt{import} \emph{items}
    & Imports the specified items, which must all be made public by
    \emph{module}, so that they
    can be used with or without module qualification, and reexport
    them from the importing module as if they were defined there.
    \\ \hline
  \end{tabular}
\end{center}
\vspace{1ex}


\subsection{Submodules}
\label{sec:Submodules}

Submodule declarations have the form:
\begin{center}
  \texttt{module} \emph{modname} \texttt{is} \emph{item} \ldots\ \texttt{end}
\end{center}
where \emph{modname} is the submodule name and the
\emph{item}s are the contents of the submodule.
Submodules are implicitly imported into the parent module.


\subsection{Top level statements}
\label{sec:Top level statements}

Statements written at the top level of a file are executed, in the order
written, at the time the program begins execution.
Top level statements of a module are executed before the top level
statements of any module that imports it, but are only executed
once regardless of how many modules import it, making them suitable for
module initialisations.
Top level statements also fill the role a \texttt{main} function or
method fills in other languages.

\subsection{Visibilty}
\label{sec:Visibilty}

Code within a module may only refer to types,
modules, procedures, functions, and resources that are \emph{visible}.
What is visible in a module is:
\begin{itemize}
\item everything that is defined in that module;
\item everything that is imported into that module, as described in
  Section~\ref{sec:Imports}; and
\item everything that is implicitly imported into that module by virtue of
  being exported (declared \texttt{public}) by one of its immediate submodules;
\item everything that is visible in its parent module
\end{itemize}


\section{Types}
\label{sec:Types}
\Lang is strongly typed, with parametric polymorphism (generics),
type inference, \nyi{abstract types},
and \nyi{subtypes} supporting the Liskov substitution principle.

% A type may declare that it \texttt{extends} another type.
% That means that,
% as in object oriented languages, any type may be ``extended'' by
% another type, and instances of that other type my be used wherever
% instances of the extended type can be.
% All data types are effectively abstract data types.
% 
% This provides similar functionality to type classes, but without the
% need to decide ahead which things should be types and which should be
% type classes.
% \Lang ensures that all programs follow Martin's dictum:
% ``Depend upon Abstractions. Do not depend upon concretions.''

Type declarations have the form:
\begin{center}
  \texttt{type} \emph{typename}(\emph{paramname,\ldots}) \texttt{=} \emph{ctorname}(\emph{membername}\texttt{:}\emph{membertype},\ldots) $\mid$ \ldots\ \texttt{end}
\end{center}
where \emph{typename}, \emph{paramname}, \emph{ctorname}, and
\emph{membername} are identifiers,
and \emph{membertype} is a type.
Here \emph{typename} is the name of the type being defined, and the
\emph{paramname}s name the type parameters.
If no type parameters are specified, the empty parentheses are omitted.
Each \emph{ctorname} is a data constructor for this type, and the
\emph{membername}s and \emph{membertype}s are the arguments of the
constructor and their types.
Again, if a \emph{ctorname} has no parameters, the empty parentheses
are omitted.
As many constructors may be specified as desired, separated by vertical
bars.

For example:
\begin{verbatim}
    type colour = colour(red:int, green:int, blue:int) end

    type list(t) =
            empty 
          | cons(head:t, tail:list(t))
    end
\end{verbatim}

It should be noted that \lang constructors are not like constructors in
object oriented languages, in that they do not have explicit implementations.
Constructors simply construct a value holding the supplied data.
But \lang constructors are ordinary \lang functions, except that they are
not explicitly defined.
You are free to define other functions to construct values of that type,
and their use will not be distinguishable from constructors.

\Lang also provides a backward mode for each constructor, to serve as
a deconstructor.
That is, constructors can be run backwards to deconstruct a data structure.
Additionally, a single argument deconstructor function is defined for
each constructor argument.
For types with more than one constructor, these backward deconstructor modes,
as well as forward deconstructor functions, are tests.
For the examples above, \lang will support to following statements (where
\texttt{c} is a color and \texttt{l} is a list):
\begin{verbatim}
     # to deconstruct a color into red, green, and blue components
     c = colour(?r, ?g, ?b)

     # the following are equivalent:
     ?r = red(c)
     ?g = green(c)
     ?b = blue(c)
     
     # to deconstruct a non-empty list into head and tail:
     if l = cons(?h, ?t) ...

     # to pattern match a singleton list:
     if l = cons(?h, empty)
\end{verbatim}

The \lang library supplies a useful little function with only
a backward mode:  \texttt{\_} (underscore).
This function does nothing in that mode, meaning that a
statement like:
\begin{verbatim}
     c = colour(?r, _, ?b)
\end{verbatim}
would set \texttt{r} to the red component of the color \texttt{c} and set
\texttt{b} to the blue component, and ignore the green component.

The language also supports Myer's uniform access principle.
Every type is simply a module whose name may be used as a type name.
The primitive operations (methods) of the type are the operations
exported by the module.

Constructors (and deconstructors) are ordinary functions.
Each type declaration includes all its data constructors, each of which
looks like a function declaration, except that the return type
and function body are omitted.
The compiler automatically generates the implementation of the
constructor and deconstructor functions.
However, constructors and deconstructors are ordinary functions, so
an existing type with defined constructors and deconstructors can be
redefined with new functions implementing the same interface as the
previous constructors and deconstructors.

Functions and procedures can be declared to be \texttt{abstract}, in
which case their implementations are omitted.
The compiler will not permit abstract operations to be invoked; the
value must be known to be of a subtype that implements the operation for
it to be used.

There is an abstract type \texttt{data} that serves as the root of the hierarchy
of data types.  This type has several useful abstract operations such
as equality testing, and printing.  All types declared with
constructors, as well as all the primitive types such as integer,
float, and char, implement this type.


\section{Functions and procedures}
\label{sec:Functions and procedures}

\Lang supports both functions and procedures.
The top level of a procedure definition, and the top level of a
module, are statement contexts.
Calls written there are taken to be procedure calls.
The arguments of a procedure or function call, and the body of a
function definition, are expressions.
Calls written as parts of expressions are taken to be function calls.

However, procedures and functions are, in fact, the same thing called
with a different syntax.
A function call is merely a procedure call whose final
argument is omitted; the value of that argument after the call is
taken to be the value of the function call.
A procedure call is merely a function call with one extra argument
whose value is the value of the function call.
So regardless of whether something is defined as procedure or
function, it may be called as either an expression or a statement.

Each procedure argument, may be input, output, or both, according
to the \verb+?+ and \verb+!+ annotations on its declaration.
A particular ordering of inputs, outputs, and in/out arguments is
called a procedure \emph{mode}.
A given procedure name may have any number of different declarations
with the same argument types and different modes, but may not have
more than one declaration with the same types and modes.
There are some restrictions on modes specific to functions:
\begin{enumerate}
\item if the last argument is output, at least one other argument must
  be input; and
\item if the last argument is input, at least one other argument must
  be output or in/out; and
\item the last argument must not be in/out.
\end{enumerate}
If any of these restrictions are not met, the procedure cannot be used
with a functional syntax in that mode.
These restrictions are imposed to ensure functional syntax is only
used for procedures that behave functionally.

As a syntactic convenience, funcs and procs can use patterns in place
of formal parameters.
This is equivalent to a variable parameter, with a deconstruction
statement inserted at the front of the body.
Further, funcs and procs can be defined by pattern matching;
this involves writing multiple definitions of the same func/proc name
and arity, with mutually exclusive patterns in the header.
This is semantically equivalent to a single definition whose body is a
disjunction of the bodies of all the definitions.


\section{Resources}
\label{sec:Resources}

\section{The Expression Problem}
\label{sec:The Expression Problem}

\Lang solves the ``expression problem'' by allowing types, funcs, and procs
to be declared \texttt{open}.
An open type is declared by preceding a type declaration with the modifier \texttt{open}.
An open type in one module can be extended with extra constructors
in another module.
This is done with an extend declaration, which has the same
syntax as a type declaration, except that it substitutes the
keyword \texttt{extend} for \texttt{type}.
The type specified in an extend declaration 
must have previously be declared an \texttt{open} type.
In this case, the constructors defined in the extend declaration
live in the enclosing module, although the type itself may live in a
different module.

Similarly, a func or proc may also be declared open by preceding
the (first) declaration of the func/proc by the keyword \texttt{open}.
An open func or proc may be extended by a definition in another module
by preceding the definition by the keyword \texttt{extend}.
Only the first definition of a func/proc need use the keyword.
The semantics of the func/proc is then the disjunction of the original
and extension definitions.
The order of definitions within a module is the order they are written in
that module; the modules themselves are taken in an undefined order that
is consistent with a module dependencies.
That is, if module A depends on B, but not vice versa, then A's
definitions must come before B's.

A func or proc definition, whether open or not, and whether the original
or extension definition, may also be declared as a default definition by
preceding it with the keyword \texttt{default} (in place of the
\texttt{extend} or \texttt{open} keyword).
This means that that definition is disjoined after all non-\texttt{default}
definitions.
If multiple default definitions are made for the same func/proc,
all the defaults for a given module are taken in the order written.
If multiple module specify defaults for the same func/proc,
then they are taken in the reverse order of the non-default definitions.
That is, if module A depends on module B, then B's default definitions
come before A's.


\section{Foreign interface}
\label{sec:Foreign interface}

\section{Code Transformation}
\label{sec:Code Transformation}

\Lang code is transformed into deterministic clausal form as the
compiler's intermediate representation.
In this form, each procedure body is represented as a (possibly empty)
list of primitive operations (comprising the common initial operations
for all clauses), and optionally a variable on which to switch and a
list of procedure bodies.
The value of the variable then determines which (exactly one)
of the bodies is executed.

Each operation in a body may have any number of inputs and any number
of outputs, but not in/out variables.
Inputs may be either variables or manifest constants; outputs must
always be distinct fresh variables.
For convenience, variable names have an explicit ``version'' number
suffix, similar to the common variable naming scheme used in SSA
languages.


\end{document}

% LocalWords:  vararg predicate's nonfailure DCG monoporphized nondet RDBMS
% LocalWords:  coroutining distfix ness supertyping Liskov backquote
% LocalWords:  restrictable ctor
