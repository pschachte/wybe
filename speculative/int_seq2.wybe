# For the generator:
# def {generator} int_seq(start: int, end: int, ?val: int) {
#    (start < end)
#
#    generate {
#        ?val = start
#    ||
#        ?val = start + 1
#    ||
#        int_seq(start + 2, end, ?val)
#    }
#
#    generate {
#        ?parity = 0
#    ||
#        ?parity = 1
#   }
#
#    ?val = val + parity + 1
#
# }

# Transformation to Det/SemiDet Wybe code:


# Translating the second generator. First proc generates the first solution,
# plus a choicepoint.

def gen2_first(?parity:int, ?cp:gen2cp) {
    ?parity = 0
    ?cp = gen2_choice2 # no arguments needed for this
}

# Second proc takes in choicepoint and generates all other solutions, with
# new choicepoint.

def {test} gen2_rest(?parity:int, !cp:gen2cp) {
    if {cp = gen2_choice2::
            ?parity = 1
            ?cp = gen2_nomore
       |otherwise:: fail
    }
}

type gen2cp { pub gen2_choice2 | gen2_nomore }



# Translating the first generator. First proc generates the first solution,
# plus a choicepoint.

def gen1first(start:int, end:int, ?val:int, ?cp:gen1cp) {
    ?val = start
    ?cp = gen1_choice2(start, end)
}

# Second proc takes in choicepoint and generates all other solutions, with
# new choicepoint.

def {test} gen1_rest(?val:int, !cp:gen1cp) {
    if {cp = gen1_choice2(?start, ?end)::
            ?val = start + 1
            ?cp = gen1_choice3(start, end)
    |   cp = gen1_choice3(?start, ?end)::
            if {int_seq_first(start + 2, end, ?val, ?innercp)::
                    ?cp = gen1_choice3_rest(innercp)
               |otherwise::
                   fail
               }
    |   cp = gen1_choice3_rest(?innercp)::
            if {int_seq_rest(?val, !innercp)::
                    ?cp = gen1_choice3_rest(innercp)
               |otherwise::
                    fail
               }
    |   otherwise:: fail
    }
}

type gen1cp { pub
              gen1_choice2(start:int, end:int)
            | gen1_choice3(start:int, end:int)
            | gen1_choice3_rest(innercp:int_seq_cp)
            | gen1_nomore
            }


def {test} int_seq_first(start:int,
                         end:int,
                         ?val:int,
                         ?cp:int_seq_cp) {
    (start < end)
    gen1first(start, end, ?val, ?gen1_cp)
    int_seq_cont1(start, end, val, gen1_cp, ?val, ?cp)
}

def {test} int_seq_cont1(start:int, end:int, val:int, gen1_cp:gen1cp, ?val:int, ?cp:int_seq_cp) {
    gen2_first(?parity, ?gen2_cp)
    int_seq_cont2(start, end, val, parity, ?val, gen1_cp, gen2_cp, ?cp)
}

def int_seq_cont2(start:int, end:int, val0:int, parity:int, ?val:int, gen1_cp:gen1cp, gen2_cp:gen2cp, ?cp:int_seq_cp) {
    ?val = val0 + parity + 1
    ?cp = int_seq_cp(start, end, val0, gen1_cp, gen2_cp)
}


def {test} int_seq_rest(?val:int,
                        !cp:int_seq_cp) {
    (cp = int_seq_cp(?start, ?end, ?val, ?gen1_cp, ?gen2_cp))
    if {gen2_rest(?parity, !gen2_cp)::
            int_seq_cont2(start, end, val, parity, ?val, gen1_cp, gen2_cp, ?cp)
       |gen1_rest(?val, !gen1_cp)::
            int_seq_cont1(start, end, val, gen1_cp, ?val, ?cp)
       |otherwise::
            fail
       }
}

type int_seq_cp { pub
    int_seq_cp(start:int, end:int, val:int, gen1_cp:gen1cp, gen2_cp:gen2cp)
}


# testing it:

if {int_seq_first(1, 10, ?val, ?cp)::
    !println(val)
    do {while int_seq_rest(?val, !cp)
        !println(val)
    }
}
