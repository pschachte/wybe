# purpose: A fast fixed-length array type
# since  : 0.1

pragma no_standard_library  # Standard library can't depend on itself!

use wybe.bool, wybe.int, wybe.machine_word, wybe.list, wybe.c_array

# Version 2:  better handled by the current uniqueness analysis
# We represent this array as a single chunk of memory, the first word of which
# is the number of elements in the array.  Following this are the array
# elements, with a full machine word for each element (regardless of the actual
# size of the element type).
#
# The advantage of this representation is that it is better handled by Wybe's
# current uniqueness analysis, allowing destructive updates to array elements
# when the analyser can determine that there are no other references to the
# array.
#
# Unfortunately, this representation is not backward compatible:  it cannot
# support a backward-mode cons operation, because the array header is at the
# start of the array, so we can't just point to an offset into the array.
# Instead, we provide an operation `values` to produce an iterator over the
# array elements, implemented by the array_iterator type.


representation (T) is address 

## Accessor procedures backward compatible with original array type
pub def {inline} length(a:_(T)):int = foreign lpvm access(a, 0, foreign lpvm sizeof(_:int):int, 0)
pub def {inline} raw_data(a:_(T)):raw_array =
    foreign llvm add(a, foreign lpvm sizeof(_:int):int)


## Construction procedures

# Construct an array filled with the given element of a given length.
pub def {inline} array(x:T, len:int):_(T) = ar where {
    ?eltsize:int = foreign lpvm sizeof(x)
    allocate_array(len, eltsize, ?ar, ?size)
    ?offset = foreign lpvm sizeof(_:int)
    do {
        while offset < size
        foreign lpvm mutate(ar, ?ar, offset, 1, size, 0, x)
        !offset + eltsize
    }
}

# Construct an array filled with 0s.  Takes advangage of the fact that GC_malloc
# clears the allocated memory.
pub def {inline} array(len:int):_(T) = ar where {
    allocate_array(len, foreign lpvm sizeof(_:T):int, ?ar, ?size)
}

# Construct a Wybe array from a c_array.  This will need to copy the data.
pub def {inline} array(data:c_array(T)):_(T) = ar where {
    ?eltsize = foreign lpvm sizeof(_:T)
    allocate_array(data^length, eltsize, ?ar, ?size)
    ?i = 0
    for ?elt in data {
        foreign lpvm mutate(ar, ?ar, i, 1, size, 0, elt)
        !i + eltsize
    }
}

# Test if an index is within the bounds of an array
pub def {test, inline} inbounds(a:_(T), idx:int) {
    (0 <= idx)
    (idx < a^length)
}


## Conversion procedures

# Convert a list into an array
pub def {inline} array(ls:list(T)):_(T) = ar where {
    ?eltsize = foreign lpvm sizeof(_:T)
    allocate_array(length(ls), eltsize, ?ar, ?size)
    ?offset:int = foreign lpvm sizeof(_:int)
    for ?x in ls {
        foreign lpvm mutate(ar, ?ar, offset, 1, size, 0, x)
        !offset + eltsize
    }
}


## Array indexing

# Get the element of an array at a given index.
# Fails when the index is out of the bounds of the array
pub def {test, inline} `[]`(a:_(T), idx:int):T = x where {
    inbounds(a, idx)
    ?x = a^unsafe_get(idx)
}

# Update the array at the given index to the given element.
# Fails when the index is out of the bounds of the array
pub def {test, inline} `[]`(!a:_(T), idx:int, x:T) {
    inbounds(a, idx)
    unsafe_update(!a, idx, x)
}

## Array slicing

# Return a sub-array from index `start` (inclusive) to `end` (exclusive), but
# restricted to the bounds of the array.
#
# We can't just return a pointer into the original array, because the first word
# of an array is its length.  So we "pretend" the array actually starts one word
# before the specified start index, and its length is `end - start`, and use the
# LPVM mutate operation to store the size where it needs to be.  Wybe's
# uniqueness analysis will turn that into a destructive update if the original
# array is unused after the slice operation, otherwise it will copy as much data
# as is needed for the slice, and then write the size where it belongs.
pub def {inline} slice(a:_(T), start:int, end:int):_(T) = subarray where {
    max(!start, 0)
    min(!end, a^length)
    max(!start, end)
    ?sizesize:int = foreign lpvm sizeof(_:int)
    ?eltsize:int = foreign lpvm sizeof(_:T)
    foreign llvm add(a^raw_data, start * eltsize - sizesize, ?start_address)
    ?sz = end - start
    ?slice_size = sizesize + sz * eltsize
    foreign lpvm mutate(start_address, ?start_address, 0, 0, slice_size, 0, sz)
    foreign llvm move(start_address, ?subarray:!_(T))
}

## Iterating over arrays

# Get an iterator over the values in an array
pub def {inline} values(ar:_(T)):array_iterator(T) =
    array_iterator(ar^raw_data,
            foreign llvm add(ar^raw_data, ar^length * foreign lpvm sizeof(_:T)))

# XXX make this implementation as private as possible
# This could be implemented the same way as `slice` above, but if the array is
# used again after being iterated over, it would be very inefficient.  This will
# avoid that problem.  However, due to limitations in the uniqueness analysis,
# iterating over an array will probably mean that later destructive update of
# the array will be inefficient.
pub type array_iterator(T) {
    constructor pub array_iterator(curr:raw_array, end:raw_array)

    pub def {test,inline} `[|]`(?head:T, ?it:_(T), it:_(T)) {
        ?eltsize:int = foreign lpvm sizeof(_:T)
        foreign llvm {test} icmp_slt(it^curr, it^end)
        foreign lpvm access(it^curr, 0, eltsize, 0, ?head)
        foreign llvm add(it^curr, eltsize, ?next)
        !it^curr = next
    }
}


## Common operations

# WARNING: does not initialise the array.
# Allocate space for an array of `len` elements of `elt_size_bytes` bytes each,
# returning the array `ar` and its `size` in bytes.
def {inline} allocate_array(len:int,elt_size_bytes:int,?ar:_(T),?size:int) {
    ?intsize:int = foreign lpvm sizeof(len)
    ?size = intsize + len * elt_size_bytes
    ?ar = foreign lpvm alloc(size)
    foreign lpvm mutate(ar, ?ar, 0, 1, size, 0, len)
}

# WARNING: does not check that the index is in the bound of the array. You 
# probably want `[]`.
# Get the element of an array at a given index
pub def {inline} unsafe_get(a:_(T), idx:int):T = x where {
    ?eltsize:int = foreign lpvm sizeof(_:T)
    ?offset = foreign lpvm sizeof(_:int) + idx * eltsize
    foreign lpvm access(a^raw_data, offset, eltsize, 0, ?x)
}

# WARNING: does not check that the index is in the bound of the array. You 
# probably want `[]`.
# Update the array at the given index to the given element
pub def {inline} unsafe_update(!a:_(T), idx:int, x:T) {
    ?sizesize:int = foreign lpvm sizeof(_:int)
    ?eltsize:int = foreign lpvm sizeof(x)
    ?offset = sizesize + idx * eltsize
    ?arraysize = sizesize + a^length * eltsize
    foreign lpvm mutate(a, ?a, offset, 0, arraysize, 0, x)
}
