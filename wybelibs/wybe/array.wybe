# purpose: Standard Array type, a null-terminated array
# since  : 0.1

pragma no_standard_library  # Standard library can't depend on itself!

use wybe.bool, wybe.int, wybe.machine_word, wybe.list

pub constructor (T) array(length:int, raw_data:raw_array(T))


# Raw array type
pub type raw_array(T) is address {}


# Get the head and tail of an array.
# Fails if the array is empty 
pub def {test} `[|]`(?head:T, ?tail:_(T), a:_(T)) {
    array(?length, ?data) = a
    (length > 0)
    foreign lpvm access(data, 0, word_size_bytes, 0, ?head)
    foreign llvm add(data, word_size_bytes, ?data)
    ?tail = array(length - 1, data)
}

# Get the element of an array at a given index.
# Fails if the index is out of the bounds of the array 
pub def {test} `[]`(a:_(T), idx:int):T = x where {
    (0 <= idx)
    (idx < a^length)
    ?x = a^unsafe_index(idx)
}

# WARNING: does not check that the index is in the bound of the array. You 
# probably want `[]`.
# Get the element of an array at a given index.
pub def {inline} unsafe_index(a:_(T), idx:int):T = x where {
    foreign lpvm access(a^raw_data, idx * word_size_bytes, word_size_bytes, 0, ?x)
}

# Conversion from list
pub def array(ls:list(T)):_(T) = ar where {
    ?len = length(ls) 
    foreign lpvm alloc(len * word_size_bytes, ?mem)
    ?offset = 0
    for ?x in ls {
        foreign lpvm mutate(mem, ?mem, offset, 1, word_size_bytes, 0, x)
        !offset += word_size_bytes
    }
    ?ar = array(len, mem)
}
