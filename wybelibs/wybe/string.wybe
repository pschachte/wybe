pragma no_standard_library  # Standard library can't depend on itself!

use wybe.int, wybe.char, wybe.bool, wybe.raw_string, wybe.io, wybe.range
use wybe.phantom, wybe.float, wybe.count

constructor nul
          | buf(len:int, raw:raw_string)
          | cat(l:_, r:_)
          | slc(base:_, range:range)
          | chr(c:char, __:int) # TODO: remove __:int

pub def str(str:raw_string, ?s:_) {
    ?len = length(str)
    if { len = 0 :: ?s = nul 
       | len = 1 :: foreign lpvm access(str, 0, 1, 0, ?c); ?s = ch(c) 
       | else :: ?s = buf(length(str), str)
    }
}
pub def raw(s:_, ?str:raw_string) {
    if { s = buf(_, ?raw_string) :: ?str = raw_string
       | else :: 
            ?len = length(s)
            foreign lpvm alloc(len + 1, ?str)
            foreign lpvm mutate(str, ?str, len, true, 1, 0, '\0')
            ?offset = 0
            pack(s, !str, !offset)
    }
}

pub def length(s:_):int = 
    if { s = buf(?len, _) :: len
       | s = cat(?l, ?r) :: length(l) + length(r)
       | s = slc(?base, ?range) :: size(range) # incorrect
       | s = chr(_, _) :: 1
       | else :: 0
    }

pub def (x:_ ,, y:_):_ =
    if { x = nul :: y 
       | y = nul :: x
       | x = cat(?l, ?r) :: cat(l, cat(r, y))
       | else :: cat(x, y)
    }
pub def (x:raw_string ,, y:raw_string):_ = str(x) ,, str(y)
pub def (x:_ ,, y:raw_string):_ = x ,, str(y)
pub def (x:raw_string ,, y:_):_ = str(x) ,, y
pub def (x:char ,, y:char):_ = ch(x) ,, ch(y)
pub def (x:_ ,, y:char):_ = x ,, ch(y)
pub def (x:char ,, y:_):_ = ch(x) ,, y
pub def (x:raw_string ,, y:char):_ = str(x) ,, ch(y)
pub def (x:char ,, y:raw_string):_ = ch(x) ,, str(y)

pub def ch(c:char):_ = chr(c, 1)

pub def (x:_ = y:_):bool  = cmp(x, y) = 0
pub def (x:_ ~= y:_):bool = cmp(x, y) ~= 0
pub def (x:_ < y:_):bool  = cmp(x, y) < 0
pub def (x:_ <= y:_):bool = cmp(x, y) <= 0
pub def (x:_ > y:_):bool  = cmp(x, y) > 0
pub def (x:_ >= y:_):bool = cmp(x, y) >= 0

pub def {test} `[|]`(?head:char, ?tail:_, s:_) {
    if { s = buf(?len, ?str) :: 
            [?head | ?str] = str
            ?tail = if { len = 1 :: nul | else :: buf(len - 1, str) }
       | s = cat(?l, ?r) :: 
            if { [?head | ?t] = l :: ?tail = cat(t, r)
               | else :: [?head | ?tail] = r
            }
       | s = slc(?base, ?range) :: 
            do {
                [?idx | ?range] = range
                if { ?head = base[idx] :: ?tail = slc(base, range); break }
            }
       | s = chr(?c, _) :: ?head = c; ?tail = nul
       | else :: fail
    }
}

pub def empty_string:_ = nul
pub def []:_ = nul
pub def {test} [](s:_, idx:int, ?c:char) {
    if { s = buf(?len, ?str) :: 
            (0 <= idx)
            (idx < len)
            ?c = unsafe_index(str, len)
       | s = cat(?l, ?r) :: 
            ?l_len = length(l)
            if { idx < l_len :: ?c = l[idx]
               | else :: ?c = r[idx - l_len]
            }
       | s = slc(?base, ?range) :: ?c = base[range[idx]]
       | s = chr(?c, _) :: (idx = 0)
       | else :: fail
    }
}
pub def [](s:_, r:range):_ = slc(s, r)
pub def [](s:raw_string, r:range):_ = str(s)[r]
pub def [](s:char, r:range):_ = ch(s)[r]

pub def print_string(s:_) use !io {
    if { s = buf(_, ?str) :: !print(str)
       | s = cat(?l, ?r) :: !print(l); !print(r)
       | s = slc(?base, ?range) :: 
            for ?i in range { 
                if { ?c = base[i] :: !print(c) }
            }
       | s = chr(?c, _) :: !print(c)
    }
}

def pack(s:_, !mem:raw_string, !offset:int) {
    if { s = buf(_, ?str) :: 
            for ?c in str {
                foreign lpvm mutate(mem, ?mem, offset, true, 1, 0, c)
                incr(!offset)
            }
       | s = cat(?l, ?r) :: 
            pack(l, !mem, !offset)
            pack(r, !mem, !offset)
       | s = slc(_, _) :: 
            for ?c in s {
                foreign lpvm mutate(mem, ?mem, offset, true, 1, 0, c)
                incr(!offset)
            }
       | s = chr(?c, _) ::
            foreign lpvm mutate(mem, ?mem, offset, true, 1, 0, c)
            incr(!offset)
    }
}

def cmp(x:_, y:_, ?c:int) {
    ?c = 0 
    do {
        if { [?cx | ?x] = x :: 
                if { [?cy | ?y] = y :: 
                        if { cx < cy :: ?c = -1; break
                           | cx > cy :: ?c = 1; break 
                        }
                   | else :: ?c = 1; break
                }
           | [_ | _] = y :: ?c = -1; break 
           | else :: break
        }
    }
} 
