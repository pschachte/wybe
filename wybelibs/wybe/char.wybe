# purpose: Standard Char type
# since  : 0.1

pragma no_standard_library  # Standard library can't depend on itself!

use wybe.bool, wybe.count, wybe.int, wybe.comparison, wybe.string, wybe.io

representation is 8 bit unsigned

## Comparisons

# Equality and disequality.
pub def foreign llvm {test} `=` =icmp_eq(x:_, y:_)
pub def foreign llvm {test} `~=`=icmp_ne(x:_, y:_)

# Inequalities.
pub def foreign llvm {test} `<` =icmp_ult(x:_, y:_)
pub def foreign llvm {test} `<=`=icmp_ule(x:_, y:_)
pub def foreign llvm {test} `>` =icmp_ugt(x:_, y:_)
pub def foreign llvm {test} `>=`=icmp_uge(x:_, y:_)

# Three-way comparison.
pub def (x:_ <=> y:_):comparison = 
    if { x < y :: lesser | x = y :: equal | else :: greater }


## Conversion procedures

# Int ordinal of a char
pub def foreign lpvm ord=cast(c:_):int

# Count (unsigned) ordinal of a char
pub def foreign lpvm ord=cast(c:_):count

# Char of an int character code
pub def {test} chr(i:int):_ = foreign lpvm cast(i) where { 0 <= i ; i <= 255 }

# Char of a count (unsigned) character code
pub def {test} chr(i:count):_ = foreign lpvm cast(i) where { i <= 255:count }

## Formatting
pub def fmt(x:_):string = string(x)
pub def fmt(x:_, minlength:int):string = fmt(x, minlength, ' ')
pub def fmt(x:_, minlength:int, fill:_):string =
    fmt(string(x), minlength, fill)

pub def {test} is_whitespace(x:_) {
    x = ' ' | x = '\t' | x = '\n' | x = '\r' | x = '\f' | x = '\v'
}

pub def {test} is_digit(x:_) { x >= '0' & x <= '9' }

pub def {test} is_upper(x:_) { x >= 'A' & x <= 'Z' }

pub def {test} is_lower(x:_) { x >= 'a' & x <= 'z' }

pub def {test} is_alpha(x:_) { is_upper(x) | is_lower(x) }

pub def {test} is_alphanumeric(x:_) { is_alpha(x) | is_digit(x) }

## I/O

pub def foreign c print=putchar(x:_) use !io

pub def println(x:_) use !io { !print(x); !nl }

pub def foreign c read=read_char(?x:_) use !io
