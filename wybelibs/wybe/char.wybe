# purpose: Standard Char type
# since  : 0.1

pragma no_standard_library  # Standard library can't depend on itself!

use wybe.bool, wybe.count, wybe.int, wybe.comparison, wybe.string, wybe.io

representation is 8 bit unsigned

## Comparisons

# Equality and disequality.
pub def {test} (x:_ =  y:_) { foreign llvm {test} icmp_eq(x, y) }
pub def {test} (x:_ ~= y:_) { foreign llvm {test} icmp_ne(x, y) }

# Inequalities.
pub def {test} (x:_ <  y:_) { foreign llvm {test} icmp_ult(x, y) }
pub def {test} (x:_ <= y:_) { foreign llvm {test} icmp_ule(x, y) }
pub def {test} (x:_ >  y:_) { foreign llvm {test} icmp_ugt(x, y) }
pub def {test} (x:_ >= y:_) { foreign llvm {test} icmp_uge(x, y) }

# Three-way comparison.
pub def (x:_ <=> y:_):comparison = 
    if { x < y :: lesser | x = y :: equal | else :: greater }


## Conversion procedures

# Int ordinal of a char
pub def ord(c:_):int = foreign lpvm cast(c)

# Count (unsigned) ordinal of a char
pub def ord(c:_):count = foreign lpvm cast(c)

# Char of an int character code
pub def {test} chr(i:int):_ = foreign lpvm cast(i) where { 0 <= i ; i <= 255 }

# Char of a count (unsigned) character code
pub def {test} chr(i:count):_ = foreign lpvm cast(i) where { i <= 255:count }

## Formatting
pub def fmt(x:_):string = string(x)
pub def fmt(x:_, minlength:int):string = fmt(x, minlength, ' ')
pub def fmt(x:_, minlength:int, fill:_):string =
    fmt(string(x), minlength, fill)

pub def {test} is_whitespace(x:_) {
    x = ' ' | x = '\t' | x = '\n' | x = '\r' | x = '\f' | x = '\v'
}

pub def {test} is_digit(x:_) { x >= '0' & x <= '9' }

pub def {test} is_upper(x:_) { x >= 'A' & x <= 'Z' }

pub def {test} is_lower(x:_) { x >= 'a' & x <= 'z' }

pub def {test} is_alpha(x:_) { is_upper(x) | is_lower(x) }

pub def {test} is_alphanumeric(x:_) { is_alpha(x) | is_digit(x) }

## I/O

pub def print(x:_) use !io { foreign c putchar(x, !io) }

pub def println(x:_) use !io { !print(x); !nl }

pub def read(?x:_) use !io { foreign c read_char(?x, !io) }
