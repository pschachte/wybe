# purpose: Standard List type
# since  : 0.1

pragma no_standard_library  # Standard library can't depend on itself!

use wybe.bool, wybe.int
use wybe.io, wybe.string, wybe.c_string, wybe.char, wybe.range, wybe.phantom, wybe.count, wybe.float

pub constructors (T) [] | [head:T | tail:_(T)]

pub def (x:_(T) ,, y:_(T)):_(T) =
    if { x = [?h|?t] :: [h|t,,y] | else :: y }

pub def length(x:_(T)) : int = length1(x, 0)

def length1(x:_(T), acc:int) : int =
    if { x = [?h|?t] :: length1(t, acc+1) | else :: acc }

pub def reverse(x:_(T)):_(T) = reverse1(x, [])

def reverse1(x:_(T), tail:_(T)):_(T) =
    if { x = [?h|?t] :: reverse1(t, [h|tail]) | else :: tail }

pub def {test} `[]`(xs:_(T), idx:int):T = x where {
    idx >= 0 # we dont want to check this every time
    ?x = index(xs, idx)
}

def {test} index(xs:_(T), idx:int):T = x where {
    [?x | ?xs] = xs
    (idx = 0 | index(xs, idx - 1, ?x))
}

pub def map(f:{resource}(A), as:_(A)) {
    for ?a in as {
        !f(a)
    }
}

pub def map(f:(A, ?B), as:_(A)):_(B) =
    if { [?a | ?as] = as :: [ f(a) | map(f, as) ] | else :: [] }


pub def map(f:(A, B, ?C), as:_(A), bs:_(B)):_(C) =
    if { [?a | ?as] = as & [?b | ?bs] = bs :: [ f(a, b) | map(f, as, bs) ]
       | else                              :: [] }

pub def {test} all(p:{test}(A), as:_(A)) {
    for ?a in as {
        p(a)
    }
}

pub def {test} any(p:{test}(A), as:_(A)) {
    [?a | ?as] = as
    (p(a) | any(p, as))
}

pub def foldl(f:(A, !B), as:_(A), !b:B) {
    for ?a in as {
        f(a, !b)
    }
}

pub def foldr(f:(A, !B), as:_(A), !b:B) {
    if { [?a | ?as] = as ::
        foldr(f, as, !b)
        f(a, !b)
    }
}

pub def filter(p:{test}(A), !as:_(A)) {
    ?out = []
    for ?a in as {
        if { p(a) :: ?out = [a | out] }
    }
    ?as = reverse(out)
}

pub def print(x:_(T), printer:{resource}(T)) use !io {
    !print("[")
    !_print_list(x, printer)
    !print("]")
}

pub def println(x:_(T), printer:{resource}(T)) use !io { !print(x, printer); !nl }

def _print_list(xs:_(T), printer:{resource}(T)) use !io {
    if { [?x | ?xs1] = xs ::
        !printer(x)
        if { [ ?x2 | ?xs2 ] = xs1 ::
            !print(", ")
        }
        !_print_list(xs1, printer)
    }
}