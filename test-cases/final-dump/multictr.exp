======================================================================
AFTER EVERYTHING:
 Module multictr
  public submods  : 
  public types    : card: (multictr.card,Just 6 bit unsigned)
                    complicated: (multictr.complicated,Just address)
                    length: (multictr.length,Just 64 bit unsigned)
                    maybe_int: (multictr.maybe_int,Just address)
                    number: (multictr.number,Just address)
                    perhaps: (multictr.perhaps,Just 64 bit unsigned)
                    rank: (multictr.rank,Just 4 bit unsigned)
                    simple: (multictr.simple,Just address)
                    suit: (multictr.suit,Just 2 bit unsigned)
                    unit: (multictr.unit,Just 0 bit unsigned)
  public resources: 
  public procs    : multictr.card./=<0>
                    multictr.card.=<0>
                    multictr.card.card<0>
                    multictr.card.card<1>
                    multictr.card.rank<0>
                    multictr.card.rank<1>
                    multictr.card.suit<0>
                    multictr.card.suit<1>
                    multictr.complicated./=<0>
                    multictr.complicated.=<0>
                    multictr.complicated.autumn<0>
                    multictr.complicated.c01<0>
                    multictr.complicated.c01<1>
                    multictr.complicated.c02<0>
                    multictr.complicated.c02<1>
                    multictr.complicated.f01<0>
                    multictr.complicated.f01<1>
                    multictr.complicated.f02<0>
                    multictr.complicated.f02<1>
                    multictr.complicated.spring<0>
                    multictr.complicated.summer<0>
                    multictr.complicated.winter<0>
                    multictr.length./=<0>
                    multictr.length.=<0>
                    multictr.length.metres<0>
                    multictr.length.metres<1>
                    multictr.length.value<0>
                    multictr.length.value<1>
                    multictr.maybe_int./=<0>
                    multictr.maybe_int.=<0>
                    multictr.maybe_int.just<0>
                    multictr.maybe_int.just<1>
                    multictr.maybe_int.nothing<0>
                    multictr.maybe_int.value<0>
                    multictr.maybe_int.value<1>
                    multictr.number./=<0>
                    multictr.number.=<0>
                    multictr.number.float<0>
                    multictr.number.float<1>
                    multictr.number.float_value<0>
                    multictr.number.float_value<1>
                    multictr.number.int<0>
                    multictr.number.int<1>
                    multictr.number.int_value<0>
                    multictr.number.int_value<1>
                    multictr.perhaps./=<0>
                    multictr.perhaps.=<0>
                    multictr.perhaps.content<0>
                    multictr.perhaps.content<1>
                    multictr.perhaps.perhaps<0>
                    multictr.perhaps.perhaps<1>
                    multictr.rank./=<0>
                    multictr.rank.=<0>
                    multictr.rank.ace<0>
                    multictr.rank.jack<0>
                    multictr.rank.king<0>
                    multictr.rank.queen<0>
                    multictr.rank.r10<0>
                    multictr.rank.r2<0>
                    multictr.rank.r3<0>
                    multictr.rank.r4<0>
                    multictr.rank.r5<0>
                    multictr.rank.r6<0>
                    multictr.rank.r7<0>
                    multictr.rank.r8<0>
                    multictr.rank.r9<0>
                    multictr.simple./=<0>
                    multictr.simple.=<0>
                    multictr.simple.one<0>
                    multictr.simple.one<1>
                    multictr.simple.one_field<0>
                    multictr.simple.one_field<1>
                    multictr.simple.two<0>
                    multictr.simple.two<1>
                    multictr.simple.two_field1<0>
                    multictr.simple.two_field1<1>
                    multictr.simple.two_field2<0>
                    multictr.simple.two_field2<1>
                    multictr.simple.zero<0>
                    multictr.suit./=<0>
                    multictr.suit.=<0>
                    multictr.suit.clubs<0>
                    multictr.suit.diamonds<0>
                    multictr.suit.hearts<0>
                    multictr.suit.spades<0>
                    multictr.unit./=<0>
                    multictr.unit.=<0>
                    multictr.unit.unit<0>
  imports         : public use multictr.card
                    public use multictr.complicated
                    public use multictr.length
                    public use multictr.maybe_int
                    public use multictr.number
                    public use multictr.perhaps
                    public use multictr.rank
                    public use multictr.simple
                    public use multictr.suit
                    public use multictr.unit
                    use wybe
  types           : card/public  is 6 bit unsigned { card(rank:rank, suit:suit) @multictr:16:9  }  @multictr:15:5, complicated/public  is address { winter() @multictr:54:8 | spring() @multictr:54:17 | summer() @multictr:54:26 | autumn() @multictr:54:35 | c01(f01:int) @multictr:55:8 | c02(f02:int) @multictr:56:8  }  @multictr:53:5, length/public  is 64 bit unsigned { metres(value:float) @multictr:25:9  }  @multictr:24:5, maybe_int/public  is address { nothing() @multictr:35:9 | just(value:int) @multictr:36:9  }  @multictr:34:5, number/public  is address { int(int_value:int) @multictr:41:8 | float(float_value:float) @multictr:42:8  }  @multictr:40:5, perhaps/public  is 64 bit unsigned { perhaps(content:maybe_int) @multictr:30:9  }  @multictr:29:5, rank/public  is 4 bit unsigned { r2() @multictr:10:9 | r3() @multictr:10:14 | r4() @multictr:10:19 | r5() @multictr:10:24 | r6() @multictr:10:29 | r7() @multictr:10:34 | r8() @multictr:10:39 | r9() @multictr:11:9 | r10() @multictr:11:14 | jack() @multictr:11:20 | queen() @multictr:11:27 | king() @multictr:11:35 | ace() @multictr:11:42  }  @multictr:9:5, simple/public  is address { zero() @multictr:47:8 | one(one_field:int) @multictr:48:8 | two(two_field1:int, two_field2:int) @multictr:49:8  }  @multictr:46:5, suit/public  is 2 bit unsigned { clubs() @multictr:5:9 | diamonds() @multictr:5:17 | hearts() @multictr:5:28 | spades() @multictr:5:37  }  @multictr:4:5, unit/public  is 0 bit unsigned { unit() @multictr:20:21  }  @multictr:20:5
  resources       : 
  submodules      : multictr.card, multictr.complicated, multictr.length, multictr.maybe_int, multictr.number, multictr.perhaps, multictr.rank, multictr.simple, multictr.suit, multictr.unit
  procs           : 


  LLVM code       :

; ModuleID = 'multictr'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    
--------------------------------------------------
 Module multictr.card
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.card./=<0>
                    multictr.card.=<0>
                    multictr.card.card<0>
                    multictr.card.card<1>
                    multictr.card.rank<0>
                    multictr.card.rank<1>
                    multictr.card.suit<0>
                    multictr.card.suit<1>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline test (0 calls)
0: /=($left#0:multictr.card, $right#0:multictr.card, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.card, ~$right#0:multictr.card, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)



= > public inline test (3 calls)
0: =($left#0:multictr.card, $right#0:multictr.card, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.card, ~$right#0:multictr.card, ?$$#0:wybe.bool)


card > public inline (0 calls)
0: card(suit#0:multictr.suit, rank#0:multictr.rank, ?$#3:multictr.card):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm shl(~rank#0:!multictr.card, 2:multictr.card, ?$temp#1:multictr.card)
    foreign llvm or(~$temp#1:multictr.card, ~suit#0:!multictr.card, ?$#3:multictr.card)
card > public inline (0 calls)
1: card(?suit#0:multictr.suit, ?rank#0:multictr.rank, $#0:multictr.card):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($#0:multictr.card, 3:multictr.card, ?$temp2#0:multictr.card)
    foreign lpvm cast(~$temp2#0:multictr.card, ?suit#0:multictr.suit)
    foreign llvm lshr(~$#0:multictr.card, 2:multictr.card, ?$temp#1:multictr.card)
    foreign llvm and(~$temp#1:multictr.card, 15:multictr.card, ?$temp2#1:multictr.card)
    foreign lpvm cast(~$temp2#1:multictr.card, ?rank#0:multictr.rank)


rank > public inline (0 calls)
0: rank($rec#0:multictr.card, ?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm lshr(~$rec#0:multictr.card, 2:multictr.card, ?$rec#1:multictr.card)
    foreign llvm and(~$rec#1:multictr.card, 15:multictr.card, ?$field#0:multictr.card)
    foreign lpvm cast(~$field#0:multictr.card, ?$#0:multictr.rank)
rank > public inline (0 calls)
1: rank($rec#0:multictr.card, ?$rec#2:multictr.card, $field#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and(~$rec#0:multictr.card, -61:multictr.card, ?$rec#1:multictr.card)
    foreign llvm shl(~$field#0:!multictr.card, 2:multictr.card, ?$field#1:multictr.card)
    foreign llvm or(~$field#1:multictr.card, ~$rec#1:multictr.card, ?$rec#2:multictr.card)


suit > public inline (0 calls)
0: suit($rec#0:multictr.card, ?$#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and(~$rec#0:multictr.card, 3:multictr.card, ?$field#0:multictr.card)
    foreign lpvm cast(~$field#0:multictr.card, ?$#0:multictr.suit)
suit > public inline (0 calls)
1: suit($rec#0:multictr.card, ?$rec#2:multictr.card, $field#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and(~$rec#0:multictr.card, -4:multictr.card, ?$rec#1:multictr.card)
    foreign llvm or(~$field#0:!multictr.card, ~$rec#1:multictr.card, ?$rec#2:multictr.card)

  LLVM code       :

; ModuleID = 'multictr.card'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.card./=<0>"(i6  %"$left#0", i6  %"$right#0")    {
entry:
  %"1$tmp$1#0" = icmp eq i6 %"$left#0", %"$right#0" 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  ret i1 0 
if.else:
  ret i1 1 
}


define external fastcc  i1 @"multictr.card.=<0>"(i6  %"$left#0", i6  %"$right#0")    {
entry:
  %"1$$$#0" = icmp eq i6 %"$left#0", %"$right#0" 
  ret i1 %"1$$$#0" 
}


define external fastcc  i6 @"multictr.card.card<0>"(i2  %"suit#0", i4  %"rank#0")    {
entry:
  %1 = zext i4 %"rank#0" to i6  
  %"1$$temp#1" = shl   i6 %1, 2 
  %2 = zext i2 %"suit#0" to i6  
  %"1$$#3" = or i6 %"1$$temp#1", %2 
  ret i6 %"1$$#3" 
}


define external fastcc  {i2, i4} @"multictr.card.card<1>"(i6  %"$#0")    {
entry:
  %"1$$temp2#0" = and i6 %"$#0", 3 
  %3 = trunc i6 %"1$$temp2#0" to i2  
  %"1$$temp#1" = lshr  i6 %"$#0", 2 
  %"1$$temp2#1" = and i6 %"1$$temp#1", 15 
  %4 = trunc i6 %"1$$temp2#1" to i4  
  %5 = insertvalue {i2, i4} undef, i2 %3, 0 
  %6 = insertvalue {i2, i4} %5, i4 %4, 1 
  ret {i2, i4} %6 
}


define external fastcc  i4 @"multictr.card.rank<0>"(i6  %"$rec#0")    {
entry:
  %"1$$rec#1" = lshr  i6 %"$rec#0", 2 
  %"1$$field#0" = and i6 %"1$$rec#1", 15 
  %7 = trunc i6 %"1$$field#0" to i4  
  ret i4 %7 
}


define external fastcc  i6 @"multictr.card.rank<1>"(i6  %"$rec#0", i4  %"$field#0")    {
entry:
  %"1$$rec#1" = and i6 %"$rec#0", -61 
  %8 = zext i4 %"$field#0" to i6  
  %"1$$field#1" = shl   i6 %8, 2 
  %"1$$rec#2" = or i6 %"1$$field#1", %"1$$rec#1" 
  ret i6 %"1$$rec#2" 
}


define external fastcc  i2 @"multictr.card.suit<0>"(i6  %"$rec#0")    {
entry:
  %"1$$field#0" = and i6 %"$rec#0", 3 
  %9 = trunc i6 %"1$$field#0" to i2  
  ret i2 %9 
}


define external fastcc  i6 @"multictr.card.suit<1>"(i6  %"$rec#0", i2  %"$field#0")    {
entry:
  %"1$$rec#1" = and i6 %"$rec#0", -4 
  %10 = zext i2 %"$field#0" to i6  
  %"1$$rec#2" = or i6 %10, %"1$$rec#1" 
  ret i6 %"1$$rec#2" 
}
--------------------------------------------------
 Module multictr.complicated
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.complicated./=<0>
                    multictr.complicated.=<0>
                    multictr.complicated.autumn<0>
                    multictr.complicated.c01<0>
                    multictr.complicated.c01<1>
                    multictr.complicated.c02<0>
                    multictr.complicated.c02<1>
                    multictr.complicated.f01<0>
                    multictr.complicated.f01<1>
                    multictr.complicated.f02<0>
                    multictr.complicated.f02<1>
                    multictr.complicated.spring<0>
                    multictr.complicated.summer<0>
                    multictr.complicated.winter<0>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline test (0 calls)
0: /=($left#0:multictr.complicated, $right#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    multictr.complicated.=<0>(~$left#0:multictr.complicated, ~$right#0:multictr.complicated, ?tmp$1#0:wybe.bool) #0
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)



= > public test (5 calls)
0: =($left#0:multictr.complicated, $right#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm cast($left#0:multictr.complicated, ?tmp$0#0:!wybe.int)
    foreign llvm icmp ult(~tmp$0#0:!wybe.int, 4:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm icmp uge($left#0:multictr.complicated, 4:wybe.int, ?tmp$10#0:wybe.bool)
        case tmp$10#0:wybe.bool of
        0:
            case ~tmp$10#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign llvm and($left#0:multictr.complicated, 7:wybe.int, ?tmp$15#0:wybe.int)
                foreign llvm icmp eq(~tmp$15#0:wybe.int, 1:wybe.int, ?tmp$16#0:wybe.bool)
                case ~tmp$16#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign lpvm access(~$left#0:multictr.complicated, -1:wybe.int, ?$left$f02#0:wybe.int)
                    foreign llvm icmp uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$18#0:wybe.bool)
                    case ~tmp$18#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$19#0:wybe.int)
                        foreign llvm icmp eq(~tmp$19#0:wybe.int, 1:wybe.int, ?tmp$20#0:wybe.bool)
                        case ~tmp$20#0:wybe.bool of
                        0:
                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                        1:
                            foreign lpvm access(~$right#0:multictr.complicated, -1:wybe.int, ?$right$f02#0:wybe.int)
                            foreign llvm icmp eq(~$left$f02#0:wybe.int, ~$right$f02#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn





        1:
            foreign llvm and($left#0:multictr.complicated, 7:wybe.int, ?tmp$11#0:wybe.int)
            foreign llvm icmp eq(~tmp$11#0:wybe.int, 0:wybe.int, ?tmp$12#0:wybe.bool)
            case ~tmp$12#0:wybe.bool of
            0:
                case ~tmp$10#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign llvm and($left#0:multictr.complicated, 7:wybe.int, ?tmp$15#0:wybe.int)
                    foreign llvm icmp eq(~tmp$15#0:wybe.int, 1:wybe.int, ?tmp$16#0:wybe.bool)
                    case ~tmp$16#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        foreign lpvm access(~$left#0:multictr.complicated, -1:wybe.int, ?$left$f02#0:wybe.int)
                        foreign llvm icmp uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$18#0:wybe.bool)
                        case ~tmp$18#0:wybe.bool of
                        0:
                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                        1:
                            foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$19#0:wybe.int)
                            foreign llvm icmp eq(~tmp$19#0:wybe.int, 1:wybe.int, ?tmp$20#0:wybe.bool)
                            case ~tmp$20#0:wybe.bool of
                            0:
                                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                            1:
                                foreign lpvm access(~$right#0:multictr.complicated, -1:wybe.int, ?$right$f02#0:wybe.int)
                                foreign llvm icmp eq(~$left$f02#0:wybe.int, ~$right$f02#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn





            1:
                foreign lpvm access(~$left#0:multictr.complicated, 0:wybe.int, ?$left$f01#0:wybe.int)
                foreign llvm icmp uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$14#0:wybe.bool)
                case ~tmp$14#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$15#0:wybe.int)
                    foreign llvm icmp eq(~tmp$15#0:wybe.int, 0:wybe.int, ?tmp$16#0:wybe.bool)
                    case ~tmp$16#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        foreign lpvm access(~$right#0:multictr.complicated, 0:wybe.int, ?$right$f01#0:wybe.int)
                        foreign llvm icmp eq(~$left$f01#0:wybe.int, ~$right$f01#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn





    1:
        foreign llvm icmp eq(~$left#0:multictr.complicated, ~$right#0:multictr.complicated, ?$$#0:wybe.bool)



autumn > public inline (0 calls)
0: autumn(?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(3:multictr.complicated, ?$#0:multictr.complicated)


c01 > public inline (0 calls)
0: c01(f01#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:!multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$#0:multictr.complicated, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~f01#0:wybe.int)
c01 > public inline test (7 calls)
1: c01(?f01#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp uge($#0:multictr.complicated, 4:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($#0:multictr.complicated, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$#0:multictr.complicated, 0:wybe.int, ?f01#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




c02 > public inline (0 calls)
0: c02(f02#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:!multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~f02#0:wybe.int)
    foreign llvm or(~$rec#1, 1:wybe.int, ?$#0:multictr.complicated)
c02 > public inline test (5 calls)
1: c02(?f02#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp uge($#0:multictr.complicated, 4:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($#0:multictr.complicated, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$#0:multictr.complicated, -1:wybe.int, ?f02#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




f01 > public inline test (0 calls)
0: f01($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp uge($rec#0:multictr.complicated, 4:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($rec#0:multictr.complicated, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$rec#0:multictr.complicated, 0:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


f01 > public inline test (0 calls)
1: f01($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp uge($rec#0:multictr.complicated, 4:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:multictr.complicated, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm mutate noalias(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




f02 > public inline test (0 calls)
0: f02($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp uge($rec#0:multictr.complicated, 4:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($rec#0:multictr.complicated, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$rec#0:multictr.complicated, -1:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


f02 > public inline test (0 calls)
1: f02($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp uge($rec#0:multictr.complicated, 4:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:multictr.complicated, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm mutate noalias(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, -1:wybe.int, 0:wybe.int, 8:wybe.int, 1:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




spring > public inline (0 calls)
0: spring(?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(1:multictr.complicated, ?$#0:multictr.complicated)


summer > public inline (0 calls)
0: summer(?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(2:multictr.complicated, ?$#0:multictr.complicated)


winter > public inline (0 calls)
0: winter(?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.complicated, ?$#0:multictr.complicated)

  LLVM code       :

; ModuleID = 'multictr.complicated'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.complicated./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$1#0" = tail call fastcc  i1  @"multictr.complicated.=<0>"(i64  %"$left#0", i64  %"$right#0")  
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  ret i1 0 
if.else:
  ret i1 1 
}


define external fastcc  i1 @"multictr.complicated.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$1#0" = icmp ult i64 %"$left#0", 4 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  %"2$$$#0" = icmp eq i64 %"$left#0", %"$right#0" 
  ret i1 %"2$$$#0" 
if.else:
  %"3$tmp$10#0" = icmp uge i64 %"$left#0", 4 
  br i1 %"3$tmp$10#0", label %if.then1, label %if.else1 
if.then1:
  %"4$tmp$11#0" = and i64 %"$left#0", 7 
  %"4$tmp$12#0" = icmp eq i64 %"4$tmp$11#0", 0 
  br i1 %"4$tmp$12#0", label %if.then2, label %if.else2 
if.else1:
  br i1 %"3$tmp$10#0", label %if.then9, label %if.else9 
if.then2:
  %1 = inttoptr i64 %"$left#0" to i64* 
  %2 = getelementptr  i64, i64* %1, i64 0 
  %3 = load  i64, i64* %2 
  %"6$tmp$14#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"6$tmp$14#0", label %if.then3, label %if.else3 
if.else2:
  br i1 %"3$tmp$10#0", label %if.then5, label %if.else5 
if.then3:
  %"8$tmp$15#0" = and i64 %"$right#0", 7 
  %"8$tmp$16#0" = icmp eq i64 %"8$tmp$15#0", 0 
  br i1 %"8$tmp$16#0", label %if.then4, label %if.else4 
if.else3:
  ret i1 0 
if.then4:
  %4 = inttoptr i64 %"$right#0" to i64* 
  %5 = getelementptr  i64, i64* %4, i64 0 
  %6 = load  i64, i64* %5 
  %"10$$$#0" = icmp eq i64 %3, %6 
  ret i1 %"10$$$#0" 
if.else4:
  ret i1 0 
if.then5:
  %"12$tmp$15#0" = and i64 %"$left#0", 7 
  %"12$tmp$16#0" = icmp eq i64 %"12$tmp$15#0", 1 
  br i1 %"12$tmp$16#0", label %if.then6, label %if.else6 
if.else5:
  ret i1 0 
if.then6:
  %7 = add   i64 %"$left#0", -1 
  %8 = inttoptr i64 %7 to i64* 
  %9 = getelementptr  i64, i64* %8, i64 0 
  %10 = load  i64, i64* %9 
  %"14$tmp$18#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"14$tmp$18#0", label %if.then7, label %if.else7 
if.else6:
  ret i1 0 
if.then7:
  %"16$tmp$19#0" = and i64 %"$right#0", 7 
  %"16$tmp$20#0" = icmp eq i64 %"16$tmp$19#0", 1 
  br i1 %"16$tmp$20#0", label %if.then8, label %if.else8 
if.else7:
  ret i1 0 
if.then8:
  %11 = add   i64 %"$right#0", -1 
  %12 = inttoptr i64 %11 to i64* 
  %13 = getelementptr  i64, i64* %12, i64 0 
  %14 = load  i64, i64* %13 
  %"18$$$#0" = icmp eq i64 %10, %14 
  ret i1 %"18$$$#0" 
if.else8:
  ret i1 0 
if.then9:
  %"20$tmp$15#0" = and i64 %"$left#0", 7 
  %"20$tmp$16#0" = icmp eq i64 %"20$tmp$15#0", 1 
  br i1 %"20$tmp$16#0", label %if.then10, label %if.else10 
if.else9:
  ret i1 0 
if.then10:
  %15 = add   i64 %"$left#0", -1 
  %16 = inttoptr i64 %15 to i64* 
  %17 = getelementptr  i64, i64* %16, i64 0 
  %18 = load  i64, i64* %17 
  %"22$tmp$18#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"22$tmp$18#0", label %if.then11, label %if.else11 
if.else10:
  ret i1 0 
if.then11:
  %"24$tmp$19#0" = and i64 %"$right#0", 7 
  %"24$tmp$20#0" = icmp eq i64 %"24$tmp$19#0", 1 
  br i1 %"24$tmp$20#0", label %if.then12, label %if.else12 
if.else11:
  ret i1 0 
if.then12:
  %19 = add   i64 %"$right#0", -1 
  %20 = inttoptr i64 %19 to i64* 
  %21 = getelementptr  i64, i64* %20, i64 0 
  %22 = load  i64, i64* %21 
  %"26$$$#0" = icmp eq i64 %18, %22 
  ret i1 %"26$$$#0" 
if.else12:
  ret i1 0 
}


define external fastcc  i64 @"multictr.complicated.autumn<0>"()    {
entry:
  ret i64 3 
}


define external fastcc  i64 @"multictr.complicated.c01<0>"(i64  %"f01#0")    {
entry:
  %23 = trunc i64 8 to i32  
  %24 = tail call ccc  i8*  @wybe_malloc(i32  %23)  
  %25 = ptrtoint i8* %24 to i64 
  %26 = inttoptr i64 %25 to i64* 
  %27 = getelementptr  i64, i64* %26, i64 0 
  store  i64 %"f01#0", i64* %27 
  ret i64 %25 
}


define external fastcc  {i64, i1} @"multictr.complicated.c01<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 0 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %35 = insertvalue {i64, i1} undef, i64 undef, 0 
  %36 = insertvalue {i64, i1} %35, i1 0, 1 
  ret {i64, i1} %36 
if.then1:
  %28 = inttoptr i64 %"$#0" to i64* 
  %29 = getelementptr  i64, i64* %28, i64 0 
  %30 = load  i64, i64* %29 
  %31 = insertvalue {i64, i1} undef, i64 %30, 0 
  %32 = insertvalue {i64, i1} %31, i1 1, 1 
  ret {i64, i1} %32 
if.else1:
  %33 = insertvalue {i64, i1} undef, i64 undef, 0 
  %34 = insertvalue {i64, i1} %33, i1 0, 1 
  ret {i64, i1} %34 
}


define external fastcc  i64 @"multictr.complicated.c02<0>"(i64  %"f02#0")    {
entry:
  %37 = trunc i64 8 to i32  
  %38 = tail call ccc  i8*  @wybe_malloc(i32  %37)  
  %39 = ptrtoint i8* %38 to i64 
  %40 = inttoptr i64 %39 to i64* 
  %41 = getelementptr  i64, i64* %40, i64 0 
  store  i64 %"f02#0", i64* %41 
  %"1$$#0" = or i64 %39, 1 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c02<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 1 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %50 = insertvalue {i64, i1} undef, i64 undef, 0 
  %51 = insertvalue {i64, i1} %50, i1 0, 1 
  ret {i64, i1} %51 
if.then1:
  %42 = add   i64 %"$#0", -1 
  %43 = inttoptr i64 %42 to i64* 
  %44 = getelementptr  i64, i64* %43, i64 0 
  %45 = load  i64, i64* %44 
  %46 = insertvalue {i64, i1} undef, i64 %45, 0 
  %47 = insertvalue {i64, i1} %46, i1 1, 1 
  ret {i64, i1} %47 
if.else1:
  %48 = insertvalue {i64, i1} undef, i64 undef, 0 
  %49 = insertvalue {i64, i1} %48, i1 0, 1 
  ret {i64, i1} %49 
}


define external fastcc  {i64, i1} @"multictr.complicated.f01<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 0 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %59 = insertvalue {i64, i1} undef, i64 undef, 0 
  %60 = insertvalue {i64, i1} %59, i1 0, 1 
  ret {i64, i1} %60 
if.then1:
  %52 = inttoptr i64 %"$rec#0" to i64* 
  %53 = getelementptr  i64, i64* %52, i64 0 
  %54 = load  i64, i64* %53 
  %55 = insertvalue {i64, i1} undef, i64 %54, 0 
  %56 = insertvalue {i64, i1} %55, i1 1, 1 
  ret {i64, i1} %56 
if.else1:
  %57 = insertvalue {i64, i1} undef, i64 undef, 0 
  %58 = insertvalue {i64, i1} %57, i1 0, 1 
  ret {i64, i1} %58 
}


define external fastcc  {i64, i1} @"multictr.complicated.f01<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 0 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %73 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %74 = insertvalue {i64, i1} %73, i1 0, 1 
  ret {i64, i1} %74 
if.then1:
  %61 = trunc i64 8 to i32  
  %62 = tail call ccc  i8*  @wybe_malloc(i32  %61)  
  %63 = ptrtoint i8* %62 to i64 
  %64 = inttoptr i64 %63 to i8* 
  %65 = inttoptr i64 %"$rec#0" to i8* 
  %66 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %64, i8*  %65, i32  %66, i32  8, i1  0)  
  %67 = inttoptr i64 %63 to i64* 
  %68 = getelementptr  i64, i64* %67, i64 0 
  store  i64 %"$field#0", i64* %68 
  %69 = insertvalue {i64, i1} undef, i64 %63, 0 
  %70 = insertvalue {i64, i1} %69, i1 1, 1 
  ret {i64, i1} %70 
if.else1:
  %71 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %72 = insertvalue {i64, i1} %71, i1 0, 1 
  ret {i64, i1} %72 
}


define external fastcc  {i64, i1} @"multictr.complicated.f02<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 1 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %83 = insertvalue {i64, i1} undef, i64 undef, 0 
  %84 = insertvalue {i64, i1} %83, i1 0, 1 
  ret {i64, i1} %84 
if.then1:
  %75 = add   i64 %"$rec#0", -1 
  %76 = inttoptr i64 %75 to i64* 
  %77 = getelementptr  i64, i64* %76, i64 0 
  %78 = load  i64, i64* %77 
  %79 = insertvalue {i64, i1} undef, i64 %78, 0 
  %80 = insertvalue {i64, i1} %79, i1 1, 1 
  ret {i64, i1} %80 
if.else1:
  %81 = insertvalue {i64, i1} undef, i64 undef, 0 
  %82 = insertvalue {i64, i1} %81, i1 0, 1 
  ret {i64, i1} %82 
}


define external fastcc  {i64, i1} @"multictr.complicated.f02<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 1 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %99 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %100 = insertvalue {i64, i1} %99, i1 0, 1 
  ret {i64, i1} %100 
if.then1:
  %85 = trunc i64 8 to i32  
  %86 = tail call ccc  i8*  @wybe_malloc(i32  %85)  
  %87 = ptrtoint i8* %86 to i64 
  %88 = sub   i64 %"$rec#0", 1 
  %89 = inttoptr i64 %87 to i8* 
  %90 = inttoptr i64 %88 to i8* 
  %91 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %89, i8*  %90, i32  %91, i32  8, i1  0)  
  %92 = add   i64 %87, -1 
  %93 = inttoptr i64 %92 to i64* 
  %94 = getelementptr  i64, i64* %93, i64 0 
  store  i64 %"$field#0", i64* %94 
  %95 = insertvalue {i64, i1} undef, i64 %87, 0 
  %96 = insertvalue {i64, i1} %95, i1 1, 1 
  ret {i64, i1} %96 
if.else1:
  %97 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %98 = insertvalue {i64, i1} %97, i1 0, 1 
  ret {i64, i1} %98 
}


define external fastcc  i64 @"multictr.complicated.spring<0>"()    {
entry:
  ret i64 1 
}


define external fastcc  i64 @"multictr.complicated.summer<0>"()    {
entry:
  ret i64 2 
}


define external fastcc  i64 @"multictr.complicated.winter<0>"()    {
entry:
  ret i64 0 
}
--------------------------------------------------
 Module multictr.length
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.length./=<0>
                    multictr.length.=<0>
                    multictr.length.metres<0>
                    multictr.length.metres<1>
                    multictr.length.value<0>
                    multictr.length.value<1>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline test (0 calls)
0: /=($left#0:multictr.length, $right#0:multictr.length, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.length, ~$right#0:multictr.length, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)



= > public inline test (3 calls)
0: =($left#0:multictr.length, $right#0:multictr.length, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.length, ~$right#0:multictr.length, ?$$#0:wybe.bool)


metres > public inline (0 calls)
0: metres(value#0:wybe.float, ?$#2:multictr.length):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(~value#0:!multictr.length, ?$#2:multictr.length)
metres > public inline (0 calls)
1: metres(?value#0:wybe.float, $#0:multictr.length):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm cast(~$#0:multictr.length, ?value#0:wybe.float)


value > public inline (0 calls)
0: value($rec#0:multictr.length, ?$#0:wybe.float):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm cast(~$rec#0:multictr.length, ?$#0:wybe.float)
value > public inline (0 calls)
1: value([$rec#0:multictr.length], ?$rec#2:multictr.length, $field#0:wybe.float):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(~$field#0:!multictr.length, ?$rec#2:multictr.length)

  LLVM code       :

; ModuleID = 'multictr.length'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.length./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$1#0" = icmp eq i64 %"$left#0", %"$right#0" 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  ret i1 0 
if.else:
  ret i1 1 
}


define external fastcc  i1 @"multictr.length.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$$$#0" = icmp eq i64 %"$left#0", %"$right#0" 
  ret i1 %"1$$$#0" 
}


define external fastcc  i64 @"multictr.length.metres<0>"(double  %"value#0")    {
entry:
  %1 = bitcast double %"value#0" to i64 
  ret i64 %1 
}


define external fastcc  double @"multictr.length.metres<1>"(i64  %"$#0")    {
entry:
  %2 = bitcast i64 %"$#0" to double 
  ret double %2 
}


define external fastcc  double @"multictr.length.value<0>"(i64  %"$rec#0")    {
entry:
  %3 = bitcast i64 %"$rec#0" to double 
  ret double %3 
}


define external fastcc  i64 @"multictr.length.value<1>"(double  %"$field#0")    {
entry:
  %4 = bitcast double %"$field#0" to i64 
  ret i64 %4 
}
--------------------------------------------------
 Module multictr.maybe_int
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.maybe_int./=<0>
                    multictr.maybe_int.=<0>
                    multictr.maybe_int.just<0>
                    multictr.maybe_int.just<1>
                    multictr.maybe_int.nothing<0>
                    multictr.maybe_int.value<0>
                    multictr.maybe_int.value<1>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline test (0 calls)
0: /=($left#0:multictr.maybe_int, $right#0:multictr.maybe_int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    multictr.maybe_int.=<0>(~$left#0:multictr.maybe_int, ~$right#0:multictr.maybe_int, ?tmp$1#0:wybe.bool) #0
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)



= > public test (4 calls)
0: =($left#0:multictr.maybe_int, $right#0:multictr.maybe_int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm cast($left#0:multictr.maybe_int, ?tmp$0#0:!wybe.int)
    foreign llvm icmp eq(~tmp$0#0:!wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm icmp ne($left#0:multictr.maybe_int, 0:wybe.int, ?tmp$7#0:wybe.bool)
        case ~tmp$7#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$left#0:multictr.maybe_int, 0:wybe.int, ?$left$value#0:wybe.int)
            foreign llvm icmp ne($right#0:multictr.maybe_int, 0:wybe.int, ?tmp$9#0:wybe.bool)
            case ~tmp$9#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign lpvm access(~$right#0:multictr.maybe_int, 0:wybe.int, ?$right$value#0:wybe.int)
                foreign llvm icmp eq(~$left$value#0:wybe.int, ~$right$value#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn



    1:
        foreign llvm icmp eq(~$left#0:multictr.maybe_int, ~$right#0:multictr.maybe_int, ?$$#0:wybe.bool)



just > public inline (0 calls)
0: just(value#0:wybe.int, ?$#0:multictr.maybe_int):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:!multictr.maybe_int)
    foreign lpvm mutate(~%$rec#0:multictr.maybe_int, ?%$#0:multictr.maybe_int, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~value#0:wybe.int)
just > public inline test (5 calls)
1: just(?value#0:wybe.int, $#0:multictr.maybe_int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($#0:multictr.maybe_int, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$#0:multictr.maybe_int, 0:wybe.int, ?value#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



nothing > public inline (0 calls)
0: nothing(?$#0:multictr.maybe_int):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.maybe_int, ?$#0:multictr.maybe_int)


value > public inline test (0 calls)
0: value($rec#0:multictr.maybe_int, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($rec#0:multictr.maybe_int, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:multictr.maybe_int, 0:wybe.int, ?$#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

value > public inline test (0 calls)
1: value($rec#0:multictr.maybe_int, ?$rec#1:multictr.maybe_int, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($rec#0:multictr.maybe_int, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.maybe_int, ?$rec#1:multictr.maybe_int)

    1:
        foreign lpvm mutate noalias(~%$rec#0:multictr.maybe_int, ?%$rec#1:multictr.maybe_int, 0:wybe.int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


  LLVM code       :

; ModuleID = 'multictr.maybe_int'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.maybe_int./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$1#0" = tail call fastcc  i1  @"multictr.maybe_int.=<0>"(i64  %"$left#0", i64  %"$right#0")  
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  ret i1 0 
if.else:
  ret i1 1 
}


define external fastcc  i1 @"multictr.maybe_int.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$1#0" = icmp eq i64 %"$left#0", 0 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  %"2$$$#0" = icmp eq i64 %"$left#0", %"$right#0" 
  ret i1 %"2$$$#0" 
if.else:
  %"3$tmp$7#0" = icmp ne i64 %"$left#0", 0 
  br i1 %"3$tmp$7#0", label %if.then1, label %if.else1 
if.then1:
  %1 = inttoptr i64 %"$left#0" to i64* 
  %2 = getelementptr  i64, i64* %1, i64 0 
  %3 = load  i64, i64* %2 
  %"4$tmp$9#0" = icmp ne i64 %"$right#0", 0 
  br i1 %"4$tmp$9#0", label %if.then2, label %if.else2 
if.else1:
  ret i1 0 
if.then2:
  %4 = inttoptr i64 %"$right#0" to i64* 
  %5 = getelementptr  i64, i64* %4, i64 0 
  %6 = load  i64, i64* %5 
  %"6$$$#0" = icmp eq i64 %3, %6 
  ret i1 %"6$$$#0" 
if.else2:
  ret i1 0 
}


define external fastcc  i64 @"multictr.maybe_int.just<0>"(i64  %"value#0")    {
entry:
  %7 = trunc i64 8 to i32  
  %8 = tail call ccc  i8*  @wybe_malloc(i32  %7)  
  %9 = ptrtoint i8* %8 to i64 
  %10 = inttoptr i64 %9 to i64* 
  %11 = getelementptr  i64, i64* %10, i64 0 
  store  i64 %"value#0", i64* %11 
  ret i64 %9 
}


define external fastcc  {i64, i1} @"multictr.maybe_int.just<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %12 = inttoptr i64 %"$#0" to i64* 
  %13 = getelementptr  i64, i64* %12, i64 0 
  %14 = load  i64, i64* %13 
  %15 = insertvalue {i64, i1} undef, i64 %14, 0 
  %16 = insertvalue {i64, i1} %15, i1 1, 1 
  ret {i64, i1} %16 
if.else:
  %17 = insertvalue {i64, i1} undef, i64 undef, 0 
  %18 = insertvalue {i64, i1} %17, i1 0, 1 
  ret {i64, i1} %18 
}


define external fastcc  i64 @"multictr.maybe_int.nothing<0>"()    {
entry:
  ret i64 0 
}


define external fastcc  {i64, i1} @"multictr.maybe_int.value<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %19 = inttoptr i64 %"$rec#0" to i64* 
  %20 = getelementptr  i64, i64* %19, i64 0 
  %21 = load  i64, i64* %20 
  %22 = insertvalue {i64, i1} undef, i64 %21, 0 
  %23 = insertvalue {i64, i1} %22, i1 1, 1 
  ret {i64, i1} %23 
if.else:
  %24 = insertvalue {i64, i1} undef, i64 undef, 0 
  %25 = insertvalue {i64, i1} %24, i1 0, 1 
  ret {i64, i1} %25 
}


define external fastcc  {i64, i1} @"multictr.maybe_int.value<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %26 = trunc i64 8 to i32  
  %27 = tail call ccc  i8*  @wybe_malloc(i32  %26)  
  %28 = ptrtoint i8* %27 to i64 
  %29 = inttoptr i64 %28 to i8* 
  %30 = inttoptr i64 %"$rec#0" to i8* 
  %31 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %29, i8*  %30, i32  %31, i32  8, i1  0)  
  %32 = inttoptr i64 %28 to i64* 
  %33 = getelementptr  i64, i64* %32, i64 0 
  store  i64 %"$field#0", i64* %33 
  %34 = insertvalue {i64, i1} undef, i64 %28, 0 
  %35 = insertvalue {i64, i1} %34, i1 1, 1 
  ret {i64, i1} %35 
if.else:
  %36 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %37 = insertvalue {i64, i1} %36, i1 0, 1 
  ret {i64, i1} %37 
}
--------------------------------------------------
 Module multictr.number
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.number./=<0>
                    multictr.number.=<0>
                    multictr.number.float<0>
                    multictr.number.float<1>
                    multictr.number.float_value<0>
                    multictr.number.float_value<1>
                    multictr.number.int<0>
                    multictr.number.int<1>
                    multictr.number.int_value<0>
                    multictr.number.int_value<1>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline test (0 calls)
0: /=($left#0:multictr.number, $right#0:multictr.number, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    multictr.number.=<0>(~$left#0:multictr.number, ~$right#0:multictr.number, ?tmp$1#0:wybe.bool) #0
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)



= > public test (5 calls)
0: =($left#0:multictr.number, $right#0:multictr.number, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($left#0:multictr.number, 7:wybe.int, ?tmp$9#0:wybe.int)
    foreign llvm icmp eq(tmp$9#0:wybe.int, 0:wybe.int, ?tmp$10#0:wybe.bool)
    case ~tmp$10#0:wybe.bool of
    0:
        foreign llvm icmp eq(~tmp$9#0:wybe.int, 1:wybe.int, ?tmp$13#0:wybe.bool)
        case ~tmp$13#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$left#0:multictr.number, -1:wybe.int, ?$left$float_value#0:wybe.float)
            foreign llvm and($right#0:multictr.number, 7:wybe.int, ?tmp$15#0:wybe.int)
            foreign llvm icmp eq(~tmp$15#0:wybe.int, 1:wybe.int, ?tmp$16#0:wybe.bool)
            case ~tmp$16#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign lpvm access(~$right#0:multictr.number, -1:wybe.int, ?$right$float_value#0:wybe.float)
                foreign llvm fcmp eq(~$left$float_value#0:wybe.float, ~$right$float_value#0:wybe.float, ?$$#0:wybe.bool) @wybe:nn:nn



    1:
        foreign lpvm access(~$left#0:multictr.number, 0:wybe.int, ?$left$int_value#0:wybe.int)
        foreign llvm and($right#0:multictr.number, 7:wybe.int, ?tmp$12#0:wybe.int)
        foreign llvm icmp eq(~tmp$12#0:wybe.int, 0:wybe.int, ?tmp$13#0:wybe.bool)
        case ~tmp$13#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$right#0:multictr.number, 0:wybe.int, ?$right$int_value#0:wybe.int)
            foreign llvm icmp eq(~$left$int_value#0:wybe.int, ~$right$int_value#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn




float > public inline (0 calls)
0: float(float_value#0:wybe.float, ?$#0:multictr.number):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:!multictr.number)
    foreign lpvm mutate(~%$rec#0:multictr.number, ?%$rec#1:multictr.number, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~float_value#0:wybe.float)
    foreign llvm or(~$rec#1, 1:wybe.int, ?$#0:multictr.number)
float > public inline test (5 calls)
1: float(?float_value#0:wybe.float, $#0:multictr.number, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($#0:multictr.number, 7:wybe.int, ?tmp$0#0:!wybe.int)
    foreign llvm icmp eq(~tmp$0#0:!wybe.int, 1:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$#0:multictr.number, -1:wybe.int, ?float_value#0:wybe.float)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



float_value > public inline test (0 calls)
0: float_value($rec#0:multictr.number, ?$#0:wybe.float, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($rec#0:multictr.number, 7:wybe.int, ?tmp$0#0:!wybe.int)
    foreign llvm icmp eq(~tmp$0#0:!wybe.int, 1:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:multictr.number, -1:wybe.int, ?$#0:wybe.float)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

float_value > public inline test (0 calls)
1: float_value($rec#0:multictr.number, ?$rec#1:multictr.number, $field#0:wybe.float, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($rec#0:multictr.number, 7:wybe.int, ?tmp$0#0:!wybe.int)
    foreign llvm icmp eq(~tmp$0#0:!wybe.int, 1:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.number, ?$rec#1:multictr.number)

    1:
        foreign lpvm mutate noalias(~%$rec#0:multictr.number, ?%$rec#1:multictr.number, -1:wybe.int, 0:wybe.int, 8:wybe.int, 1:wybe.int, ~$field#0:wybe.float)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



int > public inline (0 calls)
0: int(int_value#0:wybe.int, ?$#0:multictr.number):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:!multictr.number)
    foreign lpvm mutate(~%$rec#0:multictr.number, ?%$#0:multictr.number, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~int_value#0:wybe.int)
int > public inline test (7 calls)
1: int(?int_value#0:wybe.int, $#0:multictr.number, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($#0:multictr.number, 7:wybe.int, ?tmp$0#0:!wybe.int)
    foreign llvm icmp eq(~tmp$0#0:!wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$#0:multictr.number, 0:wybe.int, ?int_value#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



int_value > public inline test (0 calls)
0: int_value($rec#0:multictr.number, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($rec#0:multictr.number, 7:wybe.int, ?tmp$0#0:!wybe.int)
    foreign llvm icmp eq(~tmp$0#0:!wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:multictr.number, 0:wybe.int, ?$#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

int_value > public inline test (0 calls)
1: int_value($rec#0:multictr.number, ?$rec#1:multictr.number, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($rec#0:multictr.number, 7:wybe.int, ?tmp$0#0:!wybe.int)
    foreign llvm icmp eq(~tmp$0#0:!wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.number, ?$rec#1:multictr.number)

    1:
        foreign lpvm mutate noalias(~%$rec#0:multictr.number, ?%$rec#1:multictr.number, 0:wybe.int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


  LLVM code       :

; ModuleID = 'multictr.number'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.number./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$1#0" = tail call fastcc  i1  @"multictr.number.=<0>"(i64  %"$left#0", i64  %"$right#0")  
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  ret i1 0 
if.else:
  ret i1 1 
}


define external fastcc  i1 @"multictr.number.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$9#0" = and i64 %"$left#0", 7 
  %"1$tmp$10#0" = icmp eq i64 %"1$tmp$9#0", 0 
  br i1 %"1$tmp$10#0", label %if.then, label %if.else 
if.then:
  %1 = inttoptr i64 %"$left#0" to i64* 
  %2 = getelementptr  i64, i64* %1, i64 0 
  %3 = load  i64, i64* %2 
  %"2$tmp$12#0" = and i64 %"$right#0", 7 
  %"2$tmp$13#0" = icmp eq i64 %"2$tmp$12#0", 0 
  br i1 %"2$tmp$13#0", label %if.then1, label %if.else1 
if.else:
  %"3$tmp$13#0" = icmp eq i64 %"1$tmp$9#0", 1 
  br i1 %"3$tmp$13#0", label %if.then2, label %if.else2 
if.then1:
  %4 = inttoptr i64 %"$right#0" to i64* 
  %5 = getelementptr  i64, i64* %4, i64 0 
  %6 = load  i64, i64* %5 
  %"4$$$#0" = icmp eq i64 %3, %6 
  ret i1 %"4$$$#0" 
if.else1:
  ret i1 0 
if.then2:
  %7 = add   i64 %"$left#0", -1 
  %8 = inttoptr i64 %7 to double* 
  %9 = getelementptr  double, double* %8, i64 0 
  %10 = load  double, double* %9 
  %"6$tmp$15#0" = and i64 %"$right#0", 7 
  %"6$tmp$16#0" = icmp eq i64 %"6$tmp$15#0", 1 
  br i1 %"6$tmp$16#0", label %if.then3, label %if.else3 
if.else2:
  ret i1 0 
if.then3:
  %11 = add   i64 %"$right#0", -1 
  %12 = inttoptr i64 %11 to double* 
  %13 = getelementptr  double, double* %12, i64 0 
  %14 = load  double, double* %13 
  %"8$$$#0" = fcmp oeq double %10, %14 
  ret i1 %"8$$$#0" 
if.else3:
  ret i1 0 
}


define external fastcc  i64 @"multictr.number.float<0>"(double  %"float_value#0")    {
entry:
  %15 = trunc i64 8 to i32  
  %16 = tail call ccc  i8*  @wybe_malloc(i32  %15)  
  %17 = ptrtoint i8* %16 to i64 
  %18 = inttoptr i64 %17 to double* 
  %19 = getelementptr  double, double* %18, i64 0 
  store  double %"float_value#0", double* %19 
  %"1$$#0" = or i64 %17, 1 
  ret i64 %"1$$#0" 
}


define external fastcc  {double, i1} @"multictr.number.float<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = and i64 %"$#0", 7 
  %"1$tmp$1#0" = icmp eq i64 %"1$tmp$0#0", 1 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  %20 = add   i64 %"$#0", -1 
  %21 = inttoptr i64 %20 to double* 
  %22 = getelementptr  double, double* %21, i64 0 
  %23 = load  double, double* %22 
  %24 = insertvalue {double, i1} undef, double %23, 0 
  %25 = insertvalue {double, i1} %24, i1 1, 1 
  ret {double, i1} %25 
if.else:
  %26 = insertvalue {double, i1} undef, double undef, 0 
  %27 = insertvalue {double, i1} %26, i1 0, 1 
  ret {double, i1} %27 
}


define external fastcc  {double, i1} @"multictr.number.float_value<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = and i64 %"$rec#0", 7 
  %"1$tmp$1#0" = icmp eq i64 %"1$tmp$0#0", 1 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  %28 = add   i64 %"$rec#0", -1 
  %29 = inttoptr i64 %28 to double* 
  %30 = getelementptr  double, double* %29, i64 0 
  %31 = load  double, double* %30 
  %32 = insertvalue {double, i1} undef, double %31, 0 
  %33 = insertvalue {double, i1} %32, i1 1, 1 
  ret {double, i1} %33 
if.else:
  %34 = insertvalue {double, i1} undef, double undef, 0 
  %35 = insertvalue {double, i1} %34, i1 0, 1 
  ret {double, i1} %35 
}


define external fastcc  {i64, i1} @"multictr.number.float_value<1>"(i64  %"$rec#0", double  %"$field#0")    {
entry:
  %"1$tmp$0#0" = and i64 %"$rec#0", 7 
  %"1$tmp$1#0" = icmp eq i64 %"1$tmp$0#0", 1 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  %36 = trunc i64 8 to i32  
  %37 = tail call ccc  i8*  @wybe_malloc(i32  %36)  
  %38 = ptrtoint i8* %37 to i64 
  %39 = sub   i64 %"$rec#0", 1 
  %40 = inttoptr i64 %38 to i8* 
  %41 = inttoptr i64 %39 to i8* 
  %42 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %40, i8*  %41, i32  %42, i32  8, i1  0)  
  %43 = add   i64 %38, -1 
  %44 = inttoptr i64 %43 to double* 
  %45 = getelementptr  double, double* %44, i64 0 
  store  double %"$field#0", double* %45 
  %46 = insertvalue {i64, i1} undef, i64 %38, 0 
  %47 = insertvalue {i64, i1} %46, i1 1, 1 
  ret {i64, i1} %47 
if.else:
  %48 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %49 = insertvalue {i64, i1} %48, i1 0, 1 
  ret {i64, i1} %49 
}


define external fastcc  i64 @"multictr.number.int<0>"(i64  %"int_value#0")    {
entry:
  %50 = trunc i64 8 to i32  
  %51 = tail call ccc  i8*  @wybe_malloc(i32  %50)  
  %52 = ptrtoint i8* %51 to i64 
  %53 = inttoptr i64 %52 to i64* 
  %54 = getelementptr  i64, i64* %53, i64 0 
  store  i64 %"int_value#0", i64* %54 
  ret i64 %52 
}


define external fastcc  {i64, i1} @"multictr.number.int<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = and i64 %"$#0", 7 
  %"1$tmp$1#0" = icmp eq i64 %"1$tmp$0#0", 0 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  %55 = inttoptr i64 %"$#0" to i64* 
  %56 = getelementptr  i64, i64* %55, i64 0 
  %57 = load  i64, i64* %56 
  %58 = insertvalue {i64, i1} undef, i64 %57, 0 
  %59 = insertvalue {i64, i1} %58, i1 1, 1 
  ret {i64, i1} %59 
if.else:
  %60 = insertvalue {i64, i1} undef, i64 undef, 0 
  %61 = insertvalue {i64, i1} %60, i1 0, 1 
  ret {i64, i1} %61 
}


define external fastcc  {i64, i1} @"multictr.number.int_value<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = and i64 %"$rec#0", 7 
  %"1$tmp$1#0" = icmp eq i64 %"1$tmp$0#0", 0 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  %62 = inttoptr i64 %"$rec#0" to i64* 
  %63 = getelementptr  i64, i64* %62, i64 0 
  %64 = load  i64, i64* %63 
  %65 = insertvalue {i64, i1} undef, i64 %64, 0 
  %66 = insertvalue {i64, i1} %65, i1 1, 1 
  ret {i64, i1} %66 
if.else:
  %67 = insertvalue {i64, i1} undef, i64 undef, 0 
  %68 = insertvalue {i64, i1} %67, i1 0, 1 
  ret {i64, i1} %68 
}


define external fastcc  {i64, i1} @"multictr.number.int_value<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = and i64 %"$rec#0", 7 
  %"1$tmp$1#0" = icmp eq i64 %"1$tmp$0#0", 0 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  %69 = trunc i64 8 to i32  
  %70 = tail call ccc  i8*  @wybe_malloc(i32  %69)  
  %71 = ptrtoint i8* %70 to i64 
  %72 = inttoptr i64 %71 to i8* 
  %73 = inttoptr i64 %"$rec#0" to i8* 
  %74 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %72, i8*  %73, i32  %74, i32  8, i1  0)  
  %75 = inttoptr i64 %71 to i64* 
  %76 = getelementptr  i64, i64* %75, i64 0 
  store  i64 %"$field#0", i64* %76 
  %77 = insertvalue {i64, i1} undef, i64 %71, 0 
  %78 = insertvalue {i64, i1} %77, i1 1, 1 
  ret {i64, i1} %78 
if.else:
  %79 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %80 = insertvalue {i64, i1} %79, i1 0, 1 
  ret {i64, i1} %80 
}
--------------------------------------------------
 Module multictr.perhaps
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.perhaps./=<0>
                    multictr.perhaps.=<0>
                    multictr.perhaps.content<0>
                    multictr.perhaps.content<1>
                    multictr.perhaps.perhaps<0>
                    multictr.perhaps.perhaps<1>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline test (0 calls)
0: /=($left#0:multictr.perhaps, $right#0:multictr.perhaps, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.perhaps, ~$right#0:multictr.perhaps, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)



= > public inline test (3 calls)
0: =($left#0:multictr.perhaps, $right#0:multictr.perhaps, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.perhaps, ~$right#0:multictr.perhaps, ?$$#0:wybe.bool)


content > public inline (0 calls)
0: content($rec#0:multictr.perhaps, ?$#0:multictr.maybe_int):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm cast(~$rec#0:multictr.perhaps, ?$#0:multictr.maybe_int)
content > public inline (0 calls)
1: content([$rec#0:multictr.perhaps], ?$rec#2:multictr.perhaps, $field#0:multictr.maybe_int):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(~$field#0:!multictr.perhaps, ?$rec#2:multictr.perhaps)


perhaps > public inline (0 calls)
0: perhaps(content#0:multictr.maybe_int, ?$#2:multictr.perhaps):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(~content#0:!multictr.perhaps, ?$#2:multictr.perhaps)
perhaps > public inline (0 calls)
1: perhaps(?content#0:multictr.maybe_int, $#0:multictr.perhaps):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm cast(~$#0:multictr.perhaps, ?content#0:multictr.maybe_int)

  LLVM code       :

; ModuleID = 'multictr.perhaps'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.perhaps./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$1#0" = icmp eq i64 %"$left#0", %"$right#0" 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  ret i1 0 
if.else:
  ret i1 1 
}


define external fastcc  i1 @"multictr.perhaps.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$$$#0" = icmp eq i64 %"$left#0", %"$right#0" 
  ret i1 %"1$$$#0" 
}


define external fastcc  i64 @"multictr.perhaps.content<0>"(i64  %"$rec#0")    {
entry:
  ret i64 %"$rec#0" 
}


define external fastcc  i64 @"multictr.perhaps.content<1>"(i64  %"$field#0")    {
entry:
  ret i64 %"$field#0" 
}


define external fastcc  i64 @"multictr.perhaps.perhaps<0>"(i64  %"content#0")    {
entry:
  ret i64 %"content#0" 
}


define external fastcc  i64 @"multictr.perhaps.perhaps<1>"(i64  %"$#0")    {
entry:
  ret i64 %"$#0" 
}
--------------------------------------------------
 Module multictr.rank
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.rank./=<0>
                    multictr.rank.=<0>
                    multictr.rank.ace<0>
                    multictr.rank.jack<0>
                    multictr.rank.king<0>
                    multictr.rank.queen<0>
                    multictr.rank.r10<0>
                    multictr.rank.r2<0>
                    multictr.rank.r3<0>
                    multictr.rank.r4<0>
                    multictr.rank.r5<0>
                    multictr.rank.r6<0>
                    multictr.rank.r7<0>
                    multictr.rank.r8<0>
                    multictr.rank.r9<0>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline test (0 calls)
0: /=($left#0:multictr.rank, $right#0:multictr.rank, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.rank, ~$right#0:multictr.rank, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)



= > public inline test (3 calls)
0: =($left#0:multictr.rank, $right#0:multictr.rank, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.rank, ~$right#0:multictr.rank, ?$$#0:wybe.bool)


ace > public inline (0 calls)
0: ace(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(12:multictr.rank, ?$#0:multictr.rank)


jack > public inline (0 calls)
0: jack(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(9:multictr.rank, ?$#0:multictr.rank)


king > public inline (0 calls)
0: king(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(11:multictr.rank, ?$#0:multictr.rank)


queen > public inline (0 calls)
0: queen(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(10:multictr.rank, ?$#0:multictr.rank)


r10 > public inline (0 calls)
0: r10(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(8:multictr.rank, ?$#0:multictr.rank)


r2 > public inline (0 calls)
0: r2(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.rank, ?$#0:multictr.rank)


r3 > public inline (0 calls)
0: r3(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(1:multictr.rank, ?$#0:multictr.rank)


r4 > public inline (0 calls)
0: r4(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(2:multictr.rank, ?$#0:multictr.rank)


r5 > public inline (0 calls)
0: r5(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(3:multictr.rank, ?$#0:multictr.rank)


r6 > public inline (0 calls)
0: r6(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(4:multictr.rank, ?$#0:multictr.rank)


r7 > public inline (0 calls)
0: r7(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(5:multictr.rank, ?$#0:multictr.rank)


r8 > public inline (0 calls)
0: r8(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(6:multictr.rank, ?$#0:multictr.rank)


r9 > public inline (0 calls)
0: r9(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(7:multictr.rank, ?$#0:multictr.rank)

  LLVM code       :

; ModuleID = 'multictr.rank'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.rank./=<0>"(i4  %"$left#0", i4  %"$right#0")    {
entry:
  %"1$tmp$1#0" = icmp eq i4 %"$left#0", %"$right#0" 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  ret i1 0 
if.else:
  ret i1 1 
}


define external fastcc  i1 @"multictr.rank.=<0>"(i4  %"$left#0", i4  %"$right#0")    {
entry:
  %"1$$$#0" = icmp eq i4 %"$left#0", %"$right#0" 
  ret i1 %"1$$$#0" 
}


define external fastcc  i4 @"multictr.rank.ace<0>"()    {
entry:
  ret i4 12 
}


define external fastcc  i4 @"multictr.rank.jack<0>"()    {
entry:
  ret i4 9 
}


define external fastcc  i4 @"multictr.rank.king<0>"()    {
entry:
  ret i4 11 
}


define external fastcc  i4 @"multictr.rank.queen<0>"()    {
entry:
  ret i4 10 
}


define external fastcc  i4 @"multictr.rank.r10<0>"()    {
entry:
  ret i4 8 
}


define external fastcc  i4 @"multictr.rank.r2<0>"()    {
entry:
  ret i4 0 
}


define external fastcc  i4 @"multictr.rank.r3<0>"()    {
entry:
  ret i4 1 
}


define external fastcc  i4 @"multictr.rank.r4<0>"()    {
entry:
  ret i4 2 
}


define external fastcc  i4 @"multictr.rank.r5<0>"()    {
entry:
  ret i4 3 
}


define external fastcc  i4 @"multictr.rank.r6<0>"()    {
entry:
  ret i4 4 
}


define external fastcc  i4 @"multictr.rank.r7<0>"()    {
entry:
  ret i4 5 
}


define external fastcc  i4 @"multictr.rank.r8<0>"()    {
entry:
  ret i4 6 
}


define external fastcc  i4 @"multictr.rank.r9<0>"()    {
entry:
  ret i4 7 
}
--------------------------------------------------
 Module multictr.simple
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.simple./=<0>
                    multictr.simple.=<0>
                    multictr.simple.one<0>
                    multictr.simple.one<1>
                    multictr.simple.one_field<0>
                    multictr.simple.one_field<1>
                    multictr.simple.two<0>
                    multictr.simple.two<1>
                    multictr.simple.two_field1<0>
                    multictr.simple.two_field1<1>
                    multictr.simple.two_field2<0>
                    multictr.simple.two_field2<1>
                    multictr.simple.zero<0>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline test (0 calls)
0: /=($left#0:multictr.simple, $right#0:multictr.simple, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    multictr.simple.=<0>(~$left#0:multictr.simple, ~$right#0:multictr.simple, ?tmp$1#0:wybe.bool) #0
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)



= > public test (7 calls)
0: =($left#0:multictr.simple, $right#0:multictr.simple, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm cast($left#0:multictr.simple, ?tmp$0#0:!wybe.int)
    foreign llvm icmp eq(~tmp$0#0:!wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm icmp ne($left#0:multictr.simple, 0:wybe.int, ?tmp$11#0:wybe.bool)
        case tmp$11#0:wybe.bool of
        0:
            case ~tmp$11#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign llvm and($left#0:multictr.simple, 7:wybe.int, ?tmp$16#0:wybe.int)
                foreign llvm icmp eq(~tmp$16#0:wybe.int, 1:wybe.int, ?tmp$17#0:wybe.bool)
                case ~tmp$17#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign lpvm access($left#0:multictr.simple, -1:wybe.int, ?$left$two_field1#0:wybe.int)
                    foreign lpvm access(~$left#0:multictr.simple, 7:wybe.int, ?$left$two_field2#0:wybe.int)
                    foreign llvm icmp ne($right#0:multictr.simple, 0:wybe.int, ?tmp$19#0:wybe.bool)
                    case ~tmp$19#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        foreign llvm and($right#0:multictr.simple, 7:wybe.int, ?tmp$20#0:wybe.int)
                        foreign llvm icmp eq(~tmp$20#0:wybe.int, 1:wybe.int, ?tmp$21#0:wybe.bool)
                        case ~tmp$21#0:wybe.bool of
                        0:
                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                        1:
                            foreign lpvm access($right#0:multictr.simple, -1:wybe.int, ?$right$two_field1#0:wybe.int)
                            foreign lpvm access(~$right#0:multictr.simple, 7:wybe.int, ?$right$two_field2#0:wybe.int)
                            foreign llvm icmp eq(~$left$two_field1#0:wybe.int, ~$right$two_field1#0:wybe.int, ?tmp$8#0:wybe.bool) @wybe:nn:nn
                            case ~tmp$8#0:wybe.bool of
                            0:
                                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                            1:
                                foreign llvm icmp eq(~$left$two_field2#0:wybe.int, ~$right$two_field2#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn






        1:
            foreign llvm and($left#0:multictr.simple, 7:wybe.int, ?tmp$12#0:wybe.int)
            foreign llvm icmp eq(~tmp$12#0:wybe.int, 0:wybe.int, ?tmp$13#0:wybe.bool)
            case ~tmp$13#0:wybe.bool of
            0:
                case ~tmp$11#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign llvm and($left#0:multictr.simple, 7:wybe.int, ?tmp$16#0:wybe.int)
                    foreign llvm icmp eq(~tmp$16#0:wybe.int, 1:wybe.int, ?tmp$17#0:wybe.bool)
                    case ~tmp$17#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        foreign lpvm access($left#0:multictr.simple, -1:wybe.int, ?$left$two_field1#0:wybe.int)
                        foreign lpvm access(~$left#0:multictr.simple, 7:wybe.int, ?$left$two_field2#0:wybe.int)
                        foreign llvm icmp ne($right#0:multictr.simple, 0:wybe.int, ?tmp$19#0:wybe.bool)
                        case ~tmp$19#0:wybe.bool of
                        0:
                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                        1:
                            foreign llvm and($right#0:multictr.simple, 7:wybe.int, ?tmp$20#0:wybe.int)
                            foreign llvm icmp eq(~tmp$20#0:wybe.int, 1:wybe.int, ?tmp$21#0:wybe.bool)
                            case ~tmp$21#0:wybe.bool of
                            0:
                                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                            1:
                                foreign lpvm access($right#0:multictr.simple, -1:wybe.int, ?$right$two_field1#0:wybe.int)
                                foreign lpvm access(~$right#0:multictr.simple, 7:wybe.int, ?$right$two_field2#0:wybe.int)
                                foreign llvm icmp eq(~$left$two_field1#0:wybe.int, ~$right$two_field1#0:wybe.int, ?tmp$8#0:wybe.bool) @wybe:nn:nn
                                case ~tmp$8#0:wybe.bool of
                                0:
                                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                1:
                                    foreign llvm icmp eq(~$left$two_field2#0:wybe.int, ~$right$two_field2#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn






            1:
                foreign lpvm access(~$left#0:multictr.simple, 0:wybe.int, ?$left$one_field#0:wybe.int)
                foreign llvm icmp ne($right#0:multictr.simple, 0:wybe.int, ?tmp$15#0:wybe.bool)
                case ~tmp$15#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign llvm and($right#0:multictr.simple, 7:wybe.int, ?tmp$16#0:wybe.int)
                    foreign llvm icmp eq(~tmp$16#0:wybe.int, 0:wybe.int, ?tmp$17#0:wybe.bool)
                    case ~tmp$17#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        foreign lpvm access(~$right#0:multictr.simple, 0:wybe.int, ?$right$one_field#0:wybe.int)
                        foreign llvm icmp eq(~$left$one_field#0:wybe.int, ~$right$one_field#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn





    1:
        foreign llvm icmp eq(~$left#0:multictr.simple, ~$right#0:multictr.simple, ?$$#0:wybe.bool)



one > public inline (0 calls)
0: one(one_field#0:wybe.int, ?$#0:multictr.simple):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:!multictr.simple)
    foreign lpvm mutate(~%$rec#0:multictr.simple, ?%$#0:multictr.simple, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~one_field#0:wybe.int)
one > public inline test (8 calls)
1: one(?one_field#0:wybe.int, $#0:multictr.simple, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($#0:multictr.simple, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($#0:multictr.simple, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$#0:multictr.simple, 0:wybe.int, ?one_field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




one_field > public inline test (0 calls)
0: one_field($rec#0:multictr.simple, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($rec#0:multictr.simple, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($rec#0:multictr.simple, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$rec#0:multictr.simple, 0:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


one_field > public inline test (0 calls)
1: one_field($rec#0:multictr.simple, ?$rec#1:multictr.simple, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($rec#0:multictr.simple, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

    1:
        foreign llvm and($rec#0:multictr.simple, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

        1:
            foreign lpvm mutate noalias(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, 0:wybe.int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




two > public inline (0 calls)
0: two(two_field1#0:wybe.int, two_field2#0:wybe.int, ?$#0:multictr.simple):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?$rec#0:!multictr.simple)
    foreign lpvm mutate(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, ~two_field1#0:wybe.int)
    foreign lpvm mutate(~%$rec#1:multictr.simple, ?%$rec#2:multictr.simple, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, ~two_field2#0:wybe.int)
    foreign llvm or(~$rec#2, 1:wybe.int, ?$#0:multictr.simple)
two > public inline test (7 calls)
1: two(?two_field1#0:wybe.int, ?two_field2#0:wybe.int, $#0:multictr.simple, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($#0:multictr.simple, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($#0:multictr.simple, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access($#0:multictr.simple, -1:wybe.int, ?two_field1#0:wybe.int)
            foreign lpvm access(~$#0:multictr.simple, 7:wybe.int, ?two_field2#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




two_field1 > public inline test (0 calls)
0: two_field1($rec#0:multictr.simple, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($rec#0:multictr.simple, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($rec#0:multictr.simple, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$rec#0:multictr.simple, -1:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


two_field1 > public inline test (0 calls)
1: two_field1($rec#0:multictr.simple, ?$rec#1:multictr.simple, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($rec#0:multictr.simple, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

    1:
        foreign llvm and($rec#0:multictr.simple, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

        1:
            foreign lpvm mutate noalias(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, -1:wybe.int, 0:wybe.int, 16:wybe.int, 1:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




two_field2 > public inline test (0 calls)
0: two_field2($rec#0:multictr.simple, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($rec#0:multictr.simple, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($rec#0:multictr.simple, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$rec#0:multictr.simple, 7:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


two_field2 > public inline test (0 calls)
1: two_field2($rec#0:multictr.simple, ?$rec#1:multictr.simple, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($rec#0:multictr.simple, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

    1:
        foreign llvm and($rec#0:multictr.simple, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

        1:
            foreign lpvm mutate noalias(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, 7:wybe.int, 0:wybe.int, 16:wybe.int, 1:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




zero > public inline (0 calls)
0: zero(?$#0:multictr.simple):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.simple, ?$#0:multictr.simple)

  LLVM code       :

; ModuleID = 'multictr.simple'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.simple./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$1#0" = tail call fastcc  i1  @"multictr.simple.=<0>"(i64  %"$left#0", i64  %"$right#0")  
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  ret i1 0 
if.else:
  ret i1 1 
}


define external fastcc  i1 @"multictr.simple.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$1#0" = icmp eq i64 %"$left#0", 0 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  %"2$$$#0" = icmp eq i64 %"$left#0", %"$right#0" 
  ret i1 %"2$$$#0" 
if.else:
  %"3$tmp$11#0" = icmp ne i64 %"$left#0", 0 
  br i1 %"3$tmp$11#0", label %if.then1, label %if.else1 
if.then1:
  %"4$tmp$12#0" = and i64 %"$left#0", 7 
  %"4$tmp$13#0" = icmp eq i64 %"4$tmp$12#0", 0 
  br i1 %"4$tmp$13#0", label %if.then2, label %if.else2 
if.else1:
  br i1 %"3$tmp$11#0", label %if.then10, label %if.else10 
if.then2:
  %1 = inttoptr i64 %"$left#0" to i64* 
  %2 = getelementptr  i64, i64* %1, i64 0 
  %3 = load  i64, i64* %2 
  %"6$tmp$15#0" = icmp ne i64 %"$right#0", 0 
  br i1 %"6$tmp$15#0", label %if.then3, label %if.else3 
if.else2:
  br i1 %"3$tmp$11#0", label %if.then5, label %if.else5 
if.then3:
  %"8$tmp$16#0" = and i64 %"$right#0", 7 
  %"8$tmp$17#0" = icmp eq i64 %"8$tmp$16#0", 0 
  br i1 %"8$tmp$17#0", label %if.then4, label %if.else4 
if.else3:
  ret i1 0 
if.then4:
  %4 = inttoptr i64 %"$right#0" to i64* 
  %5 = getelementptr  i64, i64* %4, i64 0 
  %6 = load  i64, i64* %5 
  %"10$$$#0" = icmp eq i64 %3, %6 
  ret i1 %"10$$$#0" 
if.else4:
  ret i1 0 
if.then5:
  %"12$tmp$16#0" = and i64 %"$left#0", 7 
  %"12$tmp$17#0" = icmp eq i64 %"12$tmp$16#0", 1 
  br i1 %"12$tmp$17#0", label %if.then6, label %if.else6 
if.else5:
  ret i1 0 
if.then6:
  %7 = add   i64 %"$left#0", -1 
  %8 = inttoptr i64 %7 to i64* 
  %9 = getelementptr  i64, i64* %8, i64 0 
  %10 = load  i64, i64* %9 
  %11 = add   i64 %"$left#0", 7 
  %12 = inttoptr i64 %11 to i64* 
  %13 = getelementptr  i64, i64* %12, i64 0 
  %14 = load  i64, i64* %13 
  %"14$tmp$19#0" = icmp ne i64 %"$right#0", 0 
  br i1 %"14$tmp$19#0", label %if.then7, label %if.else7 
if.else6:
  ret i1 0 
if.then7:
  %"16$tmp$20#0" = and i64 %"$right#0", 7 
  %"16$tmp$21#0" = icmp eq i64 %"16$tmp$20#0", 1 
  br i1 %"16$tmp$21#0", label %if.then8, label %if.else8 
if.else7:
  ret i1 0 
if.then8:
  %15 = add   i64 %"$right#0", -1 
  %16 = inttoptr i64 %15 to i64* 
  %17 = getelementptr  i64, i64* %16, i64 0 
  %18 = load  i64, i64* %17 
  %19 = add   i64 %"$right#0", 7 
  %20 = inttoptr i64 %19 to i64* 
  %21 = getelementptr  i64, i64* %20, i64 0 
  %22 = load  i64, i64* %21 
  %"18$tmp$8#0" = icmp eq i64 %10, %18 
  br i1 %"18$tmp$8#0", label %if.then9, label %if.else9 
if.else8:
  ret i1 0 
if.then9:
  %"20$$$#0" = icmp eq i64 %14, %22 
  ret i1 %"20$$$#0" 
if.else9:
  ret i1 0 
if.then10:
  %"22$tmp$16#0" = and i64 %"$left#0", 7 
  %"22$tmp$17#0" = icmp eq i64 %"22$tmp$16#0", 1 
  br i1 %"22$tmp$17#0", label %if.then11, label %if.else11 
if.else10:
  ret i1 0 
if.then11:
  %23 = add   i64 %"$left#0", -1 
  %24 = inttoptr i64 %23 to i64* 
  %25 = getelementptr  i64, i64* %24, i64 0 
  %26 = load  i64, i64* %25 
  %27 = add   i64 %"$left#0", 7 
  %28 = inttoptr i64 %27 to i64* 
  %29 = getelementptr  i64, i64* %28, i64 0 
  %30 = load  i64, i64* %29 
  %"24$tmp$19#0" = icmp ne i64 %"$right#0", 0 
  br i1 %"24$tmp$19#0", label %if.then12, label %if.else12 
if.else11:
  ret i1 0 
if.then12:
  %"26$tmp$20#0" = and i64 %"$right#0", 7 
  %"26$tmp$21#0" = icmp eq i64 %"26$tmp$20#0", 1 
  br i1 %"26$tmp$21#0", label %if.then13, label %if.else13 
if.else12:
  ret i1 0 
if.then13:
  %31 = add   i64 %"$right#0", -1 
  %32 = inttoptr i64 %31 to i64* 
  %33 = getelementptr  i64, i64* %32, i64 0 
  %34 = load  i64, i64* %33 
  %35 = add   i64 %"$right#0", 7 
  %36 = inttoptr i64 %35 to i64* 
  %37 = getelementptr  i64, i64* %36, i64 0 
  %38 = load  i64, i64* %37 
  %"28$tmp$8#0" = icmp eq i64 %26, %34 
  br i1 %"28$tmp$8#0", label %if.then14, label %if.else14 
if.else13:
  ret i1 0 
if.then14:
  %"30$$$#0" = icmp eq i64 %30, %38 
  ret i1 %"30$$$#0" 
if.else14:
  ret i1 0 
}


define external fastcc  i64 @"multictr.simple.one<0>"(i64  %"one_field#0")    {
entry:
  %39 = trunc i64 8 to i32  
  %40 = tail call ccc  i8*  @wybe_malloc(i32  %39)  
  %41 = ptrtoint i8* %40 to i64 
  %42 = inttoptr i64 %41 to i64* 
  %43 = getelementptr  i64, i64* %42, i64 0 
  store  i64 %"one_field#0", i64* %43 
  ret i64 %41 
}


define external fastcc  {i64, i1} @"multictr.simple.one<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 0 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %51 = insertvalue {i64, i1} undef, i64 undef, 0 
  %52 = insertvalue {i64, i1} %51, i1 0, 1 
  ret {i64, i1} %52 
if.then1:
  %44 = inttoptr i64 %"$#0" to i64* 
  %45 = getelementptr  i64, i64* %44, i64 0 
  %46 = load  i64, i64* %45 
  %47 = insertvalue {i64, i1} undef, i64 %46, 0 
  %48 = insertvalue {i64, i1} %47, i1 1, 1 
  ret {i64, i1} %48 
if.else1:
  %49 = insertvalue {i64, i1} undef, i64 undef, 0 
  %50 = insertvalue {i64, i1} %49, i1 0, 1 
  ret {i64, i1} %50 
}


define external fastcc  {i64, i1} @"multictr.simple.one_field<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 0 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %60 = insertvalue {i64, i1} undef, i64 undef, 0 
  %61 = insertvalue {i64, i1} %60, i1 0, 1 
  ret {i64, i1} %61 
if.then1:
  %53 = inttoptr i64 %"$rec#0" to i64* 
  %54 = getelementptr  i64, i64* %53, i64 0 
  %55 = load  i64, i64* %54 
  %56 = insertvalue {i64, i1} undef, i64 %55, 0 
  %57 = insertvalue {i64, i1} %56, i1 1, 1 
  ret {i64, i1} %57 
if.else1:
  %58 = insertvalue {i64, i1} undef, i64 undef, 0 
  %59 = insertvalue {i64, i1} %58, i1 0, 1 
  ret {i64, i1} %59 
}


define external fastcc  {i64, i1} @"multictr.simple.one_field<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 0 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %74 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %75 = insertvalue {i64, i1} %74, i1 0, 1 
  ret {i64, i1} %75 
if.then1:
  %62 = trunc i64 8 to i32  
  %63 = tail call ccc  i8*  @wybe_malloc(i32  %62)  
  %64 = ptrtoint i8* %63 to i64 
  %65 = inttoptr i64 %64 to i8* 
  %66 = inttoptr i64 %"$rec#0" to i8* 
  %67 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %65, i8*  %66, i32  %67, i32  8, i1  0)  
  %68 = inttoptr i64 %64 to i64* 
  %69 = getelementptr  i64, i64* %68, i64 0 
  store  i64 %"$field#0", i64* %69 
  %70 = insertvalue {i64, i1} undef, i64 %64, 0 
  %71 = insertvalue {i64, i1} %70, i1 1, 1 
  ret {i64, i1} %71 
if.else1:
  %72 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %73 = insertvalue {i64, i1} %72, i1 0, 1 
  ret {i64, i1} %73 
}


define external fastcc  i64 @"multictr.simple.two<0>"(i64  %"two_field1#0", i64  %"two_field2#0")    {
entry:
  %76 = trunc i64 16 to i32  
  %77 = tail call ccc  i8*  @wybe_malloc(i32  %76)  
  %78 = ptrtoint i8* %77 to i64 
  %79 = inttoptr i64 %78 to i64* 
  %80 = getelementptr  i64, i64* %79, i64 0 
  store  i64 %"two_field1#0", i64* %80 
  %81 = add   i64 %78, 8 
  %82 = inttoptr i64 %81 to i64* 
  %83 = getelementptr  i64, i64* %82, i64 0 
  store  i64 %"two_field2#0", i64* %83 
  %"1$$#0" = or i64 %78, 1 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i64, i1} @"multictr.simple.two<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 1 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %98 = insertvalue {i64, i64, i1} undef, i64 undef, 0 
  %99 = insertvalue {i64, i64, i1} %98, i64 undef, 1 
  %100 = insertvalue {i64, i64, i1} %99, i1 0, 2 
  ret {i64, i64, i1} %100 
if.then1:
  %84 = add   i64 %"$#0", -1 
  %85 = inttoptr i64 %84 to i64* 
  %86 = getelementptr  i64, i64* %85, i64 0 
  %87 = load  i64, i64* %86 
  %88 = add   i64 %"$#0", 7 
  %89 = inttoptr i64 %88 to i64* 
  %90 = getelementptr  i64, i64* %89, i64 0 
  %91 = load  i64, i64* %90 
  %92 = insertvalue {i64, i64, i1} undef, i64 %87, 0 
  %93 = insertvalue {i64, i64, i1} %92, i64 %91, 1 
  %94 = insertvalue {i64, i64, i1} %93, i1 1, 2 
  ret {i64, i64, i1} %94 
if.else1:
  %95 = insertvalue {i64, i64, i1} undef, i64 undef, 0 
  %96 = insertvalue {i64, i64, i1} %95, i64 undef, 1 
  %97 = insertvalue {i64, i64, i1} %96, i1 0, 2 
  ret {i64, i64, i1} %97 
}


define external fastcc  {i64, i1} @"multictr.simple.two_field1<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 1 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %109 = insertvalue {i64, i1} undef, i64 undef, 0 
  %110 = insertvalue {i64, i1} %109, i1 0, 1 
  ret {i64, i1} %110 
if.then1:
  %101 = add   i64 %"$rec#0", -1 
  %102 = inttoptr i64 %101 to i64* 
  %103 = getelementptr  i64, i64* %102, i64 0 
  %104 = load  i64, i64* %103 
  %105 = insertvalue {i64, i1} undef, i64 %104, 0 
  %106 = insertvalue {i64, i1} %105, i1 1, 1 
  ret {i64, i1} %106 
if.else1:
  %107 = insertvalue {i64, i1} undef, i64 undef, 0 
  %108 = insertvalue {i64, i1} %107, i1 0, 1 
  ret {i64, i1} %108 
}


define external fastcc  {i64, i1} @"multictr.simple.two_field1<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 1 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %125 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %126 = insertvalue {i64, i1} %125, i1 0, 1 
  ret {i64, i1} %126 
if.then1:
  %111 = trunc i64 16 to i32  
  %112 = tail call ccc  i8*  @wybe_malloc(i32  %111)  
  %113 = ptrtoint i8* %112 to i64 
  %114 = sub   i64 %"$rec#0", 1 
  %115 = inttoptr i64 %113 to i8* 
  %116 = inttoptr i64 %114 to i8* 
  %117 = trunc i64 16 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %115, i8*  %116, i32  %117, i32  8, i1  0)  
  %118 = add   i64 %113, -1 
  %119 = inttoptr i64 %118 to i64* 
  %120 = getelementptr  i64, i64* %119, i64 0 
  store  i64 %"$field#0", i64* %120 
  %121 = insertvalue {i64, i1} undef, i64 %113, 0 
  %122 = insertvalue {i64, i1} %121, i1 1, 1 
  ret {i64, i1} %122 
if.else1:
  %123 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %124 = insertvalue {i64, i1} %123, i1 0, 1 
  ret {i64, i1} %124 
}


define external fastcc  {i64, i1} @"multictr.simple.two_field2<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 1 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %135 = insertvalue {i64, i1} undef, i64 undef, 0 
  %136 = insertvalue {i64, i1} %135, i1 0, 1 
  ret {i64, i1} %136 
if.then1:
  %127 = add   i64 %"$rec#0", 7 
  %128 = inttoptr i64 %127 to i64* 
  %129 = getelementptr  i64, i64* %128, i64 0 
  %130 = load  i64, i64* %129 
  %131 = insertvalue {i64, i1} undef, i64 %130, 0 
  %132 = insertvalue {i64, i1} %131, i1 1, 1 
  ret {i64, i1} %132 
if.else1:
  %133 = insertvalue {i64, i1} undef, i64 undef, 0 
  %134 = insertvalue {i64, i1} %133, i1 0, 1 
  ret {i64, i1} %134 
}


define external fastcc  {i64, i1} @"multictr.simple.two_field2<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 1 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %151 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %152 = insertvalue {i64, i1} %151, i1 0, 1 
  ret {i64, i1} %152 
if.then1:
  %137 = trunc i64 16 to i32  
  %138 = tail call ccc  i8*  @wybe_malloc(i32  %137)  
  %139 = ptrtoint i8* %138 to i64 
  %140 = sub   i64 %"$rec#0", 1 
  %141 = inttoptr i64 %139 to i8* 
  %142 = inttoptr i64 %140 to i8* 
  %143 = trunc i64 16 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %141, i8*  %142, i32  %143, i32  8, i1  0)  
  %144 = add   i64 %139, 7 
  %145 = inttoptr i64 %144 to i64* 
  %146 = getelementptr  i64, i64* %145, i64 0 
  store  i64 %"$field#0", i64* %146 
  %147 = insertvalue {i64, i1} undef, i64 %139, 0 
  %148 = insertvalue {i64, i1} %147, i1 1, 1 
  ret {i64, i1} %148 
if.else1:
  %149 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %150 = insertvalue {i64, i1} %149, i1 0, 1 
  ret {i64, i1} %150 
}


define external fastcc  i64 @"multictr.simple.zero<0>"()    {
entry:
  ret i64 0 
}
--------------------------------------------------
 Module multictr.suit
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.suit./=<0>
                    multictr.suit.=<0>
                    multictr.suit.clubs<0>
                    multictr.suit.diamonds<0>
                    multictr.suit.hearts<0>
                    multictr.suit.spades<0>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline test (0 calls)
0: /=($left#0:multictr.suit, $right#0:multictr.suit, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.suit, ~$right#0:multictr.suit, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)



= > public inline test (3 calls)
0: =($left#0:multictr.suit, $right#0:multictr.suit, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.suit, ~$right#0:multictr.suit, ?$$#0:wybe.bool)


clubs > public inline (0 calls)
0: clubs(?$#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.suit, ?$#0:multictr.suit)


diamonds > public inline (0 calls)
0: diamonds(?$#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(1:multictr.suit, ?$#0:multictr.suit)


hearts > public inline (0 calls)
0: hearts(?$#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(2:multictr.suit, ?$#0:multictr.suit)


spades > public inline (0 calls)
0: spades(?$#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(3:multictr.suit, ?$#0:multictr.suit)

  LLVM code       :

; ModuleID = 'multictr.suit'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.suit./=<0>"(i2  %"$left#0", i2  %"$right#0")    {
entry:
  %"1$tmp$1#0" = icmp eq i2 %"$left#0", %"$right#0" 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  ret i1 0 
if.else:
  ret i1 1 
}


define external fastcc  i1 @"multictr.suit.=<0>"(i2  %"$left#0", i2  %"$right#0")    {
entry:
  %"1$$$#0" = icmp eq i2 %"$left#0", %"$right#0" 
  ret i1 %"1$$$#0" 
}


define external fastcc  i2 @"multictr.suit.clubs<0>"()    {
entry:
  ret i2 0 
}


define external fastcc  i2 @"multictr.suit.diamonds<0>"()    {
entry:
  ret i2 1 
}


define external fastcc  i2 @"multictr.suit.hearts<0>"()    {
entry:
  ret i2 2 
}


define external fastcc  i2 @"multictr.suit.spades<0>"()    {
entry:
  ret i2 3 
}
--------------------------------------------------
 Module multictr.unit
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.unit./=<0>
                    multictr.unit.=<0>
                    multictr.unit.unit<0>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline test (0 calls)
0: /=([$left#0:multictr.unit], [$right#0:multictr.unit], ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)


= > public inline test (3 calls)
0: =([$left#0:multictr.unit], [$right#0:multictr.unit], ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


unit > public inline (0 calls)
0: unit(?$#0:multictr.unit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.unit, ?$#0:multictr.unit)

  LLVM code       :

; ModuleID = 'multictr.unit'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.unit./=<0>"()    {
entry:
  ret i1 0 
}


define external fastcc  i1 @"multictr.unit.=<0>"()    {
entry:
  ret i1 1 
}


define external fastcc  void @"multictr.unit.unit<0>"()    {
entry:
  ret void 
}
