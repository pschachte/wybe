======================================================================
AFTER EVERYTHING:
 Module multictr
  representation  : (not a type)
  public submods  : card -> multictr.card
                    complicated -> multictr.complicated
                    length -> multictr.length
                    maybe_int -> multictr.maybe_int
                    number -> multictr.number
                    perhaps -> multictr.perhaps
                    rank -> multictr.rank
                    simple -> multictr.simple
                    suit -> multictr.suit
                    unit -> multictr.unit
  public resources: 
  public procs    : multictr.card./=<0>
                    multictr.card.=<0>
                    multictr.card.card<0>
                    multictr.card.card<1>
                    multictr.card.rank<0>
                    multictr.card.rank<1>
                    multictr.card.suit<0>
                    multictr.card.suit<1>
                    multictr.complicated./=<0>
                    multictr.complicated.=<0>
                    multictr.complicated.autumn<0>
                    multictr.complicated.c01<0>
                    multictr.complicated.c01<1>
                    multictr.complicated.c02<0>
                    multictr.complicated.c02<1>
                    multictr.complicated.c03<0>
                    multictr.complicated.c03<1>
                    multictr.complicated.c04<0>
                    multictr.complicated.c04<1>
                    multictr.complicated.c05<0>
                    multictr.complicated.c05<1>
                    multictr.complicated.c06<0>
                    multictr.complicated.c06<1>
                    multictr.complicated.c07<0>
                    multictr.complicated.c07<1>
                    multictr.complicated.c08<0>
                    multictr.complicated.c08<1>
                    multictr.complicated.c09<0>
                    multictr.complicated.c09<1>
                    multictr.complicated.c10<0>
                    multictr.complicated.c10<1>
                    multictr.complicated.c11<0>
                    multictr.complicated.c11<1>
                    multictr.complicated.c12<0>
                    multictr.complicated.c12<1>
                    multictr.complicated.c13<0>
                    multictr.complicated.c13<1>
                    multictr.complicated.c14<0>
                    multictr.complicated.c14<1>
                    multictr.complicated.c15<0>
                    multictr.complicated.c15<1>
                    multictr.complicated.c16<0>
                    multictr.complicated.c16<1>
                    multictr.complicated.c17<0>
                    multictr.complicated.c17<1>
                    multictr.complicated.f01<0>
                    multictr.complicated.f01<1>
                    multictr.complicated.f02<0>
                    multictr.complicated.f02<1>
                    multictr.complicated.f03<0>
                    multictr.complicated.f03<1>
                    multictr.complicated.f04<0>
                    multictr.complicated.f04<1>
                    multictr.complicated.f05<0>
                    multictr.complicated.f05<1>
                    multictr.complicated.f06<0>
                    multictr.complicated.f06<1>
                    multictr.complicated.f07<0>
                    multictr.complicated.f07<1>
                    multictr.complicated.f08<0>
                    multictr.complicated.f08<1>
                    multictr.complicated.f09<0>
                    multictr.complicated.f09<1>
                    multictr.complicated.f10<0>
                    multictr.complicated.f10<1>
                    multictr.complicated.f11<0>
                    multictr.complicated.f11<1>
                    multictr.complicated.f12<0>
                    multictr.complicated.f12<1>
                    multictr.complicated.f13<0>
                    multictr.complicated.f13<1>
                    multictr.complicated.f14<0>
                    multictr.complicated.f14<1>
                    multictr.complicated.f15<0>
                    multictr.complicated.f15<1>
                    multictr.complicated.f16<0>
                    multictr.complicated.f16<1>
                    multictr.complicated.f17<0>
                    multictr.complicated.f17<1>
                    multictr.complicated.spring<0>
                    multictr.complicated.summer<0>
                    multictr.complicated.winter<0>
                    multictr.length./=<0>
                    multictr.length.=<0>
                    multictr.length.metres<0>
                    multictr.length.metres<1>
                    multictr.length.value<0>
                    multictr.length.value<1>
                    multictr.maybe_int./=<0>
                    multictr.maybe_int.=<0>
                    multictr.maybe_int.just<0>
                    multictr.maybe_int.just<1>
                    multictr.maybe_int.nothing<0>
                    multictr.maybe_int.value<0>
                    multictr.maybe_int.value<1>
                    multictr.number./=<0>
                    multictr.number.=<0>
                    multictr.number.float<0>
                    multictr.number.float<1>
                    multictr.number.float_value<0>
                    multictr.number.float_value<1>
                    multictr.number.int<0>
                    multictr.number.int<1>
                    multictr.number.int_value<0>
                    multictr.number.int_value<1>
                    multictr.perhaps./=<0>
                    multictr.perhaps.=<0>
                    multictr.perhaps.content<0>
                    multictr.perhaps.content<1>
                    multictr.perhaps.perhaps<0>
                    multictr.perhaps.perhaps<1>
                    multictr.rank./=<0>
                    multictr.rank.=<0>
                    multictr.rank.ace<0>
                    multictr.rank.jack<0>
                    multictr.rank.king<0>
                    multictr.rank.queen<0>
                    multictr.rank.r10<0>
                    multictr.rank.r2<0>
                    multictr.rank.r3<0>
                    multictr.rank.r4<0>
                    multictr.rank.r5<0>
                    multictr.rank.r6<0>
                    multictr.rank.r7<0>
                    multictr.rank.r8<0>
                    multictr.rank.r9<0>
                    multictr.simple./=<0>
                    multictr.simple.=<0>
                    multictr.simple.one<0>
                    multictr.simple.one<1>
                    multictr.simple.one_field<0>
                    multictr.simple.one_field<1>
                    multictr.simple.two<0>
                    multictr.simple.two<1>
                    multictr.simple.two_field1<0>
                    multictr.simple.two_field1<1>
                    multictr.simple.two_field2<0>
                    multictr.simple.two_field2<1>
                    multictr.simple.zero<0>
                    multictr.suit./=<0>
                    multictr.suit.=<0>
                    multictr.suit.clubs<0>
                    multictr.suit.diamonds<0>
                    multictr.suit.hearts<0>
                    multictr.suit.spades<0>
                    multictr.unit./=<0>
                    multictr.unit.=<0>
                    multictr.unit.unit<0>
  imports         : public use multictr.card
                    public use multictr.complicated
                    public use multictr.length
                    public use multictr.maybe_int
                    public use multictr.number
                    public use multictr.perhaps
                    public use multictr.rank
                    public use multictr.simple
                    public use multictr.suit
                    public use multictr.unit
                    use wybe
  resources       : 
  submodules      : multictr.card, multictr.complicated, multictr.length, multictr.maybe_int, multictr.number, multictr.perhaps, multictr.rank, multictr.simple, multictr.suit, multictr.unit
  procs           : 


  LLVM code       :

; ModuleID = 'multictr'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    
--------------------------------------------------
 Module multictr.card
  representation  : 6 bit unsigned
  public submods  : 
  public resources: 
  public procs    : multictr.card./=<0>
                    multictr.card.=<0>
                    multictr.card.card<0>
                    multictr.card.card<1>
                    multictr.card.rank<0>
                    multictr.card.rank<1>
                    multictr.card.suit<0>
                    multictr.card.suit<1>
  imports         : use multictr
                    use wybe
  resources       : 
  procs           : 

/= > public {inline} (0 calls)
0: multictr.card./=<0>
/=($left#0:multictr.card, $right#0:multictr.card, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_eq(~$left#0:multictr.card, ~$right#0:multictr.card, ?tmp$0#0:wybe.bool)
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public {inline} (1 calls)
0: multictr.card.=<0>
=($left#0:multictr.card, $right#0:multictr.card, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_eq(~$left#0:multictr.card, ~$right#0:multictr.card, ?$$#0:!wybe.bool)


card > public {inline} (0 calls)
0: multictr.card.card<0>
card(suit#0:multictr.suit, rank#0:multictr.rank, ?$#3:multictr.card):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm shl(~rank#0:!multictr.card, 2:multictr.card, ?$temp#1:multictr.card)
    foreign llvm or(~$temp#1:multictr.card, ~suit#0:!multictr.card, ?$#3:multictr.card)
card > public {inline} (0 calls)
1: multictr.card.card<1>
card(?suit#0:multictr.suit, ?rank#0:multictr.rank, $#0:multictr.card):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($#0:multictr.card, 3:multictr.card, ?$temp2#0:multictr.card)
    foreign lpvm cast(~$temp2#0:multictr.card, ?suit#0:multictr.suit)
    foreign llvm lshr(~$#0:multictr.card, 2:multictr.card, ?$temp#1:multictr.card)
    foreign llvm and(~$temp#1:multictr.card, 15:multictr.card, ?$temp2#1:multictr.card)
    foreign lpvm cast(~$temp2#1:multictr.card, ?rank#0:multictr.rank)


rank > public {inline} (0 calls)
0: multictr.card.rank<0>
rank($rec#0:multictr.card, ?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm lshr(~$rec#0:multictr.card, 2:multictr.card, ?$rec#1:multictr.card)
    foreign llvm and(~$rec#1:multictr.card, 15:multictr.card, ?$field#0:multictr.card)
    foreign lpvm cast(~$field#0:multictr.card, ?$#0:multictr.rank)
rank > public {inline} (0 calls)
1: multictr.card.rank<1>
rank($rec#0:multictr.card, ?$rec#2:multictr.card, $field#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and(~$rec#0:multictr.card, -61:multictr.card, ?$rec#1:multictr.card)
    foreign llvm shl(~$field#0:!multictr.card, 2:multictr.card, ?$tmp#0:multictr.card)
    foreign llvm or(~$rec#1:multictr.card, ~$tmp#0:multictr.card, ?$rec#2:multictr.card)


suit > public {inline} (0 calls)
0: multictr.card.suit<0>
suit($rec#0:multictr.card, ?$#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and(~$rec#0:multictr.card, 3:multictr.card, ?$field#0:multictr.card)
    foreign lpvm cast(~$field#0:multictr.card, ?$#0:multictr.suit)
suit > public {inline} (0 calls)
1: multictr.card.suit<1>
suit($rec#0:multictr.card, ?$rec#2:multictr.card, $field#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and(~$rec#0:multictr.card, -4:multictr.card, ?$rec#1:multictr.card)
    foreign llvm or(~$field#0:!multictr.card, ~$rec#1:multictr.card, ?$rec#2:multictr.card)

  LLVM code       :

; ModuleID = 'multictr.card'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.card./=<0>"(i6  %"$left#0", i6  %"$right#0")    {
entry:
  %"1$tmp$0#0" = icmp eq i6 %"$left#0", %"$right#0" 
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.card.=<0>"(i6  %"$left#0", i6  %"$right#0")    {
entry:
  %"1$$$#0" = icmp eq i6 %"$left#0", %"$right#0" 
  ret i1 %"1$$$#0" 
}


define external fastcc  i6 @"multictr.card.card<0>"(i2  %"suit#0", i4  %"rank#0")    {
entry:
  %1 = zext i4 %"rank#0" to i6  
  %"1$$temp#1" = shl   i6 %1, 2 
  %2 = zext i2 %"suit#0" to i6  
  %"1$$#3" = or i6 %"1$$temp#1", %2 
  ret i6 %"1$$#3" 
}


define external fastcc  {i2, i4} @"multictr.card.card<1>"(i6  %"$#0")    {
entry:
  %"1$$temp2#0" = and i6 %"$#0", 3 
  %3 = trunc i6 %"1$$temp2#0" to i2  
  %"1$$temp#1" = lshr  i6 %"$#0", 2 
  %"1$$temp2#1" = and i6 %"1$$temp#1", 15 
  %4 = trunc i6 %"1$$temp2#1" to i4  
  %5 = insertvalue {i2, i4} undef, i2 %3, 0 
  %6 = insertvalue {i2, i4} %5, i4 %4, 1 
  ret {i2, i4} %6 
}


define external fastcc  i4 @"multictr.card.rank<0>"(i6  %"$rec#0")    {
entry:
  %"1$$rec#1" = lshr  i6 %"$rec#0", 2 
  %"1$$field#0" = and i6 %"1$$rec#1", 15 
  %7 = trunc i6 %"1$$field#0" to i4  
  ret i4 %7 
}


define external fastcc  i6 @"multictr.card.rank<1>"(i6  %"$rec#0", i4  %"$field#0")    {
entry:
  %"1$$rec#1" = and i6 %"$rec#0", -61 
  %8 = zext i4 %"$field#0" to i6  
  %"1$$tmp#0" = shl   i6 %8, 2 
  %"1$$rec#2" = or i6 %"1$$rec#1", %"1$$tmp#0" 
  ret i6 %"1$$rec#2" 
}


define external fastcc  i2 @"multictr.card.suit<0>"(i6  %"$rec#0")    {
entry:
  %"1$$field#0" = and i6 %"$rec#0", 3 
  %9 = trunc i6 %"1$$field#0" to i2  
  ret i2 %9 
}


define external fastcc  i6 @"multictr.card.suit<1>"(i6  %"$rec#0", i2  %"$field#0")    {
entry:
  %"1$$rec#1" = and i6 %"$rec#0", -4 
  %10 = zext i2 %"$field#0" to i6  
  %"1$$rec#2" = or i6 %10, %"1$$rec#1" 
  ret i6 %"1$$rec#2" 
}
--------------------------------------------------
 Module multictr.complicated
  representation  : address
  public submods  : 
  public resources: 
  public procs    : multictr.complicated./=<0>
                    multictr.complicated.=<0>
                    multictr.complicated.autumn<0>
                    multictr.complicated.c01<0>
                    multictr.complicated.c01<1>
                    multictr.complicated.c02<0>
                    multictr.complicated.c02<1>
                    multictr.complicated.c03<0>
                    multictr.complicated.c03<1>
                    multictr.complicated.c04<0>
                    multictr.complicated.c04<1>
                    multictr.complicated.c05<0>
                    multictr.complicated.c05<1>
                    multictr.complicated.c06<0>
                    multictr.complicated.c06<1>
                    multictr.complicated.c07<0>
                    multictr.complicated.c07<1>
                    multictr.complicated.c08<0>
                    multictr.complicated.c08<1>
                    multictr.complicated.c09<0>
                    multictr.complicated.c09<1>
                    multictr.complicated.c10<0>
                    multictr.complicated.c10<1>
                    multictr.complicated.c11<0>
                    multictr.complicated.c11<1>
                    multictr.complicated.c12<0>
                    multictr.complicated.c12<1>
                    multictr.complicated.c13<0>
                    multictr.complicated.c13<1>
                    multictr.complicated.c14<0>
                    multictr.complicated.c14<1>
                    multictr.complicated.c15<0>
                    multictr.complicated.c15<1>
                    multictr.complicated.c16<0>
                    multictr.complicated.c16<1>
                    multictr.complicated.c17<0>
                    multictr.complicated.c17<1>
                    multictr.complicated.f01<0>
                    multictr.complicated.f01<1>
                    multictr.complicated.f02<0>
                    multictr.complicated.f02<1>
                    multictr.complicated.f03<0>
                    multictr.complicated.f03<1>
                    multictr.complicated.f04<0>
                    multictr.complicated.f04<1>
                    multictr.complicated.f05<0>
                    multictr.complicated.f05<1>
                    multictr.complicated.f06<0>
                    multictr.complicated.f06<1>
                    multictr.complicated.f07<0>
                    multictr.complicated.f07<1>
                    multictr.complicated.f08<0>
                    multictr.complicated.f08<1>
                    multictr.complicated.f09<0>
                    multictr.complicated.f09<1>
                    multictr.complicated.f10<0>
                    multictr.complicated.f10<1>
                    multictr.complicated.f11<0>
                    multictr.complicated.f11<1>
                    multictr.complicated.f12<0>
                    multictr.complicated.f12<1>
                    multictr.complicated.f13<0>
                    multictr.complicated.f13<1>
                    multictr.complicated.f14<0>
                    multictr.complicated.f14<1>
                    multictr.complicated.f15<0>
                    multictr.complicated.f15<1>
                    multictr.complicated.f16<0>
                    multictr.complicated.f16<1>
                    multictr.complicated.f17<0>
                    multictr.complicated.f17<1>
                    multictr.complicated.spring<0>
                    multictr.complicated.summer<0>
                    multictr.complicated.winter<0>
  imports         : use multictr
                    use wybe
  resources       : 
  procs           : 

/= > public {inline} (0 calls)
0: multictr.complicated./=<0>
/=($left#0:multictr.complicated, $right#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    multictr.complicated.=<0>(~$left#0:multictr.complicated, ~$right#0:multictr.complicated, ?tmp$0#0:wybe.bool) #0
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public (1 calls)
0: multictr.complicated.=<0>
=($left#0:multictr.complicated, $right#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($left#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm icmp_eq(~$left#0:multictr.complicated, ~$right#0:multictr.complicated, ?$$#0:!wybe.bool)

    1:
        foreign llvm and($left#0:multictr.complicated, 7:wybe.int, ?tmp$55#0:wybe.int)
        foreign llvm icmp_eq(tmp$55#0:wybe.int, 0:wybe.int, ?tmp$56#0:wybe.bool)
        case ~tmp$56#0:wybe.bool of
        0:
            foreign llvm icmp_eq(tmp$55#0:wybe.int, 1:wybe.int, ?tmp$60#0:wybe.bool)
            case ~tmp$60#0:wybe.bool of
            0:
                foreign llvm icmp_eq(tmp$55#0:wybe.int, 2:wybe.int, ?tmp$64#0:wybe.bool)
                case ~tmp$64#0:wybe.bool of
                0:
                    foreign llvm icmp_eq(tmp$55#0:wybe.int, 3:wybe.int, ?tmp$68#0:wybe.bool)
                    case ~tmp$68#0:wybe.bool of
                    0:
                        foreign llvm icmp_eq(tmp$55#0:wybe.int, 4:wybe.int, ?tmp$72#0:wybe.bool)
                        case ~tmp$72#0:wybe.bool of
                        0:
                            foreign llvm icmp_eq(tmp$55#0:wybe.int, 5:wybe.int, ?tmp$76#0:wybe.bool)
                            case ~tmp$76#0:wybe.bool of
                            0:
                                foreign llvm icmp_eq(tmp$55#0:wybe.int, 6:wybe.int, ?tmp$80#0:wybe.bool)
                                case ~tmp$80#0:wybe.bool of
                                0:
                                    foreign llvm icmp_eq(~tmp$55#0:wybe.int, 7:wybe.int, ?tmp$84#0:wybe.bool)
                                    case ~tmp$84#0:wybe.bool of
                                    0:
                                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                    1:
                                        foreign lpvm access($left#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?tmp$85#0:16 bit unsigned)
                                        foreign llvm icmp_eq(tmp$85#0:16 bit unsigned, 7:16 bit unsigned, ?tmp$86#0:wybe.bool)
                                        case ~tmp$86#0:wybe.bool of
                                        0:
                                            foreign llvm icmp_eq(tmp$85#0:16 bit unsigned, 8:16 bit unsigned, ?tmp$92#0:wybe.bool)
                                            case ~tmp$92#0:wybe.bool of
                                            0:
                                                foreign llvm icmp_eq(tmp$85#0:16 bit unsigned, 9:16 bit unsigned, ?tmp$98#0:wybe.bool)
                                                case ~tmp$98#0:wybe.bool of
                                                0:
                                                    foreign llvm icmp_eq(tmp$85#0:16 bit unsigned, 10:16 bit unsigned, ?tmp$104#0:wybe.bool)
                                                    case ~tmp$104#0:wybe.bool of
                                                    0:
                                                        foreign llvm icmp_eq(tmp$85#0:16 bit unsigned, 11:16 bit unsigned, ?tmp$110#0:wybe.bool)
                                                        case ~tmp$110#0:wybe.bool of
                                                        0:
                                                            foreign llvm icmp_eq(tmp$85#0:16 bit unsigned, 12:16 bit unsigned, ?tmp$116#0:wybe.bool)
                                                            case ~tmp$116#0:wybe.bool of
                                                            0:
                                                                foreign llvm icmp_eq(tmp$85#0:16 bit unsigned, 13:16 bit unsigned, ?tmp$122#0:wybe.bool)
                                                                case ~tmp$122#0:wybe.bool of
                                                                0:
                                                                    foreign llvm icmp_eq(tmp$85#0:16 bit unsigned, 14:16 bit unsigned, ?tmp$128#0:wybe.bool)
                                                                    case ~tmp$128#0:wybe.bool of
                                                                    0:
                                                                        foreign llvm icmp_eq(tmp$85#0:16 bit unsigned, 15:16 bit unsigned, ?tmp$134#0:wybe.bool)
                                                                        case ~tmp$134#0:wybe.bool of
                                                                        0:
                                                                            foreign llvm icmp_eq(~tmp$85#0:16 bit unsigned, 16:16 bit unsigned, ?tmp$140#0:wybe.bool)
                                                                            case ~tmp$140#0:wybe.bool of
                                                                            0:
                                                                                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                            1:
                                                                                foreign lpvm access(~$left#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$left$f17#0:wybe.int)
                                                                                foreign llvm icmp_uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$142#0:wybe.bool)
                                                                                case ~tmp$142#0:wybe.bool of
                                                                                0:
                                                                                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                                1:
                                                                                    foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$143#0:wybe.int)
                                                                                    foreign llvm icmp_eq(~tmp$143#0:wybe.int, 7:wybe.int, ?tmp$144#0:wybe.bool)
                                                                                    case ~tmp$144#0:wybe.bool of
                                                                                    0:
                                                                                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                                    1:
                                                                                        foreign lpvm access($right#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?tmp$145#0:16 bit unsigned)
                                                                                        foreign llvm icmp_eq(~tmp$145#0:16 bit unsigned, 16:16 bit unsigned, ?tmp$146#0:wybe.bool)
                                                                                        case ~tmp$146#0:wybe.bool of
                                                                                        0:
                                                                                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                                        1:
                                                                                            foreign lpvm access(~$right#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$right$f17#0:wybe.int)
                                                                                            foreign llvm icmp_eq(~$left$f17#0:wybe.int, ~$right$f17#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn





                                                                        1:
                                                                            foreign lpvm access(~$left#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$left$f16#0:wybe.int)
                                                                            foreign llvm icmp_uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$136#0:wybe.bool)
                                                                            case ~tmp$136#0:wybe.bool of
                                                                            0:
                                                                                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                            1:
                                                                                foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$137#0:wybe.int)
                                                                                foreign llvm icmp_eq(~tmp$137#0:wybe.int, 7:wybe.int, ?tmp$138#0:wybe.bool)
                                                                                case ~tmp$138#0:wybe.bool of
                                                                                0:
                                                                                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                                1:
                                                                                    foreign lpvm access($right#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?tmp$139#0:16 bit unsigned)
                                                                                    foreign llvm icmp_eq(~tmp$139#0:16 bit unsigned, 15:16 bit unsigned, ?tmp$140#0:wybe.bool)
                                                                                    case ~tmp$140#0:wybe.bool of
                                                                                    0:
                                                                                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                                    1:
                                                                                        foreign lpvm access(~$right#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$right$f16#0:wybe.int)
                                                                                        foreign llvm icmp_eq(~$left$f16#0:wybe.int, ~$right$f16#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn





                                                                    1:
                                                                        foreign lpvm access(~$left#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$left$f15#0:wybe.int)
                                                                        foreign llvm icmp_uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$130#0:wybe.bool)
                                                                        case ~tmp$130#0:wybe.bool of
                                                                        0:
                                                                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                        1:
                                                                            foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$131#0:wybe.int)
                                                                            foreign llvm icmp_eq(~tmp$131#0:wybe.int, 7:wybe.int, ?tmp$132#0:wybe.bool)
                                                                            case ~tmp$132#0:wybe.bool of
                                                                            0:
                                                                                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                            1:
                                                                                foreign lpvm access($right#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?tmp$133#0:16 bit unsigned)
                                                                                foreign llvm icmp_eq(~tmp$133#0:16 bit unsigned, 14:16 bit unsigned, ?tmp$134#0:wybe.bool)
                                                                                case ~tmp$134#0:wybe.bool of
                                                                                0:
                                                                                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                                1:
                                                                                    foreign lpvm access(~$right#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$right$f15#0:wybe.int)
                                                                                    foreign llvm icmp_eq(~$left$f15#0:wybe.int, ~$right$f15#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn





                                                                1:
                                                                    foreign lpvm access(~$left#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$left$f14#0:wybe.int)
                                                                    foreign llvm icmp_uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$124#0:wybe.bool)
                                                                    case ~tmp$124#0:wybe.bool of
                                                                    0:
                                                                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                    1:
                                                                        foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$125#0:wybe.int)
                                                                        foreign llvm icmp_eq(~tmp$125#0:wybe.int, 7:wybe.int, ?tmp$126#0:wybe.bool)
                                                                        case ~tmp$126#0:wybe.bool of
                                                                        0:
                                                                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                        1:
                                                                            foreign lpvm access($right#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?tmp$127#0:16 bit unsigned)
                                                                            foreign llvm icmp_eq(~tmp$127#0:16 bit unsigned, 13:16 bit unsigned, ?tmp$128#0:wybe.bool)
                                                                            case ~tmp$128#0:wybe.bool of
                                                                            0:
                                                                                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                            1:
                                                                                foreign lpvm access(~$right#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$right$f14#0:wybe.int)
                                                                                foreign llvm icmp_eq(~$left$f14#0:wybe.int, ~$right$f14#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn





                                                            1:
                                                                foreign lpvm access(~$left#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$left$f13#0:wybe.int)
                                                                foreign llvm icmp_uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$118#0:wybe.bool)
                                                                case ~tmp$118#0:wybe.bool of
                                                                0:
                                                                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                1:
                                                                    foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$119#0:wybe.int)
                                                                    foreign llvm icmp_eq(~tmp$119#0:wybe.int, 7:wybe.int, ?tmp$120#0:wybe.bool)
                                                                    case ~tmp$120#0:wybe.bool of
                                                                    0:
                                                                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                    1:
                                                                        foreign lpvm access($right#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?tmp$121#0:16 bit unsigned)
                                                                        foreign llvm icmp_eq(~tmp$121#0:16 bit unsigned, 12:16 bit unsigned, ?tmp$122#0:wybe.bool)
                                                                        case ~tmp$122#0:wybe.bool of
                                                                        0:
                                                                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                        1:
                                                                            foreign lpvm access(~$right#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$right$f13#0:wybe.int)
                                                                            foreign llvm icmp_eq(~$left$f13#0:wybe.int, ~$right$f13#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn





                                                        1:
                                                            foreign lpvm access(~$left#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$left$f12#0:wybe.int)
                                                            foreign llvm icmp_uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$112#0:wybe.bool)
                                                            case ~tmp$112#0:wybe.bool of
                                                            0:
                                                                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                            1:
                                                                foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$113#0:wybe.int)
                                                                foreign llvm icmp_eq(~tmp$113#0:wybe.int, 7:wybe.int, ?tmp$114#0:wybe.bool)
                                                                case ~tmp$114#0:wybe.bool of
                                                                0:
                                                                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                1:
                                                                    foreign lpvm access($right#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?tmp$115#0:16 bit unsigned)
                                                                    foreign llvm icmp_eq(~tmp$115#0:16 bit unsigned, 11:16 bit unsigned, ?tmp$116#0:wybe.bool)
                                                                    case ~tmp$116#0:wybe.bool of
                                                                    0:
                                                                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                    1:
                                                                        foreign lpvm access(~$right#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$right$f12#0:wybe.int)
                                                                        foreign llvm icmp_eq(~$left$f12#0:wybe.int, ~$right$f12#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn





                                                    1:
                                                        foreign lpvm access(~$left#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$left$f11#0:wybe.int)
                                                        foreign llvm icmp_uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$106#0:wybe.bool)
                                                        case ~tmp$106#0:wybe.bool of
                                                        0:
                                                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                        1:
                                                            foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$107#0:wybe.int)
                                                            foreign llvm icmp_eq(~tmp$107#0:wybe.int, 7:wybe.int, ?tmp$108#0:wybe.bool)
                                                            case ~tmp$108#0:wybe.bool of
                                                            0:
                                                                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                            1:
                                                                foreign lpvm access($right#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?tmp$109#0:16 bit unsigned)
                                                                foreign llvm icmp_eq(~tmp$109#0:16 bit unsigned, 10:16 bit unsigned, ?tmp$110#0:wybe.bool)
                                                                case ~tmp$110#0:wybe.bool of
                                                                0:
                                                                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                                1:
                                                                    foreign lpvm access(~$right#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$right$f11#0:wybe.int)
                                                                    foreign llvm icmp_eq(~$left$f11#0:wybe.int, ~$right$f11#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn





                                                1:
                                                    foreign lpvm access(~$left#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$left$f10#0:wybe.int)
                                                    foreign llvm icmp_uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$100#0:wybe.bool)
                                                    case ~tmp$100#0:wybe.bool of
                                                    0:
                                                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                    1:
                                                        foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$101#0:wybe.int)
                                                        foreign llvm icmp_eq(~tmp$101#0:wybe.int, 7:wybe.int, ?tmp$102#0:wybe.bool)
                                                        case ~tmp$102#0:wybe.bool of
                                                        0:
                                                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                        1:
                                                            foreign lpvm access($right#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?tmp$103#0:16 bit unsigned)
                                                            foreign llvm icmp_eq(~tmp$103#0:16 bit unsigned, 9:16 bit unsigned, ?tmp$104#0:wybe.bool)
                                                            case ~tmp$104#0:wybe.bool of
                                                            0:
                                                                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                            1:
                                                                foreign lpvm access(~$right#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$right$f10#0:wybe.int)
                                                                foreign llvm icmp_eq(~$left$f10#0:wybe.int, ~$right$f10#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn





                                            1:
                                                foreign lpvm access(~$left#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$left$f09#0:wybe.int)
                                                foreign llvm icmp_uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$94#0:wybe.bool)
                                                case ~tmp$94#0:wybe.bool of
                                                0:
                                                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                1:
                                                    foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$95#0:wybe.int)
                                                    foreign llvm icmp_eq(~tmp$95#0:wybe.int, 7:wybe.int, ?tmp$96#0:wybe.bool)
                                                    case ~tmp$96#0:wybe.bool of
                                                    0:
                                                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                    1:
                                                        foreign lpvm access($right#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?tmp$97#0:16 bit unsigned)
                                                        foreign llvm icmp_eq(~tmp$97#0:16 bit unsigned, 8:16 bit unsigned, ?tmp$98#0:wybe.bool)
                                                        case ~tmp$98#0:wybe.bool of
                                                        0:
                                                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                        1:
                                                            foreign lpvm access(~$right#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$right$f09#0:wybe.int)
                                                            foreign llvm icmp_eq(~$left$f09#0:wybe.int, ~$right$f09#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn





                                        1:
                                            foreign lpvm access(~$left#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$left$f08#0:wybe.int)
                                            foreign llvm icmp_uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$88#0:wybe.bool)
                                            case ~tmp$88#0:wybe.bool of
                                            0:
                                                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                            1:
                                                foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$89#0:wybe.int)
                                                foreign llvm icmp_eq(~tmp$89#0:wybe.int, 7:wybe.int, ?tmp$90#0:wybe.bool)
                                                case ~tmp$90#0:wybe.bool of
                                                0:
                                                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                1:
                                                    foreign lpvm access($right#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?tmp$91#0:16 bit unsigned)
                                                    foreign llvm icmp_eq(~tmp$91#0:16 bit unsigned, 7:16 bit unsigned, ?tmp$92#0:wybe.bool)
                                                    case ~tmp$92#0:wybe.bool of
                                                    0:
                                                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                                    1:
                                                        foreign lpvm access(~$right#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$right$f08#0:wybe.int)
                                                        foreign llvm icmp_eq(~$left$f08#0:wybe.int, ~$right$f08#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn






                                1:
                                    foreign lpvm access(~$left#0:multictr.complicated, -6:wybe.int, 8:wybe.int, 6:wybe.int, ?$left$f07#0:wybe.int)
                                    foreign llvm icmp_uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$82#0:wybe.bool)
                                    case ~tmp$82#0:wybe.bool of
                                    0:
                                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                    1:
                                        foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$83#0:wybe.int)
                                        foreign llvm icmp_eq(~tmp$83#0:wybe.int, 6:wybe.int, ?tmp$84#0:wybe.bool)
                                        case ~tmp$84#0:wybe.bool of
                                        0:
                                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                        1:
                                            foreign lpvm access(~$right#0:multictr.complicated, -6:wybe.int, 8:wybe.int, 6:wybe.int, ?$right$f07#0:wybe.int)
                                            foreign llvm icmp_eq(~$left$f07#0:wybe.int, ~$right$f07#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn




                            1:
                                foreign lpvm access(~$left#0:multictr.complicated, -5:wybe.int, 8:wybe.int, 5:wybe.int, ?$left$f06#0:wybe.int)
                                foreign llvm icmp_uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$78#0:wybe.bool)
                                case ~tmp$78#0:wybe.bool of
                                0:
                                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                1:
                                    foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$79#0:wybe.int)
                                    foreign llvm icmp_eq(~tmp$79#0:wybe.int, 5:wybe.int, ?tmp$80#0:wybe.bool)
                                    case ~tmp$80#0:wybe.bool of
                                    0:
                                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                    1:
                                        foreign lpvm access(~$right#0:multictr.complicated, -5:wybe.int, 8:wybe.int, 5:wybe.int, ?$right$f06#0:wybe.int)
                                        foreign llvm icmp_eq(~$left$f06#0:wybe.int, ~$right$f06#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn




                        1:
                            foreign lpvm access(~$left#0:multictr.complicated, -4:wybe.int, 8:wybe.int, 4:wybe.int, ?$left$f05#0:wybe.int)
                            foreign llvm icmp_uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$74#0:wybe.bool)
                            case ~tmp$74#0:wybe.bool of
                            0:
                                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                            1:
                                foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$75#0:wybe.int)
                                foreign llvm icmp_eq(~tmp$75#0:wybe.int, 4:wybe.int, ?tmp$76#0:wybe.bool)
                                case ~tmp$76#0:wybe.bool of
                                0:
                                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                                1:
                                    foreign lpvm access(~$right#0:multictr.complicated, -4:wybe.int, 8:wybe.int, 4:wybe.int, ?$right$f05#0:wybe.int)
                                    foreign llvm icmp_eq(~$left$f05#0:wybe.int, ~$right$f05#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn




                    1:
                        foreign lpvm access(~$left#0:multictr.complicated, -3:wybe.int, 8:wybe.int, 3:wybe.int, ?$left$f04#0:wybe.int)
                        foreign llvm icmp_uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$70#0:wybe.bool)
                        case ~tmp$70#0:wybe.bool of
                        0:
                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                        1:
                            foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$71#0:wybe.int)
                            foreign llvm icmp_eq(~tmp$71#0:wybe.int, 3:wybe.int, ?tmp$72#0:wybe.bool)
                            case ~tmp$72#0:wybe.bool of
                            0:
                                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                            1:
                                foreign lpvm access(~$right#0:multictr.complicated, -3:wybe.int, 8:wybe.int, 3:wybe.int, ?$right$f04#0:wybe.int)
                                foreign llvm icmp_eq(~$left$f04#0:wybe.int, ~$right$f04#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn




                1:
                    foreign lpvm access(~$left#0:multictr.complicated, -2:wybe.int, 8:wybe.int, 2:wybe.int, ?$left$f03#0:wybe.int)
                    foreign llvm icmp_uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$66#0:wybe.bool)
                    case ~tmp$66#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$67#0:wybe.int)
                        foreign llvm icmp_eq(~tmp$67#0:wybe.int, 2:wybe.int, ?tmp$68#0:wybe.bool)
                        case ~tmp$68#0:wybe.bool of
                        0:
                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                        1:
                            foreign lpvm access(~$right#0:multictr.complicated, -2:wybe.int, 8:wybe.int, 2:wybe.int, ?$right$f03#0:wybe.int)
                            foreign llvm icmp_eq(~$left$f03#0:wybe.int, ~$right$f03#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn




            1:
                foreign lpvm access(~$left#0:multictr.complicated, -1:wybe.int, 8:wybe.int, 1:wybe.int, ?$left$f02#0:wybe.int)
                foreign llvm icmp_uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$62#0:wybe.bool)
                case ~tmp$62#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$63#0:wybe.int)
                    foreign llvm icmp_eq(~tmp$63#0:wybe.int, 1:wybe.int, ?tmp$64#0:wybe.bool)
                    case ~tmp$64#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        foreign lpvm access(~$right#0:multictr.complicated, -1:wybe.int, 8:wybe.int, 1:wybe.int, ?$right$f02#0:wybe.int)
                        foreign llvm icmp_eq(~$left$f02#0:wybe.int, ~$right$f02#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn




        1:
            foreign lpvm access(~$left#0:multictr.complicated, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$left$f01#0:wybe.int)
            foreign llvm icmp_uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$58#0:wybe.bool)
            case ~tmp$58#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$59#0:wybe.int)
                foreign llvm icmp_eq(~tmp$59#0:wybe.int, 0:wybe.int, ?tmp$60#0:wybe.bool)
                case ~tmp$60#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign lpvm access(~$right#0:multictr.complicated, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$right$f01#0:wybe.int)
                    foreign llvm icmp_eq(~$left$f01#0:wybe.int, ~$right$f01#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn






autumn > public {inline} (0 calls)
0: multictr.complicated.autumn<0>
autumn(?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(3:multictr.complicated, ?$#0:multictr.complicated)


c01 > public {inline} (0 calls)
0: multictr.complicated.c01<0>
c01(f01#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$#0:multictr.complicated, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~f01#0:wybe.int)
c01 > public {inline} (40 calls)
1: multictr.complicated.c01<1>
c01(?f01#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?f01#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 0:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?f01#0:wybe.int)

        1:
            foreign lpvm access(~$#0:multictr.complicated, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?f01#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




c02 > public {inline} (0 calls)
0: multictr.complicated.c02<0>
c02(f02#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~f02#0:wybe.int)
    foreign llvm or(~$rec#1:multictr.complicated, 1:wybe.int, ?$#0:multictr.complicated)
c02 > public {inline} (35 calls)
1: multictr.complicated.c02<1>
c02(?f02#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?f02#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 1:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?f02#0:wybe.int)

        1:
            foreign lpvm access(~$#0:multictr.complicated, -1:wybe.int, 8:wybe.int, 1:wybe.int, ?f02#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




c03 > public {inline} (0 calls)
0: multictr.complicated.c03<0>
c03(f03#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~f03#0:wybe.int)
    foreign llvm or(~$rec#1:multictr.complicated, 2:wybe.int, ?$#0:multictr.complicated)
c03 > public {inline} (33 calls)
1: multictr.complicated.c03<1>
c03(?f03#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?f03#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 2:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?f03#0:wybe.int)

        1:
            foreign lpvm access(~$#0:multictr.complicated, -2:wybe.int, 8:wybe.int, 2:wybe.int, ?f03#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




c04 > public {inline} (0 calls)
0: multictr.complicated.c04<0>
c04(f04#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~f04#0:wybe.int)
    foreign llvm or(~$rec#1:multictr.complicated, 3:wybe.int, ?$#0:multictr.complicated)
c04 > public {inline} (31 calls)
1: multictr.complicated.c04<1>
c04(?f04#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?f04#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 3:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?f04#0:wybe.int)

        1:
            foreign lpvm access(~$#0:multictr.complicated, -3:wybe.int, 8:wybe.int, 3:wybe.int, ?f04#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




c05 > public {inline} (0 calls)
0: multictr.complicated.c05<0>
c05(f05#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~f05#0:wybe.int)
    foreign llvm or(~$rec#1:multictr.complicated, 4:wybe.int, ?$#0:multictr.complicated)
c05 > public {inline} (29 calls)
1: multictr.complicated.c05<1>
c05(?f05#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?f05#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 4:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?f05#0:wybe.int)

        1:
            foreign lpvm access(~$#0:multictr.complicated, -4:wybe.int, 8:wybe.int, 4:wybe.int, ?f05#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




c06 > public {inline} (0 calls)
0: multictr.complicated.c06<0>
c06(f06#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~f06#0:wybe.int)
    foreign llvm or(~$rec#1:multictr.complicated, 5:wybe.int, ?$#0:multictr.complicated)
c06 > public {inline} (27 calls)
1: multictr.complicated.c06<1>
c06(?f06#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?f06#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 5:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?f06#0:wybe.int)

        1:
            foreign lpvm access(~$#0:multictr.complicated, -5:wybe.int, 8:wybe.int, 5:wybe.int, ?f06#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




c07 > public {inline} (0 calls)
0: multictr.complicated.c07<0>
c07(f07#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~f07#0:wybe.int)
    foreign llvm or(~$rec#1:multictr.complicated, 6:wybe.int, ?$#0:multictr.complicated)
c07 > public {inline} (25 calls)
1: multictr.complicated.c07<1>
c07(?f07#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?f07#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 6:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?f07#0:wybe.int)

        1:
            foreign lpvm access(~$#0:multictr.complicated, -6:wybe.int, 8:wybe.int, 6:wybe.int, ?f07#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




c08 > public {inline} (0 calls)
0: multictr.complicated.c08<0>
c08(f08#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?$rec#0:multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 7:wybe.int)
    foreign lpvm mutate(~%$rec#1:multictr.complicated, ?%$rec#2:multictr.complicated, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, ~f08#0:wybe.int)
    foreign llvm or(~$rec#2:multictr.complicated, 7:wybe.int, ?$#0:multictr.complicated)
c08 > public {inline} (23 calls)
1: multictr.complicated.c08<1>
c08(?f08#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?f08#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?f08#0:wybe.int)

        1:
            foreign lpvm access($#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 7:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?f08#0:wybe.int)

            1:
                foreign lpvm access(~$#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?f08#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





c09 > public {inline} (0 calls)
0: multictr.complicated.c09<0>
c09(f09#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?$rec#0:multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 8:wybe.int)
    foreign lpvm mutate(~%$rec#1:multictr.complicated, ?%$rec#2:multictr.complicated, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, ~f09#0:wybe.int)
    foreign llvm or(~$rec#2:multictr.complicated, 7:wybe.int, ?$#0:multictr.complicated)
c09 > public {inline} (21 calls)
1: multictr.complicated.c09<1>
c09(?f09#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?f09#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?f09#0:wybe.int)

        1:
            foreign lpvm access($#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 8:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?f09#0:wybe.int)

            1:
                foreign lpvm access(~$#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?f09#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





c10 > public {inline} (0 calls)
0: multictr.complicated.c10<0>
c10(f10#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?$rec#0:multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 9:wybe.int)
    foreign lpvm mutate(~%$rec#1:multictr.complicated, ?%$rec#2:multictr.complicated, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, ~f10#0:wybe.int)
    foreign llvm or(~$rec#2:multictr.complicated, 7:wybe.int, ?$#0:multictr.complicated)
c10 > public {inline} (19 calls)
1: multictr.complicated.c10<1>
c10(?f10#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?f10#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?f10#0:wybe.int)

        1:
            foreign lpvm access($#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 9:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?f10#0:wybe.int)

            1:
                foreign lpvm access(~$#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?f10#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





c11 > public {inline} (0 calls)
0: multictr.complicated.c11<0>
c11(f11#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?$rec#0:multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 10:wybe.int)
    foreign lpvm mutate(~%$rec#1:multictr.complicated, ?%$rec#2:multictr.complicated, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, ~f11#0:wybe.int)
    foreign llvm or(~$rec#2:multictr.complicated, 7:wybe.int, ?$#0:multictr.complicated)
c11 > public {inline} (17 calls)
1: multictr.complicated.c11<1>
c11(?f11#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?f11#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?f11#0:wybe.int)

        1:
            foreign lpvm access($#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 10:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?f11#0:wybe.int)

            1:
                foreign lpvm access(~$#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?f11#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





c12 > public {inline} (0 calls)
0: multictr.complicated.c12<0>
c12(f12#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?$rec#0:multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 11:wybe.int)
    foreign lpvm mutate(~%$rec#1:multictr.complicated, ?%$rec#2:multictr.complicated, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, ~f12#0:wybe.int)
    foreign llvm or(~$rec#2:multictr.complicated, 7:wybe.int, ?$#0:multictr.complicated)
c12 > public {inline} (15 calls)
1: multictr.complicated.c12<1>
c12(?f12#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?f12#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?f12#0:wybe.int)

        1:
            foreign lpvm access($#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 11:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?f12#0:wybe.int)

            1:
                foreign lpvm access(~$#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?f12#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





c13 > public {inline} (0 calls)
0: multictr.complicated.c13<0>
c13(f13#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?$rec#0:multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 12:wybe.int)
    foreign lpvm mutate(~%$rec#1:multictr.complicated, ?%$rec#2:multictr.complicated, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, ~f13#0:wybe.int)
    foreign llvm or(~$rec#2:multictr.complicated, 7:wybe.int, ?$#0:multictr.complicated)
c13 > public {inline} (13 calls)
1: multictr.complicated.c13<1>
c13(?f13#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?f13#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?f13#0:wybe.int)

        1:
            foreign lpvm access($#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 12:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?f13#0:wybe.int)

            1:
                foreign lpvm access(~$#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?f13#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





c14 > public {inline} (0 calls)
0: multictr.complicated.c14<0>
c14(f14#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?$rec#0:multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 13:wybe.int)
    foreign lpvm mutate(~%$rec#1:multictr.complicated, ?%$rec#2:multictr.complicated, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, ~f14#0:wybe.int)
    foreign llvm or(~$rec#2:multictr.complicated, 7:wybe.int, ?$#0:multictr.complicated)
c14 > public {inline} (11 calls)
1: multictr.complicated.c14<1>
c14(?f14#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?f14#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?f14#0:wybe.int)

        1:
            foreign lpvm access($#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 13:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?f14#0:wybe.int)

            1:
                foreign lpvm access(~$#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?f14#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





c15 > public {inline} (0 calls)
0: multictr.complicated.c15<0>
c15(f15#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?$rec#0:multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 14:wybe.int)
    foreign lpvm mutate(~%$rec#1:multictr.complicated, ?%$rec#2:multictr.complicated, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, ~f15#0:wybe.int)
    foreign llvm or(~$rec#2:multictr.complicated, 7:wybe.int, ?$#0:multictr.complicated)
c15 > public {inline} (9 calls)
1: multictr.complicated.c15<1>
c15(?f15#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?f15#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?f15#0:wybe.int)

        1:
            foreign lpvm access($#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 14:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?f15#0:wybe.int)

            1:
                foreign lpvm access(~$#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?f15#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





c16 > public {inline} (0 calls)
0: multictr.complicated.c16<0>
c16(f16#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?$rec#0:multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 15:wybe.int)
    foreign lpvm mutate(~%$rec#1:multictr.complicated, ?%$rec#2:multictr.complicated, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, ~f16#0:wybe.int)
    foreign llvm or(~$rec#2:multictr.complicated, 7:wybe.int, ?$#0:multictr.complicated)
c16 > public {inline} (7 calls)
1: multictr.complicated.c16<1>
c16(?f16#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?f16#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?f16#0:wybe.int)

        1:
            foreign lpvm access($#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 15:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?f16#0:wybe.int)

            1:
                foreign lpvm access(~$#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?f16#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





c17 > public {inline} (0 calls)
0: multictr.complicated.c17<0>
c17(f17#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?$rec#0:multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 16:wybe.int)
    foreign lpvm mutate(~%$rec#1:multictr.complicated, ?%$rec#2:multictr.complicated, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, ~f17#0:wybe.int)
    foreign llvm or(~$rec#2:multictr.complicated, 7:wybe.int, ?$#0:multictr.complicated)
c17 > public {inline} (5 calls)
1: multictr.complicated.c17<1>
c17(?f17#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?f17#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?f17#0:wybe.int)

        1:
            foreign lpvm access($#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 16:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?f17#0:wybe.int)

            1:
                foreign lpvm access(~$#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?f17#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





f01 > public {inline} (0 calls)
0: multictr.complicated.f01<0>
f01($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 0:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access(~$rec#0:multictr.complicated, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


f01 > public {inline} (0 calls)
1: multictr.complicated.f01<1>
f01($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 0:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm {noalias} mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




f02 > public {inline} (0 calls)
0: multictr.complicated.f02<0>
f02($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 1:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access(~$rec#0:multictr.complicated, -1:wybe.int, 8:wybe.int, 1:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


f02 > public {inline} (0 calls)
1: multictr.complicated.f02<1>
f02($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 1:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm {noalias} mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, -1:wybe.int, 0:wybe.int, 8:wybe.int, 1:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




f03 > public {inline} (0 calls)
0: multictr.complicated.f03<0>
f03($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 2:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access(~$rec#0:multictr.complicated, -2:wybe.int, 8:wybe.int, 2:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


f03 > public {inline} (0 calls)
1: multictr.complicated.f03<1>
f03($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 2:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm {noalias} mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, -2:wybe.int, 0:wybe.int, 8:wybe.int, 2:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




f04 > public {inline} (0 calls)
0: multictr.complicated.f04<0>
f04($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 3:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access(~$rec#0:multictr.complicated, -3:wybe.int, 8:wybe.int, 3:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


f04 > public {inline} (0 calls)
1: multictr.complicated.f04<1>
f04($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 3:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm {noalias} mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, -3:wybe.int, 0:wybe.int, 8:wybe.int, 3:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




f05 > public {inline} (0 calls)
0: multictr.complicated.f05<0>
f05($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 4:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access(~$rec#0:multictr.complicated, -4:wybe.int, 8:wybe.int, 4:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


f05 > public {inline} (0 calls)
1: multictr.complicated.f05<1>
f05($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 4:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm {noalias} mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, -4:wybe.int, 0:wybe.int, 8:wybe.int, 4:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




f06 > public {inline} (0 calls)
0: multictr.complicated.f06<0>
f06($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 5:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access(~$rec#0:multictr.complicated, -5:wybe.int, 8:wybe.int, 5:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


f06 > public {inline} (0 calls)
1: multictr.complicated.f06<1>
f06($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 5:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm {noalias} mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, -5:wybe.int, 0:wybe.int, 8:wybe.int, 5:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




f07 > public {inline} (0 calls)
0: multictr.complicated.f07<0>
f07($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 6:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access(~$rec#0:multictr.complicated, -6:wybe.int, 8:wybe.int, 6:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


f07 > public {inline} (0 calls)
1: multictr.complicated.f07<1>
f07($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 6:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm {noalias} mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, -6:wybe.int, 0:wybe.int, 8:wybe.int, 6:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




f08 > public {inline} (0 calls)
0: multictr.complicated.f08<0>
f08($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 7:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

            1:
                foreign lpvm access(~$rec#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



f08 > public {inline} (0 calls)
1: multictr.complicated.f08<1>
f08($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 7:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

            1:
                foreign lpvm {noalias} mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 1:wybe.int, 0:wybe.int, 16:wybe.int, 7:wybe.int, ~$field#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





f09 > public {inline} (0 calls)
0: multictr.complicated.f09<0>
f09($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 8:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

            1:
                foreign lpvm access(~$rec#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



f09 > public {inline} (0 calls)
1: multictr.complicated.f09<1>
f09($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 8:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

            1:
                foreign lpvm {noalias} mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 1:wybe.int, 0:wybe.int, 16:wybe.int, 7:wybe.int, ~$field#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





f10 > public {inline} (0 calls)
0: multictr.complicated.f10<0>
f10($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 9:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

            1:
                foreign lpvm access(~$rec#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



f10 > public {inline} (0 calls)
1: multictr.complicated.f10<1>
f10($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 9:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

            1:
                foreign lpvm {noalias} mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 1:wybe.int, 0:wybe.int, 16:wybe.int, 7:wybe.int, ~$field#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





f11 > public {inline} (0 calls)
0: multictr.complicated.f11<0>
f11($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 10:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

            1:
                foreign lpvm access(~$rec#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



f11 > public {inline} (0 calls)
1: multictr.complicated.f11<1>
f11($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 10:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

            1:
                foreign lpvm {noalias} mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 1:wybe.int, 0:wybe.int, 16:wybe.int, 7:wybe.int, ~$field#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





f12 > public {inline} (0 calls)
0: multictr.complicated.f12<0>
f12($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 11:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

            1:
                foreign lpvm access(~$rec#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



f12 > public {inline} (0 calls)
1: multictr.complicated.f12<1>
f12($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 11:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

            1:
                foreign lpvm {noalias} mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 1:wybe.int, 0:wybe.int, 16:wybe.int, 7:wybe.int, ~$field#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





f13 > public {inline} (0 calls)
0: multictr.complicated.f13<0>
f13($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 12:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

            1:
                foreign lpvm access(~$rec#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



f13 > public {inline} (0 calls)
1: multictr.complicated.f13<1>
f13($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 12:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

            1:
                foreign lpvm {noalias} mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 1:wybe.int, 0:wybe.int, 16:wybe.int, 7:wybe.int, ~$field#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





f14 > public {inline} (0 calls)
0: multictr.complicated.f14<0>
f14($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 13:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

            1:
                foreign lpvm access(~$rec#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



f14 > public {inline} (0 calls)
1: multictr.complicated.f14<1>
f14($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 13:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

            1:
                foreign lpvm {noalias} mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 1:wybe.int, 0:wybe.int, 16:wybe.int, 7:wybe.int, ~$field#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





f15 > public {inline} (0 calls)
0: multictr.complicated.f15<0>
f15($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 14:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

            1:
                foreign lpvm access(~$rec#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



f15 > public {inline} (0 calls)
1: multictr.complicated.f15<1>
f15($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 14:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

            1:
                foreign lpvm {noalias} mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 1:wybe.int, 0:wybe.int, 16:wybe.int, 7:wybe.int, ~$field#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





f16 > public {inline} (0 calls)
0: multictr.complicated.f16<0>
f16($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 15:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

            1:
                foreign lpvm access(~$rec#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



f16 > public {inline} (0 calls)
1: multictr.complicated.f16<1>
f16($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 15:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

            1:
                foreign lpvm {noalias} mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 1:wybe.int, 0:wybe.int, 16:wybe.int, 7:wybe.int, ~$field#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





f17 > public {inline} (0 calls)
0: multictr.complicated.f17<0>
f17($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 16:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

            1:
                foreign lpvm access(~$rec#0:multictr.complicated, 1:wybe.int, 16:wybe.int, 7:wybe.int, ?$#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



f17 > public {inline} (0 calls)
1: multictr.complicated.f17<1>
f17($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_uge($rec#0:!wybe.int, 4:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm access($rec#0:multictr.complicated, -7:wybe.int, 16:wybe.int, 7:wybe.int, ?$tag#0:!16 bit unsigned)
            foreign llvm icmp_eq(~$tag#0:16 bit unsigned, 16:16 bit unsigned, ?tmp$3#0:!wybe.bool)
            case ~tmp$3#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
                foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

            1:
                foreign lpvm {noalias} mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 1:wybe.int, 0:wybe.int, 16:wybe.int, 7:wybe.int, ~$field#0:wybe.int)
                foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)





spring > public {inline} (0 calls)
0: multictr.complicated.spring<0>
spring(?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(1:multictr.complicated, ?$#0:multictr.complicated)


summer > public {inline} (0 calls)
0: multictr.complicated.summer<0>
summer(?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(2:multictr.complicated, ?$#0:multictr.complicated)


winter > public {inline} (0 calls)
0: multictr.complicated.winter<0>
winter(?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.complicated, ?$#0:multictr.complicated)

  LLVM code       :

; ModuleID = 'multictr.complicated'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.complicated./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = tail call fastcc  i1  @"multictr.complicated.=<0>"(i64  %"$left#0", i64  %"$right#0")  
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.complicated.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$left#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$55#0" = and i64 %"$left#0", 7 
  %"2$tmp$56#0" = icmp eq i64 %"2$tmp$55#0", 0 
  br i1 %"2$tmp$56#0", label %if.then1, label %if.else1 
if.else:
  %"3$$$#0" = icmp eq i64 %"$left#0", %"$right#0" 
  ret i1 %"3$$$#0" 
if.then1:
  %1 = inttoptr i64 %"$left#0" to i64* 
  %2 = getelementptr  i64, i64* %1, i64 0 
  %3 = load  i64, i64* %2 
  %"4$tmp$58#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"4$tmp$58#0", label %if.then2, label %if.else2 
if.else1:
  %"5$tmp$60#0" = icmp eq i64 %"2$tmp$55#0", 1 
  br i1 %"5$tmp$60#0", label %if.then4, label %if.else4 
if.then2:
  %"6$tmp$59#0" = and i64 %"$right#0", 7 
  %"6$tmp$60#0" = icmp eq i64 %"6$tmp$59#0", 0 
  br i1 %"6$tmp$60#0", label %if.then3, label %if.else3 
if.else2:
  ret i1 0 
if.then3:
  %4 = inttoptr i64 %"$right#0" to i64* 
  %5 = getelementptr  i64, i64* %4, i64 0 
  %6 = load  i64, i64* %5 
  %"8$$$#0" = icmp eq i64 %3, %6 
  ret i1 %"8$$$#0" 
if.else3:
  ret i1 0 
if.then4:
  %7 = add   i64 %"$left#0", -1 
  %8 = inttoptr i64 %7 to i64* 
  %9 = getelementptr  i64, i64* %8, i64 0 
  %10 = load  i64, i64* %9 
  %"10$tmp$62#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"10$tmp$62#0", label %if.then5, label %if.else5 
if.else4:
  %"11$tmp$64#0" = icmp eq i64 %"2$tmp$55#0", 2 
  br i1 %"11$tmp$64#0", label %if.then7, label %if.else7 
if.then5:
  %"12$tmp$63#0" = and i64 %"$right#0", 7 
  %"12$tmp$64#0" = icmp eq i64 %"12$tmp$63#0", 1 
  br i1 %"12$tmp$64#0", label %if.then6, label %if.else6 
if.else5:
  ret i1 0 
if.then6:
  %11 = add   i64 %"$right#0", -1 
  %12 = inttoptr i64 %11 to i64* 
  %13 = getelementptr  i64, i64* %12, i64 0 
  %14 = load  i64, i64* %13 
  %"14$$$#0" = icmp eq i64 %10, %14 
  ret i1 %"14$$$#0" 
if.else6:
  ret i1 0 
if.then7:
  %15 = add   i64 %"$left#0", -2 
  %16 = inttoptr i64 %15 to i64* 
  %17 = getelementptr  i64, i64* %16, i64 0 
  %18 = load  i64, i64* %17 
  %"16$tmp$66#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"16$tmp$66#0", label %if.then8, label %if.else8 
if.else7:
  %"17$tmp$68#0" = icmp eq i64 %"2$tmp$55#0", 3 
  br i1 %"17$tmp$68#0", label %if.then10, label %if.else10 
if.then8:
  %"18$tmp$67#0" = and i64 %"$right#0", 7 
  %"18$tmp$68#0" = icmp eq i64 %"18$tmp$67#0", 2 
  br i1 %"18$tmp$68#0", label %if.then9, label %if.else9 
if.else8:
  ret i1 0 
if.then9:
  %19 = add   i64 %"$right#0", -2 
  %20 = inttoptr i64 %19 to i64* 
  %21 = getelementptr  i64, i64* %20, i64 0 
  %22 = load  i64, i64* %21 
  %"20$$$#0" = icmp eq i64 %18, %22 
  ret i1 %"20$$$#0" 
if.else9:
  ret i1 0 
if.then10:
  %23 = add   i64 %"$left#0", -3 
  %24 = inttoptr i64 %23 to i64* 
  %25 = getelementptr  i64, i64* %24, i64 0 
  %26 = load  i64, i64* %25 
  %"22$tmp$70#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"22$tmp$70#0", label %if.then11, label %if.else11 
if.else10:
  %"23$tmp$72#0" = icmp eq i64 %"2$tmp$55#0", 4 
  br i1 %"23$tmp$72#0", label %if.then13, label %if.else13 
if.then11:
  %"24$tmp$71#0" = and i64 %"$right#0", 7 
  %"24$tmp$72#0" = icmp eq i64 %"24$tmp$71#0", 3 
  br i1 %"24$tmp$72#0", label %if.then12, label %if.else12 
if.else11:
  ret i1 0 
if.then12:
  %27 = add   i64 %"$right#0", -3 
  %28 = inttoptr i64 %27 to i64* 
  %29 = getelementptr  i64, i64* %28, i64 0 
  %30 = load  i64, i64* %29 
  %"26$$$#0" = icmp eq i64 %26, %30 
  ret i1 %"26$$$#0" 
if.else12:
  ret i1 0 
if.then13:
  %31 = add   i64 %"$left#0", -4 
  %32 = inttoptr i64 %31 to i64* 
  %33 = getelementptr  i64, i64* %32, i64 0 
  %34 = load  i64, i64* %33 
  %"28$tmp$74#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"28$tmp$74#0", label %if.then14, label %if.else14 
if.else13:
  %"29$tmp$76#0" = icmp eq i64 %"2$tmp$55#0", 5 
  br i1 %"29$tmp$76#0", label %if.then16, label %if.else16 
if.then14:
  %"30$tmp$75#0" = and i64 %"$right#0", 7 
  %"30$tmp$76#0" = icmp eq i64 %"30$tmp$75#0", 4 
  br i1 %"30$tmp$76#0", label %if.then15, label %if.else15 
if.else14:
  ret i1 0 
if.then15:
  %35 = add   i64 %"$right#0", -4 
  %36 = inttoptr i64 %35 to i64* 
  %37 = getelementptr  i64, i64* %36, i64 0 
  %38 = load  i64, i64* %37 
  %"32$$$#0" = icmp eq i64 %34, %38 
  ret i1 %"32$$$#0" 
if.else15:
  ret i1 0 
if.then16:
  %39 = add   i64 %"$left#0", -5 
  %40 = inttoptr i64 %39 to i64* 
  %41 = getelementptr  i64, i64* %40, i64 0 
  %42 = load  i64, i64* %41 
  %"34$tmp$78#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"34$tmp$78#0", label %if.then17, label %if.else17 
if.else16:
  %"35$tmp$80#0" = icmp eq i64 %"2$tmp$55#0", 6 
  br i1 %"35$tmp$80#0", label %if.then19, label %if.else19 
if.then17:
  %"36$tmp$79#0" = and i64 %"$right#0", 7 
  %"36$tmp$80#0" = icmp eq i64 %"36$tmp$79#0", 5 
  br i1 %"36$tmp$80#0", label %if.then18, label %if.else18 
if.else17:
  ret i1 0 
if.then18:
  %43 = add   i64 %"$right#0", -5 
  %44 = inttoptr i64 %43 to i64* 
  %45 = getelementptr  i64, i64* %44, i64 0 
  %46 = load  i64, i64* %45 
  %"38$$$#0" = icmp eq i64 %42, %46 
  ret i1 %"38$$$#0" 
if.else18:
  ret i1 0 
if.then19:
  %47 = add   i64 %"$left#0", -6 
  %48 = inttoptr i64 %47 to i64* 
  %49 = getelementptr  i64, i64* %48, i64 0 
  %50 = load  i64, i64* %49 
  %"40$tmp$82#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"40$tmp$82#0", label %if.then20, label %if.else20 
if.else19:
  %"41$tmp$84#0" = icmp eq i64 %"2$tmp$55#0", 7 
  br i1 %"41$tmp$84#0", label %if.then22, label %if.else22 
if.then20:
  %"42$tmp$83#0" = and i64 %"$right#0", 7 
  %"42$tmp$84#0" = icmp eq i64 %"42$tmp$83#0", 6 
  br i1 %"42$tmp$84#0", label %if.then21, label %if.else21 
if.else20:
  ret i1 0 
if.then21:
  %51 = add   i64 %"$right#0", -6 
  %52 = inttoptr i64 %51 to i64* 
  %53 = getelementptr  i64, i64* %52, i64 0 
  %54 = load  i64, i64* %53 
  %"44$$$#0" = icmp eq i64 %50, %54 
  ret i1 %"44$$$#0" 
if.else21:
  ret i1 0 
if.then22:
  %55 = add   i64 %"$left#0", -7 
  %56 = inttoptr i64 %55 to i16* 
  %57 = getelementptr  i16, i16* %56, i64 0 
  %58 = load  i16, i16* %57 
  %"46$tmp$86#0" = icmp eq i16 %58, 7 
  br i1 %"46$tmp$86#0", label %if.then23, label %if.else23 
if.else22:
  ret i1 0 
if.then23:
  %59 = add   i64 %"$left#0", 1 
  %60 = inttoptr i64 %59 to i64* 
  %61 = getelementptr  i64, i64* %60, i64 0 
  %62 = load  i64, i64* %61 
  %"48$tmp$88#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"48$tmp$88#0", label %if.then24, label %if.else24 
if.else23:
  %"49$tmp$92#0" = icmp eq i16 %58, 8 
  br i1 %"49$tmp$92#0", label %if.then27, label %if.else27 
if.then24:
  %"50$tmp$89#0" = and i64 %"$right#0", 7 
  %"50$tmp$90#0" = icmp eq i64 %"50$tmp$89#0", 7 
  br i1 %"50$tmp$90#0", label %if.then25, label %if.else25 
if.else24:
  ret i1 0 
if.then25:
  %63 = add   i64 %"$right#0", -7 
  %64 = inttoptr i64 %63 to i16* 
  %65 = getelementptr  i16, i16* %64, i64 0 
  %66 = load  i16, i16* %65 
  %"52$tmp$92#0" = icmp eq i16 %66, 7 
  br i1 %"52$tmp$92#0", label %if.then26, label %if.else26 
if.else25:
  ret i1 0 
if.then26:
  %67 = add   i64 %"$right#0", 1 
  %68 = inttoptr i64 %67 to i64* 
  %69 = getelementptr  i64, i64* %68, i64 0 
  %70 = load  i64, i64* %69 
  %"54$$$#0" = icmp eq i64 %62, %70 
  ret i1 %"54$$$#0" 
if.else26:
  ret i1 0 
if.then27:
  %71 = add   i64 %"$left#0", 1 
  %72 = inttoptr i64 %71 to i64* 
  %73 = getelementptr  i64, i64* %72, i64 0 
  %74 = load  i64, i64* %73 
  %"56$tmp$94#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"56$tmp$94#0", label %if.then28, label %if.else28 
if.else27:
  %"57$tmp$98#0" = icmp eq i16 %58, 9 
  br i1 %"57$tmp$98#0", label %if.then31, label %if.else31 
if.then28:
  %"58$tmp$95#0" = and i64 %"$right#0", 7 
  %"58$tmp$96#0" = icmp eq i64 %"58$tmp$95#0", 7 
  br i1 %"58$tmp$96#0", label %if.then29, label %if.else29 
if.else28:
  ret i1 0 
if.then29:
  %75 = add   i64 %"$right#0", -7 
  %76 = inttoptr i64 %75 to i16* 
  %77 = getelementptr  i16, i16* %76, i64 0 
  %78 = load  i16, i16* %77 
  %"60$tmp$98#0" = icmp eq i16 %78, 8 
  br i1 %"60$tmp$98#0", label %if.then30, label %if.else30 
if.else29:
  ret i1 0 
if.then30:
  %79 = add   i64 %"$right#0", 1 
  %80 = inttoptr i64 %79 to i64* 
  %81 = getelementptr  i64, i64* %80, i64 0 
  %82 = load  i64, i64* %81 
  %"62$$$#0" = icmp eq i64 %74, %82 
  ret i1 %"62$$$#0" 
if.else30:
  ret i1 0 
if.then31:
  %83 = add   i64 %"$left#0", 1 
  %84 = inttoptr i64 %83 to i64* 
  %85 = getelementptr  i64, i64* %84, i64 0 
  %86 = load  i64, i64* %85 
  %"64$tmp$100#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"64$tmp$100#0", label %if.then32, label %if.else32 
if.else31:
  %"65$tmp$104#0" = icmp eq i16 %58, 10 
  br i1 %"65$tmp$104#0", label %if.then35, label %if.else35 
if.then32:
  %"66$tmp$101#0" = and i64 %"$right#0", 7 
  %"66$tmp$102#0" = icmp eq i64 %"66$tmp$101#0", 7 
  br i1 %"66$tmp$102#0", label %if.then33, label %if.else33 
if.else32:
  ret i1 0 
if.then33:
  %87 = add   i64 %"$right#0", -7 
  %88 = inttoptr i64 %87 to i16* 
  %89 = getelementptr  i16, i16* %88, i64 0 
  %90 = load  i16, i16* %89 
  %"68$tmp$104#0" = icmp eq i16 %90, 9 
  br i1 %"68$tmp$104#0", label %if.then34, label %if.else34 
if.else33:
  ret i1 0 
if.then34:
  %91 = add   i64 %"$right#0", 1 
  %92 = inttoptr i64 %91 to i64* 
  %93 = getelementptr  i64, i64* %92, i64 0 
  %94 = load  i64, i64* %93 
  %"70$$$#0" = icmp eq i64 %86, %94 
  ret i1 %"70$$$#0" 
if.else34:
  ret i1 0 
if.then35:
  %95 = add   i64 %"$left#0", 1 
  %96 = inttoptr i64 %95 to i64* 
  %97 = getelementptr  i64, i64* %96, i64 0 
  %98 = load  i64, i64* %97 
  %"72$tmp$106#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"72$tmp$106#0", label %if.then36, label %if.else36 
if.else35:
  %"73$tmp$110#0" = icmp eq i16 %58, 11 
  br i1 %"73$tmp$110#0", label %if.then39, label %if.else39 
if.then36:
  %"74$tmp$107#0" = and i64 %"$right#0", 7 
  %"74$tmp$108#0" = icmp eq i64 %"74$tmp$107#0", 7 
  br i1 %"74$tmp$108#0", label %if.then37, label %if.else37 
if.else36:
  ret i1 0 
if.then37:
  %99 = add   i64 %"$right#0", -7 
  %100 = inttoptr i64 %99 to i16* 
  %101 = getelementptr  i16, i16* %100, i64 0 
  %102 = load  i16, i16* %101 
  %"76$tmp$110#0" = icmp eq i16 %102, 10 
  br i1 %"76$tmp$110#0", label %if.then38, label %if.else38 
if.else37:
  ret i1 0 
if.then38:
  %103 = add   i64 %"$right#0", 1 
  %104 = inttoptr i64 %103 to i64* 
  %105 = getelementptr  i64, i64* %104, i64 0 
  %106 = load  i64, i64* %105 
  %"78$$$#0" = icmp eq i64 %98, %106 
  ret i1 %"78$$$#0" 
if.else38:
  ret i1 0 
if.then39:
  %107 = add   i64 %"$left#0", 1 
  %108 = inttoptr i64 %107 to i64* 
  %109 = getelementptr  i64, i64* %108, i64 0 
  %110 = load  i64, i64* %109 
  %"80$tmp$112#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"80$tmp$112#0", label %if.then40, label %if.else40 
if.else39:
  %"81$tmp$116#0" = icmp eq i16 %58, 12 
  br i1 %"81$tmp$116#0", label %if.then43, label %if.else43 
if.then40:
  %"82$tmp$113#0" = and i64 %"$right#0", 7 
  %"82$tmp$114#0" = icmp eq i64 %"82$tmp$113#0", 7 
  br i1 %"82$tmp$114#0", label %if.then41, label %if.else41 
if.else40:
  ret i1 0 
if.then41:
  %111 = add   i64 %"$right#0", -7 
  %112 = inttoptr i64 %111 to i16* 
  %113 = getelementptr  i16, i16* %112, i64 0 
  %114 = load  i16, i16* %113 
  %"84$tmp$116#0" = icmp eq i16 %114, 11 
  br i1 %"84$tmp$116#0", label %if.then42, label %if.else42 
if.else41:
  ret i1 0 
if.then42:
  %115 = add   i64 %"$right#0", 1 
  %116 = inttoptr i64 %115 to i64* 
  %117 = getelementptr  i64, i64* %116, i64 0 
  %118 = load  i64, i64* %117 
  %"86$$$#0" = icmp eq i64 %110, %118 
  ret i1 %"86$$$#0" 
if.else42:
  ret i1 0 
if.then43:
  %119 = add   i64 %"$left#0", 1 
  %120 = inttoptr i64 %119 to i64* 
  %121 = getelementptr  i64, i64* %120, i64 0 
  %122 = load  i64, i64* %121 
  %"88$tmp$118#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"88$tmp$118#0", label %if.then44, label %if.else44 
if.else43:
  %"89$tmp$122#0" = icmp eq i16 %58, 13 
  br i1 %"89$tmp$122#0", label %if.then47, label %if.else47 
if.then44:
  %"90$tmp$119#0" = and i64 %"$right#0", 7 
  %"90$tmp$120#0" = icmp eq i64 %"90$tmp$119#0", 7 
  br i1 %"90$tmp$120#0", label %if.then45, label %if.else45 
if.else44:
  ret i1 0 
if.then45:
  %123 = add   i64 %"$right#0", -7 
  %124 = inttoptr i64 %123 to i16* 
  %125 = getelementptr  i16, i16* %124, i64 0 
  %126 = load  i16, i16* %125 
  %"92$tmp$122#0" = icmp eq i16 %126, 12 
  br i1 %"92$tmp$122#0", label %if.then46, label %if.else46 
if.else45:
  ret i1 0 
if.then46:
  %127 = add   i64 %"$right#0", 1 
  %128 = inttoptr i64 %127 to i64* 
  %129 = getelementptr  i64, i64* %128, i64 0 
  %130 = load  i64, i64* %129 
  %"94$$$#0" = icmp eq i64 %122, %130 
  ret i1 %"94$$$#0" 
if.else46:
  ret i1 0 
if.then47:
  %131 = add   i64 %"$left#0", 1 
  %132 = inttoptr i64 %131 to i64* 
  %133 = getelementptr  i64, i64* %132, i64 0 
  %134 = load  i64, i64* %133 
  %"96$tmp$124#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"96$tmp$124#0", label %if.then48, label %if.else48 
if.else47:
  %"97$tmp$128#0" = icmp eq i16 %58, 14 
  br i1 %"97$tmp$128#0", label %if.then51, label %if.else51 
if.then48:
  %"98$tmp$125#0" = and i64 %"$right#0", 7 
  %"98$tmp$126#0" = icmp eq i64 %"98$tmp$125#0", 7 
  br i1 %"98$tmp$126#0", label %if.then49, label %if.else49 
if.else48:
  ret i1 0 
if.then49:
  %135 = add   i64 %"$right#0", -7 
  %136 = inttoptr i64 %135 to i16* 
  %137 = getelementptr  i16, i16* %136, i64 0 
  %138 = load  i16, i16* %137 
  %"100$tmp$128#0" = icmp eq i16 %138, 13 
  br i1 %"100$tmp$128#0", label %if.then50, label %if.else50 
if.else49:
  ret i1 0 
if.then50:
  %139 = add   i64 %"$right#0", 1 
  %140 = inttoptr i64 %139 to i64* 
  %141 = getelementptr  i64, i64* %140, i64 0 
  %142 = load  i64, i64* %141 
  %"102$$$#0" = icmp eq i64 %134, %142 
  ret i1 %"102$$$#0" 
if.else50:
  ret i1 0 
if.then51:
  %143 = add   i64 %"$left#0", 1 
  %144 = inttoptr i64 %143 to i64* 
  %145 = getelementptr  i64, i64* %144, i64 0 
  %146 = load  i64, i64* %145 
  %"104$tmp$130#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"104$tmp$130#0", label %if.then52, label %if.else52 
if.else51:
  %"105$tmp$134#0" = icmp eq i16 %58, 15 
  br i1 %"105$tmp$134#0", label %if.then55, label %if.else55 
if.then52:
  %"106$tmp$131#0" = and i64 %"$right#0", 7 
  %"106$tmp$132#0" = icmp eq i64 %"106$tmp$131#0", 7 
  br i1 %"106$tmp$132#0", label %if.then53, label %if.else53 
if.else52:
  ret i1 0 
if.then53:
  %147 = add   i64 %"$right#0", -7 
  %148 = inttoptr i64 %147 to i16* 
  %149 = getelementptr  i16, i16* %148, i64 0 
  %150 = load  i16, i16* %149 
  %"108$tmp$134#0" = icmp eq i16 %150, 14 
  br i1 %"108$tmp$134#0", label %if.then54, label %if.else54 
if.else53:
  ret i1 0 
if.then54:
  %151 = add   i64 %"$right#0", 1 
  %152 = inttoptr i64 %151 to i64* 
  %153 = getelementptr  i64, i64* %152, i64 0 
  %154 = load  i64, i64* %153 
  %"110$$$#0" = icmp eq i64 %146, %154 
  ret i1 %"110$$$#0" 
if.else54:
  ret i1 0 
if.then55:
  %155 = add   i64 %"$left#0", 1 
  %156 = inttoptr i64 %155 to i64* 
  %157 = getelementptr  i64, i64* %156, i64 0 
  %158 = load  i64, i64* %157 
  %"112$tmp$136#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"112$tmp$136#0", label %if.then56, label %if.else56 
if.else55:
  %"113$tmp$140#0" = icmp eq i16 %58, 16 
  br i1 %"113$tmp$140#0", label %if.then59, label %if.else59 
if.then56:
  %"114$tmp$137#0" = and i64 %"$right#0", 7 
  %"114$tmp$138#0" = icmp eq i64 %"114$tmp$137#0", 7 
  br i1 %"114$tmp$138#0", label %if.then57, label %if.else57 
if.else56:
  ret i1 0 
if.then57:
  %159 = add   i64 %"$right#0", -7 
  %160 = inttoptr i64 %159 to i16* 
  %161 = getelementptr  i16, i16* %160, i64 0 
  %162 = load  i16, i16* %161 
  %"116$tmp$140#0" = icmp eq i16 %162, 15 
  br i1 %"116$tmp$140#0", label %if.then58, label %if.else58 
if.else57:
  ret i1 0 
if.then58:
  %163 = add   i64 %"$right#0", 1 
  %164 = inttoptr i64 %163 to i64* 
  %165 = getelementptr  i64, i64* %164, i64 0 
  %166 = load  i64, i64* %165 
  %"118$$$#0" = icmp eq i64 %158, %166 
  ret i1 %"118$$$#0" 
if.else58:
  ret i1 0 
if.then59:
  %167 = add   i64 %"$left#0", 1 
  %168 = inttoptr i64 %167 to i64* 
  %169 = getelementptr  i64, i64* %168, i64 0 
  %170 = load  i64, i64* %169 
  %"120$tmp$142#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"120$tmp$142#0", label %if.then60, label %if.else60 
if.else59:
  ret i1 0 
if.then60:
  %"122$tmp$143#0" = and i64 %"$right#0", 7 
  %"122$tmp$144#0" = icmp eq i64 %"122$tmp$143#0", 7 
  br i1 %"122$tmp$144#0", label %if.then61, label %if.else61 
if.else60:
  ret i1 0 
if.then61:
  %171 = add   i64 %"$right#0", -7 
  %172 = inttoptr i64 %171 to i16* 
  %173 = getelementptr  i16, i16* %172, i64 0 
  %174 = load  i16, i16* %173 
  %"124$tmp$146#0" = icmp eq i16 %174, 16 
  br i1 %"124$tmp$146#0", label %if.then62, label %if.else62 
if.else61:
  ret i1 0 
if.then62:
  %175 = add   i64 %"$right#0", 1 
  %176 = inttoptr i64 %175 to i64* 
  %177 = getelementptr  i64, i64* %176, i64 0 
  %178 = load  i64, i64* %177 
  %"126$$$#0" = icmp eq i64 %170, %178 
  ret i1 %"126$$$#0" 
if.else62:
  ret i1 0 
}


define external fastcc  i64 @"multictr.complicated.autumn<0>"()    {
entry:
  ret i64 3 
}


define external fastcc  i64 @"multictr.complicated.c01<0>"(i64  %"f01#0")    {
entry:
  %179 = trunc i64 8 to i32  
  %180 = tail call ccc  i8*  @wybe_malloc(i32  %179)  
  %181 = ptrtoint i8* %180 to i64 
  %182 = inttoptr i64 %181 to i64* 
  %183 = getelementptr  i64, i64* %182, i64 0 
  store  i64 %"f01#0", i64* %183 
  ret i64 %181 
}


define external fastcc  {i64, i1} @"multictr.complicated.c01<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 0 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %191 = insertvalue {i64, i1} undef, i64 undef, 0 
  %192 = insertvalue {i64, i1} %191, i1 0, 1 
  ret {i64, i1} %192 
if.then1:
  %184 = inttoptr i64 %"$#0" to i64* 
  %185 = getelementptr  i64, i64* %184, i64 0 
  %186 = load  i64, i64* %185 
  %187 = insertvalue {i64, i1} undef, i64 %186, 0 
  %188 = insertvalue {i64, i1} %187, i1 1, 1 
  ret {i64, i1} %188 
if.else1:
  %189 = insertvalue {i64, i1} undef, i64 undef, 0 
  %190 = insertvalue {i64, i1} %189, i1 0, 1 
  ret {i64, i1} %190 
}


define external fastcc  i64 @"multictr.complicated.c02<0>"(i64  %"f02#0")    {
entry:
  %193 = trunc i64 8 to i32  
  %194 = tail call ccc  i8*  @wybe_malloc(i32  %193)  
  %195 = ptrtoint i8* %194 to i64 
  %196 = inttoptr i64 %195 to i64* 
  %197 = getelementptr  i64, i64* %196, i64 0 
  store  i64 %"f02#0", i64* %197 
  %"1$$#0" = or i64 %195, 1 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c02<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 1 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %206 = insertvalue {i64, i1} undef, i64 undef, 0 
  %207 = insertvalue {i64, i1} %206, i1 0, 1 
  ret {i64, i1} %207 
if.then1:
  %198 = add   i64 %"$#0", -1 
  %199 = inttoptr i64 %198 to i64* 
  %200 = getelementptr  i64, i64* %199, i64 0 
  %201 = load  i64, i64* %200 
  %202 = insertvalue {i64, i1} undef, i64 %201, 0 
  %203 = insertvalue {i64, i1} %202, i1 1, 1 
  ret {i64, i1} %203 
if.else1:
  %204 = insertvalue {i64, i1} undef, i64 undef, 0 
  %205 = insertvalue {i64, i1} %204, i1 0, 1 
  ret {i64, i1} %205 
}


define external fastcc  i64 @"multictr.complicated.c03<0>"(i64  %"f03#0")    {
entry:
  %208 = trunc i64 8 to i32  
  %209 = tail call ccc  i8*  @wybe_malloc(i32  %208)  
  %210 = ptrtoint i8* %209 to i64 
  %211 = inttoptr i64 %210 to i64* 
  %212 = getelementptr  i64, i64* %211, i64 0 
  store  i64 %"f03#0", i64* %212 
  %"1$$#0" = or i64 %210, 2 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c03<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 2 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %221 = insertvalue {i64, i1} undef, i64 undef, 0 
  %222 = insertvalue {i64, i1} %221, i1 0, 1 
  ret {i64, i1} %222 
if.then1:
  %213 = add   i64 %"$#0", -2 
  %214 = inttoptr i64 %213 to i64* 
  %215 = getelementptr  i64, i64* %214, i64 0 
  %216 = load  i64, i64* %215 
  %217 = insertvalue {i64, i1} undef, i64 %216, 0 
  %218 = insertvalue {i64, i1} %217, i1 1, 1 
  ret {i64, i1} %218 
if.else1:
  %219 = insertvalue {i64, i1} undef, i64 undef, 0 
  %220 = insertvalue {i64, i1} %219, i1 0, 1 
  ret {i64, i1} %220 
}


define external fastcc  i64 @"multictr.complicated.c04<0>"(i64  %"f04#0")    {
entry:
  %223 = trunc i64 8 to i32  
  %224 = tail call ccc  i8*  @wybe_malloc(i32  %223)  
  %225 = ptrtoint i8* %224 to i64 
  %226 = inttoptr i64 %225 to i64* 
  %227 = getelementptr  i64, i64* %226, i64 0 
  store  i64 %"f04#0", i64* %227 
  %"1$$#0" = or i64 %225, 3 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c04<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 3 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %236 = insertvalue {i64, i1} undef, i64 undef, 0 
  %237 = insertvalue {i64, i1} %236, i1 0, 1 
  ret {i64, i1} %237 
if.then1:
  %228 = add   i64 %"$#0", -3 
  %229 = inttoptr i64 %228 to i64* 
  %230 = getelementptr  i64, i64* %229, i64 0 
  %231 = load  i64, i64* %230 
  %232 = insertvalue {i64, i1} undef, i64 %231, 0 
  %233 = insertvalue {i64, i1} %232, i1 1, 1 
  ret {i64, i1} %233 
if.else1:
  %234 = insertvalue {i64, i1} undef, i64 undef, 0 
  %235 = insertvalue {i64, i1} %234, i1 0, 1 
  ret {i64, i1} %235 
}


define external fastcc  i64 @"multictr.complicated.c05<0>"(i64  %"f05#0")    {
entry:
  %238 = trunc i64 8 to i32  
  %239 = tail call ccc  i8*  @wybe_malloc(i32  %238)  
  %240 = ptrtoint i8* %239 to i64 
  %241 = inttoptr i64 %240 to i64* 
  %242 = getelementptr  i64, i64* %241, i64 0 
  store  i64 %"f05#0", i64* %242 
  %"1$$#0" = or i64 %240, 4 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c05<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 4 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %251 = insertvalue {i64, i1} undef, i64 undef, 0 
  %252 = insertvalue {i64, i1} %251, i1 0, 1 
  ret {i64, i1} %252 
if.then1:
  %243 = add   i64 %"$#0", -4 
  %244 = inttoptr i64 %243 to i64* 
  %245 = getelementptr  i64, i64* %244, i64 0 
  %246 = load  i64, i64* %245 
  %247 = insertvalue {i64, i1} undef, i64 %246, 0 
  %248 = insertvalue {i64, i1} %247, i1 1, 1 
  ret {i64, i1} %248 
if.else1:
  %249 = insertvalue {i64, i1} undef, i64 undef, 0 
  %250 = insertvalue {i64, i1} %249, i1 0, 1 
  ret {i64, i1} %250 
}


define external fastcc  i64 @"multictr.complicated.c06<0>"(i64  %"f06#0")    {
entry:
  %253 = trunc i64 8 to i32  
  %254 = tail call ccc  i8*  @wybe_malloc(i32  %253)  
  %255 = ptrtoint i8* %254 to i64 
  %256 = inttoptr i64 %255 to i64* 
  %257 = getelementptr  i64, i64* %256, i64 0 
  store  i64 %"f06#0", i64* %257 
  %"1$$#0" = or i64 %255, 5 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c06<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 5 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %266 = insertvalue {i64, i1} undef, i64 undef, 0 
  %267 = insertvalue {i64, i1} %266, i1 0, 1 
  ret {i64, i1} %267 
if.then1:
  %258 = add   i64 %"$#0", -5 
  %259 = inttoptr i64 %258 to i64* 
  %260 = getelementptr  i64, i64* %259, i64 0 
  %261 = load  i64, i64* %260 
  %262 = insertvalue {i64, i1} undef, i64 %261, 0 
  %263 = insertvalue {i64, i1} %262, i1 1, 1 
  ret {i64, i1} %263 
if.else1:
  %264 = insertvalue {i64, i1} undef, i64 undef, 0 
  %265 = insertvalue {i64, i1} %264, i1 0, 1 
  ret {i64, i1} %265 
}


define external fastcc  i64 @"multictr.complicated.c07<0>"(i64  %"f07#0")    {
entry:
  %268 = trunc i64 8 to i32  
  %269 = tail call ccc  i8*  @wybe_malloc(i32  %268)  
  %270 = ptrtoint i8* %269 to i64 
  %271 = inttoptr i64 %270 to i64* 
  %272 = getelementptr  i64, i64* %271, i64 0 
  store  i64 %"f07#0", i64* %272 
  %"1$$#0" = or i64 %270, 6 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c07<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 6 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %281 = insertvalue {i64, i1} undef, i64 undef, 0 
  %282 = insertvalue {i64, i1} %281, i1 0, 1 
  ret {i64, i1} %282 
if.then1:
  %273 = add   i64 %"$#0", -6 
  %274 = inttoptr i64 %273 to i64* 
  %275 = getelementptr  i64, i64* %274, i64 0 
  %276 = load  i64, i64* %275 
  %277 = insertvalue {i64, i1} undef, i64 %276, 0 
  %278 = insertvalue {i64, i1} %277, i1 1, 1 
  ret {i64, i1} %278 
if.else1:
  %279 = insertvalue {i64, i1} undef, i64 undef, 0 
  %280 = insertvalue {i64, i1} %279, i1 0, 1 
  ret {i64, i1} %280 
}


define external fastcc  i64 @"multictr.complicated.c08<0>"(i64  %"f08#0")    {
entry:
  %283 = trunc i64 16 to i32  
  %284 = tail call ccc  i8*  @wybe_malloc(i32  %283)  
  %285 = ptrtoint i8* %284 to i64 
  %286 = inttoptr i64 %285 to i64* 
  %287 = getelementptr  i64, i64* %286, i64 0 
  store  i64 7, i64* %287 
  %288 = add   i64 %285, 8 
  %289 = inttoptr i64 %288 to i64* 
  %290 = getelementptr  i64, i64* %289, i64 0 
  store  i64 %"f08#0", i64* %290 
  %"1$$#0" = or i64 %285, 7 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c08<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %305 = insertvalue {i64, i1} undef, i64 undef, 0 
  %306 = insertvalue {i64, i1} %305, i1 0, 1 
  ret {i64, i1} %306 
if.then1:
  %291 = add   i64 %"$#0", -7 
  %292 = inttoptr i64 %291 to i16* 
  %293 = getelementptr  i16, i16* %292, i64 0 
  %294 = load  i16, i16* %293 
  %"4$tmp$3#0" = icmp eq i16 %294, 7 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %303 = insertvalue {i64, i1} undef, i64 undef, 0 
  %304 = insertvalue {i64, i1} %303, i1 0, 1 
  ret {i64, i1} %304 
if.then2:
  %295 = add   i64 %"$#0", 1 
  %296 = inttoptr i64 %295 to i64* 
  %297 = getelementptr  i64, i64* %296, i64 0 
  %298 = load  i64, i64* %297 
  %299 = insertvalue {i64, i1} undef, i64 %298, 0 
  %300 = insertvalue {i64, i1} %299, i1 1, 1 
  ret {i64, i1} %300 
if.else2:
  %301 = insertvalue {i64, i1} undef, i64 undef, 0 
  %302 = insertvalue {i64, i1} %301, i1 0, 1 
  ret {i64, i1} %302 
}


define external fastcc  i64 @"multictr.complicated.c09<0>"(i64  %"f09#0")    {
entry:
  %307 = trunc i64 16 to i32  
  %308 = tail call ccc  i8*  @wybe_malloc(i32  %307)  
  %309 = ptrtoint i8* %308 to i64 
  %310 = inttoptr i64 %309 to i64* 
  %311 = getelementptr  i64, i64* %310, i64 0 
  store  i64 8, i64* %311 
  %312 = add   i64 %309, 8 
  %313 = inttoptr i64 %312 to i64* 
  %314 = getelementptr  i64, i64* %313, i64 0 
  store  i64 %"f09#0", i64* %314 
  %"1$$#0" = or i64 %309, 7 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c09<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %329 = insertvalue {i64, i1} undef, i64 undef, 0 
  %330 = insertvalue {i64, i1} %329, i1 0, 1 
  ret {i64, i1} %330 
if.then1:
  %315 = add   i64 %"$#0", -7 
  %316 = inttoptr i64 %315 to i16* 
  %317 = getelementptr  i16, i16* %316, i64 0 
  %318 = load  i16, i16* %317 
  %"4$tmp$3#0" = icmp eq i16 %318, 8 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %327 = insertvalue {i64, i1} undef, i64 undef, 0 
  %328 = insertvalue {i64, i1} %327, i1 0, 1 
  ret {i64, i1} %328 
if.then2:
  %319 = add   i64 %"$#0", 1 
  %320 = inttoptr i64 %319 to i64* 
  %321 = getelementptr  i64, i64* %320, i64 0 
  %322 = load  i64, i64* %321 
  %323 = insertvalue {i64, i1} undef, i64 %322, 0 
  %324 = insertvalue {i64, i1} %323, i1 1, 1 
  ret {i64, i1} %324 
if.else2:
  %325 = insertvalue {i64, i1} undef, i64 undef, 0 
  %326 = insertvalue {i64, i1} %325, i1 0, 1 
  ret {i64, i1} %326 
}


define external fastcc  i64 @"multictr.complicated.c10<0>"(i64  %"f10#0")    {
entry:
  %331 = trunc i64 16 to i32  
  %332 = tail call ccc  i8*  @wybe_malloc(i32  %331)  
  %333 = ptrtoint i8* %332 to i64 
  %334 = inttoptr i64 %333 to i64* 
  %335 = getelementptr  i64, i64* %334, i64 0 
  store  i64 9, i64* %335 
  %336 = add   i64 %333, 8 
  %337 = inttoptr i64 %336 to i64* 
  %338 = getelementptr  i64, i64* %337, i64 0 
  store  i64 %"f10#0", i64* %338 
  %"1$$#0" = or i64 %333, 7 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c10<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %353 = insertvalue {i64, i1} undef, i64 undef, 0 
  %354 = insertvalue {i64, i1} %353, i1 0, 1 
  ret {i64, i1} %354 
if.then1:
  %339 = add   i64 %"$#0", -7 
  %340 = inttoptr i64 %339 to i16* 
  %341 = getelementptr  i16, i16* %340, i64 0 
  %342 = load  i16, i16* %341 
  %"4$tmp$3#0" = icmp eq i16 %342, 9 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %351 = insertvalue {i64, i1} undef, i64 undef, 0 
  %352 = insertvalue {i64, i1} %351, i1 0, 1 
  ret {i64, i1} %352 
if.then2:
  %343 = add   i64 %"$#0", 1 
  %344 = inttoptr i64 %343 to i64* 
  %345 = getelementptr  i64, i64* %344, i64 0 
  %346 = load  i64, i64* %345 
  %347 = insertvalue {i64, i1} undef, i64 %346, 0 
  %348 = insertvalue {i64, i1} %347, i1 1, 1 
  ret {i64, i1} %348 
if.else2:
  %349 = insertvalue {i64, i1} undef, i64 undef, 0 
  %350 = insertvalue {i64, i1} %349, i1 0, 1 
  ret {i64, i1} %350 
}


define external fastcc  i64 @"multictr.complicated.c11<0>"(i64  %"f11#0")    {
entry:
  %355 = trunc i64 16 to i32  
  %356 = tail call ccc  i8*  @wybe_malloc(i32  %355)  
  %357 = ptrtoint i8* %356 to i64 
  %358 = inttoptr i64 %357 to i64* 
  %359 = getelementptr  i64, i64* %358, i64 0 
  store  i64 10, i64* %359 
  %360 = add   i64 %357, 8 
  %361 = inttoptr i64 %360 to i64* 
  %362 = getelementptr  i64, i64* %361, i64 0 
  store  i64 %"f11#0", i64* %362 
  %"1$$#0" = or i64 %357, 7 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c11<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %377 = insertvalue {i64, i1} undef, i64 undef, 0 
  %378 = insertvalue {i64, i1} %377, i1 0, 1 
  ret {i64, i1} %378 
if.then1:
  %363 = add   i64 %"$#0", -7 
  %364 = inttoptr i64 %363 to i16* 
  %365 = getelementptr  i16, i16* %364, i64 0 
  %366 = load  i16, i16* %365 
  %"4$tmp$3#0" = icmp eq i16 %366, 10 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %375 = insertvalue {i64, i1} undef, i64 undef, 0 
  %376 = insertvalue {i64, i1} %375, i1 0, 1 
  ret {i64, i1} %376 
if.then2:
  %367 = add   i64 %"$#0", 1 
  %368 = inttoptr i64 %367 to i64* 
  %369 = getelementptr  i64, i64* %368, i64 0 
  %370 = load  i64, i64* %369 
  %371 = insertvalue {i64, i1} undef, i64 %370, 0 
  %372 = insertvalue {i64, i1} %371, i1 1, 1 
  ret {i64, i1} %372 
if.else2:
  %373 = insertvalue {i64, i1} undef, i64 undef, 0 
  %374 = insertvalue {i64, i1} %373, i1 0, 1 
  ret {i64, i1} %374 
}


define external fastcc  i64 @"multictr.complicated.c12<0>"(i64  %"f12#0")    {
entry:
  %379 = trunc i64 16 to i32  
  %380 = tail call ccc  i8*  @wybe_malloc(i32  %379)  
  %381 = ptrtoint i8* %380 to i64 
  %382 = inttoptr i64 %381 to i64* 
  %383 = getelementptr  i64, i64* %382, i64 0 
  store  i64 11, i64* %383 
  %384 = add   i64 %381, 8 
  %385 = inttoptr i64 %384 to i64* 
  %386 = getelementptr  i64, i64* %385, i64 0 
  store  i64 %"f12#0", i64* %386 
  %"1$$#0" = or i64 %381, 7 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c12<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %401 = insertvalue {i64, i1} undef, i64 undef, 0 
  %402 = insertvalue {i64, i1} %401, i1 0, 1 
  ret {i64, i1} %402 
if.then1:
  %387 = add   i64 %"$#0", -7 
  %388 = inttoptr i64 %387 to i16* 
  %389 = getelementptr  i16, i16* %388, i64 0 
  %390 = load  i16, i16* %389 
  %"4$tmp$3#0" = icmp eq i16 %390, 11 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %399 = insertvalue {i64, i1} undef, i64 undef, 0 
  %400 = insertvalue {i64, i1} %399, i1 0, 1 
  ret {i64, i1} %400 
if.then2:
  %391 = add   i64 %"$#0", 1 
  %392 = inttoptr i64 %391 to i64* 
  %393 = getelementptr  i64, i64* %392, i64 0 
  %394 = load  i64, i64* %393 
  %395 = insertvalue {i64, i1} undef, i64 %394, 0 
  %396 = insertvalue {i64, i1} %395, i1 1, 1 
  ret {i64, i1} %396 
if.else2:
  %397 = insertvalue {i64, i1} undef, i64 undef, 0 
  %398 = insertvalue {i64, i1} %397, i1 0, 1 
  ret {i64, i1} %398 
}


define external fastcc  i64 @"multictr.complicated.c13<0>"(i64  %"f13#0")    {
entry:
  %403 = trunc i64 16 to i32  
  %404 = tail call ccc  i8*  @wybe_malloc(i32  %403)  
  %405 = ptrtoint i8* %404 to i64 
  %406 = inttoptr i64 %405 to i64* 
  %407 = getelementptr  i64, i64* %406, i64 0 
  store  i64 12, i64* %407 
  %408 = add   i64 %405, 8 
  %409 = inttoptr i64 %408 to i64* 
  %410 = getelementptr  i64, i64* %409, i64 0 
  store  i64 %"f13#0", i64* %410 
  %"1$$#0" = or i64 %405, 7 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c13<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %425 = insertvalue {i64, i1} undef, i64 undef, 0 
  %426 = insertvalue {i64, i1} %425, i1 0, 1 
  ret {i64, i1} %426 
if.then1:
  %411 = add   i64 %"$#0", -7 
  %412 = inttoptr i64 %411 to i16* 
  %413 = getelementptr  i16, i16* %412, i64 0 
  %414 = load  i16, i16* %413 
  %"4$tmp$3#0" = icmp eq i16 %414, 12 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %423 = insertvalue {i64, i1} undef, i64 undef, 0 
  %424 = insertvalue {i64, i1} %423, i1 0, 1 
  ret {i64, i1} %424 
if.then2:
  %415 = add   i64 %"$#0", 1 
  %416 = inttoptr i64 %415 to i64* 
  %417 = getelementptr  i64, i64* %416, i64 0 
  %418 = load  i64, i64* %417 
  %419 = insertvalue {i64, i1} undef, i64 %418, 0 
  %420 = insertvalue {i64, i1} %419, i1 1, 1 
  ret {i64, i1} %420 
if.else2:
  %421 = insertvalue {i64, i1} undef, i64 undef, 0 
  %422 = insertvalue {i64, i1} %421, i1 0, 1 
  ret {i64, i1} %422 
}


define external fastcc  i64 @"multictr.complicated.c14<0>"(i64  %"f14#0")    {
entry:
  %427 = trunc i64 16 to i32  
  %428 = tail call ccc  i8*  @wybe_malloc(i32  %427)  
  %429 = ptrtoint i8* %428 to i64 
  %430 = inttoptr i64 %429 to i64* 
  %431 = getelementptr  i64, i64* %430, i64 0 
  store  i64 13, i64* %431 
  %432 = add   i64 %429, 8 
  %433 = inttoptr i64 %432 to i64* 
  %434 = getelementptr  i64, i64* %433, i64 0 
  store  i64 %"f14#0", i64* %434 
  %"1$$#0" = or i64 %429, 7 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c14<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %449 = insertvalue {i64, i1} undef, i64 undef, 0 
  %450 = insertvalue {i64, i1} %449, i1 0, 1 
  ret {i64, i1} %450 
if.then1:
  %435 = add   i64 %"$#0", -7 
  %436 = inttoptr i64 %435 to i16* 
  %437 = getelementptr  i16, i16* %436, i64 0 
  %438 = load  i16, i16* %437 
  %"4$tmp$3#0" = icmp eq i16 %438, 13 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %447 = insertvalue {i64, i1} undef, i64 undef, 0 
  %448 = insertvalue {i64, i1} %447, i1 0, 1 
  ret {i64, i1} %448 
if.then2:
  %439 = add   i64 %"$#0", 1 
  %440 = inttoptr i64 %439 to i64* 
  %441 = getelementptr  i64, i64* %440, i64 0 
  %442 = load  i64, i64* %441 
  %443 = insertvalue {i64, i1} undef, i64 %442, 0 
  %444 = insertvalue {i64, i1} %443, i1 1, 1 
  ret {i64, i1} %444 
if.else2:
  %445 = insertvalue {i64, i1} undef, i64 undef, 0 
  %446 = insertvalue {i64, i1} %445, i1 0, 1 
  ret {i64, i1} %446 
}


define external fastcc  i64 @"multictr.complicated.c15<0>"(i64  %"f15#0")    {
entry:
  %451 = trunc i64 16 to i32  
  %452 = tail call ccc  i8*  @wybe_malloc(i32  %451)  
  %453 = ptrtoint i8* %452 to i64 
  %454 = inttoptr i64 %453 to i64* 
  %455 = getelementptr  i64, i64* %454, i64 0 
  store  i64 14, i64* %455 
  %456 = add   i64 %453, 8 
  %457 = inttoptr i64 %456 to i64* 
  %458 = getelementptr  i64, i64* %457, i64 0 
  store  i64 %"f15#0", i64* %458 
  %"1$$#0" = or i64 %453, 7 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c15<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %473 = insertvalue {i64, i1} undef, i64 undef, 0 
  %474 = insertvalue {i64, i1} %473, i1 0, 1 
  ret {i64, i1} %474 
if.then1:
  %459 = add   i64 %"$#0", -7 
  %460 = inttoptr i64 %459 to i16* 
  %461 = getelementptr  i16, i16* %460, i64 0 
  %462 = load  i16, i16* %461 
  %"4$tmp$3#0" = icmp eq i16 %462, 14 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %471 = insertvalue {i64, i1} undef, i64 undef, 0 
  %472 = insertvalue {i64, i1} %471, i1 0, 1 
  ret {i64, i1} %472 
if.then2:
  %463 = add   i64 %"$#0", 1 
  %464 = inttoptr i64 %463 to i64* 
  %465 = getelementptr  i64, i64* %464, i64 0 
  %466 = load  i64, i64* %465 
  %467 = insertvalue {i64, i1} undef, i64 %466, 0 
  %468 = insertvalue {i64, i1} %467, i1 1, 1 
  ret {i64, i1} %468 
if.else2:
  %469 = insertvalue {i64, i1} undef, i64 undef, 0 
  %470 = insertvalue {i64, i1} %469, i1 0, 1 
  ret {i64, i1} %470 
}


define external fastcc  i64 @"multictr.complicated.c16<0>"(i64  %"f16#0")    {
entry:
  %475 = trunc i64 16 to i32  
  %476 = tail call ccc  i8*  @wybe_malloc(i32  %475)  
  %477 = ptrtoint i8* %476 to i64 
  %478 = inttoptr i64 %477 to i64* 
  %479 = getelementptr  i64, i64* %478, i64 0 
  store  i64 15, i64* %479 
  %480 = add   i64 %477, 8 
  %481 = inttoptr i64 %480 to i64* 
  %482 = getelementptr  i64, i64* %481, i64 0 
  store  i64 %"f16#0", i64* %482 
  %"1$$#0" = or i64 %477, 7 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c16<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %497 = insertvalue {i64, i1} undef, i64 undef, 0 
  %498 = insertvalue {i64, i1} %497, i1 0, 1 
  ret {i64, i1} %498 
if.then1:
  %483 = add   i64 %"$#0", -7 
  %484 = inttoptr i64 %483 to i16* 
  %485 = getelementptr  i16, i16* %484, i64 0 
  %486 = load  i16, i16* %485 
  %"4$tmp$3#0" = icmp eq i16 %486, 15 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %495 = insertvalue {i64, i1} undef, i64 undef, 0 
  %496 = insertvalue {i64, i1} %495, i1 0, 1 
  ret {i64, i1} %496 
if.then2:
  %487 = add   i64 %"$#0", 1 
  %488 = inttoptr i64 %487 to i64* 
  %489 = getelementptr  i64, i64* %488, i64 0 
  %490 = load  i64, i64* %489 
  %491 = insertvalue {i64, i1} undef, i64 %490, 0 
  %492 = insertvalue {i64, i1} %491, i1 1, 1 
  ret {i64, i1} %492 
if.else2:
  %493 = insertvalue {i64, i1} undef, i64 undef, 0 
  %494 = insertvalue {i64, i1} %493, i1 0, 1 
  ret {i64, i1} %494 
}


define external fastcc  i64 @"multictr.complicated.c17<0>"(i64  %"f17#0")    {
entry:
  %499 = trunc i64 16 to i32  
  %500 = tail call ccc  i8*  @wybe_malloc(i32  %499)  
  %501 = ptrtoint i8* %500 to i64 
  %502 = inttoptr i64 %501 to i64* 
  %503 = getelementptr  i64, i64* %502, i64 0 
  store  i64 16, i64* %503 
  %504 = add   i64 %501, 8 
  %505 = inttoptr i64 %504 to i64* 
  %506 = getelementptr  i64, i64* %505, i64 0 
  store  i64 %"f17#0", i64* %506 
  %"1$$#0" = or i64 %501, 7 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c17<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %521 = insertvalue {i64, i1} undef, i64 undef, 0 
  %522 = insertvalue {i64, i1} %521, i1 0, 1 
  ret {i64, i1} %522 
if.then1:
  %507 = add   i64 %"$#0", -7 
  %508 = inttoptr i64 %507 to i16* 
  %509 = getelementptr  i16, i16* %508, i64 0 
  %510 = load  i16, i16* %509 
  %"4$tmp$3#0" = icmp eq i16 %510, 16 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %519 = insertvalue {i64, i1} undef, i64 undef, 0 
  %520 = insertvalue {i64, i1} %519, i1 0, 1 
  ret {i64, i1} %520 
if.then2:
  %511 = add   i64 %"$#0", 1 
  %512 = inttoptr i64 %511 to i64* 
  %513 = getelementptr  i64, i64* %512, i64 0 
  %514 = load  i64, i64* %513 
  %515 = insertvalue {i64, i1} undef, i64 %514, 0 
  %516 = insertvalue {i64, i1} %515, i1 1, 1 
  ret {i64, i1} %516 
if.else2:
  %517 = insertvalue {i64, i1} undef, i64 undef, 0 
  %518 = insertvalue {i64, i1} %517, i1 0, 1 
  ret {i64, i1} %518 
}


define external fastcc  {i64, i1} @"multictr.complicated.f01<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 0 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %530 = insertvalue {i64, i1} undef, i64 undef, 0 
  %531 = insertvalue {i64, i1} %530, i1 0, 1 
  ret {i64, i1} %531 
if.then1:
  %523 = inttoptr i64 %"$rec#0" to i64* 
  %524 = getelementptr  i64, i64* %523, i64 0 
  %525 = load  i64, i64* %524 
  %526 = insertvalue {i64, i1} undef, i64 %525, 0 
  %527 = insertvalue {i64, i1} %526, i1 1, 1 
  ret {i64, i1} %527 
if.else1:
  %528 = insertvalue {i64, i1} undef, i64 undef, 0 
  %529 = insertvalue {i64, i1} %528, i1 0, 1 
  ret {i64, i1} %529 
}


define external fastcc  {i64, i1} @"multictr.complicated.f01<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 0 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %544 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %545 = insertvalue {i64, i1} %544, i1 0, 1 
  ret {i64, i1} %545 
if.then1:
  %532 = trunc i64 8 to i32  
  %533 = tail call ccc  i8*  @wybe_malloc(i32  %532)  
  %534 = ptrtoint i8* %533 to i64 
  %535 = inttoptr i64 %534 to i8* 
  %536 = inttoptr i64 %"$rec#0" to i8* 
  %537 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %535, i8*  %536, i32  %537, i32  8, i1  0)  
  %538 = inttoptr i64 %534 to i64* 
  %539 = getelementptr  i64, i64* %538, i64 0 
  store  i64 %"$field#0", i64* %539 
  %540 = insertvalue {i64, i1} undef, i64 %534, 0 
  %541 = insertvalue {i64, i1} %540, i1 1, 1 
  ret {i64, i1} %541 
if.else1:
  %542 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %543 = insertvalue {i64, i1} %542, i1 0, 1 
  ret {i64, i1} %543 
}


define external fastcc  {i64, i1} @"multictr.complicated.f02<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 1 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %554 = insertvalue {i64, i1} undef, i64 undef, 0 
  %555 = insertvalue {i64, i1} %554, i1 0, 1 
  ret {i64, i1} %555 
if.then1:
  %546 = add   i64 %"$rec#0", -1 
  %547 = inttoptr i64 %546 to i64* 
  %548 = getelementptr  i64, i64* %547, i64 0 
  %549 = load  i64, i64* %548 
  %550 = insertvalue {i64, i1} undef, i64 %549, 0 
  %551 = insertvalue {i64, i1} %550, i1 1, 1 
  ret {i64, i1} %551 
if.else1:
  %552 = insertvalue {i64, i1} undef, i64 undef, 0 
  %553 = insertvalue {i64, i1} %552, i1 0, 1 
  ret {i64, i1} %553 
}


define external fastcc  {i64, i1} @"multictr.complicated.f02<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 1 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %571 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %572 = insertvalue {i64, i1} %571, i1 0, 1 
  ret {i64, i1} %572 
if.then1:
  %556 = trunc i64 8 to i32  
  %557 = tail call ccc  i8*  @wybe_malloc(i32  %556)  
  %558 = ptrtoint i8* %557 to i64 
  %559 = add   i64 %558, 1 
  %560 = sub   i64 %"$rec#0", 1 
  %561 = inttoptr i64 %558 to i8* 
  %562 = inttoptr i64 %560 to i8* 
  %563 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %561, i8*  %562, i32  %563, i32  8, i1  0)  
  %564 = add   i64 %559, -1 
  %565 = inttoptr i64 %564 to i64* 
  %566 = getelementptr  i64, i64* %565, i64 0 
  store  i64 %"$field#0", i64* %566 
  %567 = insertvalue {i64, i1} undef, i64 %559, 0 
  %568 = insertvalue {i64, i1} %567, i1 1, 1 
  ret {i64, i1} %568 
if.else1:
  %569 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %570 = insertvalue {i64, i1} %569, i1 0, 1 
  ret {i64, i1} %570 
}


define external fastcc  {i64, i1} @"multictr.complicated.f03<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 2 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %581 = insertvalue {i64, i1} undef, i64 undef, 0 
  %582 = insertvalue {i64, i1} %581, i1 0, 1 
  ret {i64, i1} %582 
if.then1:
  %573 = add   i64 %"$rec#0", -2 
  %574 = inttoptr i64 %573 to i64* 
  %575 = getelementptr  i64, i64* %574, i64 0 
  %576 = load  i64, i64* %575 
  %577 = insertvalue {i64, i1} undef, i64 %576, 0 
  %578 = insertvalue {i64, i1} %577, i1 1, 1 
  ret {i64, i1} %578 
if.else1:
  %579 = insertvalue {i64, i1} undef, i64 undef, 0 
  %580 = insertvalue {i64, i1} %579, i1 0, 1 
  ret {i64, i1} %580 
}


define external fastcc  {i64, i1} @"multictr.complicated.f03<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 2 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %598 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %599 = insertvalue {i64, i1} %598, i1 0, 1 
  ret {i64, i1} %599 
if.then1:
  %583 = trunc i64 8 to i32  
  %584 = tail call ccc  i8*  @wybe_malloc(i32  %583)  
  %585 = ptrtoint i8* %584 to i64 
  %586 = add   i64 %585, 2 
  %587 = sub   i64 %"$rec#0", 2 
  %588 = inttoptr i64 %585 to i8* 
  %589 = inttoptr i64 %587 to i8* 
  %590 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %588, i8*  %589, i32  %590, i32  8, i1  0)  
  %591 = add   i64 %586, -2 
  %592 = inttoptr i64 %591 to i64* 
  %593 = getelementptr  i64, i64* %592, i64 0 
  store  i64 %"$field#0", i64* %593 
  %594 = insertvalue {i64, i1} undef, i64 %586, 0 
  %595 = insertvalue {i64, i1} %594, i1 1, 1 
  ret {i64, i1} %595 
if.else1:
  %596 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %597 = insertvalue {i64, i1} %596, i1 0, 1 
  ret {i64, i1} %597 
}


define external fastcc  {i64, i1} @"multictr.complicated.f04<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 3 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %608 = insertvalue {i64, i1} undef, i64 undef, 0 
  %609 = insertvalue {i64, i1} %608, i1 0, 1 
  ret {i64, i1} %609 
if.then1:
  %600 = add   i64 %"$rec#0", -3 
  %601 = inttoptr i64 %600 to i64* 
  %602 = getelementptr  i64, i64* %601, i64 0 
  %603 = load  i64, i64* %602 
  %604 = insertvalue {i64, i1} undef, i64 %603, 0 
  %605 = insertvalue {i64, i1} %604, i1 1, 1 
  ret {i64, i1} %605 
if.else1:
  %606 = insertvalue {i64, i1} undef, i64 undef, 0 
  %607 = insertvalue {i64, i1} %606, i1 0, 1 
  ret {i64, i1} %607 
}


define external fastcc  {i64, i1} @"multictr.complicated.f04<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 3 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %625 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %626 = insertvalue {i64, i1} %625, i1 0, 1 
  ret {i64, i1} %626 
if.then1:
  %610 = trunc i64 8 to i32  
  %611 = tail call ccc  i8*  @wybe_malloc(i32  %610)  
  %612 = ptrtoint i8* %611 to i64 
  %613 = add   i64 %612, 3 
  %614 = sub   i64 %"$rec#0", 3 
  %615 = inttoptr i64 %612 to i8* 
  %616 = inttoptr i64 %614 to i8* 
  %617 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %615, i8*  %616, i32  %617, i32  8, i1  0)  
  %618 = add   i64 %613, -3 
  %619 = inttoptr i64 %618 to i64* 
  %620 = getelementptr  i64, i64* %619, i64 0 
  store  i64 %"$field#0", i64* %620 
  %621 = insertvalue {i64, i1} undef, i64 %613, 0 
  %622 = insertvalue {i64, i1} %621, i1 1, 1 
  ret {i64, i1} %622 
if.else1:
  %623 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %624 = insertvalue {i64, i1} %623, i1 0, 1 
  ret {i64, i1} %624 
}


define external fastcc  {i64, i1} @"multictr.complicated.f05<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 4 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %635 = insertvalue {i64, i1} undef, i64 undef, 0 
  %636 = insertvalue {i64, i1} %635, i1 0, 1 
  ret {i64, i1} %636 
if.then1:
  %627 = add   i64 %"$rec#0", -4 
  %628 = inttoptr i64 %627 to i64* 
  %629 = getelementptr  i64, i64* %628, i64 0 
  %630 = load  i64, i64* %629 
  %631 = insertvalue {i64, i1} undef, i64 %630, 0 
  %632 = insertvalue {i64, i1} %631, i1 1, 1 
  ret {i64, i1} %632 
if.else1:
  %633 = insertvalue {i64, i1} undef, i64 undef, 0 
  %634 = insertvalue {i64, i1} %633, i1 0, 1 
  ret {i64, i1} %634 
}


define external fastcc  {i64, i1} @"multictr.complicated.f05<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 4 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %652 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %653 = insertvalue {i64, i1} %652, i1 0, 1 
  ret {i64, i1} %653 
if.then1:
  %637 = trunc i64 8 to i32  
  %638 = tail call ccc  i8*  @wybe_malloc(i32  %637)  
  %639 = ptrtoint i8* %638 to i64 
  %640 = add   i64 %639, 4 
  %641 = sub   i64 %"$rec#0", 4 
  %642 = inttoptr i64 %639 to i8* 
  %643 = inttoptr i64 %641 to i8* 
  %644 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %642, i8*  %643, i32  %644, i32  8, i1  0)  
  %645 = add   i64 %640, -4 
  %646 = inttoptr i64 %645 to i64* 
  %647 = getelementptr  i64, i64* %646, i64 0 
  store  i64 %"$field#0", i64* %647 
  %648 = insertvalue {i64, i1} undef, i64 %640, 0 
  %649 = insertvalue {i64, i1} %648, i1 1, 1 
  ret {i64, i1} %649 
if.else1:
  %650 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %651 = insertvalue {i64, i1} %650, i1 0, 1 
  ret {i64, i1} %651 
}


define external fastcc  {i64, i1} @"multictr.complicated.f06<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 5 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %662 = insertvalue {i64, i1} undef, i64 undef, 0 
  %663 = insertvalue {i64, i1} %662, i1 0, 1 
  ret {i64, i1} %663 
if.then1:
  %654 = add   i64 %"$rec#0", -5 
  %655 = inttoptr i64 %654 to i64* 
  %656 = getelementptr  i64, i64* %655, i64 0 
  %657 = load  i64, i64* %656 
  %658 = insertvalue {i64, i1} undef, i64 %657, 0 
  %659 = insertvalue {i64, i1} %658, i1 1, 1 
  ret {i64, i1} %659 
if.else1:
  %660 = insertvalue {i64, i1} undef, i64 undef, 0 
  %661 = insertvalue {i64, i1} %660, i1 0, 1 
  ret {i64, i1} %661 
}


define external fastcc  {i64, i1} @"multictr.complicated.f06<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 5 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %679 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %680 = insertvalue {i64, i1} %679, i1 0, 1 
  ret {i64, i1} %680 
if.then1:
  %664 = trunc i64 8 to i32  
  %665 = tail call ccc  i8*  @wybe_malloc(i32  %664)  
  %666 = ptrtoint i8* %665 to i64 
  %667 = add   i64 %666, 5 
  %668 = sub   i64 %"$rec#0", 5 
  %669 = inttoptr i64 %666 to i8* 
  %670 = inttoptr i64 %668 to i8* 
  %671 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %669, i8*  %670, i32  %671, i32  8, i1  0)  
  %672 = add   i64 %667, -5 
  %673 = inttoptr i64 %672 to i64* 
  %674 = getelementptr  i64, i64* %673, i64 0 
  store  i64 %"$field#0", i64* %674 
  %675 = insertvalue {i64, i1} undef, i64 %667, 0 
  %676 = insertvalue {i64, i1} %675, i1 1, 1 
  ret {i64, i1} %676 
if.else1:
  %677 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %678 = insertvalue {i64, i1} %677, i1 0, 1 
  ret {i64, i1} %678 
}


define external fastcc  {i64, i1} @"multictr.complicated.f07<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 6 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %689 = insertvalue {i64, i1} undef, i64 undef, 0 
  %690 = insertvalue {i64, i1} %689, i1 0, 1 
  ret {i64, i1} %690 
if.then1:
  %681 = add   i64 %"$rec#0", -6 
  %682 = inttoptr i64 %681 to i64* 
  %683 = getelementptr  i64, i64* %682, i64 0 
  %684 = load  i64, i64* %683 
  %685 = insertvalue {i64, i1} undef, i64 %684, 0 
  %686 = insertvalue {i64, i1} %685, i1 1, 1 
  ret {i64, i1} %686 
if.else1:
  %687 = insertvalue {i64, i1} undef, i64 undef, 0 
  %688 = insertvalue {i64, i1} %687, i1 0, 1 
  ret {i64, i1} %688 
}


define external fastcc  {i64, i1} @"multictr.complicated.f07<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 6 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %706 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %707 = insertvalue {i64, i1} %706, i1 0, 1 
  ret {i64, i1} %707 
if.then1:
  %691 = trunc i64 8 to i32  
  %692 = tail call ccc  i8*  @wybe_malloc(i32  %691)  
  %693 = ptrtoint i8* %692 to i64 
  %694 = add   i64 %693, 6 
  %695 = sub   i64 %"$rec#0", 6 
  %696 = inttoptr i64 %693 to i8* 
  %697 = inttoptr i64 %695 to i8* 
  %698 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %696, i8*  %697, i32  %698, i32  8, i1  0)  
  %699 = add   i64 %694, -6 
  %700 = inttoptr i64 %699 to i64* 
  %701 = getelementptr  i64, i64* %700, i64 0 
  store  i64 %"$field#0", i64* %701 
  %702 = insertvalue {i64, i1} undef, i64 %694, 0 
  %703 = insertvalue {i64, i1} %702, i1 1, 1 
  ret {i64, i1} %703 
if.else1:
  %704 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %705 = insertvalue {i64, i1} %704, i1 0, 1 
  ret {i64, i1} %705 
}


define external fastcc  {i64, i1} @"multictr.complicated.f08<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %722 = insertvalue {i64, i1} undef, i64 undef, 0 
  %723 = insertvalue {i64, i1} %722, i1 0, 1 
  ret {i64, i1} %723 
if.then1:
  %708 = add   i64 %"$rec#0", -7 
  %709 = inttoptr i64 %708 to i16* 
  %710 = getelementptr  i16, i16* %709, i64 0 
  %711 = load  i16, i16* %710 
  %"4$tmp$3#0" = icmp eq i16 %711, 7 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %720 = insertvalue {i64, i1} undef, i64 undef, 0 
  %721 = insertvalue {i64, i1} %720, i1 0, 1 
  ret {i64, i1} %721 
if.then2:
  %712 = add   i64 %"$rec#0", 1 
  %713 = inttoptr i64 %712 to i64* 
  %714 = getelementptr  i64, i64* %713, i64 0 
  %715 = load  i64, i64* %714 
  %716 = insertvalue {i64, i1} undef, i64 %715, 0 
  %717 = insertvalue {i64, i1} %716, i1 1, 1 
  ret {i64, i1} %717 
if.else2:
  %718 = insertvalue {i64, i1} undef, i64 undef, 0 
  %719 = insertvalue {i64, i1} %718, i1 0, 1 
  ret {i64, i1} %719 
}


define external fastcc  {i64, i1} @"multictr.complicated.f08<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %745 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %746 = insertvalue {i64, i1} %745, i1 0, 1 
  ret {i64, i1} %746 
if.then1:
  %724 = add   i64 %"$rec#0", -7 
  %725 = inttoptr i64 %724 to i16* 
  %726 = getelementptr  i16, i16* %725, i64 0 
  %727 = load  i16, i16* %726 
  %"4$tmp$3#0" = icmp eq i16 %727, 7 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %743 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %744 = insertvalue {i64, i1} %743, i1 0, 1 
  ret {i64, i1} %744 
if.then2:
  %728 = trunc i64 16 to i32  
  %729 = tail call ccc  i8*  @wybe_malloc(i32  %728)  
  %730 = ptrtoint i8* %729 to i64 
  %731 = add   i64 %730, 7 
  %732 = sub   i64 %"$rec#0", 7 
  %733 = inttoptr i64 %730 to i8* 
  %734 = inttoptr i64 %732 to i8* 
  %735 = trunc i64 16 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %733, i8*  %734, i32  %735, i32  8, i1  0)  
  %736 = add   i64 %731, 1 
  %737 = inttoptr i64 %736 to i64* 
  %738 = getelementptr  i64, i64* %737, i64 0 
  store  i64 %"$field#0", i64* %738 
  %739 = insertvalue {i64, i1} undef, i64 %731, 0 
  %740 = insertvalue {i64, i1} %739, i1 1, 1 
  ret {i64, i1} %740 
if.else2:
  %741 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %742 = insertvalue {i64, i1} %741, i1 0, 1 
  ret {i64, i1} %742 
}


define external fastcc  {i64, i1} @"multictr.complicated.f09<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %761 = insertvalue {i64, i1} undef, i64 undef, 0 
  %762 = insertvalue {i64, i1} %761, i1 0, 1 
  ret {i64, i1} %762 
if.then1:
  %747 = add   i64 %"$rec#0", -7 
  %748 = inttoptr i64 %747 to i16* 
  %749 = getelementptr  i16, i16* %748, i64 0 
  %750 = load  i16, i16* %749 
  %"4$tmp$3#0" = icmp eq i16 %750, 8 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %759 = insertvalue {i64, i1} undef, i64 undef, 0 
  %760 = insertvalue {i64, i1} %759, i1 0, 1 
  ret {i64, i1} %760 
if.then2:
  %751 = add   i64 %"$rec#0", 1 
  %752 = inttoptr i64 %751 to i64* 
  %753 = getelementptr  i64, i64* %752, i64 0 
  %754 = load  i64, i64* %753 
  %755 = insertvalue {i64, i1} undef, i64 %754, 0 
  %756 = insertvalue {i64, i1} %755, i1 1, 1 
  ret {i64, i1} %756 
if.else2:
  %757 = insertvalue {i64, i1} undef, i64 undef, 0 
  %758 = insertvalue {i64, i1} %757, i1 0, 1 
  ret {i64, i1} %758 
}


define external fastcc  {i64, i1} @"multictr.complicated.f09<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %784 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %785 = insertvalue {i64, i1} %784, i1 0, 1 
  ret {i64, i1} %785 
if.then1:
  %763 = add   i64 %"$rec#0", -7 
  %764 = inttoptr i64 %763 to i16* 
  %765 = getelementptr  i16, i16* %764, i64 0 
  %766 = load  i16, i16* %765 
  %"4$tmp$3#0" = icmp eq i16 %766, 8 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %782 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %783 = insertvalue {i64, i1} %782, i1 0, 1 
  ret {i64, i1} %783 
if.then2:
  %767 = trunc i64 16 to i32  
  %768 = tail call ccc  i8*  @wybe_malloc(i32  %767)  
  %769 = ptrtoint i8* %768 to i64 
  %770 = add   i64 %769, 7 
  %771 = sub   i64 %"$rec#0", 7 
  %772 = inttoptr i64 %769 to i8* 
  %773 = inttoptr i64 %771 to i8* 
  %774 = trunc i64 16 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %772, i8*  %773, i32  %774, i32  8, i1  0)  
  %775 = add   i64 %770, 1 
  %776 = inttoptr i64 %775 to i64* 
  %777 = getelementptr  i64, i64* %776, i64 0 
  store  i64 %"$field#0", i64* %777 
  %778 = insertvalue {i64, i1} undef, i64 %770, 0 
  %779 = insertvalue {i64, i1} %778, i1 1, 1 
  ret {i64, i1} %779 
if.else2:
  %780 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %781 = insertvalue {i64, i1} %780, i1 0, 1 
  ret {i64, i1} %781 
}


define external fastcc  {i64, i1} @"multictr.complicated.f10<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %800 = insertvalue {i64, i1} undef, i64 undef, 0 
  %801 = insertvalue {i64, i1} %800, i1 0, 1 
  ret {i64, i1} %801 
if.then1:
  %786 = add   i64 %"$rec#0", -7 
  %787 = inttoptr i64 %786 to i16* 
  %788 = getelementptr  i16, i16* %787, i64 0 
  %789 = load  i16, i16* %788 
  %"4$tmp$3#0" = icmp eq i16 %789, 9 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %798 = insertvalue {i64, i1} undef, i64 undef, 0 
  %799 = insertvalue {i64, i1} %798, i1 0, 1 
  ret {i64, i1} %799 
if.then2:
  %790 = add   i64 %"$rec#0", 1 
  %791 = inttoptr i64 %790 to i64* 
  %792 = getelementptr  i64, i64* %791, i64 0 
  %793 = load  i64, i64* %792 
  %794 = insertvalue {i64, i1} undef, i64 %793, 0 
  %795 = insertvalue {i64, i1} %794, i1 1, 1 
  ret {i64, i1} %795 
if.else2:
  %796 = insertvalue {i64, i1} undef, i64 undef, 0 
  %797 = insertvalue {i64, i1} %796, i1 0, 1 
  ret {i64, i1} %797 
}


define external fastcc  {i64, i1} @"multictr.complicated.f10<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %823 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %824 = insertvalue {i64, i1} %823, i1 0, 1 
  ret {i64, i1} %824 
if.then1:
  %802 = add   i64 %"$rec#0", -7 
  %803 = inttoptr i64 %802 to i16* 
  %804 = getelementptr  i16, i16* %803, i64 0 
  %805 = load  i16, i16* %804 
  %"4$tmp$3#0" = icmp eq i16 %805, 9 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %821 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %822 = insertvalue {i64, i1} %821, i1 0, 1 
  ret {i64, i1} %822 
if.then2:
  %806 = trunc i64 16 to i32  
  %807 = tail call ccc  i8*  @wybe_malloc(i32  %806)  
  %808 = ptrtoint i8* %807 to i64 
  %809 = add   i64 %808, 7 
  %810 = sub   i64 %"$rec#0", 7 
  %811 = inttoptr i64 %808 to i8* 
  %812 = inttoptr i64 %810 to i8* 
  %813 = trunc i64 16 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %811, i8*  %812, i32  %813, i32  8, i1  0)  
  %814 = add   i64 %809, 1 
  %815 = inttoptr i64 %814 to i64* 
  %816 = getelementptr  i64, i64* %815, i64 0 
  store  i64 %"$field#0", i64* %816 
  %817 = insertvalue {i64, i1} undef, i64 %809, 0 
  %818 = insertvalue {i64, i1} %817, i1 1, 1 
  ret {i64, i1} %818 
if.else2:
  %819 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %820 = insertvalue {i64, i1} %819, i1 0, 1 
  ret {i64, i1} %820 
}


define external fastcc  {i64, i1} @"multictr.complicated.f11<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %839 = insertvalue {i64, i1} undef, i64 undef, 0 
  %840 = insertvalue {i64, i1} %839, i1 0, 1 
  ret {i64, i1} %840 
if.then1:
  %825 = add   i64 %"$rec#0", -7 
  %826 = inttoptr i64 %825 to i16* 
  %827 = getelementptr  i16, i16* %826, i64 0 
  %828 = load  i16, i16* %827 
  %"4$tmp$3#0" = icmp eq i16 %828, 10 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %837 = insertvalue {i64, i1} undef, i64 undef, 0 
  %838 = insertvalue {i64, i1} %837, i1 0, 1 
  ret {i64, i1} %838 
if.then2:
  %829 = add   i64 %"$rec#0", 1 
  %830 = inttoptr i64 %829 to i64* 
  %831 = getelementptr  i64, i64* %830, i64 0 
  %832 = load  i64, i64* %831 
  %833 = insertvalue {i64, i1} undef, i64 %832, 0 
  %834 = insertvalue {i64, i1} %833, i1 1, 1 
  ret {i64, i1} %834 
if.else2:
  %835 = insertvalue {i64, i1} undef, i64 undef, 0 
  %836 = insertvalue {i64, i1} %835, i1 0, 1 
  ret {i64, i1} %836 
}


define external fastcc  {i64, i1} @"multictr.complicated.f11<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %862 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %863 = insertvalue {i64, i1} %862, i1 0, 1 
  ret {i64, i1} %863 
if.then1:
  %841 = add   i64 %"$rec#0", -7 
  %842 = inttoptr i64 %841 to i16* 
  %843 = getelementptr  i16, i16* %842, i64 0 
  %844 = load  i16, i16* %843 
  %"4$tmp$3#0" = icmp eq i16 %844, 10 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %860 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %861 = insertvalue {i64, i1} %860, i1 0, 1 
  ret {i64, i1} %861 
if.then2:
  %845 = trunc i64 16 to i32  
  %846 = tail call ccc  i8*  @wybe_malloc(i32  %845)  
  %847 = ptrtoint i8* %846 to i64 
  %848 = add   i64 %847, 7 
  %849 = sub   i64 %"$rec#0", 7 
  %850 = inttoptr i64 %847 to i8* 
  %851 = inttoptr i64 %849 to i8* 
  %852 = trunc i64 16 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %850, i8*  %851, i32  %852, i32  8, i1  0)  
  %853 = add   i64 %848, 1 
  %854 = inttoptr i64 %853 to i64* 
  %855 = getelementptr  i64, i64* %854, i64 0 
  store  i64 %"$field#0", i64* %855 
  %856 = insertvalue {i64, i1} undef, i64 %848, 0 
  %857 = insertvalue {i64, i1} %856, i1 1, 1 
  ret {i64, i1} %857 
if.else2:
  %858 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %859 = insertvalue {i64, i1} %858, i1 0, 1 
  ret {i64, i1} %859 
}


define external fastcc  {i64, i1} @"multictr.complicated.f12<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %878 = insertvalue {i64, i1} undef, i64 undef, 0 
  %879 = insertvalue {i64, i1} %878, i1 0, 1 
  ret {i64, i1} %879 
if.then1:
  %864 = add   i64 %"$rec#0", -7 
  %865 = inttoptr i64 %864 to i16* 
  %866 = getelementptr  i16, i16* %865, i64 0 
  %867 = load  i16, i16* %866 
  %"4$tmp$3#0" = icmp eq i16 %867, 11 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %876 = insertvalue {i64, i1} undef, i64 undef, 0 
  %877 = insertvalue {i64, i1} %876, i1 0, 1 
  ret {i64, i1} %877 
if.then2:
  %868 = add   i64 %"$rec#0", 1 
  %869 = inttoptr i64 %868 to i64* 
  %870 = getelementptr  i64, i64* %869, i64 0 
  %871 = load  i64, i64* %870 
  %872 = insertvalue {i64, i1} undef, i64 %871, 0 
  %873 = insertvalue {i64, i1} %872, i1 1, 1 
  ret {i64, i1} %873 
if.else2:
  %874 = insertvalue {i64, i1} undef, i64 undef, 0 
  %875 = insertvalue {i64, i1} %874, i1 0, 1 
  ret {i64, i1} %875 
}


define external fastcc  {i64, i1} @"multictr.complicated.f12<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %901 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %902 = insertvalue {i64, i1} %901, i1 0, 1 
  ret {i64, i1} %902 
if.then1:
  %880 = add   i64 %"$rec#0", -7 
  %881 = inttoptr i64 %880 to i16* 
  %882 = getelementptr  i16, i16* %881, i64 0 
  %883 = load  i16, i16* %882 
  %"4$tmp$3#0" = icmp eq i16 %883, 11 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %899 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %900 = insertvalue {i64, i1} %899, i1 0, 1 
  ret {i64, i1} %900 
if.then2:
  %884 = trunc i64 16 to i32  
  %885 = tail call ccc  i8*  @wybe_malloc(i32  %884)  
  %886 = ptrtoint i8* %885 to i64 
  %887 = add   i64 %886, 7 
  %888 = sub   i64 %"$rec#0", 7 
  %889 = inttoptr i64 %886 to i8* 
  %890 = inttoptr i64 %888 to i8* 
  %891 = trunc i64 16 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %889, i8*  %890, i32  %891, i32  8, i1  0)  
  %892 = add   i64 %887, 1 
  %893 = inttoptr i64 %892 to i64* 
  %894 = getelementptr  i64, i64* %893, i64 0 
  store  i64 %"$field#0", i64* %894 
  %895 = insertvalue {i64, i1} undef, i64 %887, 0 
  %896 = insertvalue {i64, i1} %895, i1 1, 1 
  ret {i64, i1} %896 
if.else2:
  %897 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %898 = insertvalue {i64, i1} %897, i1 0, 1 
  ret {i64, i1} %898 
}


define external fastcc  {i64, i1} @"multictr.complicated.f13<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %917 = insertvalue {i64, i1} undef, i64 undef, 0 
  %918 = insertvalue {i64, i1} %917, i1 0, 1 
  ret {i64, i1} %918 
if.then1:
  %903 = add   i64 %"$rec#0", -7 
  %904 = inttoptr i64 %903 to i16* 
  %905 = getelementptr  i16, i16* %904, i64 0 
  %906 = load  i16, i16* %905 
  %"4$tmp$3#0" = icmp eq i16 %906, 12 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %915 = insertvalue {i64, i1} undef, i64 undef, 0 
  %916 = insertvalue {i64, i1} %915, i1 0, 1 
  ret {i64, i1} %916 
if.then2:
  %907 = add   i64 %"$rec#0", 1 
  %908 = inttoptr i64 %907 to i64* 
  %909 = getelementptr  i64, i64* %908, i64 0 
  %910 = load  i64, i64* %909 
  %911 = insertvalue {i64, i1} undef, i64 %910, 0 
  %912 = insertvalue {i64, i1} %911, i1 1, 1 
  ret {i64, i1} %912 
if.else2:
  %913 = insertvalue {i64, i1} undef, i64 undef, 0 
  %914 = insertvalue {i64, i1} %913, i1 0, 1 
  ret {i64, i1} %914 
}


define external fastcc  {i64, i1} @"multictr.complicated.f13<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %940 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %941 = insertvalue {i64, i1} %940, i1 0, 1 
  ret {i64, i1} %941 
if.then1:
  %919 = add   i64 %"$rec#0", -7 
  %920 = inttoptr i64 %919 to i16* 
  %921 = getelementptr  i16, i16* %920, i64 0 
  %922 = load  i16, i16* %921 
  %"4$tmp$3#0" = icmp eq i16 %922, 12 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %938 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %939 = insertvalue {i64, i1} %938, i1 0, 1 
  ret {i64, i1} %939 
if.then2:
  %923 = trunc i64 16 to i32  
  %924 = tail call ccc  i8*  @wybe_malloc(i32  %923)  
  %925 = ptrtoint i8* %924 to i64 
  %926 = add   i64 %925, 7 
  %927 = sub   i64 %"$rec#0", 7 
  %928 = inttoptr i64 %925 to i8* 
  %929 = inttoptr i64 %927 to i8* 
  %930 = trunc i64 16 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %928, i8*  %929, i32  %930, i32  8, i1  0)  
  %931 = add   i64 %926, 1 
  %932 = inttoptr i64 %931 to i64* 
  %933 = getelementptr  i64, i64* %932, i64 0 
  store  i64 %"$field#0", i64* %933 
  %934 = insertvalue {i64, i1} undef, i64 %926, 0 
  %935 = insertvalue {i64, i1} %934, i1 1, 1 
  ret {i64, i1} %935 
if.else2:
  %936 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %937 = insertvalue {i64, i1} %936, i1 0, 1 
  ret {i64, i1} %937 
}


define external fastcc  {i64, i1} @"multictr.complicated.f14<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %956 = insertvalue {i64, i1} undef, i64 undef, 0 
  %957 = insertvalue {i64, i1} %956, i1 0, 1 
  ret {i64, i1} %957 
if.then1:
  %942 = add   i64 %"$rec#0", -7 
  %943 = inttoptr i64 %942 to i16* 
  %944 = getelementptr  i16, i16* %943, i64 0 
  %945 = load  i16, i16* %944 
  %"4$tmp$3#0" = icmp eq i16 %945, 13 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %954 = insertvalue {i64, i1} undef, i64 undef, 0 
  %955 = insertvalue {i64, i1} %954, i1 0, 1 
  ret {i64, i1} %955 
if.then2:
  %946 = add   i64 %"$rec#0", 1 
  %947 = inttoptr i64 %946 to i64* 
  %948 = getelementptr  i64, i64* %947, i64 0 
  %949 = load  i64, i64* %948 
  %950 = insertvalue {i64, i1} undef, i64 %949, 0 
  %951 = insertvalue {i64, i1} %950, i1 1, 1 
  ret {i64, i1} %951 
if.else2:
  %952 = insertvalue {i64, i1} undef, i64 undef, 0 
  %953 = insertvalue {i64, i1} %952, i1 0, 1 
  ret {i64, i1} %953 
}


define external fastcc  {i64, i1} @"multictr.complicated.f14<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %979 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %980 = insertvalue {i64, i1} %979, i1 0, 1 
  ret {i64, i1} %980 
if.then1:
  %958 = add   i64 %"$rec#0", -7 
  %959 = inttoptr i64 %958 to i16* 
  %960 = getelementptr  i16, i16* %959, i64 0 
  %961 = load  i16, i16* %960 
  %"4$tmp$3#0" = icmp eq i16 %961, 13 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %977 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %978 = insertvalue {i64, i1} %977, i1 0, 1 
  ret {i64, i1} %978 
if.then2:
  %962 = trunc i64 16 to i32  
  %963 = tail call ccc  i8*  @wybe_malloc(i32  %962)  
  %964 = ptrtoint i8* %963 to i64 
  %965 = add   i64 %964, 7 
  %966 = sub   i64 %"$rec#0", 7 
  %967 = inttoptr i64 %964 to i8* 
  %968 = inttoptr i64 %966 to i8* 
  %969 = trunc i64 16 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %967, i8*  %968, i32  %969, i32  8, i1  0)  
  %970 = add   i64 %965, 1 
  %971 = inttoptr i64 %970 to i64* 
  %972 = getelementptr  i64, i64* %971, i64 0 
  store  i64 %"$field#0", i64* %972 
  %973 = insertvalue {i64, i1} undef, i64 %965, 0 
  %974 = insertvalue {i64, i1} %973, i1 1, 1 
  ret {i64, i1} %974 
if.else2:
  %975 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %976 = insertvalue {i64, i1} %975, i1 0, 1 
  ret {i64, i1} %976 
}


define external fastcc  {i64, i1} @"multictr.complicated.f15<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %995 = insertvalue {i64, i1} undef, i64 undef, 0 
  %996 = insertvalue {i64, i1} %995, i1 0, 1 
  ret {i64, i1} %996 
if.then1:
  %981 = add   i64 %"$rec#0", -7 
  %982 = inttoptr i64 %981 to i16* 
  %983 = getelementptr  i16, i16* %982, i64 0 
  %984 = load  i16, i16* %983 
  %"4$tmp$3#0" = icmp eq i16 %984, 14 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %993 = insertvalue {i64, i1} undef, i64 undef, 0 
  %994 = insertvalue {i64, i1} %993, i1 0, 1 
  ret {i64, i1} %994 
if.then2:
  %985 = add   i64 %"$rec#0", 1 
  %986 = inttoptr i64 %985 to i64* 
  %987 = getelementptr  i64, i64* %986, i64 0 
  %988 = load  i64, i64* %987 
  %989 = insertvalue {i64, i1} undef, i64 %988, 0 
  %990 = insertvalue {i64, i1} %989, i1 1, 1 
  ret {i64, i1} %990 
if.else2:
  %991 = insertvalue {i64, i1} undef, i64 undef, 0 
  %992 = insertvalue {i64, i1} %991, i1 0, 1 
  ret {i64, i1} %992 
}


define external fastcc  {i64, i1} @"multictr.complicated.f15<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %1018 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %1019 = insertvalue {i64, i1} %1018, i1 0, 1 
  ret {i64, i1} %1019 
if.then1:
  %997 = add   i64 %"$rec#0", -7 
  %998 = inttoptr i64 %997 to i16* 
  %999 = getelementptr  i16, i16* %998, i64 0 
  %1000 = load  i16, i16* %999 
  %"4$tmp$3#0" = icmp eq i16 %1000, 14 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %1016 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %1017 = insertvalue {i64, i1} %1016, i1 0, 1 
  ret {i64, i1} %1017 
if.then2:
  %1001 = trunc i64 16 to i32  
  %1002 = tail call ccc  i8*  @wybe_malloc(i32  %1001)  
  %1003 = ptrtoint i8* %1002 to i64 
  %1004 = add   i64 %1003, 7 
  %1005 = sub   i64 %"$rec#0", 7 
  %1006 = inttoptr i64 %1003 to i8* 
  %1007 = inttoptr i64 %1005 to i8* 
  %1008 = trunc i64 16 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %1006, i8*  %1007, i32  %1008, i32  8, i1  0)  
  %1009 = add   i64 %1004, 1 
  %1010 = inttoptr i64 %1009 to i64* 
  %1011 = getelementptr  i64, i64* %1010, i64 0 
  store  i64 %"$field#0", i64* %1011 
  %1012 = insertvalue {i64, i1} undef, i64 %1004, 0 
  %1013 = insertvalue {i64, i1} %1012, i1 1, 1 
  ret {i64, i1} %1013 
if.else2:
  %1014 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %1015 = insertvalue {i64, i1} %1014, i1 0, 1 
  ret {i64, i1} %1015 
}


define external fastcc  {i64, i1} @"multictr.complicated.f16<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %1034 = insertvalue {i64, i1} undef, i64 undef, 0 
  %1035 = insertvalue {i64, i1} %1034, i1 0, 1 
  ret {i64, i1} %1035 
if.then1:
  %1020 = add   i64 %"$rec#0", -7 
  %1021 = inttoptr i64 %1020 to i16* 
  %1022 = getelementptr  i16, i16* %1021, i64 0 
  %1023 = load  i16, i16* %1022 
  %"4$tmp$3#0" = icmp eq i16 %1023, 15 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %1032 = insertvalue {i64, i1} undef, i64 undef, 0 
  %1033 = insertvalue {i64, i1} %1032, i1 0, 1 
  ret {i64, i1} %1033 
if.then2:
  %1024 = add   i64 %"$rec#0", 1 
  %1025 = inttoptr i64 %1024 to i64* 
  %1026 = getelementptr  i64, i64* %1025, i64 0 
  %1027 = load  i64, i64* %1026 
  %1028 = insertvalue {i64, i1} undef, i64 %1027, 0 
  %1029 = insertvalue {i64, i1} %1028, i1 1, 1 
  ret {i64, i1} %1029 
if.else2:
  %1030 = insertvalue {i64, i1} undef, i64 undef, 0 
  %1031 = insertvalue {i64, i1} %1030, i1 0, 1 
  ret {i64, i1} %1031 
}


define external fastcc  {i64, i1} @"multictr.complicated.f16<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %1057 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %1058 = insertvalue {i64, i1} %1057, i1 0, 1 
  ret {i64, i1} %1058 
if.then1:
  %1036 = add   i64 %"$rec#0", -7 
  %1037 = inttoptr i64 %1036 to i16* 
  %1038 = getelementptr  i16, i16* %1037, i64 0 
  %1039 = load  i16, i16* %1038 
  %"4$tmp$3#0" = icmp eq i16 %1039, 15 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %1055 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %1056 = insertvalue {i64, i1} %1055, i1 0, 1 
  ret {i64, i1} %1056 
if.then2:
  %1040 = trunc i64 16 to i32  
  %1041 = tail call ccc  i8*  @wybe_malloc(i32  %1040)  
  %1042 = ptrtoint i8* %1041 to i64 
  %1043 = add   i64 %1042, 7 
  %1044 = sub   i64 %"$rec#0", 7 
  %1045 = inttoptr i64 %1042 to i8* 
  %1046 = inttoptr i64 %1044 to i8* 
  %1047 = trunc i64 16 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %1045, i8*  %1046, i32  %1047, i32  8, i1  0)  
  %1048 = add   i64 %1043, 1 
  %1049 = inttoptr i64 %1048 to i64* 
  %1050 = getelementptr  i64, i64* %1049, i64 0 
  store  i64 %"$field#0", i64* %1050 
  %1051 = insertvalue {i64, i1} undef, i64 %1043, 0 
  %1052 = insertvalue {i64, i1} %1051, i1 1, 1 
  ret {i64, i1} %1052 
if.else2:
  %1053 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %1054 = insertvalue {i64, i1} %1053, i1 0, 1 
  ret {i64, i1} %1054 
}


define external fastcc  {i64, i1} @"multictr.complicated.f17<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %1073 = insertvalue {i64, i1} undef, i64 undef, 0 
  %1074 = insertvalue {i64, i1} %1073, i1 0, 1 
  ret {i64, i1} %1074 
if.then1:
  %1059 = add   i64 %"$rec#0", -7 
  %1060 = inttoptr i64 %1059 to i16* 
  %1061 = getelementptr  i16, i16* %1060, i64 0 
  %1062 = load  i16, i16* %1061 
  %"4$tmp$3#0" = icmp eq i16 %1062, 16 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %1071 = insertvalue {i64, i1} undef, i64 undef, 0 
  %1072 = insertvalue {i64, i1} %1071, i1 0, 1 
  ret {i64, i1} %1072 
if.then2:
  %1063 = add   i64 %"$rec#0", 1 
  %1064 = inttoptr i64 %1063 to i64* 
  %1065 = getelementptr  i64, i64* %1064, i64 0 
  %1066 = load  i64, i64* %1065 
  %1067 = insertvalue {i64, i1} undef, i64 %1066, 0 
  %1068 = insertvalue {i64, i1} %1067, i1 1, 1 
  ret {i64, i1} %1068 
if.else2:
  %1069 = insertvalue {i64, i1} undef, i64 undef, 0 
  %1070 = insertvalue {i64, i1} %1069, i1 0, 1 
  ret {i64, i1} %1070 
}


define external fastcc  {i64, i1} @"multictr.complicated.f17<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 7 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %1096 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %1097 = insertvalue {i64, i1} %1096, i1 0, 1 
  ret {i64, i1} %1097 
if.then1:
  %1075 = add   i64 %"$rec#0", -7 
  %1076 = inttoptr i64 %1075 to i16* 
  %1077 = getelementptr  i16, i16* %1076, i64 0 
  %1078 = load  i16, i16* %1077 
  %"4$tmp$3#0" = icmp eq i16 %1078, 16 
  br i1 %"4$tmp$3#0", label %if.then2, label %if.else2 
if.else1:
  %1094 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %1095 = insertvalue {i64, i1} %1094, i1 0, 1 
  ret {i64, i1} %1095 
if.then2:
  %1079 = trunc i64 16 to i32  
  %1080 = tail call ccc  i8*  @wybe_malloc(i32  %1079)  
  %1081 = ptrtoint i8* %1080 to i64 
  %1082 = add   i64 %1081, 7 
  %1083 = sub   i64 %"$rec#0", 7 
  %1084 = inttoptr i64 %1081 to i8* 
  %1085 = inttoptr i64 %1083 to i8* 
  %1086 = trunc i64 16 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %1084, i8*  %1085, i32  %1086, i32  8, i1  0)  
  %1087 = add   i64 %1082, 1 
  %1088 = inttoptr i64 %1087 to i64* 
  %1089 = getelementptr  i64, i64* %1088, i64 0 
  store  i64 %"$field#0", i64* %1089 
  %1090 = insertvalue {i64, i1} undef, i64 %1082, 0 
  %1091 = insertvalue {i64, i1} %1090, i1 1, 1 
  ret {i64, i1} %1091 
if.else2:
  %1092 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %1093 = insertvalue {i64, i1} %1092, i1 0, 1 
  ret {i64, i1} %1093 
}


define external fastcc  i64 @"multictr.complicated.spring<0>"()    {
entry:
  ret i64 1 
}


define external fastcc  i64 @"multictr.complicated.summer<0>"()    {
entry:
  ret i64 2 
}


define external fastcc  i64 @"multictr.complicated.winter<0>"()    {
entry:
  ret i64 0 
}
--------------------------------------------------
 Module multictr.length
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : multictr.length./=<0>
                    multictr.length.=<0>
                    multictr.length.metres<0>
                    multictr.length.metres<1>
                    multictr.length.value<0>
                    multictr.length.value<1>
  imports         : use multictr
                    use wybe
  resources       : 
  procs           : 

/= > public {inline} (0 calls)
0: multictr.length./=<0>
/=($left#0:multictr.length, $right#0:multictr.length, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_eq(~$left#0:multictr.length, ~$right#0:multictr.length, ?tmp$0#0:wybe.bool)
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public {inline} (1 calls)
0: multictr.length.=<0>
=($left#0:multictr.length, $right#0:multictr.length, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_eq(~$left#0:multictr.length, ~$right#0:multictr.length, ?$$#0:!wybe.bool)


metres > public {inline} (0 calls)
0: multictr.length.metres<0>
metres(value#0:wybe.float, ?$#2:multictr.length):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(~value#0:!multictr.length, ?$#2:multictr.length)
metres > public {inline} (0 calls)
1: multictr.length.metres<1>
metres(?value#0:wybe.float, $#0:multictr.length):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm cast(~$#0:multictr.length, ?value#0:wybe.float)


value > public {inline} (0 calls)
0: multictr.length.value<0>
value($rec#0:multictr.length, ?$#0:wybe.float):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm cast(~$rec#0:multictr.length, ?$#0:wybe.float)
value > public {inline} (0 calls)
1: multictr.length.value<1>
value([$rec#0:multictr.length], ?$rec#2:multictr.length, $field#0:wybe.float):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(~$field#0:!multictr.length, ?$rec#2:multictr.length)

  LLVM code       :

; ModuleID = 'multictr.length'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.length./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = icmp eq i64 %"$left#0", %"$right#0" 
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.length.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$$$#0" = icmp eq i64 %"$left#0", %"$right#0" 
  ret i1 %"1$$$#0" 
}


define external fastcc  i64 @"multictr.length.metres<0>"(double  %"value#0")    {
entry:
  %1 = bitcast double %"value#0" to i64 
  ret i64 %1 
}


define external fastcc  double @"multictr.length.metres<1>"(i64  %"$#0")    {
entry:
  %2 = bitcast i64 %"$#0" to double 
  ret double %2 
}


define external fastcc  double @"multictr.length.value<0>"(i64  %"$rec#0")    {
entry:
  %3 = bitcast i64 %"$rec#0" to double 
  ret double %3 
}


define external fastcc  i64 @"multictr.length.value<1>"(double  %"$field#0")    {
entry:
  %4 = bitcast double %"$field#0" to i64 
  ret i64 %4 
}
--------------------------------------------------
 Module multictr.maybe_int
  representation  : address
  public submods  : 
  public resources: 
  public procs    : multictr.maybe_int./=<0>
                    multictr.maybe_int.=<0>
                    multictr.maybe_int.just<0>
                    multictr.maybe_int.just<1>
                    multictr.maybe_int.nothing<0>
                    multictr.maybe_int.value<0>
                    multictr.maybe_int.value<1>
  imports         : use multictr
                    use wybe
  resources       : 
  procs           : 

/= > public {inline} (0 calls)
0: multictr.maybe_int./=<0>
/=($left#0:multictr.maybe_int, $right#0:multictr.maybe_int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    multictr.maybe_int.=<0>(~$left#0:multictr.maybe_int, ~$right#0:multictr.maybe_int, ?tmp$0#0:wybe.bool) #0
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public (1 calls)
0: multictr.maybe_int.=<0>
=($left#0:multictr.maybe_int, $right#0:multictr.maybe_int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_ne($left#0:!wybe.int, 0:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm icmp_eq(~$left#0:multictr.maybe_int, ~$right#0:multictr.maybe_int, ?$$#0:!wybe.bool)

    1:
        foreign lpvm access(~$left#0:multictr.maybe_int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$left$value#0:wybe.int)
        foreign llvm icmp_ne($right#0:multictr.maybe_int, 0:wybe.int, ?tmp$8#0:wybe.bool)
        case ~tmp$8#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$right#0:multictr.maybe_int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$right$value#0:wybe.int)
            foreign llvm icmp_eq(~$left$value#0:wybe.int, ~$right$value#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn




just > public {inline} (0 calls)
0: multictr.maybe_int.just<0>
just(value#0:wybe.int, ?$#0:multictr.maybe_int):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.maybe_int)
    foreign lpvm mutate(~%$rec#0:multictr.maybe_int, ?%$#0:multictr.maybe_int, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~value#0:wybe.int)
just > public {inline} (8 calls)
1: multictr.maybe_int.just<1>
just(?value#0:wybe.int, $#0:multictr.maybe_int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_ne($#0:!wybe.int, 0:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?value#0:wybe.int)

    1:
        foreign lpvm access(~$#0:multictr.maybe_int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?value#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



nothing > public {inline} (0 calls)
0: multictr.maybe_int.nothing<0>
nothing(?$#0:multictr.maybe_int):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.maybe_int, ?$#0:multictr.maybe_int)


value > public {inline} (0 calls)
0: multictr.maybe_int.value<0>
value($rec#0:multictr.maybe_int, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_ne($rec#0:!wybe.int, 0:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign lpvm access(~$rec#0:multictr.maybe_int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

value > public {inline} (0 calls)
1: multictr.maybe_int.value<1>
value($rec#0:multictr.maybe_int, ?$rec#1:multictr.maybe_int, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_ne($rec#0:!wybe.int, 0:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.maybe_int, ?$rec#1:multictr.maybe_int)

    1:
        foreign lpvm {noalias} mutate(~%$rec#0:multictr.maybe_int, ?%$rec#1:multictr.maybe_int, 0:wybe.int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


  LLVM code       :

; ModuleID = 'multictr.maybe_int'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.maybe_int./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = tail call fastcc  i1  @"multictr.maybe_int.=<0>"(i64  %"$left#0", i64  %"$right#0")  
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.maybe_int.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$left#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %1 = inttoptr i64 %"$left#0" to i64* 
  %2 = getelementptr  i64, i64* %1, i64 0 
  %3 = load  i64, i64* %2 
  %"2$tmp$8#0" = icmp ne i64 %"$right#0", 0 
  br i1 %"2$tmp$8#0", label %if.then1, label %if.else1 
if.else:
  %"3$$$#0" = icmp eq i64 %"$left#0", %"$right#0" 
  ret i1 %"3$$$#0" 
if.then1:
  %4 = inttoptr i64 %"$right#0" to i64* 
  %5 = getelementptr  i64, i64* %4, i64 0 
  %6 = load  i64, i64* %5 
  %"4$$$#0" = icmp eq i64 %3, %6 
  ret i1 %"4$$$#0" 
if.else1:
  ret i1 0 
}


define external fastcc  i64 @"multictr.maybe_int.just<0>"(i64  %"value#0")    {
entry:
  %7 = trunc i64 8 to i32  
  %8 = tail call ccc  i8*  @wybe_malloc(i32  %7)  
  %9 = ptrtoint i8* %8 to i64 
  %10 = inttoptr i64 %9 to i64* 
  %11 = getelementptr  i64, i64* %10, i64 0 
  store  i64 %"value#0", i64* %11 
  ret i64 %9 
}


define external fastcc  {i64, i1} @"multictr.maybe_int.just<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %12 = inttoptr i64 %"$#0" to i64* 
  %13 = getelementptr  i64, i64* %12, i64 0 
  %14 = load  i64, i64* %13 
  %15 = insertvalue {i64, i1} undef, i64 %14, 0 
  %16 = insertvalue {i64, i1} %15, i1 1, 1 
  ret {i64, i1} %16 
if.else:
  %17 = insertvalue {i64, i1} undef, i64 undef, 0 
  %18 = insertvalue {i64, i1} %17, i1 0, 1 
  ret {i64, i1} %18 
}


define external fastcc  i64 @"multictr.maybe_int.nothing<0>"()    {
entry:
  ret i64 0 
}


define external fastcc  {i64, i1} @"multictr.maybe_int.value<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %19 = inttoptr i64 %"$rec#0" to i64* 
  %20 = getelementptr  i64, i64* %19, i64 0 
  %21 = load  i64, i64* %20 
  %22 = insertvalue {i64, i1} undef, i64 %21, 0 
  %23 = insertvalue {i64, i1} %22, i1 1, 1 
  ret {i64, i1} %23 
if.else:
  %24 = insertvalue {i64, i1} undef, i64 undef, 0 
  %25 = insertvalue {i64, i1} %24, i1 0, 1 
  ret {i64, i1} %25 
}


define external fastcc  {i64, i1} @"multictr.maybe_int.value<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %26 = trunc i64 8 to i32  
  %27 = tail call ccc  i8*  @wybe_malloc(i32  %26)  
  %28 = ptrtoint i8* %27 to i64 
  %29 = inttoptr i64 %28 to i8* 
  %30 = inttoptr i64 %"$rec#0" to i8* 
  %31 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %29, i8*  %30, i32  %31, i32  8, i1  0)  
  %32 = inttoptr i64 %28 to i64* 
  %33 = getelementptr  i64, i64* %32, i64 0 
  store  i64 %"$field#0", i64* %33 
  %34 = insertvalue {i64, i1} undef, i64 %28, 0 
  %35 = insertvalue {i64, i1} %34, i1 1, 1 
  ret {i64, i1} %35 
if.else:
  %36 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %37 = insertvalue {i64, i1} %36, i1 0, 1 
  ret {i64, i1} %37 
}
--------------------------------------------------
 Module multictr.number
  representation  : address
  public submods  : 
  public resources: 
  public procs    : multictr.number./=<0>
                    multictr.number.=<0>
                    multictr.number.float<0>
                    multictr.number.float<1>
                    multictr.number.float_value<0>
                    multictr.number.float_value<1>
                    multictr.number.int<0>
                    multictr.number.int<1>
                    multictr.number.int_value<0>
                    multictr.number.int_value<1>
  imports         : use multictr
                    use wybe
  resources       : 
  procs           : 

/= > public {inline} (0 calls)
0: multictr.number./=<0>
/=($left#0:multictr.number, $right#0:multictr.number, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    multictr.number.=<0>(~$left#0:multictr.number, ~$right#0:multictr.number, ?tmp$0#0:wybe.bool) #0
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public (1 calls)
0: multictr.number.=<0>
=($left#0:multictr.number, $right#0:multictr.number, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($left#0:multictr.number, 7:wybe.int, ?tmp$8#0:wybe.int)
    foreign llvm icmp_eq(tmp$8#0:wybe.int, 0:wybe.int, ?tmp$9#0:wybe.bool)
    case ~tmp$9#0:wybe.bool of
    0:
        foreign llvm icmp_eq(~tmp$8#0:wybe.int, 1:wybe.int, ?tmp$12#0:wybe.bool)
        case ~tmp$12#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$left#0:multictr.number, -1:wybe.int, 8:wybe.int, 1:wybe.int, ?$left$float_value#0:wybe.float)
            foreign llvm and($right#0:multictr.number, 7:wybe.int, ?tmp$14#0:wybe.int)
            foreign llvm icmp_eq(~tmp$14#0:wybe.int, 1:wybe.int, ?tmp$15#0:wybe.bool)
            case ~tmp$15#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign lpvm access(~$right#0:multictr.number, -1:wybe.int, 8:wybe.int, 1:wybe.int, ?$right$float_value#0:wybe.float)
                foreign llvm fcmp_eq(~$left$float_value#0:wybe.float, ~$right$float_value#0:wybe.float, ?$$#0:wybe.bool) @float:nn:nn



    1:
        foreign lpvm access(~$left#0:multictr.number, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$left$int_value#0:wybe.int)
        foreign llvm and($right#0:multictr.number, 7:wybe.int, ?tmp$11#0:wybe.int)
        foreign llvm icmp_eq(~tmp$11#0:wybe.int, 0:wybe.int, ?tmp$12#0:wybe.bool)
        case ~tmp$12#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$right#0:multictr.number, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$right$int_value#0:wybe.int)
            foreign llvm icmp_eq(~$left$int_value#0:wybe.int, ~$right$int_value#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn




float > public {inline} (0 calls)
0: multictr.number.float<0>
float(float_value#0:wybe.float, ?$#0:multictr.number):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.number)
    foreign lpvm mutate(~%$rec#0:multictr.number, ?%$rec#1:multictr.number, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~float_value#0:wybe.float)
    foreign llvm or(~$rec#1:multictr.number, 1:wybe.int, ?$#0:multictr.number)
float > public {inline} (5 calls)
1: multictr.number.float<1>
float(?float_value#0:wybe.float, $#0:multictr.number, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.int)
    foreign llvm icmp_eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.float, ?float_value#0:wybe.float)

    1:
        foreign lpvm access(~$#0:multictr.number, -1:wybe.int, 8:wybe.int, 1:wybe.int, ?float_value#0:wybe.float)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



float_value > public {inline} (0 calls)
0: multictr.number.float_value<0>
float_value($rec#0:multictr.number, ?$#0:wybe.float, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.int)
    foreign llvm icmp_eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.float, ?$#0:wybe.float)

    1:
        foreign lpvm access(~$rec#0:multictr.number, -1:wybe.int, 8:wybe.int, 1:wybe.int, ?$#0:wybe.float)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

float_value > public {inline} (0 calls)
1: multictr.number.float_value<1>
float_value($rec#0:multictr.number, ?$rec#1:multictr.number, $field#0:wybe.float, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.int)
    foreign llvm icmp_eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.number, ?$rec#1:multictr.number)

    1:
        foreign lpvm {noalias} mutate(~%$rec#0:multictr.number, ?%$rec#1:multictr.number, -1:wybe.int, 0:wybe.int, 8:wybe.int, 1:wybe.int, ~$field#0:wybe.float)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



int > public {inline} (0 calls)
0: multictr.number.int<0>
int(int_value#0:wybe.int, ?$#0:multictr.number):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.number)
    foreign lpvm mutate(~%$rec#0:multictr.number, ?%$#0:multictr.number, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~int_value#0:wybe.int)
int > public {inline} (10 calls)
1: multictr.number.int<1>
int(?int_value#0:wybe.int, $#0:multictr.number, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.int)
    foreign llvm icmp_eq(~tmp$1#0:!wybe.int, 0:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?int_value#0:wybe.int)

    1:
        foreign lpvm access(~$#0:multictr.number, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?int_value#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



int_value > public {inline} (0 calls)
0: multictr.number.int_value<0>
int_value($rec#0:multictr.number, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.int)
    foreign llvm icmp_eq(~tmp$1#0:!wybe.int, 0:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign lpvm access(~$rec#0:multictr.number, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

int_value > public {inline} (0 calls)
1: multictr.number.int_value<1>
int_value($rec#0:multictr.number, ?$rec#1:multictr.number, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$1#0:!wybe.int)
    foreign llvm icmp_eq(~tmp$1#0:!wybe.int, 0:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.number, ?$rec#1:multictr.number)

    1:
        foreign lpvm {noalias} mutate(~%$rec#0:multictr.number, ?%$rec#1:multictr.number, 0:wybe.int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


  LLVM code       :

; ModuleID = 'multictr.number'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.number./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = tail call fastcc  i1  @"multictr.number.=<0>"(i64  %"$left#0", i64  %"$right#0")  
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.number.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$8#0" = and i64 %"$left#0", 7 
  %"1$tmp$9#0" = icmp eq i64 %"1$tmp$8#0", 0 
  br i1 %"1$tmp$9#0", label %if.then, label %if.else 
if.then:
  %1 = inttoptr i64 %"$left#0" to i64* 
  %2 = getelementptr  i64, i64* %1, i64 0 
  %3 = load  i64, i64* %2 
  %"2$tmp$11#0" = and i64 %"$right#0", 7 
  %"2$tmp$12#0" = icmp eq i64 %"2$tmp$11#0", 0 
  br i1 %"2$tmp$12#0", label %if.then1, label %if.else1 
if.else:
  %"3$tmp$12#0" = icmp eq i64 %"1$tmp$8#0", 1 
  br i1 %"3$tmp$12#0", label %if.then2, label %if.else2 
if.then1:
  %4 = inttoptr i64 %"$right#0" to i64* 
  %5 = getelementptr  i64, i64* %4, i64 0 
  %6 = load  i64, i64* %5 
  %"4$$$#0" = icmp eq i64 %3, %6 
  ret i1 %"4$$$#0" 
if.else1:
  ret i1 0 
if.then2:
  %7 = add   i64 %"$left#0", -1 
  %8 = inttoptr i64 %7 to double* 
  %9 = getelementptr  double, double* %8, i64 0 
  %10 = load  double, double* %9 
  %"6$tmp$14#0" = and i64 %"$right#0", 7 
  %"6$tmp$15#0" = icmp eq i64 %"6$tmp$14#0", 1 
  br i1 %"6$tmp$15#0", label %if.then3, label %if.else3 
if.else2:
  ret i1 0 
if.then3:
  %11 = add   i64 %"$right#0", -1 
  %12 = inttoptr i64 %11 to double* 
  %13 = getelementptr  double, double* %12, i64 0 
  %14 = load  double, double* %13 
  %"8$$$#0" = fcmp oeq double %10, %14 
  ret i1 %"8$$$#0" 
if.else3:
  ret i1 0 
}


define external fastcc  i64 @"multictr.number.float<0>"(double  %"float_value#0")    {
entry:
  %15 = trunc i64 8 to i32  
  %16 = tail call ccc  i8*  @wybe_malloc(i32  %15)  
  %17 = ptrtoint i8* %16 to i64 
  %18 = inttoptr i64 %17 to double* 
  %19 = getelementptr  double, double* %18, i64 0 
  store  double %"float_value#0", double* %19 
  %"1$$#0" = or i64 %17, 1 
  ret i64 %"1$$#0" 
}


define external fastcc  {double, i1} @"multictr.number.float<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$1#0" = and i64 %"$#0", 7 
  %"1$tmp$0#0" = icmp eq i64 %"1$tmp$1#0", 1 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %20 = add   i64 %"$#0", -1 
  %21 = inttoptr i64 %20 to double* 
  %22 = getelementptr  double, double* %21, i64 0 
  %23 = load  double, double* %22 
  %24 = insertvalue {double, i1} undef, double %23, 0 
  %25 = insertvalue {double, i1} %24, i1 1, 1 
  ret {double, i1} %25 
if.else:
  %26 = insertvalue {double, i1} undef, double undef, 0 
  %27 = insertvalue {double, i1} %26, i1 0, 1 
  ret {double, i1} %27 
}


define external fastcc  {double, i1} @"multictr.number.float_value<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$1#0" = and i64 %"$rec#0", 7 
  %"1$tmp$0#0" = icmp eq i64 %"1$tmp$1#0", 1 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %28 = add   i64 %"$rec#0", -1 
  %29 = inttoptr i64 %28 to double* 
  %30 = getelementptr  double, double* %29, i64 0 
  %31 = load  double, double* %30 
  %32 = insertvalue {double, i1} undef, double %31, 0 
  %33 = insertvalue {double, i1} %32, i1 1, 1 
  ret {double, i1} %33 
if.else:
  %34 = insertvalue {double, i1} undef, double undef, 0 
  %35 = insertvalue {double, i1} %34, i1 0, 1 
  ret {double, i1} %35 
}


define external fastcc  {i64, i1} @"multictr.number.float_value<1>"(i64  %"$rec#0", double  %"$field#0")    {
entry:
  %"1$tmp$1#0" = and i64 %"$rec#0", 7 
  %"1$tmp$0#0" = icmp eq i64 %"1$tmp$1#0", 1 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %36 = trunc i64 8 to i32  
  %37 = tail call ccc  i8*  @wybe_malloc(i32  %36)  
  %38 = ptrtoint i8* %37 to i64 
  %39 = add   i64 %38, 1 
  %40 = sub   i64 %"$rec#0", 1 
  %41 = inttoptr i64 %38 to i8* 
  %42 = inttoptr i64 %40 to i8* 
  %43 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %41, i8*  %42, i32  %43, i32  8, i1  0)  
  %44 = add   i64 %39, -1 
  %45 = inttoptr i64 %44 to double* 
  %46 = getelementptr  double, double* %45, i64 0 
  store  double %"$field#0", double* %46 
  %47 = insertvalue {i64, i1} undef, i64 %39, 0 
  %48 = insertvalue {i64, i1} %47, i1 1, 1 
  ret {i64, i1} %48 
if.else:
  %49 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %50 = insertvalue {i64, i1} %49, i1 0, 1 
  ret {i64, i1} %50 
}


define external fastcc  i64 @"multictr.number.int<0>"(i64  %"int_value#0")    {
entry:
  %51 = trunc i64 8 to i32  
  %52 = tail call ccc  i8*  @wybe_malloc(i32  %51)  
  %53 = ptrtoint i8* %52 to i64 
  %54 = inttoptr i64 %53 to i64* 
  %55 = getelementptr  i64, i64* %54, i64 0 
  store  i64 %"int_value#0", i64* %55 
  ret i64 %53 
}


define external fastcc  {i64, i1} @"multictr.number.int<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$1#0" = and i64 %"$#0", 7 
  %"1$tmp$0#0" = icmp eq i64 %"1$tmp$1#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %56 = inttoptr i64 %"$#0" to i64* 
  %57 = getelementptr  i64, i64* %56, i64 0 
  %58 = load  i64, i64* %57 
  %59 = insertvalue {i64, i1} undef, i64 %58, 0 
  %60 = insertvalue {i64, i1} %59, i1 1, 1 
  ret {i64, i1} %60 
if.else:
  %61 = insertvalue {i64, i1} undef, i64 undef, 0 
  %62 = insertvalue {i64, i1} %61, i1 0, 1 
  ret {i64, i1} %62 
}


define external fastcc  {i64, i1} @"multictr.number.int_value<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$1#0" = and i64 %"$rec#0", 7 
  %"1$tmp$0#0" = icmp eq i64 %"1$tmp$1#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %63 = inttoptr i64 %"$rec#0" to i64* 
  %64 = getelementptr  i64, i64* %63, i64 0 
  %65 = load  i64, i64* %64 
  %66 = insertvalue {i64, i1} undef, i64 %65, 0 
  %67 = insertvalue {i64, i1} %66, i1 1, 1 
  ret {i64, i1} %67 
if.else:
  %68 = insertvalue {i64, i1} undef, i64 undef, 0 
  %69 = insertvalue {i64, i1} %68, i1 0, 1 
  ret {i64, i1} %69 
}


define external fastcc  {i64, i1} @"multictr.number.int_value<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$1#0" = and i64 %"$rec#0", 7 
  %"1$tmp$0#0" = icmp eq i64 %"1$tmp$1#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %70 = trunc i64 8 to i32  
  %71 = tail call ccc  i8*  @wybe_malloc(i32  %70)  
  %72 = ptrtoint i8* %71 to i64 
  %73 = inttoptr i64 %72 to i8* 
  %74 = inttoptr i64 %"$rec#0" to i8* 
  %75 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %73, i8*  %74, i32  %75, i32  8, i1  0)  
  %76 = inttoptr i64 %72 to i64* 
  %77 = getelementptr  i64, i64* %76, i64 0 
  store  i64 %"$field#0", i64* %77 
  %78 = insertvalue {i64, i1} undef, i64 %72, 0 
  %79 = insertvalue {i64, i1} %78, i1 1, 1 
  ret {i64, i1} %79 
if.else:
  %80 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %81 = insertvalue {i64, i1} %80, i1 0, 1 
  ret {i64, i1} %81 
}
--------------------------------------------------
 Module multictr.perhaps
  representation  : 64 bit unsigned
  public submods  : 
  public resources: 
  public procs    : multictr.perhaps./=<0>
                    multictr.perhaps.=<0>
                    multictr.perhaps.content<0>
                    multictr.perhaps.content<1>
                    multictr.perhaps.perhaps<0>
                    multictr.perhaps.perhaps<1>
  imports         : use multictr
                    use wybe
  resources       : 
  procs           : 

/= > public {inline} (0 calls)
0: multictr.perhaps./=<0>
/=($left#0:multictr.perhaps, $right#0:multictr.perhaps, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_eq(~$left#0:multictr.perhaps, ~$right#0:multictr.perhaps, ?tmp$0#0:wybe.bool)
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public {inline} (1 calls)
0: multictr.perhaps.=<0>
=($left#0:multictr.perhaps, $right#0:multictr.perhaps, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_eq(~$left#0:multictr.perhaps, ~$right#0:multictr.perhaps, ?$$#0:!wybe.bool)


content > public {inline} (0 calls)
0: multictr.perhaps.content<0>
content($rec#0:multictr.perhaps, ?$#0:multictr.maybe_int):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm cast(~$rec#0:multictr.perhaps, ?$#0:multictr.maybe_int)
content > public {inline} (0 calls)
1: multictr.perhaps.content<1>
content([$rec#0:multictr.perhaps], ?$rec#2:multictr.perhaps, $field#0:multictr.maybe_int):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(~$field#0:!multictr.perhaps, ?$rec#2:multictr.perhaps)


perhaps > public {inline} (0 calls)
0: multictr.perhaps.perhaps<0>
perhaps(content#0:multictr.maybe_int, ?$#2:multictr.perhaps):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(~content#0:!multictr.perhaps, ?$#2:multictr.perhaps)
perhaps > public {inline} (0 calls)
1: multictr.perhaps.perhaps<1>
perhaps(?content#0:multictr.maybe_int, $#0:multictr.perhaps):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm cast(~$#0:multictr.perhaps, ?content#0:multictr.maybe_int)

  LLVM code       :

; ModuleID = 'multictr.perhaps'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.perhaps./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = icmp eq i64 %"$left#0", %"$right#0" 
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.perhaps.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$$$#0" = icmp eq i64 %"$left#0", %"$right#0" 
  ret i1 %"1$$$#0" 
}


define external fastcc  i64 @"multictr.perhaps.content<0>"(i64  %"$rec#0")    {
entry:
  ret i64 %"$rec#0" 
}


define external fastcc  i64 @"multictr.perhaps.content<1>"(i64  %"$field#0")    {
entry:
  ret i64 %"$field#0" 
}


define external fastcc  i64 @"multictr.perhaps.perhaps<0>"(i64  %"content#0")    {
entry:
  ret i64 %"content#0" 
}


define external fastcc  i64 @"multictr.perhaps.perhaps<1>"(i64  %"$#0")    {
entry:
  ret i64 %"$#0" 
}
--------------------------------------------------
 Module multictr.rank
  representation  : 4 bit unsigned
  public submods  : 
  public resources: 
  public procs    : multictr.rank./=<0>
                    multictr.rank.=<0>
                    multictr.rank.ace<0>
                    multictr.rank.jack<0>
                    multictr.rank.king<0>
                    multictr.rank.queen<0>
                    multictr.rank.r10<0>
                    multictr.rank.r2<0>
                    multictr.rank.r3<0>
                    multictr.rank.r4<0>
                    multictr.rank.r5<0>
                    multictr.rank.r6<0>
                    multictr.rank.r7<0>
                    multictr.rank.r8<0>
                    multictr.rank.r9<0>
  imports         : use multictr
                    use wybe
  resources       : 
  procs           : 

/= > public {inline} (0 calls)
0: multictr.rank./=<0>
/=($left#0:multictr.rank, $right#0:multictr.rank, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_eq(~$left#0:multictr.rank, ~$right#0:multictr.rank, ?tmp$0#0:wybe.bool)
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public {inline} (1 calls)
0: multictr.rank.=<0>
=($left#0:multictr.rank, $right#0:multictr.rank, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_eq(~$left#0:multictr.rank, ~$right#0:multictr.rank, ?$$#0:!wybe.bool)


ace > public {inline} (0 calls)
0: multictr.rank.ace<0>
ace(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(12:multictr.rank, ?$#0:multictr.rank)


jack > public {inline} (0 calls)
0: multictr.rank.jack<0>
jack(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(9:multictr.rank, ?$#0:multictr.rank)


king > public {inline} (0 calls)
0: multictr.rank.king<0>
king(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(11:multictr.rank, ?$#0:multictr.rank)


queen > public {inline} (0 calls)
0: multictr.rank.queen<0>
queen(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(10:multictr.rank, ?$#0:multictr.rank)


r10 > public {inline} (0 calls)
0: multictr.rank.r10<0>
r10(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(8:multictr.rank, ?$#0:multictr.rank)


r2 > public {inline} (0 calls)
0: multictr.rank.r2<0>
r2(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.rank, ?$#0:multictr.rank)


r3 > public {inline} (0 calls)
0: multictr.rank.r3<0>
r3(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(1:multictr.rank, ?$#0:multictr.rank)


r4 > public {inline} (0 calls)
0: multictr.rank.r4<0>
r4(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(2:multictr.rank, ?$#0:multictr.rank)


r5 > public {inline} (0 calls)
0: multictr.rank.r5<0>
r5(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(3:multictr.rank, ?$#0:multictr.rank)


r6 > public {inline} (0 calls)
0: multictr.rank.r6<0>
r6(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(4:multictr.rank, ?$#0:multictr.rank)


r7 > public {inline} (0 calls)
0: multictr.rank.r7<0>
r7(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(5:multictr.rank, ?$#0:multictr.rank)


r8 > public {inline} (0 calls)
0: multictr.rank.r8<0>
r8(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(6:multictr.rank, ?$#0:multictr.rank)


r9 > public {inline} (0 calls)
0: multictr.rank.r9<0>
r9(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(7:multictr.rank, ?$#0:multictr.rank)

  LLVM code       :

; ModuleID = 'multictr.rank'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.rank./=<0>"(i4  %"$left#0", i4  %"$right#0")    {
entry:
  %"1$tmp$0#0" = icmp eq i4 %"$left#0", %"$right#0" 
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.rank.=<0>"(i4  %"$left#0", i4  %"$right#0")    {
entry:
  %"1$$$#0" = icmp eq i4 %"$left#0", %"$right#0" 
  ret i1 %"1$$$#0" 
}


define external fastcc  i4 @"multictr.rank.ace<0>"()    {
entry:
  ret i4 12 
}


define external fastcc  i4 @"multictr.rank.jack<0>"()    {
entry:
  ret i4 9 
}


define external fastcc  i4 @"multictr.rank.king<0>"()    {
entry:
  ret i4 11 
}


define external fastcc  i4 @"multictr.rank.queen<0>"()    {
entry:
  ret i4 10 
}


define external fastcc  i4 @"multictr.rank.r10<0>"()    {
entry:
  ret i4 8 
}


define external fastcc  i4 @"multictr.rank.r2<0>"()    {
entry:
  ret i4 0 
}


define external fastcc  i4 @"multictr.rank.r3<0>"()    {
entry:
  ret i4 1 
}


define external fastcc  i4 @"multictr.rank.r4<0>"()    {
entry:
  ret i4 2 
}


define external fastcc  i4 @"multictr.rank.r5<0>"()    {
entry:
  ret i4 3 
}


define external fastcc  i4 @"multictr.rank.r6<0>"()    {
entry:
  ret i4 4 
}


define external fastcc  i4 @"multictr.rank.r7<0>"()    {
entry:
  ret i4 5 
}


define external fastcc  i4 @"multictr.rank.r8<0>"()    {
entry:
  ret i4 6 
}


define external fastcc  i4 @"multictr.rank.r9<0>"()    {
entry:
  ret i4 7 
}
--------------------------------------------------
 Module multictr.simple
  representation  : address
  public submods  : 
  public resources: 
  public procs    : multictr.simple./=<0>
                    multictr.simple.=<0>
                    multictr.simple.one<0>
                    multictr.simple.one<1>
                    multictr.simple.one_field<0>
                    multictr.simple.one_field<1>
                    multictr.simple.two<0>
                    multictr.simple.two<1>
                    multictr.simple.two_field1<0>
                    multictr.simple.two_field1<1>
                    multictr.simple.two_field2<0>
                    multictr.simple.two_field2<1>
                    multictr.simple.zero<0>
  imports         : use multictr
                    use wybe
  resources       : 
  procs           : 

/= > public {inline} (0 calls)
0: multictr.simple./=<0>
/=($left#0:multictr.simple, $right#0:multictr.simple, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    multictr.simple.=<0>(~$left#0:multictr.simple, ~$right#0:multictr.simple, ?tmp$0#0:wybe.bool) #0
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public (1 calls)
0: multictr.simple.=<0>
=($left#0:multictr.simple, $right#0:multictr.simple, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_ne($left#0:!wybe.int, 0:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm icmp_eq(~$left#0:multictr.simple, ~$right#0:multictr.simple, ?$$#0:!wybe.bool)

    1:
        foreign llvm and($left#0:multictr.simple, 7:wybe.int, ?tmp$11#0:wybe.int)
        foreign llvm icmp_eq(tmp$11#0:wybe.int, 0:wybe.int, ?tmp$12#0:wybe.bool)
        case ~tmp$12#0:wybe.bool of
        0:
            foreign llvm icmp_eq(~tmp$11#0:wybe.int, 1:wybe.int, ?tmp$16#0:wybe.bool)
            case ~tmp$16#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign lpvm access($left#0:multictr.simple, -1:wybe.int, 16:wybe.int, 1:wybe.int, ?$left$two_field1#0:wybe.int)
                foreign lpvm access(~$left#0:multictr.simple, 7:wybe.int, 16:wybe.int, 1:wybe.int, ?$left$two_field2#0:wybe.int)
                foreign llvm icmp_ne($right#0:multictr.simple, 0:wybe.int, ?tmp$18#0:wybe.bool)
                case ~tmp$18#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign llvm and($right#0:multictr.simple, 7:wybe.int, ?tmp$19#0:wybe.int)
                    foreign llvm icmp_eq(~tmp$19#0:wybe.int, 1:wybe.int, ?tmp$20#0:wybe.bool)
                    case ~tmp$20#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        foreign lpvm access($right#0:multictr.simple, -1:wybe.int, 16:wybe.int, 1:wybe.int, ?$right$two_field1#0:wybe.int)
                        foreign lpvm access(~$right#0:multictr.simple, 7:wybe.int, 16:wybe.int, 1:wybe.int, ?$right$two_field2#0:wybe.int)
                        foreign llvm icmp_eq(~$left$two_field1#0:wybe.int, ~$right$two_field1#0:wybe.int, ?tmp$5#0:wybe.bool) @int:nn:nn
                        case ~tmp$5#0:wybe.bool of
                        0:
                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                        1:
                            foreign llvm icmp_eq(~$left$two_field2#0:wybe.int, ~$right$two_field2#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn





        1:
            foreign lpvm access(~$left#0:multictr.simple, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$left$one_field#0:wybe.int)
            foreign llvm icmp_ne($right#0:multictr.simple, 0:wybe.int, ?tmp$14#0:wybe.bool)
            case ~tmp$14#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign llvm and($right#0:multictr.simple, 7:wybe.int, ?tmp$15#0:wybe.int)
                foreign llvm icmp_eq(~tmp$15#0:wybe.int, 0:wybe.int, ?tmp$16#0:wybe.bool)
                case ~tmp$16#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign lpvm access(~$right#0:multictr.simple, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$right$one_field#0:wybe.int)
                    foreign llvm icmp_eq(~$left$one_field#0:wybe.int, ~$right$one_field#0:wybe.int, ?$$#0:wybe.bool) @int:nn:nn






one > public {inline} (0 calls)
0: multictr.simple.one<0>
one(one_field#0:wybe.int, ?$#0:multictr.simple):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.simple)
    foreign lpvm mutate(~%$rec#0:multictr.simple, ?%$#0:multictr.simple, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~one_field#0:wybe.int)
one > public {inline} (11 calls)
1: multictr.simple.one<1>
one(?one_field#0:wybe.int, $#0:multictr.simple, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_ne($#0:!wybe.int, 0:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?one_field#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 0:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?one_field#0:wybe.int)

        1:
            foreign lpvm access(~$#0:multictr.simple, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?one_field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




one_field > public {inline} (0 calls)
0: multictr.simple.one_field<0>
one_field($rec#0:multictr.simple, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_ne($rec#0:!wybe.int, 0:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 0:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access(~$rec#0:multictr.simple, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


one_field > public {inline} (0 calls)
1: multictr.simple.one_field<1>
one_field($rec#0:multictr.simple, ?$rec#1:multictr.simple, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_ne($rec#0:!wybe.int, 0:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 0:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

        1:
            foreign lpvm {noalias} mutate(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, 0:wybe.int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




two > public {inline} (0 calls)
0: multictr.simple.two<0>
two(two_field1#0:wybe.int, two_field2#0:wybe.int, ?$#0:multictr.simple):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?$rec#0:multictr.simple)
    foreign lpvm mutate(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, ~two_field1#0:wybe.int)
    foreign lpvm mutate(~%$rec#1:multictr.simple, ?%$rec#2:multictr.simple, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, ~two_field2#0:wybe.int)
    foreign llvm or(~$rec#2:multictr.simple, 1:wybe.int, ?$#0:multictr.simple)
two > public {inline} (7 calls)
1: multictr.simple.two<1>
two(?two_field1#0:wybe.int, ?two_field2#0:wybe.int, $#0:multictr.simple, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_ne($#0:!wybe.int, 0:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?two_field1#0:wybe.int)
        foreign llvm move(undef:wybe.int, ?two_field2#0:wybe.int)

    1:
        foreign llvm and($#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 1:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?two_field1#0:wybe.int)
            foreign llvm move(undef:wybe.int, ?two_field2#0:wybe.int)

        1:
            foreign lpvm access($#0:multictr.simple, -1:wybe.int, 16:wybe.int, 1:wybe.int, ?two_field1#0:wybe.int)
            foreign lpvm access(~$#0:multictr.simple, 7:wybe.int, 16:wybe.int, 1:wybe.int, ?two_field2#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




two_field1 > public {inline} (0 calls)
0: multictr.simple.two_field1<0>
two_field1($rec#0:multictr.simple, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_ne($rec#0:!wybe.int, 0:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 1:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access(~$rec#0:multictr.simple, -1:wybe.int, 16:wybe.int, 1:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


two_field1 > public {inline} (0 calls)
1: multictr.simple.two_field1<1>
two_field1($rec#0:multictr.simple, ?$rec#1:multictr.simple, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_ne($rec#0:!wybe.int, 0:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 1:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

        1:
            foreign lpvm {noalias} mutate(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, -1:wybe.int, 0:wybe.int, 16:wybe.int, 1:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




two_field2 > public {inline} (0 calls)
0: multictr.simple.two_field2<0>
two_field2($rec#0:multictr.simple, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_ne($rec#0:!wybe.int, 0:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 1:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?$#0:wybe.int)

        1:
            foreign lpvm access(~$rec#0:multictr.simple, 7:wybe.int, 16:wybe.int, 1:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


two_field2 > public {inline} (0 calls)
1: multictr.simple.two_field2<1>
two_field2($rec#0:multictr.simple, ?$rec#1:multictr.simple, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_ne($rec#0:!wybe.int, 0:wybe.int, ?tmp$0#0:!wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

    1:
        foreign llvm and($rec#0:!wybe.int, 7:wybe.int, ?tmp$2#0:!wybe.int)
        foreign llvm icmp_eq(~tmp$2#0:!wybe.int, 1:wybe.int, ?tmp$1#0:!wybe.bool)
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

        1:
            foreign lpvm {noalias} mutate(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, 7:wybe.int, 0:wybe.int, 16:wybe.int, 1:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




zero > public {inline} (0 calls)
0: multictr.simple.zero<0>
zero(?$#0:multictr.simple):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.simple, ?$#0:multictr.simple)

  LLVM code       :

; ModuleID = 'multictr.simple'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.simple./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = tail call fastcc  i1  @"multictr.simple.=<0>"(i64  %"$left#0", i64  %"$right#0")  
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.simple.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$left#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$11#0" = and i64 %"$left#0", 7 
  %"2$tmp$12#0" = icmp eq i64 %"2$tmp$11#0", 0 
  br i1 %"2$tmp$12#0", label %if.then1, label %if.else1 
if.else:
  %"3$$$#0" = icmp eq i64 %"$left#0", %"$right#0" 
  ret i1 %"3$$$#0" 
if.then1:
  %1 = inttoptr i64 %"$left#0" to i64* 
  %2 = getelementptr  i64, i64* %1, i64 0 
  %3 = load  i64, i64* %2 
  %"4$tmp$14#0" = icmp ne i64 %"$right#0", 0 
  br i1 %"4$tmp$14#0", label %if.then2, label %if.else2 
if.else1:
  %"5$tmp$16#0" = icmp eq i64 %"2$tmp$11#0", 1 
  br i1 %"5$tmp$16#0", label %if.then4, label %if.else4 
if.then2:
  %"6$tmp$15#0" = and i64 %"$right#0", 7 
  %"6$tmp$16#0" = icmp eq i64 %"6$tmp$15#0", 0 
  br i1 %"6$tmp$16#0", label %if.then3, label %if.else3 
if.else2:
  ret i1 0 
if.then3:
  %4 = inttoptr i64 %"$right#0" to i64* 
  %5 = getelementptr  i64, i64* %4, i64 0 
  %6 = load  i64, i64* %5 
  %"8$$$#0" = icmp eq i64 %3, %6 
  ret i1 %"8$$$#0" 
if.else3:
  ret i1 0 
if.then4:
  %7 = add   i64 %"$left#0", -1 
  %8 = inttoptr i64 %7 to i64* 
  %9 = getelementptr  i64, i64* %8, i64 0 
  %10 = load  i64, i64* %9 
  %11 = add   i64 %"$left#0", 7 
  %12 = inttoptr i64 %11 to i64* 
  %13 = getelementptr  i64, i64* %12, i64 0 
  %14 = load  i64, i64* %13 
  %"10$tmp$18#0" = icmp ne i64 %"$right#0", 0 
  br i1 %"10$tmp$18#0", label %if.then5, label %if.else5 
if.else4:
  ret i1 0 
if.then5:
  %"12$tmp$19#0" = and i64 %"$right#0", 7 
  %"12$tmp$20#0" = icmp eq i64 %"12$tmp$19#0", 1 
  br i1 %"12$tmp$20#0", label %if.then6, label %if.else6 
if.else5:
  ret i1 0 
if.then6:
  %15 = add   i64 %"$right#0", -1 
  %16 = inttoptr i64 %15 to i64* 
  %17 = getelementptr  i64, i64* %16, i64 0 
  %18 = load  i64, i64* %17 
  %19 = add   i64 %"$right#0", 7 
  %20 = inttoptr i64 %19 to i64* 
  %21 = getelementptr  i64, i64* %20, i64 0 
  %22 = load  i64, i64* %21 
  %"14$tmp$5#0" = icmp eq i64 %10, %18 
  br i1 %"14$tmp$5#0", label %if.then7, label %if.else7 
if.else6:
  ret i1 0 
if.then7:
  %"16$$$#0" = icmp eq i64 %14, %22 
  ret i1 %"16$$$#0" 
if.else7:
  ret i1 0 
}


define external fastcc  i64 @"multictr.simple.one<0>"(i64  %"one_field#0")    {
entry:
  %23 = trunc i64 8 to i32  
  %24 = tail call ccc  i8*  @wybe_malloc(i32  %23)  
  %25 = ptrtoint i8* %24 to i64 
  %26 = inttoptr i64 %25 to i64* 
  %27 = getelementptr  i64, i64* %26, i64 0 
  store  i64 %"one_field#0", i64* %27 
  ret i64 %25 
}


define external fastcc  {i64, i1} @"multictr.simple.one<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 0 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %35 = insertvalue {i64, i1} undef, i64 undef, 0 
  %36 = insertvalue {i64, i1} %35, i1 0, 1 
  ret {i64, i1} %36 
if.then1:
  %28 = inttoptr i64 %"$#0" to i64* 
  %29 = getelementptr  i64, i64* %28, i64 0 
  %30 = load  i64, i64* %29 
  %31 = insertvalue {i64, i1} undef, i64 %30, 0 
  %32 = insertvalue {i64, i1} %31, i1 1, 1 
  ret {i64, i1} %32 
if.else1:
  %33 = insertvalue {i64, i1} undef, i64 undef, 0 
  %34 = insertvalue {i64, i1} %33, i1 0, 1 
  ret {i64, i1} %34 
}


define external fastcc  {i64, i1} @"multictr.simple.one_field<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 0 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %44 = insertvalue {i64, i1} undef, i64 undef, 0 
  %45 = insertvalue {i64, i1} %44, i1 0, 1 
  ret {i64, i1} %45 
if.then1:
  %37 = inttoptr i64 %"$rec#0" to i64* 
  %38 = getelementptr  i64, i64* %37, i64 0 
  %39 = load  i64, i64* %38 
  %40 = insertvalue {i64, i1} undef, i64 %39, 0 
  %41 = insertvalue {i64, i1} %40, i1 1, 1 
  ret {i64, i1} %41 
if.else1:
  %42 = insertvalue {i64, i1} undef, i64 undef, 0 
  %43 = insertvalue {i64, i1} %42, i1 0, 1 
  ret {i64, i1} %43 
}


define external fastcc  {i64, i1} @"multictr.simple.one_field<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 0 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %58 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %59 = insertvalue {i64, i1} %58, i1 0, 1 
  ret {i64, i1} %59 
if.then1:
  %46 = trunc i64 8 to i32  
  %47 = tail call ccc  i8*  @wybe_malloc(i32  %46)  
  %48 = ptrtoint i8* %47 to i64 
  %49 = inttoptr i64 %48 to i8* 
  %50 = inttoptr i64 %"$rec#0" to i8* 
  %51 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %49, i8*  %50, i32  %51, i32  8, i1  0)  
  %52 = inttoptr i64 %48 to i64* 
  %53 = getelementptr  i64, i64* %52, i64 0 
  store  i64 %"$field#0", i64* %53 
  %54 = insertvalue {i64, i1} undef, i64 %48, 0 
  %55 = insertvalue {i64, i1} %54, i1 1, 1 
  ret {i64, i1} %55 
if.else1:
  %56 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %57 = insertvalue {i64, i1} %56, i1 0, 1 
  ret {i64, i1} %57 
}


define external fastcc  i64 @"multictr.simple.two<0>"(i64  %"two_field1#0", i64  %"two_field2#0")    {
entry:
  %60 = trunc i64 16 to i32  
  %61 = tail call ccc  i8*  @wybe_malloc(i32  %60)  
  %62 = ptrtoint i8* %61 to i64 
  %63 = inttoptr i64 %62 to i64* 
  %64 = getelementptr  i64, i64* %63, i64 0 
  store  i64 %"two_field1#0", i64* %64 
  %65 = add   i64 %62, 8 
  %66 = inttoptr i64 %65 to i64* 
  %67 = getelementptr  i64, i64* %66, i64 0 
  store  i64 %"two_field2#0", i64* %67 
  %"1$$#0" = or i64 %62, 1 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i64, i1} @"multictr.simple.two<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 1 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %82 = insertvalue {i64, i64, i1} undef, i64 undef, 0 
  %83 = insertvalue {i64, i64, i1} %82, i64 undef, 1 
  %84 = insertvalue {i64, i64, i1} %83, i1 0, 2 
  ret {i64, i64, i1} %84 
if.then1:
  %68 = add   i64 %"$#0", -1 
  %69 = inttoptr i64 %68 to i64* 
  %70 = getelementptr  i64, i64* %69, i64 0 
  %71 = load  i64, i64* %70 
  %72 = add   i64 %"$#0", 7 
  %73 = inttoptr i64 %72 to i64* 
  %74 = getelementptr  i64, i64* %73, i64 0 
  %75 = load  i64, i64* %74 
  %76 = insertvalue {i64, i64, i1} undef, i64 %71, 0 
  %77 = insertvalue {i64, i64, i1} %76, i64 %75, 1 
  %78 = insertvalue {i64, i64, i1} %77, i1 1, 2 
  ret {i64, i64, i1} %78 
if.else1:
  %79 = insertvalue {i64, i64, i1} undef, i64 undef, 0 
  %80 = insertvalue {i64, i64, i1} %79, i64 undef, 1 
  %81 = insertvalue {i64, i64, i1} %80, i1 0, 2 
  ret {i64, i64, i1} %81 
}


define external fastcc  {i64, i1} @"multictr.simple.two_field1<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 1 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %93 = insertvalue {i64, i1} undef, i64 undef, 0 
  %94 = insertvalue {i64, i1} %93, i1 0, 1 
  ret {i64, i1} %94 
if.then1:
  %85 = add   i64 %"$rec#0", -1 
  %86 = inttoptr i64 %85 to i64* 
  %87 = getelementptr  i64, i64* %86, i64 0 
  %88 = load  i64, i64* %87 
  %89 = insertvalue {i64, i1} undef, i64 %88, 0 
  %90 = insertvalue {i64, i1} %89, i1 1, 1 
  ret {i64, i1} %90 
if.else1:
  %91 = insertvalue {i64, i1} undef, i64 undef, 0 
  %92 = insertvalue {i64, i1} %91, i1 0, 1 
  ret {i64, i1} %92 
}


define external fastcc  {i64, i1} @"multictr.simple.two_field1<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 1 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %110 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %111 = insertvalue {i64, i1} %110, i1 0, 1 
  ret {i64, i1} %111 
if.then1:
  %95 = trunc i64 16 to i32  
  %96 = tail call ccc  i8*  @wybe_malloc(i32  %95)  
  %97 = ptrtoint i8* %96 to i64 
  %98 = add   i64 %97, 1 
  %99 = sub   i64 %"$rec#0", 1 
  %100 = inttoptr i64 %97 to i8* 
  %101 = inttoptr i64 %99 to i8* 
  %102 = trunc i64 16 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %100, i8*  %101, i32  %102, i32  8, i1  0)  
  %103 = add   i64 %98, -1 
  %104 = inttoptr i64 %103 to i64* 
  %105 = getelementptr  i64, i64* %104, i64 0 
  store  i64 %"$field#0", i64* %105 
  %106 = insertvalue {i64, i1} undef, i64 %98, 0 
  %107 = insertvalue {i64, i1} %106, i1 1, 1 
  ret {i64, i1} %107 
if.else1:
  %108 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %109 = insertvalue {i64, i1} %108, i1 0, 1 
  ret {i64, i1} %109 
}


define external fastcc  {i64, i1} @"multictr.simple.two_field2<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 1 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %120 = insertvalue {i64, i1} undef, i64 undef, 0 
  %121 = insertvalue {i64, i1} %120, i1 0, 1 
  ret {i64, i1} %121 
if.then1:
  %112 = add   i64 %"$rec#0", 7 
  %113 = inttoptr i64 %112 to i64* 
  %114 = getelementptr  i64, i64* %113, i64 0 
  %115 = load  i64, i64* %114 
  %116 = insertvalue {i64, i1} undef, i64 %115, 0 
  %117 = insertvalue {i64, i1} %116, i1 1, 1 
  ret {i64, i1} %117 
if.else1:
  %118 = insertvalue {i64, i1} undef, i64 undef, 0 
  %119 = insertvalue {i64, i1} %118, i1 0, 1 
  ret {i64, i1} %119 
}


define external fastcc  {i64, i1} @"multictr.simple.two_field2<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$2#0" = and i64 %"$rec#0", 7 
  %"2$tmp$1#0" = icmp eq i64 %"2$tmp$2#0", 1 
  br i1 %"2$tmp$1#0", label %if.then1, label %if.else1 
if.else:
  %137 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %138 = insertvalue {i64, i1} %137, i1 0, 1 
  ret {i64, i1} %138 
if.then1:
  %122 = trunc i64 16 to i32  
  %123 = tail call ccc  i8*  @wybe_malloc(i32  %122)  
  %124 = ptrtoint i8* %123 to i64 
  %125 = add   i64 %124, 1 
  %126 = sub   i64 %"$rec#0", 1 
  %127 = inttoptr i64 %124 to i8* 
  %128 = inttoptr i64 %126 to i8* 
  %129 = trunc i64 16 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %127, i8*  %128, i32  %129, i32  8, i1  0)  
  %130 = add   i64 %125, 7 
  %131 = inttoptr i64 %130 to i64* 
  %132 = getelementptr  i64, i64* %131, i64 0 
  store  i64 %"$field#0", i64* %132 
  %133 = insertvalue {i64, i1} undef, i64 %125, 0 
  %134 = insertvalue {i64, i1} %133, i1 1, 1 
  ret {i64, i1} %134 
if.else1:
  %135 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %136 = insertvalue {i64, i1} %135, i1 0, 1 
  ret {i64, i1} %136 
}


define external fastcc  i64 @"multictr.simple.zero<0>"()    {
entry:
  ret i64 0 
}
--------------------------------------------------
 Module multictr.suit
  representation  : 2 bit unsigned
  public submods  : 
  public resources: 
  public procs    : multictr.suit./=<0>
                    multictr.suit.=<0>
                    multictr.suit.clubs<0>
                    multictr.suit.diamonds<0>
                    multictr.suit.hearts<0>
                    multictr.suit.spades<0>
  imports         : use multictr
                    use wybe
  resources       : 
  procs           : 

/= > public {inline} (0 calls)
0: multictr.suit./=<0>
/=($left#0:multictr.suit, $right#0:multictr.suit, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_eq(~$left#0:multictr.suit, ~$right#0:multictr.suit, ?tmp$0#0:wybe.bool)
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public {inline} (1 calls)
0: multictr.suit.=<0>
=($left#0:multictr.suit, $right#0:multictr.suit, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp_eq(~$left#0:multictr.suit, ~$right#0:multictr.suit, ?$$#0:!wybe.bool)


clubs > public {inline} (0 calls)
0: multictr.suit.clubs<0>
clubs(?$#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.suit, ?$#0:multictr.suit)


diamonds > public {inline} (0 calls)
0: multictr.suit.diamonds<0>
diamonds(?$#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(1:multictr.suit, ?$#0:multictr.suit)


hearts > public {inline} (0 calls)
0: multictr.suit.hearts<0>
hearts(?$#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(2:multictr.suit, ?$#0:multictr.suit)


spades > public {inline} (0 calls)
0: multictr.suit.spades<0>
spades(?$#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(3:multictr.suit, ?$#0:multictr.suit)

  LLVM code       :

; ModuleID = 'multictr.suit'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.suit./=<0>"(i2  %"$left#0", i2  %"$right#0")    {
entry:
  %"1$tmp$0#0" = icmp eq i2 %"$left#0", %"$right#0" 
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.suit.=<0>"(i2  %"$left#0", i2  %"$right#0")    {
entry:
  %"1$$$#0" = icmp eq i2 %"$left#0", %"$right#0" 
  ret i1 %"1$$$#0" 
}


define external fastcc  i2 @"multictr.suit.clubs<0>"()    {
entry:
  ret i2 0 
}


define external fastcc  i2 @"multictr.suit.diamonds<0>"()    {
entry:
  ret i2 1 
}


define external fastcc  i2 @"multictr.suit.hearts<0>"()    {
entry:
  ret i2 2 
}


define external fastcc  i2 @"multictr.suit.spades<0>"()    {
entry:
  ret i2 3 
}
--------------------------------------------------
 Module multictr.unit
  representation  : 0 bit unsigned
  public submods  : 
  public resources: 
  public procs    : multictr.unit./=<0>
                    multictr.unit.=<0>
                    multictr.unit.unit<0>
  imports         : use multictr
                    use wybe
  resources       : 
  procs           : 

/= > public {inline} (0 calls)
0: multictr.unit./=<0>
/=([$left#0:multictr.unit], [$right#0:multictr.unit], ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)


= > public {inline} (1 calls)
0: multictr.unit.=<0>
=([$left#0:multictr.unit], [$right#0:multictr.unit], ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


unit > public {inline} (0 calls)
0: multictr.unit.unit<0>
unit(?$#0:multictr.unit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.unit, ?$#0:multictr.unit)

  LLVM code       :

; ModuleID = 'multictr.unit'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.unit./=<0>"()    {
entry:
  ret i1 0 
}


define external fastcc  i1 @"multictr.unit.=<0>"()    {
entry:
  ret i1 1 
}


define external fastcc  void @"multictr.unit.unit<0>"()    {
entry:
  ret void 
}
