======================================================================
AFTER EVERYTHING:
 Module multictr
  public submods  : 
  public types    : card: (multictr.card,Just 6 bit unsigned)
                    complicated: (multictr.complicated,Just address)
                    length: (multictr.length,Just 64 bit unsigned)
                    maybe_int: (multictr.maybe_int,Just address)
                    number: (multictr.number,Just address)
                    perhaps: (multictr.perhaps,Just 64 bit unsigned)
                    rank: (multictr.rank,Just 4 bit unsigned)
                    simple: (multictr.simple,Just address)
                    suit: (multictr.suit,Just 2 bit unsigned)
                    unit: (multictr.unit,Just 0 bit unsigned)
  public resources: 
  public procs    : multictr.card./=<0>
                    multictr.card.=<0>
                    multictr.card.card<0>
                    multictr.card.card<1>
                    multictr.card.rank<0>
                    multictr.card.rank<1>
                    multictr.card.suit<0>
                    multictr.card.suit<1>
                    multictr.complicated./=<0>
                    multictr.complicated.=<0>
                    multictr.complicated.autumn<0>
                    multictr.complicated.c01<0>
                    multictr.complicated.c01<1>
                    multictr.complicated.c02<0>
                    multictr.complicated.c02<1>
                    multictr.complicated.f01<0>
                    multictr.complicated.f01<1>
                    multictr.complicated.f02<0>
                    multictr.complicated.f02<1>
                    multictr.complicated.spring<0>
                    multictr.complicated.summer<0>
                    multictr.complicated.winter<0>
                    multictr.length./=<0>
                    multictr.length.=<0>
                    multictr.length.metres<0>
                    multictr.length.metres<1>
                    multictr.length.value<0>
                    multictr.length.value<1>
                    multictr.maybe_int./=<0>
                    multictr.maybe_int.=<0>
                    multictr.maybe_int.just<0>
                    multictr.maybe_int.just<1>
                    multictr.maybe_int.nothing<0>
                    multictr.maybe_int.value<0>
                    multictr.maybe_int.value<1>
                    multictr.number./=<0>
                    multictr.number.=<0>
                    multictr.number.float<0>
                    multictr.number.float<1>
                    multictr.number.float_value<0>
                    multictr.number.float_value<1>
                    multictr.number.int<0>
                    multictr.number.int<1>
                    multictr.number.int_value<0>
                    multictr.number.int_value<1>
                    multictr.perhaps./=<0>
                    multictr.perhaps.=<0>
                    multictr.perhaps.content<0>
                    multictr.perhaps.content<1>
                    multictr.perhaps.perhaps<0>
                    multictr.perhaps.perhaps<1>
                    multictr.rank./=<0>
                    multictr.rank.=<0>
                    multictr.rank.ace<0>
                    multictr.rank.jack<0>
                    multictr.rank.king<0>
                    multictr.rank.queen<0>
                    multictr.rank.r10<0>
                    multictr.rank.r2<0>
                    multictr.rank.r3<0>
                    multictr.rank.r4<0>
                    multictr.rank.r5<0>
                    multictr.rank.r6<0>
                    multictr.rank.r7<0>
                    multictr.rank.r8<0>
                    multictr.rank.r9<0>
                    multictr.simple./=<0>
                    multictr.simple.=<0>
                    multictr.simple.one<0>
                    multictr.simple.one<1>
                    multictr.simple.one_field<0>
                    multictr.simple.one_field<1>
                    multictr.simple.two<0>
                    multictr.simple.two<1>
                    multictr.simple.two_field1<0>
                    multictr.simple.two_field1<1>
                    multictr.simple.two_field2<0>
                    multictr.simple.two_field2<1>
                    multictr.simple.zero<0>
                    multictr.suit./=<0>
                    multictr.suit.=<0>
                    multictr.suit.clubs<0>
                    multictr.suit.diamonds<0>
                    multictr.suit.hearts<0>
                    multictr.suit.spades<0>
                    multictr.unit./=<0>
                    multictr.unit.=<0>
                    multictr.unit.unit<0>
  imports         : public use multictr.card
                    public use multictr.complicated
                    public use multictr.length
                    public use multictr.maybe_int
                    public use multictr.number
                    public use multictr.perhaps
                    public use multictr.rank
                    public use multictr.simple
                    public use multictr.suit
                    public use multictr.unit
                    use wybe
  types           : card/public  is 6 bit unsigned { card(rank:rank, suit:suit) @multictr:16:9  }  @multictr:15:5, complicated/public  is address { winter() @multictr:54:8 | spring() @multictr:54:17 | summer() @multictr:54:26 | autumn() @multictr:54:35 | c01(f01:int) @multictr:55:8 | c02(f02:int) @multictr:56:8  }  @multictr:53:5, length/public  is 64 bit unsigned { metres(value:float) @multictr:25:9  }  @multictr:24:5, maybe_int/public  is address { nothing() @multictr:35:9 | just(value:int) @multictr:36:9  }  @multictr:34:5, number/public  is address { int(int_value:int) @multictr:41:8 | float(float_value:float) @multictr:42:8  }  @multictr:40:5, perhaps/public  is 64 bit unsigned { perhaps(content:maybe_int) @multictr:30:9  }  @multictr:29:5, rank/public  is 4 bit unsigned { r2() @multictr:10:9 | r3() @multictr:10:14 | r4() @multictr:10:19 | r5() @multictr:10:24 | r6() @multictr:10:29 | r7() @multictr:10:34 | r8() @multictr:10:39 | r9() @multictr:11:9 | r10() @multictr:11:14 | jack() @multictr:11:20 | queen() @multictr:11:27 | king() @multictr:11:35 | ace() @multictr:11:42  }  @multictr:9:5, simple/public  is address { zero() @multictr:47:8 | one(one_field:int) @multictr:48:8 | two(two_field1:int, two_field2:int) @multictr:49:8  }  @multictr:46:5, suit/public  is 2 bit unsigned { clubs() @multictr:5:9 | diamonds() @multictr:5:17 | hearts() @multictr:5:28 | spades() @multictr:5:37  }  @multictr:4:5, unit/public  is 0 bit unsigned { unit() @multictr:20:21  }  @multictr:20:5
  resources       : 
  submodules      : multictr.card, multictr.complicated, multictr.length, multictr.maybe_int, multictr.number, multictr.perhaps, multictr.rank, multictr.simple, multictr.suit, multictr.unit
  procs           : 


  LLVM code       :

; ModuleID = 'multictr'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    
--------------------------------------------------
 Module multictr.card
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.card./=<0>
                    multictr.card.=<0>
                    multictr.card.card<0>
                    multictr.card.card<1>
                    multictr.card.rank<0>
                    multictr.card.rank<1>
                    multictr.card.suit<0>
                    multictr.card.suit<1>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline (0 calls)
0: /=($left#0:multictr.card, $right#0:multictr.card, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.card, ~$right#0:multictr.card, ?tmp$0#0:wybe.bool)
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public inline (1 calls)
0: =($left#0:multictr.card, $right#0:multictr.card, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.card, ~$right#0:multictr.card, ?$$#0:wybe.bool)


card > public inline (0 calls)
0: card(suit#0:multictr.suit, rank#0:multictr.rank, ?$#3:multictr.card):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm shl(~rank#0:!multictr.card, 2:multictr.card, ?$temp#1:multictr.card)
    foreign llvm or(~$temp#1:multictr.card, ~suit#0:!multictr.card, ?$#3:multictr.card)
card > public inline (0 calls)
1: card(?suit#0:multictr.suit, ?rank#0:multictr.rank, $#0:multictr.card):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($#0:multictr.card, 3:multictr.card, ?$temp2#0:multictr.card)
    foreign lpvm cast(~$temp2#0:multictr.card, ?suit#0:multictr.suit)
    foreign llvm lshr(~$#0:multictr.card, 2:multictr.card, ?$temp#1:multictr.card)
    foreign llvm and(~$temp#1:multictr.card, 15:multictr.card, ?$temp2#1:multictr.card)
    foreign lpvm cast(~$temp2#1:multictr.card, ?rank#0:multictr.rank)


rank > public inline (0 calls)
0: rank($rec#0:multictr.card, ?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm lshr(~$rec#0:multictr.card, 2:multictr.card, ?$rec#1:multictr.card)
    foreign llvm and(~$rec#1:multictr.card, 15:multictr.card, ?$field#0:multictr.card)
    foreign lpvm cast(~$field#0:multictr.card, ?$#0:multictr.rank)
rank > public inline (0 calls)
1: rank($rec#0:multictr.card, ?$rec#2:multictr.card, $field#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and(~$rec#0:multictr.card, -61:multictr.card, ?$rec#1:multictr.card)
    foreign llvm shl(~$field#0:!multictr.card, 2:multictr.card, ?$field#1:multictr.card)
    foreign llvm or(~$field#1:multictr.card, ~$rec#1:multictr.card, ?$rec#2:multictr.card)


suit > public inline (0 calls)
0: suit($rec#0:multictr.card, ?$#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and(~$rec#0:multictr.card, 3:multictr.card, ?$field#0:multictr.card)
    foreign lpvm cast(~$field#0:multictr.card, ?$#0:multictr.suit)
suit > public inline (0 calls)
1: suit($rec#0:multictr.card, ?$rec#2:multictr.card, $field#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and(~$rec#0:multictr.card, -4:multictr.card, ?$rec#1:multictr.card)
    foreign llvm or(~$field#0:!multictr.card, ~$rec#1:multictr.card, ?$rec#2:multictr.card)

  LLVM code       :

; ModuleID = 'multictr.card'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.card./=<0>"(i6  %"$left#0", i6  %"$right#0")    {
entry:
  %"1$tmp$0#0" = icmp eq i6 %"$left#0", %"$right#0" 
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.card.=<0>"(i6  %"$left#0", i6  %"$right#0")    {
entry:
  %"1$$$#0" = icmp eq i6 %"$left#0", %"$right#0" 
  ret i1 %"1$$$#0" 
}


define external fastcc  i6 @"multictr.card.card<0>"(i2  %"suit#0", i4  %"rank#0")    {
entry:
  %1 = zext i4 %"rank#0" to i6  
  %"1$$temp#1" = shl   i6 %1, 2 
  %2 = zext i2 %"suit#0" to i6  
  %"1$$#3" = or i6 %"1$$temp#1", %2 
  ret i6 %"1$$#3" 
}


define external fastcc  {i2, i4} @"multictr.card.card<1>"(i6  %"$#0")    {
entry:
  %"1$$temp2#0" = and i6 %"$#0", 3 
  %3 = trunc i6 %"1$$temp2#0" to i2  
  %"1$$temp#1" = lshr  i6 %"$#0", 2 
  %"1$$temp2#1" = and i6 %"1$$temp#1", 15 
  %4 = trunc i6 %"1$$temp2#1" to i4  
  %5 = insertvalue {i2, i4} undef, i2 %3, 0 
  %6 = insertvalue {i2, i4} %5, i4 %4, 1 
  ret {i2, i4} %6 
}


define external fastcc  i4 @"multictr.card.rank<0>"(i6  %"$rec#0")    {
entry:
  %"1$$rec#1" = lshr  i6 %"$rec#0", 2 
  %"1$$field#0" = and i6 %"1$$rec#1", 15 
  %7 = trunc i6 %"1$$field#0" to i4  
  ret i4 %7 
}


define external fastcc  i6 @"multictr.card.rank<1>"(i6  %"$rec#0", i4  %"$field#0")    {
entry:
  %"1$$rec#1" = and i6 %"$rec#0", -61 
  %8 = zext i4 %"$field#0" to i6  
  %"1$$field#1" = shl   i6 %8, 2 
  %"1$$rec#2" = or i6 %"1$$field#1", %"1$$rec#1" 
  ret i6 %"1$$rec#2" 
}


define external fastcc  i2 @"multictr.card.suit<0>"(i6  %"$rec#0")    {
entry:
  %"1$$field#0" = and i6 %"$rec#0", 3 
  %9 = trunc i6 %"1$$field#0" to i2  
  ret i2 %9 
}


define external fastcc  i6 @"multictr.card.suit<1>"(i6  %"$rec#0", i2  %"$field#0")    {
entry:
  %"1$$rec#1" = and i6 %"$rec#0", -4 
  %10 = zext i2 %"$field#0" to i6  
  %"1$$rec#2" = or i6 %10, %"1$$rec#1" 
  ret i6 %"1$$rec#2" 
}
--------------------------------------------------
 Module multictr.complicated
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.complicated./=<0>
                    multictr.complicated.=<0>
                    multictr.complicated.autumn<0>
                    multictr.complicated.c01<0>
                    multictr.complicated.c01<1>
                    multictr.complicated.c02<0>
                    multictr.complicated.c02<1>
                    multictr.complicated.f01<0>
                    multictr.complicated.f01<1>
                    multictr.complicated.f02<0>
                    multictr.complicated.f02<1>
                    multictr.complicated.spring<0>
                    multictr.complicated.summer<0>
                    multictr.complicated.winter<0>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline (0 calls)
0: /=($left#0:multictr.complicated, $right#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    multictr.complicated.=<0>(~$left#0:multictr.complicated, ~$right#0:multictr.complicated, ?tmp$0#0:wybe.bool) #0
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public (3 calls)
0: =($left#0:multictr.complicated, $right#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp uge($left#0:!wybe.int, 4:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm icmp eq(~$left#0:multictr.complicated, ~$right#0:multictr.complicated, ?$$#0:wybe.bool)

    1:
        foreign llvm and($left#0:multictr.complicated, 7:wybe.int, ?tmp$10#0:wybe.int)
        foreign llvm icmp eq(tmp$10#0:wybe.int, 0:wybe.int, ?tmp$11#0:wybe.bool)
        case ~tmp$11#0:wybe.bool of
        0:
            foreign llvm icmp eq(~tmp$10#0:wybe.int, 1:wybe.int, ?tmp$15#0:wybe.bool)
            case ~tmp$15#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign lpvm access(~$left#0:multictr.complicated, -1:wybe.int, 8:wybe.int, 1:wybe.int, ?$left$f02#0:wybe.int)
                foreign llvm icmp uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$17#0:wybe.bool)
                case ~tmp$17#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$18#0:wybe.int)
                    foreign llvm icmp eq(~tmp$18#0:wybe.int, 1:wybe.int, ?tmp$19#0:wybe.bool)
                    case ~tmp$19#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        foreign lpvm access(~$right#0:multictr.complicated, -1:wybe.int, 8:wybe.int, 1:wybe.int, ?$right$f02#0:wybe.int)
                        foreign llvm icmp eq(~$left$f02#0:wybe.int, ~$right$f02#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn




        1:
            foreign lpvm access(~$left#0:multictr.complicated, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$left$f01#0:wybe.int)
            foreign llvm icmp uge($right#0:multictr.complicated, 4:wybe.int, ?tmp$13#0:wybe.bool)
            case ~tmp$13#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign llvm and($right#0:multictr.complicated, 7:wybe.int, ?tmp$14#0:wybe.int)
                foreign llvm icmp eq(~tmp$14#0:wybe.int, 0:wybe.int, ?tmp$15#0:wybe.bool)
                case ~tmp$15#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign lpvm access(~$right#0:multictr.complicated, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$right$f01#0:wybe.int)
                    foreign llvm icmp eq(~$left$f01#0:wybe.int, ~$right$f01#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn






autumn > public inline (0 calls)
0: autumn(?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(3:multictr.complicated, ?$#0:multictr.complicated)


c01 > public inline (0 calls)
0: c01(f01#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:!multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$#0:multictr.complicated, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~f01#0:wybe.int)
c01 > public inline (10 calls)
1: c01(?f01#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp uge($#0:multictr.complicated, 4:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($#0:multictr.complicated, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$#0:multictr.complicated, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?f01#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




c02 > public inline (0 calls)
0: c02(f02#0:wybe.int, ?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:!multictr.complicated)
    foreign lpvm mutate(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~f02#0:wybe.int)
    foreign llvm or(~$rec#1, 1:wybe.int, ?$#0:multictr.complicated)
c02 > public inline (5 calls)
1: c02(?f02#0:wybe.int, $#0:multictr.complicated, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp uge($#0:multictr.complicated, 4:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($#0:multictr.complicated, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$#0:multictr.complicated, -1:wybe.int, 8:wybe.int, 1:wybe.int, ?f02#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




f01 > public inline (0 calls)
0: f01($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp uge($rec#0:multictr.complicated, 4:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($rec#0:multictr.complicated, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$rec#0:multictr.complicated, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


f01 > public inline (0 calls)
1: f01($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp uge($rec#0:multictr.complicated, 4:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:multictr.complicated, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm mutate noalias(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, 0:wybe.int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




f02 > public inline (0 calls)
0: f02($rec#0:multictr.complicated, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp uge($rec#0:multictr.complicated, 4:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($rec#0:multictr.complicated, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$rec#0:multictr.complicated, -1:wybe.int, 8:wybe.int, 1:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


f02 > public inline (0 calls)
1: f02($rec#0:multictr.complicated, ?$rec#1:multictr.complicated, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp uge($rec#0:multictr.complicated, 4:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

    1:
        foreign llvm and($rec#0:multictr.complicated, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.complicated, ?$rec#1:multictr.complicated)

        1:
            foreign lpvm mutate noalias(~%$rec#0:multictr.complicated, ?%$rec#1:multictr.complicated, -1:wybe.int, 0:wybe.int, 8:wybe.int, 1:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




spring > public inline (0 calls)
0: spring(?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(1:multictr.complicated, ?$#0:multictr.complicated)


summer > public inline (0 calls)
0: summer(?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(2:multictr.complicated, ?$#0:multictr.complicated)


winter > public inline (0 calls)
0: winter(?$#0:multictr.complicated):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.complicated, ?$#0:multictr.complicated)

  LLVM code       :

; ModuleID = 'multictr.complicated'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.complicated./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = tail call fastcc  i1  @"multictr.complicated.=<0>"(i64  %"$left#0", i64  %"$right#0")  
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.complicated.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$left#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$10#0" = and i64 %"$left#0", 7 
  %"2$tmp$11#0" = icmp eq i64 %"2$tmp$10#0", 0 
  br i1 %"2$tmp$11#0", label %if.then1, label %if.else1 
if.else:
  %"3$$$#0" = icmp eq i64 %"$left#0", %"$right#0" 
  ret i1 %"3$$$#0" 
if.then1:
  %1 = inttoptr i64 %"$left#0" to i64* 
  %2 = getelementptr  i64, i64* %1, i64 0 
  %3 = load  i64, i64* %2 
  %"4$tmp$13#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"4$tmp$13#0", label %if.then2, label %if.else2 
if.else1:
  %"5$tmp$15#0" = icmp eq i64 %"2$tmp$10#0", 1 
  br i1 %"5$tmp$15#0", label %if.then4, label %if.else4 
if.then2:
  %"6$tmp$14#0" = and i64 %"$right#0", 7 
  %"6$tmp$15#0" = icmp eq i64 %"6$tmp$14#0", 0 
  br i1 %"6$tmp$15#0", label %if.then3, label %if.else3 
if.else2:
  ret i1 0 
if.then3:
  %4 = inttoptr i64 %"$right#0" to i64* 
  %5 = getelementptr  i64, i64* %4, i64 0 
  %6 = load  i64, i64* %5 
  %"8$$$#0" = icmp eq i64 %3, %6 
  ret i1 %"8$$$#0" 
if.else3:
  ret i1 0 
if.then4:
  %7 = add   i64 %"$left#0", -1 
  %8 = inttoptr i64 %7 to i64* 
  %9 = getelementptr  i64, i64* %8, i64 0 
  %10 = load  i64, i64* %9 
  %"10$tmp$17#0" = icmp uge i64 %"$right#0", 4 
  br i1 %"10$tmp$17#0", label %if.then5, label %if.else5 
if.else4:
  ret i1 0 
if.then5:
  %"12$tmp$18#0" = and i64 %"$right#0", 7 
  %"12$tmp$19#0" = icmp eq i64 %"12$tmp$18#0", 1 
  br i1 %"12$tmp$19#0", label %if.then6, label %if.else6 
if.else5:
  ret i1 0 
if.then6:
  %11 = add   i64 %"$right#0", -1 
  %12 = inttoptr i64 %11 to i64* 
  %13 = getelementptr  i64, i64* %12, i64 0 
  %14 = load  i64, i64* %13 
  %"14$$$#0" = icmp eq i64 %10, %14 
  ret i1 %"14$$$#0" 
if.else6:
  ret i1 0 
}


define external fastcc  i64 @"multictr.complicated.autumn<0>"()    {
entry:
  ret i64 3 
}


define external fastcc  i64 @"multictr.complicated.c01<0>"(i64  %"f01#0")    {
entry:
  %15 = trunc i64 8 to i32  
  %16 = tail call ccc  i8*  @wybe_malloc(i32  %15)  
  %17 = ptrtoint i8* %16 to i64 
  %18 = inttoptr i64 %17 to i64* 
  %19 = getelementptr  i64, i64* %18, i64 0 
  store  i64 %"f01#0", i64* %19 
  ret i64 %17 
}


define external fastcc  {i64, i1} @"multictr.complicated.c01<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 0 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %27 = insertvalue {i64, i1} undef, i64 undef, 0 
  %28 = insertvalue {i64, i1} %27, i1 0, 1 
  ret {i64, i1} %28 
if.then1:
  %20 = inttoptr i64 %"$#0" to i64* 
  %21 = getelementptr  i64, i64* %20, i64 0 
  %22 = load  i64, i64* %21 
  %23 = insertvalue {i64, i1} undef, i64 %22, 0 
  %24 = insertvalue {i64, i1} %23, i1 1, 1 
  ret {i64, i1} %24 
if.else1:
  %25 = insertvalue {i64, i1} undef, i64 undef, 0 
  %26 = insertvalue {i64, i1} %25, i1 0, 1 
  ret {i64, i1} %26 
}


define external fastcc  i64 @"multictr.complicated.c02<0>"(i64  %"f02#0")    {
entry:
  %29 = trunc i64 8 to i32  
  %30 = tail call ccc  i8*  @wybe_malloc(i32  %29)  
  %31 = ptrtoint i8* %30 to i64 
  %32 = inttoptr i64 %31 to i64* 
  %33 = getelementptr  i64, i64* %32, i64 0 
  store  i64 %"f02#0", i64* %33 
  %"1$$#0" = or i64 %31, 1 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i1} @"multictr.complicated.c02<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 1 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %42 = insertvalue {i64, i1} undef, i64 undef, 0 
  %43 = insertvalue {i64, i1} %42, i1 0, 1 
  ret {i64, i1} %43 
if.then1:
  %34 = add   i64 %"$#0", -1 
  %35 = inttoptr i64 %34 to i64* 
  %36 = getelementptr  i64, i64* %35, i64 0 
  %37 = load  i64, i64* %36 
  %38 = insertvalue {i64, i1} undef, i64 %37, 0 
  %39 = insertvalue {i64, i1} %38, i1 1, 1 
  ret {i64, i1} %39 
if.else1:
  %40 = insertvalue {i64, i1} undef, i64 undef, 0 
  %41 = insertvalue {i64, i1} %40, i1 0, 1 
  ret {i64, i1} %41 
}


define external fastcc  {i64, i1} @"multictr.complicated.f01<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 0 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %51 = insertvalue {i64, i1} undef, i64 undef, 0 
  %52 = insertvalue {i64, i1} %51, i1 0, 1 
  ret {i64, i1} %52 
if.then1:
  %44 = inttoptr i64 %"$rec#0" to i64* 
  %45 = getelementptr  i64, i64* %44, i64 0 
  %46 = load  i64, i64* %45 
  %47 = insertvalue {i64, i1} undef, i64 %46, 0 
  %48 = insertvalue {i64, i1} %47, i1 1, 1 
  ret {i64, i1} %48 
if.else1:
  %49 = insertvalue {i64, i1} undef, i64 undef, 0 
  %50 = insertvalue {i64, i1} %49, i1 0, 1 
  ret {i64, i1} %50 
}


define external fastcc  {i64, i1} @"multictr.complicated.f01<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 0 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %65 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %66 = insertvalue {i64, i1} %65, i1 0, 1 
  ret {i64, i1} %66 
if.then1:
  %53 = trunc i64 8 to i32  
  %54 = tail call ccc  i8*  @wybe_malloc(i32  %53)  
  %55 = ptrtoint i8* %54 to i64 
  %56 = inttoptr i64 %55 to i8* 
  %57 = inttoptr i64 %"$rec#0" to i8* 
  %58 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %56, i8*  %57, i32  %58, i32  8, i1  0)  
  %59 = inttoptr i64 %55 to i64* 
  %60 = getelementptr  i64, i64* %59, i64 0 
  store  i64 %"$field#0", i64* %60 
  %61 = insertvalue {i64, i1} undef, i64 %55, 0 
  %62 = insertvalue {i64, i1} %61, i1 1, 1 
  ret {i64, i1} %62 
if.else1:
  %63 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %64 = insertvalue {i64, i1} %63, i1 0, 1 
  ret {i64, i1} %64 
}


define external fastcc  {i64, i1} @"multictr.complicated.f02<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 1 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %75 = insertvalue {i64, i1} undef, i64 undef, 0 
  %76 = insertvalue {i64, i1} %75, i1 0, 1 
  ret {i64, i1} %76 
if.then1:
  %67 = add   i64 %"$rec#0", -1 
  %68 = inttoptr i64 %67 to i64* 
  %69 = getelementptr  i64, i64* %68, i64 0 
  %70 = load  i64, i64* %69 
  %71 = insertvalue {i64, i1} undef, i64 %70, 0 
  %72 = insertvalue {i64, i1} %71, i1 1, 1 
  ret {i64, i1} %72 
if.else1:
  %73 = insertvalue {i64, i1} undef, i64 undef, 0 
  %74 = insertvalue {i64, i1} %73, i1 0, 1 
  ret {i64, i1} %74 
}


define external fastcc  {i64, i1} @"multictr.complicated.f02<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp uge i64 %"$rec#0", 4 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 1 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %92 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %93 = insertvalue {i64, i1} %92, i1 0, 1 
  ret {i64, i1} %93 
if.then1:
  %77 = trunc i64 8 to i32  
  %78 = tail call ccc  i8*  @wybe_malloc(i32  %77)  
  %79 = ptrtoint i8* %78 to i64 
  %80 = add   i64 %79, 1 
  %81 = sub   i64 %"$rec#0", 1 
  %82 = inttoptr i64 %79 to i8* 
  %83 = inttoptr i64 %81 to i8* 
  %84 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %82, i8*  %83, i32  %84, i32  8, i1  0)  
  %85 = add   i64 %80, -1 
  %86 = inttoptr i64 %85 to i64* 
  %87 = getelementptr  i64, i64* %86, i64 0 
  store  i64 %"$field#0", i64* %87 
  %88 = insertvalue {i64, i1} undef, i64 %80, 0 
  %89 = insertvalue {i64, i1} %88, i1 1, 1 
  ret {i64, i1} %89 
if.else1:
  %90 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %91 = insertvalue {i64, i1} %90, i1 0, 1 
  ret {i64, i1} %91 
}


define external fastcc  i64 @"multictr.complicated.spring<0>"()    {
entry:
  ret i64 1 
}


define external fastcc  i64 @"multictr.complicated.summer<0>"()    {
entry:
  ret i64 2 
}


define external fastcc  i64 @"multictr.complicated.winter<0>"()    {
entry:
  ret i64 0 
}
--------------------------------------------------
 Module multictr.length
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.length./=<0>
                    multictr.length.=<0>
                    multictr.length.metres<0>
                    multictr.length.metres<1>
                    multictr.length.value<0>
                    multictr.length.value<1>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline (0 calls)
0: /=($left#0:multictr.length, $right#0:multictr.length, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.length, ~$right#0:multictr.length, ?tmp$0#0:wybe.bool)
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public inline (1 calls)
0: =($left#0:multictr.length, $right#0:multictr.length, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.length, ~$right#0:multictr.length, ?$$#0:wybe.bool)


metres > public inline (0 calls)
0: metres(value#0:wybe.float, ?$#2:multictr.length):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(~value#0:!multictr.length, ?$#2:multictr.length)
metres > public inline (0 calls)
1: metres(?value#0:wybe.float, $#0:multictr.length):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm cast(~$#0:multictr.length, ?value#0:wybe.float)


value > public inline (0 calls)
0: value($rec#0:multictr.length, ?$#0:wybe.float):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm cast(~$rec#0:multictr.length, ?$#0:wybe.float)
value > public inline (0 calls)
1: value([$rec#0:multictr.length], ?$rec#2:multictr.length, $field#0:wybe.float):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(~$field#0:!multictr.length, ?$rec#2:multictr.length)

  LLVM code       :

; ModuleID = 'multictr.length'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.length./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = icmp eq i64 %"$left#0", %"$right#0" 
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.length.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$$$#0" = icmp eq i64 %"$left#0", %"$right#0" 
  ret i1 %"1$$$#0" 
}


define external fastcc  i64 @"multictr.length.metres<0>"(double  %"value#0")    {
entry:
  %1 = bitcast double %"value#0" to i64 
  ret i64 %1 
}


define external fastcc  double @"multictr.length.metres<1>"(i64  %"$#0")    {
entry:
  %2 = bitcast i64 %"$#0" to double 
  ret double %2 
}


define external fastcc  double @"multictr.length.value<0>"(i64  %"$rec#0")    {
entry:
  %3 = bitcast i64 %"$rec#0" to double 
  ret double %3 
}


define external fastcc  i64 @"multictr.length.value<1>"(double  %"$field#0")    {
entry:
  %4 = bitcast double %"$field#0" to i64 
  ret i64 %4 
}
--------------------------------------------------
 Module multictr.maybe_int
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.maybe_int./=<0>
                    multictr.maybe_int.=<0>
                    multictr.maybe_int.just<0>
                    multictr.maybe_int.just<1>
                    multictr.maybe_int.nothing<0>
                    multictr.maybe_int.value<0>
                    multictr.maybe_int.value<1>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline (0 calls)
0: /=($left#0:multictr.maybe_int, $right#0:multictr.maybe_int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    multictr.maybe_int.=<0>(~$left#0:multictr.maybe_int, ~$right#0:multictr.maybe_int, ?tmp$0#0:wybe.bool) #0
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public (2 calls)
0: =($left#0:multictr.maybe_int, $right#0:multictr.maybe_int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($left#0:!wybe.int, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm icmp eq(~$left#0:multictr.maybe_int, ~$right#0:multictr.maybe_int, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$left#0:multictr.maybe_int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$left$value#0:wybe.int)
        foreign llvm icmp ne($right#0:multictr.maybe_int, 0:wybe.int, ?tmp$8#0:wybe.bool)
        case ~tmp$8#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$right#0:multictr.maybe_int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$right$value#0:wybe.int)
            foreign llvm icmp eq(~$left$value#0:wybe.int, ~$right$value#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn




just > public inline (0 calls)
0: just(value#0:wybe.int, ?$#0:multictr.maybe_int):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:!multictr.maybe_int)
    foreign lpvm mutate(~%$rec#0:multictr.maybe_int, ?%$#0:multictr.maybe_int, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~value#0:wybe.int)
just > public inline (8 calls)
1: just(?value#0:wybe.int, $#0:multictr.maybe_int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($#0:multictr.maybe_int, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$#0:multictr.maybe_int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?value#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



nothing > public inline (0 calls)
0: nothing(?$#0:multictr.maybe_int):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.maybe_int, ?$#0:multictr.maybe_int)


value > public inline (0 calls)
0: value($rec#0:multictr.maybe_int, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($rec#0:multictr.maybe_int, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:multictr.maybe_int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

value > public inline (0 calls)
1: value($rec#0:multictr.maybe_int, ?$rec#1:multictr.maybe_int, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($rec#0:multictr.maybe_int, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.maybe_int, ?$rec#1:multictr.maybe_int)

    1:
        foreign lpvm mutate noalias(~%$rec#0:multictr.maybe_int, ?%$rec#1:multictr.maybe_int, 0:wybe.int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


  LLVM code       :

; ModuleID = 'multictr.maybe_int'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.maybe_int./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = tail call fastcc  i1  @"multictr.maybe_int.=<0>"(i64  %"$left#0", i64  %"$right#0")  
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.maybe_int.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$left#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %1 = inttoptr i64 %"$left#0" to i64* 
  %2 = getelementptr  i64, i64* %1, i64 0 
  %3 = load  i64, i64* %2 
  %"2$tmp$8#0" = icmp ne i64 %"$right#0", 0 
  br i1 %"2$tmp$8#0", label %if.then1, label %if.else1 
if.else:
  %"3$$$#0" = icmp eq i64 %"$left#0", %"$right#0" 
  ret i1 %"3$$$#0" 
if.then1:
  %4 = inttoptr i64 %"$right#0" to i64* 
  %5 = getelementptr  i64, i64* %4, i64 0 
  %6 = load  i64, i64* %5 
  %"4$$$#0" = icmp eq i64 %3, %6 
  ret i1 %"4$$$#0" 
if.else1:
  ret i1 0 
}


define external fastcc  i64 @"multictr.maybe_int.just<0>"(i64  %"value#0")    {
entry:
  %7 = trunc i64 8 to i32  
  %8 = tail call ccc  i8*  @wybe_malloc(i32  %7)  
  %9 = ptrtoint i8* %8 to i64 
  %10 = inttoptr i64 %9 to i64* 
  %11 = getelementptr  i64, i64* %10, i64 0 
  store  i64 %"value#0", i64* %11 
  ret i64 %9 
}


define external fastcc  {i64, i1} @"multictr.maybe_int.just<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %12 = inttoptr i64 %"$#0" to i64* 
  %13 = getelementptr  i64, i64* %12, i64 0 
  %14 = load  i64, i64* %13 
  %15 = insertvalue {i64, i1} undef, i64 %14, 0 
  %16 = insertvalue {i64, i1} %15, i1 1, 1 
  ret {i64, i1} %16 
if.else:
  %17 = insertvalue {i64, i1} undef, i64 undef, 0 
  %18 = insertvalue {i64, i1} %17, i1 0, 1 
  ret {i64, i1} %18 
}


define external fastcc  i64 @"multictr.maybe_int.nothing<0>"()    {
entry:
  ret i64 0 
}


define external fastcc  {i64, i1} @"multictr.maybe_int.value<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %19 = inttoptr i64 %"$rec#0" to i64* 
  %20 = getelementptr  i64, i64* %19, i64 0 
  %21 = load  i64, i64* %20 
  %22 = insertvalue {i64, i1} undef, i64 %21, 0 
  %23 = insertvalue {i64, i1} %22, i1 1, 1 
  ret {i64, i1} %23 
if.else:
  %24 = insertvalue {i64, i1} undef, i64 undef, 0 
  %25 = insertvalue {i64, i1} %24, i1 0, 1 
  ret {i64, i1} %25 
}


define external fastcc  {i64, i1} @"multictr.maybe_int.value<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %26 = trunc i64 8 to i32  
  %27 = tail call ccc  i8*  @wybe_malloc(i32  %26)  
  %28 = ptrtoint i8* %27 to i64 
  %29 = inttoptr i64 %28 to i8* 
  %30 = inttoptr i64 %"$rec#0" to i8* 
  %31 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %29, i8*  %30, i32  %31, i32  8, i1  0)  
  %32 = inttoptr i64 %28 to i64* 
  %33 = getelementptr  i64, i64* %32, i64 0 
  store  i64 %"$field#0", i64* %33 
  %34 = insertvalue {i64, i1} undef, i64 %28, 0 
  %35 = insertvalue {i64, i1} %34, i1 1, 1 
  ret {i64, i1} %35 
if.else:
  %36 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %37 = insertvalue {i64, i1} %36, i1 0, 1 
  ret {i64, i1} %37 
}
--------------------------------------------------
 Module multictr.number
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.number./=<0>
                    multictr.number.=<0>
                    multictr.number.float<0>
                    multictr.number.float<1>
                    multictr.number.float_value<0>
                    multictr.number.float_value<1>
                    multictr.number.int<0>
                    multictr.number.int<1>
                    multictr.number.int_value<0>
                    multictr.number.int_value<1>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline (0 calls)
0: /=($left#0:multictr.number, $right#0:multictr.number, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    multictr.number.=<0>(~$left#0:multictr.number, ~$right#0:multictr.number, ?tmp$0#0:wybe.bool) #0
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public (3 calls)
0: =($left#0:multictr.number, $right#0:multictr.number, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($left#0:multictr.number, 7:wybe.int, ?tmp$8#0:wybe.int)
    foreign llvm icmp eq(tmp$8#0:wybe.int, 0:wybe.int, ?tmp$9#0:wybe.bool)
    case ~tmp$9#0:wybe.bool of
    0:
        foreign llvm icmp eq(~tmp$8#0:wybe.int, 1:wybe.int, ?tmp$12#0:wybe.bool)
        case ~tmp$12#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$left#0:multictr.number, -1:wybe.int, 8:wybe.int, 1:wybe.int, ?$left$float_value#0:wybe.float)
            foreign llvm and($right#0:multictr.number, 7:wybe.int, ?tmp$14#0:wybe.int)
            foreign llvm icmp eq(~tmp$14#0:wybe.int, 1:wybe.int, ?tmp$15#0:wybe.bool)
            case ~tmp$15#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign lpvm access(~$right#0:multictr.number, -1:wybe.int, 8:wybe.int, 1:wybe.int, ?$right$float_value#0:wybe.float)
                foreign llvm fcmp eq(~$left$float_value#0:wybe.float, ~$right$float_value#0:wybe.float, ?$$#0:wybe.bool) @wybe:nn:nn



    1:
        foreign lpvm access(~$left#0:multictr.number, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$left$int_value#0:wybe.int)
        foreign llvm and($right#0:multictr.number, 7:wybe.int, ?tmp$11#0:wybe.int)
        foreign llvm icmp eq(~tmp$11#0:wybe.int, 0:wybe.int, ?tmp$12#0:wybe.bool)
        case ~tmp$12#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$right#0:multictr.number, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$right$int_value#0:wybe.int)
            foreign llvm icmp eq(~$left$int_value#0:wybe.int, ~$right$int_value#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn




float > public inline (0 calls)
0: float(float_value#0:wybe.float, ?$#0:multictr.number):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:!multictr.number)
    foreign lpvm mutate(~%$rec#0:multictr.number, ?%$rec#1:multictr.number, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~float_value#0:wybe.float)
    foreign llvm or(~$rec#1, 1:wybe.int, ?$#0:multictr.number)
float > public inline (5 calls)
1: float(?float_value#0:wybe.float, $#0:multictr.number, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($#0:multictr.number, 7:wybe.int, ?tmp$0#0:!wybe.int)
    foreign llvm icmp eq(~tmp$0#0:!wybe.int, 1:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$#0:multictr.number, -1:wybe.int, 8:wybe.int, 1:wybe.int, ?float_value#0:wybe.float)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



float_value > public inline (0 calls)
0: float_value($rec#0:multictr.number, ?$#0:wybe.float, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($rec#0:multictr.number, 7:wybe.int, ?tmp$0#0:!wybe.int)
    foreign llvm icmp eq(~tmp$0#0:!wybe.int, 1:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:multictr.number, -1:wybe.int, 8:wybe.int, 1:wybe.int, ?$#0:wybe.float)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

float_value > public inline (0 calls)
1: float_value($rec#0:multictr.number, ?$rec#1:multictr.number, $field#0:wybe.float, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($rec#0:multictr.number, 7:wybe.int, ?tmp$0#0:!wybe.int)
    foreign llvm icmp eq(~tmp$0#0:!wybe.int, 1:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.number, ?$rec#1:multictr.number)

    1:
        foreign lpvm mutate noalias(~%$rec#0:multictr.number, ?%$rec#1:multictr.number, -1:wybe.int, 0:wybe.int, 8:wybe.int, 1:wybe.int, ~$field#0:wybe.float)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



int > public inline (0 calls)
0: int(int_value#0:wybe.int, ?$#0:multictr.number):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:!multictr.number)
    foreign lpvm mutate(~%$rec#0:multictr.number, ?%$#0:multictr.number, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~int_value#0:wybe.int)
int > public inline (10 calls)
1: int(?int_value#0:wybe.int, $#0:multictr.number, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($#0:multictr.number, 7:wybe.int, ?tmp$0#0:!wybe.int)
    foreign llvm icmp eq(~tmp$0#0:!wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$#0:multictr.number, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?int_value#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



int_value > public inline (0 calls)
0: int_value($rec#0:multictr.number, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($rec#0:multictr.number, 7:wybe.int, ?tmp$0#0:!wybe.int)
    foreign llvm icmp eq(~tmp$0#0:!wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:multictr.number, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

int_value > public inline (0 calls)
1: int_value($rec#0:multictr.number, ?$rec#1:multictr.number, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm and($rec#0:multictr.number, 7:wybe.int, ?tmp$0#0:!wybe.int)
    foreign llvm icmp eq(~tmp$0#0:!wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.number, ?$rec#1:multictr.number)

    1:
        foreign lpvm mutate noalias(~%$rec#0:multictr.number, ?%$rec#1:multictr.number, 0:wybe.int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


  LLVM code       :

; ModuleID = 'multictr.number'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.number./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = tail call fastcc  i1  @"multictr.number.=<0>"(i64  %"$left#0", i64  %"$right#0")  
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.number.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$8#0" = and i64 %"$left#0", 7 
  %"1$tmp$9#0" = icmp eq i64 %"1$tmp$8#0", 0 
  br i1 %"1$tmp$9#0", label %if.then, label %if.else 
if.then:
  %1 = inttoptr i64 %"$left#0" to i64* 
  %2 = getelementptr  i64, i64* %1, i64 0 
  %3 = load  i64, i64* %2 
  %"2$tmp$11#0" = and i64 %"$right#0", 7 
  %"2$tmp$12#0" = icmp eq i64 %"2$tmp$11#0", 0 
  br i1 %"2$tmp$12#0", label %if.then1, label %if.else1 
if.else:
  %"3$tmp$12#0" = icmp eq i64 %"1$tmp$8#0", 1 
  br i1 %"3$tmp$12#0", label %if.then2, label %if.else2 
if.then1:
  %4 = inttoptr i64 %"$right#0" to i64* 
  %5 = getelementptr  i64, i64* %4, i64 0 
  %6 = load  i64, i64* %5 
  %"4$$$#0" = icmp eq i64 %3, %6 
  ret i1 %"4$$$#0" 
if.else1:
  ret i1 0 
if.then2:
  %7 = add   i64 %"$left#0", -1 
  %8 = inttoptr i64 %7 to double* 
  %9 = getelementptr  double, double* %8, i64 0 
  %10 = load  double, double* %9 
  %"6$tmp$14#0" = and i64 %"$right#0", 7 
  %"6$tmp$15#0" = icmp eq i64 %"6$tmp$14#0", 1 
  br i1 %"6$tmp$15#0", label %if.then3, label %if.else3 
if.else2:
  ret i1 0 
if.then3:
  %11 = add   i64 %"$right#0", -1 
  %12 = inttoptr i64 %11 to double* 
  %13 = getelementptr  double, double* %12, i64 0 
  %14 = load  double, double* %13 
  %"8$$$#0" = fcmp oeq double %10, %14 
  ret i1 %"8$$$#0" 
if.else3:
  ret i1 0 
}


define external fastcc  i64 @"multictr.number.float<0>"(double  %"float_value#0")    {
entry:
  %15 = trunc i64 8 to i32  
  %16 = tail call ccc  i8*  @wybe_malloc(i32  %15)  
  %17 = ptrtoint i8* %16 to i64 
  %18 = inttoptr i64 %17 to double* 
  %19 = getelementptr  double, double* %18, i64 0 
  store  double %"float_value#0", double* %19 
  %"1$$#0" = or i64 %17, 1 
  ret i64 %"1$$#0" 
}


define external fastcc  {double, i1} @"multictr.number.float<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = and i64 %"$#0", 7 
  %"1$tmp$1#0" = icmp eq i64 %"1$tmp$0#0", 1 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  %20 = add   i64 %"$#0", -1 
  %21 = inttoptr i64 %20 to double* 
  %22 = getelementptr  double, double* %21, i64 0 
  %23 = load  double, double* %22 
  %24 = insertvalue {double, i1} undef, double %23, 0 
  %25 = insertvalue {double, i1} %24, i1 1, 1 
  ret {double, i1} %25 
if.else:
  %26 = insertvalue {double, i1} undef, double undef, 0 
  %27 = insertvalue {double, i1} %26, i1 0, 1 
  ret {double, i1} %27 
}


define external fastcc  {double, i1} @"multictr.number.float_value<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = and i64 %"$rec#0", 7 
  %"1$tmp$1#0" = icmp eq i64 %"1$tmp$0#0", 1 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  %28 = add   i64 %"$rec#0", -1 
  %29 = inttoptr i64 %28 to double* 
  %30 = getelementptr  double, double* %29, i64 0 
  %31 = load  double, double* %30 
  %32 = insertvalue {double, i1} undef, double %31, 0 
  %33 = insertvalue {double, i1} %32, i1 1, 1 
  ret {double, i1} %33 
if.else:
  %34 = insertvalue {double, i1} undef, double undef, 0 
  %35 = insertvalue {double, i1} %34, i1 0, 1 
  ret {double, i1} %35 
}


define external fastcc  {i64, i1} @"multictr.number.float_value<1>"(i64  %"$rec#0", double  %"$field#0")    {
entry:
  %"1$tmp$0#0" = and i64 %"$rec#0", 7 
  %"1$tmp$1#0" = icmp eq i64 %"1$tmp$0#0", 1 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  %36 = trunc i64 8 to i32  
  %37 = tail call ccc  i8*  @wybe_malloc(i32  %36)  
  %38 = ptrtoint i8* %37 to i64 
  %39 = add   i64 %38, 1 
  %40 = sub   i64 %"$rec#0", 1 
  %41 = inttoptr i64 %38 to i8* 
  %42 = inttoptr i64 %40 to i8* 
  %43 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %41, i8*  %42, i32  %43, i32  8, i1  0)  
  %44 = add   i64 %39, -1 
  %45 = inttoptr i64 %44 to double* 
  %46 = getelementptr  double, double* %45, i64 0 
  store  double %"$field#0", double* %46 
  %47 = insertvalue {i64, i1} undef, i64 %39, 0 
  %48 = insertvalue {i64, i1} %47, i1 1, 1 
  ret {i64, i1} %48 
if.else:
  %49 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %50 = insertvalue {i64, i1} %49, i1 0, 1 
  ret {i64, i1} %50 
}


define external fastcc  i64 @"multictr.number.int<0>"(i64  %"int_value#0")    {
entry:
  %51 = trunc i64 8 to i32  
  %52 = tail call ccc  i8*  @wybe_malloc(i32  %51)  
  %53 = ptrtoint i8* %52 to i64 
  %54 = inttoptr i64 %53 to i64* 
  %55 = getelementptr  i64, i64* %54, i64 0 
  store  i64 %"int_value#0", i64* %55 
  ret i64 %53 
}


define external fastcc  {i64, i1} @"multictr.number.int<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = and i64 %"$#0", 7 
  %"1$tmp$1#0" = icmp eq i64 %"1$tmp$0#0", 0 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  %56 = inttoptr i64 %"$#0" to i64* 
  %57 = getelementptr  i64, i64* %56, i64 0 
  %58 = load  i64, i64* %57 
  %59 = insertvalue {i64, i1} undef, i64 %58, 0 
  %60 = insertvalue {i64, i1} %59, i1 1, 1 
  ret {i64, i1} %60 
if.else:
  %61 = insertvalue {i64, i1} undef, i64 undef, 0 
  %62 = insertvalue {i64, i1} %61, i1 0, 1 
  ret {i64, i1} %62 
}


define external fastcc  {i64, i1} @"multictr.number.int_value<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = and i64 %"$rec#0", 7 
  %"1$tmp$1#0" = icmp eq i64 %"1$tmp$0#0", 0 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  %63 = inttoptr i64 %"$rec#0" to i64* 
  %64 = getelementptr  i64, i64* %63, i64 0 
  %65 = load  i64, i64* %64 
  %66 = insertvalue {i64, i1} undef, i64 %65, 0 
  %67 = insertvalue {i64, i1} %66, i1 1, 1 
  ret {i64, i1} %67 
if.else:
  %68 = insertvalue {i64, i1} undef, i64 undef, 0 
  %69 = insertvalue {i64, i1} %68, i1 0, 1 
  ret {i64, i1} %69 
}


define external fastcc  {i64, i1} @"multictr.number.int_value<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = and i64 %"$rec#0", 7 
  %"1$tmp$1#0" = icmp eq i64 %"1$tmp$0#0", 0 
  br i1 %"1$tmp$1#0", label %if.then, label %if.else 
if.then:
  %70 = trunc i64 8 to i32  
  %71 = tail call ccc  i8*  @wybe_malloc(i32  %70)  
  %72 = ptrtoint i8* %71 to i64 
  %73 = inttoptr i64 %72 to i8* 
  %74 = inttoptr i64 %"$rec#0" to i8* 
  %75 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %73, i8*  %74, i32  %75, i32  8, i1  0)  
  %76 = inttoptr i64 %72 to i64* 
  %77 = getelementptr  i64, i64* %76, i64 0 
  store  i64 %"$field#0", i64* %77 
  %78 = insertvalue {i64, i1} undef, i64 %72, 0 
  %79 = insertvalue {i64, i1} %78, i1 1, 1 
  ret {i64, i1} %79 
if.else:
  %80 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %81 = insertvalue {i64, i1} %80, i1 0, 1 
  ret {i64, i1} %81 
}
--------------------------------------------------
 Module multictr.perhaps
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.perhaps./=<0>
                    multictr.perhaps.=<0>
                    multictr.perhaps.content<0>
                    multictr.perhaps.content<1>
                    multictr.perhaps.perhaps<0>
                    multictr.perhaps.perhaps<1>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline (0 calls)
0: /=($left#0:multictr.perhaps, $right#0:multictr.perhaps, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.perhaps, ~$right#0:multictr.perhaps, ?tmp$0#0:wybe.bool)
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public inline (1 calls)
0: =($left#0:multictr.perhaps, $right#0:multictr.perhaps, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.perhaps, ~$right#0:multictr.perhaps, ?$$#0:wybe.bool)


content > public inline (0 calls)
0: content($rec#0:multictr.perhaps, ?$#0:multictr.maybe_int):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm cast(~$rec#0:multictr.perhaps, ?$#0:multictr.maybe_int)
content > public inline (0 calls)
1: content([$rec#0:multictr.perhaps], ?$rec#2:multictr.perhaps, $field#0:multictr.maybe_int):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(~$field#0:!multictr.perhaps, ?$rec#2:multictr.perhaps)


perhaps > public inline (0 calls)
0: perhaps(content#0:multictr.maybe_int, ?$#2:multictr.perhaps):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(~content#0:!multictr.perhaps, ?$#2:multictr.perhaps)
perhaps > public inline (0 calls)
1: perhaps(?content#0:multictr.maybe_int, $#0:multictr.perhaps):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm cast(~$#0:multictr.perhaps, ?content#0:multictr.maybe_int)

  LLVM code       :

; ModuleID = 'multictr.perhaps'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.perhaps./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = icmp eq i64 %"$left#0", %"$right#0" 
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.perhaps.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$$$#0" = icmp eq i64 %"$left#0", %"$right#0" 
  ret i1 %"1$$$#0" 
}


define external fastcc  i64 @"multictr.perhaps.content<0>"(i64  %"$rec#0")    {
entry:
  ret i64 %"$rec#0" 
}


define external fastcc  i64 @"multictr.perhaps.content<1>"(i64  %"$field#0")    {
entry:
  ret i64 %"$field#0" 
}


define external fastcc  i64 @"multictr.perhaps.perhaps<0>"(i64  %"content#0")    {
entry:
  ret i64 %"content#0" 
}


define external fastcc  i64 @"multictr.perhaps.perhaps<1>"(i64  %"$#0")    {
entry:
  ret i64 %"$#0" 
}
--------------------------------------------------
 Module multictr.rank
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.rank./=<0>
                    multictr.rank.=<0>
                    multictr.rank.ace<0>
                    multictr.rank.jack<0>
                    multictr.rank.king<0>
                    multictr.rank.queen<0>
                    multictr.rank.r10<0>
                    multictr.rank.r2<0>
                    multictr.rank.r3<0>
                    multictr.rank.r4<0>
                    multictr.rank.r5<0>
                    multictr.rank.r6<0>
                    multictr.rank.r7<0>
                    multictr.rank.r8<0>
                    multictr.rank.r9<0>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline (0 calls)
0: /=($left#0:multictr.rank, $right#0:multictr.rank, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.rank, ~$right#0:multictr.rank, ?tmp$0#0:wybe.bool)
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public inline (1 calls)
0: =($left#0:multictr.rank, $right#0:multictr.rank, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.rank, ~$right#0:multictr.rank, ?$$#0:wybe.bool)


ace > public inline (0 calls)
0: ace(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(12:multictr.rank, ?$#0:multictr.rank)


jack > public inline (0 calls)
0: jack(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(9:multictr.rank, ?$#0:multictr.rank)


king > public inline (0 calls)
0: king(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(11:multictr.rank, ?$#0:multictr.rank)


queen > public inline (0 calls)
0: queen(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(10:multictr.rank, ?$#0:multictr.rank)


r10 > public inline (0 calls)
0: r10(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(8:multictr.rank, ?$#0:multictr.rank)


r2 > public inline (0 calls)
0: r2(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.rank, ?$#0:multictr.rank)


r3 > public inline (0 calls)
0: r3(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(1:multictr.rank, ?$#0:multictr.rank)


r4 > public inline (0 calls)
0: r4(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(2:multictr.rank, ?$#0:multictr.rank)


r5 > public inline (0 calls)
0: r5(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(3:multictr.rank, ?$#0:multictr.rank)


r6 > public inline (0 calls)
0: r6(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(4:multictr.rank, ?$#0:multictr.rank)


r7 > public inline (0 calls)
0: r7(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(5:multictr.rank, ?$#0:multictr.rank)


r8 > public inline (0 calls)
0: r8(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(6:multictr.rank, ?$#0:multictr.rank)


r9 > public inline (0 calls)
0: r9(?$#0:multictr.rank):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(7:multictr.rank, ?$#0:multictr.rank)

  LLVM code       :

; ModuleID = 'multictr.rank'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.rank./=<0>"(i4  %"$left#0", i4  %"$right#0")    {
entry:
  %"1$tmp$0#0" = icmp eq i4 %"$left#0", %"$right#0" 
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.rank.=<0>"(i4  %"$left#0", i4  %"$right#0")    {
entry:
  %"1$$$#0" = icmp eq i4 %"$left#0", %"$right#0" 
  ret i1 %"1$$$#0" 
}


define external fastcc  i4 @"multictr.rank.ace<0>"()    {
entry:
  ret i4 12 
}


define external fastcc  i4 @"multictr.rank.jack<0>"()    {
entry:
  ret i4 9 
}


define external fastcc  i4 @"multictr.rank.king<0>"()    {
entry:
  ret i4 11 
}


define external fastcc  i4 @"multictr.rank.queen<0>"()    {
entry:
  ret i4 10 
}


define external fastcc  i4 @"multictr.rank.r10<0>"()    {
entry:
  ret i4 8 
}


define external fastcc  i4 @"multictr.rank.r2<0>"()    {
entry:
  ret i4 0 
}


define external fastcc  i4 @"multictr.rank.r3<0>"()    {
entry:
  ret i4 1 
}


define external fastcc  i4 @"multictr.rank.r4<0>"()    {
entry:
  ret i4 2 
}


define external fastcc  i4 @"multictr.rank.r5<0>"()    {
entry:
  ret i4 3 
}


define external fastcc  i4 @"multictr.rank.r6<0>"()    {
entry:
  ret i4 4 
}


define external fastcc  i4 @"multictr.rank.r7<0>"()    {
entry:
  ret i4 5 
}


define external fastcc  i4 @"multictr.rank.r8<0>"()    {
entry:
  ret i4 6 
}


define external fastcc  i4 @"multictr.rank.r9<0>"()    {
entry:
  ret i4 7 
}
--------------------------------------------------
 Module multictr.simple
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.simple./=<0>
                    multictr.simple.=<0>
                    multictr.simple.one<0>
                    multictr.simple.one<1>
                    multictr.simple.one_field<0>
                    multictr.simple.one_field<1>
                    multictr.simple.two<0>
                    multictr.simple.two<1>
                    multictr.simple.two_field1<0>
                    multictr.simple.two_field1<1>
                    multictr.simple.two_field2<0>
                    multictr.simple.two_field2<1>
                    multictr.simple.zero<0>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline (0 calls)
0: /=($left#0:multictr.simple, $right#0:multictr.simple, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    multictr.simple.=<0>(~$left#0:multictr.simple, ~$right#0:multictr.simple, ?tmp$0#0:wybe.bool) #0
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public (5 calls)
0: =($left#0:multictr.simple, $right#0:multictr.simple, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($left#0:!wybe.int, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm icmp eq(~$left#0:multictr.simple, ~$right#0:multictr.simple, ?$$#0:wybe.bool)

    1:
        foreign llvm and($left#0:multictr.simple, 7:wybe.int, ?tmp$11#0:wybe.int)
        foreign llvm icmp eq(tmp$11#0:wybe.int, 0:wybe.int, ?tmp$12#0:wybe.bool)
        case ~tmp$12#0:wybe.bool of
        0:
            foreign llvm icmp eq(~tmp$11#0:wybe.int, 1:wybe.int, ?tmp$16#0:wybe.bool)
            case ~tmp$16#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign lpvm access($left#0:multictr.simple, -1:wybe.int, 16:wybe.int, 1:wybe.int, ?$left$two_field1#0:wybe.int)
                foreign lpvm access(~$left#0:multictr.simple, 7:wybe.int, 16:wybe.int, 1:wybe.int, ?$left$two_field2#0:wybe.int)
                foreign llvm icmp ne($right#0:multictr.simple, 0:wybe.int, ?tmp$18#0:wybe.bool)
                case ~tmp$18#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign llvm and($right#0:multictr.simple, 7:wybe.int, ?tmp$19#0:wybe.int)
                    foreign llvm icmp eq(~tmp$19#0:wybe.int, 1:wybe.int, ?tmp$20#0:wybe.bool)
                    case ~tmp$20#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        foreign lpvm access($right#0:multictr.simple, -1:wybe.int, 16:wybe.int, 1:wybe.int, ?$right$two_field1#0:wybe.int)
                        foreign lpvm access(~$right#0:multictr.simple, 7:wybe.int, 16:wybe.int, 1:wybe.int, ?$right$two_field2#0:wybe.int)
                        foreign llvm icmp eq(~$left$two_field1#0:wybe.int, ~$right$two_field1#0:wybe.int, ?tmp$5#0:wybe.bool) @wybe:nn:nn
                        case ~tmp$5#0:wybe.bool of
                        0:
                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                        1:
                            foreign llvm icmp eq(~$left$two_field2#0:wybe.int, ~$right$two_field2#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn





        1:
            foreign lpvm access(~$left#0:multictr.simple, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$left$one_field#0:wybe.int)
            foreign llvm icmp ne($right#0:multictr.simple, 0:wybe.int, ?tmp$14#0:wybe.bool)
            case ~tmp$14#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign llvm and($right#0:multictr.simple, 7:wybe.int, ?tmp$15#0:wybe.int)
                foreign llvm icmp eq(~tmp$15#0:wybe.int, 0:wybe.int, ?tmp$16#0:wybe.bool)
                case ~tmp$16#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign lpvm access(~$right#0:multictr.simple, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$right$one_field#0:wybe.int)
                    foreign llvm icmp eq(~$left$one_field#0:wybe.int, ~$right$one_field#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn






one > public inline (0 calls)
0: one(one_field#0:wybe.int, ?$#0:multictr.simple):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:!multictr.simple)
    foreign lpvm mutate(~%$rec#0:multictr.simple, ?%$#0:multictr.simple, 0:wybe.int, 1:wybe.int, 8:wybe.int, 0:wybe.int, ~one_field#0:wybe.int)
one > public inline (11 calls)
1: one(?one_field#0:wybe.int, $#0:multictr.simple, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($#0:multictr.simple, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($#0:multictr.simple, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$#0:multictr.simple, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?one_field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




one_field > public inline (0 calls)
0: one_field($rec#0:multictr.simple, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($rec#0:multictr.simple, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($rec#0:multictr.simple, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$rec#0:multictr.simple, 0:wybe.int, 8:wybe.int, 0:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


one_field > public inline (0 calls)
1: one_field($rec#0:multictr.simple, ?$rec#1:multictr.simple, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($rec#0:multictr.simple, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

    1:
        foreign llvm and($rec#0:multictr.simple, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

        1:
            foreign lpvm mutate noalias(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, 0:wybe.int, 0:wybe.int, 8:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




two > public inline (0 calls)
0: two(two_field1#0:wybe.int, two_field2#0:wybe.int, ?$#0:multictr.simple):
 AliasPairs: []
 InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?$rec#0:!multictr.simple)
    foreign lpvm mutate(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, ~two_field1#0:wybe.int)
    foreign lpvm mutate(~%$rec#1:multictr.simple, ?%$rec#2:multictr.simple, 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, ~two_field2#0:wybe.int)
    foreign llvm or(~$rec#2, 1:wybe.int, ?$#0:multictr.simple)
two > public inline (7 calls)
1: two(?two_field1#0:wybe.int, ?two_field2#0:wybe.int, $#0:multictr.simple, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($#0:multictr.simple, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($#0:multictr.simple, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access($#0:multictr.simple, -1:wybe.int, 16:wybe.int, 1:wybe.int, ?two_field1#0:wybe.int)
            foreign lpvm access(~$#0:multictr.simple, 7:wybe.int, 16:wybe.int, 1:wybe.int, ?two_field2#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




two_field1 > public inline (0 calls)
0: two_field1($rec#0:multictr.simple, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($rec#0:multictr.simple, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($rec#0:multictr.simple, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$rec#0:multictr.simple, -1:wybe.int, 16:wybe.int, 1:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


two_field1 > public inline (0 calls)
1: two_field1($rec#0:multictr.simple, ?$rec#1:multictr.simple, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($rec#0:multictr.simple, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

    1:
        foreign llvm and($rec#0:multictr.simple, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

        1:
            foreign lpvm mutate noalias(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, -1:wybe.int, 0:wybe.int, 16:wybe.int, 1:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




two_field2 > public inline (0 calls)
0: two_field2($rec#0:multictr.simple, ?$#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($rec#0:multictr.simple, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and($rec#0:multictr.simple, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$rec#0:multictr.simple, 7:wybe.int, 16:wybe.int, 1:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


two_field2 > public inline (0 calls)
1: two_field2($rec#0:multictr.simple, ?$rec#1:multictr.simple, $field#0:wybe.int, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp ne($rec#0:multictr.simple, 0:wybe.int, ?tmp$0#0:wybe.bool)
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

    1:
        foreign llvm and($rec#0:multictr.simple, 7:wybe.int, ?tmp$1#0:!wybe.int)
        foreign llvm icmp eq(~tmp$1#0:!wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
        case ~tmp$2#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

        1:
            foreign lpvm mutate noalias(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, 7:wybe.int, 0:wybe.int, 16:wybe.int, 1:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




zero > public inline (0 calls)
0: zero(?$#0:multictr.simple):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.simple, ?$#0:multictr.simple)

  LLVM code       :

; ModuleID = 'multictr.simple'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.simple./=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = tail call fastcc  i1  @"multictr.simple.=<0>"(i64  %"$left#0", i64  %"$right#0")  
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.simple.=<0>"(i64  %"$left#0", i64  %"$right#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$left#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$11#0" = and i64 %"$left#0", 7 
  %"2$tmp$12#0" = icmp eq i64 %"2$tmp$11#0", 0 
  br i1 %"2$tmp$12#0", label %if.then1, label %if.else1 
if.else:
  %"3$$$#0" = icmp eq i64 %"$left#0", %"$right#0" 
  ret i1 %"3$$$#0" 
if.then1:
  %1 = inttoptr i64 %"$left#0" to i64* 
  %2 = getelementptr  i64, i64* %1, i64 0 
  %3 = load  i64, i64* %2 
  %"4$tmp$14#0" = icmp ne i64 %"$right#0", 0 
  br i1 %"4$tmp$14#0", label %if.then2, label %if.else2 
if.else1:
  %"5$tmp$16#0" = icmp eq i64 %"2$tmp$11#0", 1 
  br i1 %"5$tmp$16#0", label %if.then4, label %if.else4 
if.then2:
  %"6$tmp$15#0" = and i64 %"$right#0", 7 
  %"6$tmp$16#0" = icmp eq i64 %"6$tmp$15#0", 0 
  br i1 %"6$tmp$16#0", label %if.then3, label %if.else3 
if.else2:
  ret i1 0 
if.then3:
  %4 = inttoptr i64 %"$right#0" to i64* 
  %5 = getelementptr  i64, i64* %4, i64 0 
  %6 = load  i64, i64* %5 
  %"8$$$#0" = icmp eq i64 %3, %6 
  ret i1 %"8$$$#0" 
if.else3:
  ret i1 0 
if.then4:
  %7 = add   i64 %"$left#0", -1 
  %8 = inttoptr i64 %7 to i64* 
  %9 = getelementptr  i64, i64* %8, i64 0 
  %10 = load  i64, i64* %9 
  %11 = add   i64 %"$left#0", 7 
  %12 = inttoptr i64 %11 to i64* 
  %13 = getelementptr  i64, i64* %12, i64 0 
  %14 = load  i64, i64* %13 
  %"10$tmp$18#0" = icmp ne i64 %"$right#0", 0 
  br i1 %"10$tmp$18#0", label %if.then5, label %if.else5 
if.else4:
  ret i1 0 
if.then5:
  %"12$tmp$19#0" = and i64 %"$right#0", 7 
  %"12$tmp$20#0" = icmp eq i64 %"12$tmp$19#0", 1 
  br i1 %"12$tmp$20#0", label %if.then6, label %if.else6 
if.else5:
  ret i1 0 
if.then6:
  %15 = add   i64 %"$right#0", -1 
  %16 = inttoptr i64 %15 to i64* 
  %17 = getelementptr  i64, i64* %16, i64 0 
  %18 = load  i64, i64* %17 
  %19 = add   i64 %"$right#0", 7 
  %20 = inttoptr i64 %19 to i64* 
  %21 = getelementptr  i64, i64* %20, i64 0 
  %22 = load  i64, i64* %21 
  %"14$tmp$5#0" = icmp eq i64 %10, %18 
  br i1 %"14$tmp$5#0", label %if.then7, label %if.else7 
if.else6:
  ret i1 0 
if.then7:
  %"16$$$#0" = icmp eq i64 %14, %22 
  ret i1 %"16$$$#0" 
if.else7:
  ret i1 0 
}


define external fastcc  i64 @"multictr.simple.one<0>"(i64  %"one_field#0")    {
entry:
  %23 = trunc i64 8 to i32  
  %24 = tail call ccc  i8*  @wybe_malloc(i32  %23)  
  %25 = ptrtoint i8* %24 to i64 
  %26 = inttoptr i64 %25 to i64* 
  %27 = getelementptr  i64, i64* %26, i64 0 
  store  i64 %"one_field#0", i64* %27 
  ret i64 %25 
}


define external fastcc  {i64, i1} @"multictr.simple.one<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 0 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %35 = insertvalue {i64, i1} undef, i64 undef, 0 
  %36 = insertvalue {i64, i1} %35, i1 0, 1 
  ret {i64, i1} %36 
if.then1:
  %28 = inttoptr i64 %"$#0" to i64* 
  %29 = getelementptr  i64, i64* %28, i64 0 
  %30 = load  i64, i64* %29 
  %31 = insertvalue {i64, i1} undef, i64 %30, 0 
  %32 = insertvalue {i64, i1} %31, i1 1, 1 
  ret {i64, i1} %32 
if.else1:
  %33 = insertvalue {i64, i1} undef, i64 undef, 0 
  %34 = insertvalue {i64, i1} %33, i1 0, 1 
  ret {i64, i1} %34 
}


define external fastcc  {i64, i1} @"multictr.simple.one_field<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 0 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %44 = insertvalue {i64, i1} undef, i64 undef, 0 
  %45 = insertvalue {i64, i1} %44, i1 0, 1 
  ret {i64, i1} %45 
if.then1:
  %37 = inttoptr i64 %"$rec#0" to i64* 
  %38 = getelementptr  i64, i64* %37, i64 0 
  %39 = load  i64, i64* %38 
  %40 = insertvalue {i64, i1} undef, i64 %39, 0 
  %41 = insertvalue {i64, i1} %40, i1 1, 1 
  ret {i64, i1} %41 
if.else1:
  %42 = insertvalue {i64, i1} undef, i64 undef, 0 
  %43 = insertvalue {i64, i1} %42, i1 0, 1 
  ret {i64, i1} %43 
}


define external fastcc  {i64, i1} @"multictr.simple.one_field<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 0 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %58 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %59 = insertvalue {i64, i1} %58, i1 0, 1 
  ret {i64, i1} %59 
if.then1:
  %46 = trunc i64 8 to i32  
  %47 = tail call ccc  i8*  @wybe_malloc(i32  %46)  
  %48 = ptrtoint i8* %47 to i64 
  %49 = inttoptr i64 %48 to i8* 
  %50 = inttoptr i64 %"$rec#0" to i8* 
  %51 = trunc i64 8 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %49, i8*  %50, i32  %51, i32  8, i1  0)  
  %52 = inttoptr i64 %48 to i64* 
  %53 = getelementptr  i64, i64* %52, i64 0 
  store  i64 %"$field#0", i64* %53 
  %54 = insertvalue {i64, i1} undef, i64 %48, 0 
  %55 = insertvalue {i64, i1} %54, i1 1, 1 
  ret {i64, i1} %55 
if.else1:
  %56 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %57 = insertvalue {i64, i1} %56, i1 0, 1 
  ret {i64, i1} %57 
}


define external fastcc  i64 @"multictr.simple.two<0>"(i64  %"two_field1#0", i64  %"two_field2#0")    {
entry:
  %60 = trunc i64 16 to i32  
  %61 = tail call ccc  i8*  @wybe_malloc(i32  %60)  
  %62 = ptrtoint i8* %61 to i64 
  %63 = inttoptr i64 %62 to i64* 
  %64 = getelementptr  i64, i64* %63, i64 0 
  store  i64 %"two_field1#0", i64* %64 
  %65 = add   i64 %62, 8 
  %66 = inttoptr i64 %65 to i64* 
  %67 = getelementptr  i64, i64* %66, i64 0 
  store  i64 %"two_field2#0", i64* %67 
  %"1$$#0" = or i64 %62, 1 
  ret i64 %"1$$#0" 
}


define external fastcc  {i64, i64, i1} @"multictr.simple.two<1>"(i64  %"$#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 1 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %82 = insertvalue {i64, i64, i1} undef, i64 undef, 0 
  %83 = insertvalue {i64, i64, i1} %82, i64 undef, 1 
  %84 = insertvalue {i64, i64, i1} %83, i1 0, 2 
  ret {i64, i64, i1} %84 
if.then1:
  %68 = add   i64 %"$#0", -1 
  %69 = inttoptr i64 %68 to i64* 
  %70 = getelementptr  i64, i64* %69, i64 0 
  %71 = load  i64, i64* %70 
  %72 = add   i64 %"$#0", 7 
  %73 = inttoptr i64 %72 to i64* 
  %74 = getelementptr  i64, i64* %73, i64 0 
  %75 = load  i64, i64* %74 
  %76 = insertvalue {i64, i64, i1} undef, i64 %71, 0 
  %77 = insertvalue {i64, i64, i1} %76, i64 %75, 1 
  %78 = insertvalue {i64, i64, i1} %77, i1 1, 2 
  ret {i64, i64, i1} %78 
if.else1:
  %79 = insertvalue {i64, i64, i1} undef, i64 undef, 0 
  %80 = insertvalue {i64, i64, i1} %79, i64 undef, 1 
  %81 = insertvalue {i64, i64, i1} %80, i1 0, 2 
  ret {i64, i64, i1} %81 
}


define external fastcc  {i64, i1} @"multictr.simple.two_field1<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 1 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %93 = insertvalue {i64, i1} undef, i64 undef, 0 
  %94 = insertvalue {i64, i1} %93, i1 0, 1 
  ret {i64, i1} %94 
if.then1:
  %85 = add   i64 %"$rec#0", -1 
  %86 = inttoptr i64 %85 to i64* 
  %87 = getelementptr  i64, i64* %86, i64 0 
  %88 = load  i64, i64* %87 
  %89 = insertvalue {i64, i1} undef, i64 %88, 0 
  %90 = insertvalue {i64, i1} %89, i1 1, 1 
  ret {i64, i1} %90 
if.else1:
  %91 = insertvalue {i64, i1} undef, i64 undef, 0 
  %92 = insertvalue {i64, i1} %91, i1 0, 1 
  ret {i64, i1} %92 
}


define external fastcc  {i64, i1} @"multictr.simple.two_field1<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 1 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %110 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %111 = insertvalue {i64, i1} %110, i1 0, 1 
  ret {i64, i1} %111 
if.then1:
  %95 = trunc i64 16 to i32  
  %96 = tail call ccc  i8*  @wybe_malloc(i32  %95)  
  %97 = ptrtoint i8* %96 to i64 
  %98 = add   i64 %97, 1 
  %99 = sub   i64 %"$rec#0", 1 
  %100 = inttoptr i64 %97 to i8* 
  %101 = inttoptr i64 %99 to i8* 
  %102 = trunc i64 16 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %100, i8*  %101, i32  %102, i32  8, i1  0)  
  %103 = add   i64 %98, -1 
  %104 = inttoptr i64 %103 to i64* 
  %105 = getelementptr  i64, i64* %104, i64 0 
  store  i64 %"$field#0", i64* %105 
  %106 = insertvalue {i64, i1} undef, i64 %98, 0 
  %107 = insertvalue {i64, i1} %106, i1 1, 1 
  ret {i64, i1} %107 
if.else1:
  %108 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %109 = insertvalue {i64, i1} %108, i1 0, 1 
  ret {i64, i1} %109 
}


define external fastcc  {i64, i1} @"multictr.simple.two_field2<0>"(i64  %"$rec#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 1 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %120 = insertvalue {i64, i1} undef, i64 undef, 0 
  %121 = insertvalue {i64, i1} %120, i1 0, 1 
  ret {i64, i1} %121 
if.then1:
  %112 = add   i64 %"$rec#0", 7 
  %113 = inttoptr i64 %112 to i64* 
  %114 = getelementptr  i64, i64* %113, i64 0 
  %115 = load  i64, i64* %114 
  %116 = insertvalue {i64, i1} undef, i64 %115, 0 
  %117 = insertvalue {i64, i1} %116, i1 1, 1 
  ret {i64, i1} %117 
if.else1:
  %118 = insertvalue {i64, i1} undef, i64 undef, 0 
  %119 = insertvalue {i64, i1} %118, i1 0, 1 
  ret {i64, i1} %119 
}


define external fastcc  {i64, i1} @"multictr.simple.two_field2<1>"(i64  %"$rec#0", i64  %"$field#0")    {
entry:
  %"1$tmp$0#0" = icmp ne i64 %"$rec#0", 0 
  br i1 %"1$tmp$0#0", label %if.then, label %if.else 
if.then:
  %"2$tmp$1#0" = and i64 %"$rec#0", 7 
  %"2$tmp$2#0" = icmp eq i64 %"2$tmp$1#0", 1 
  br i1 %"2$tmp$2#0", label %if.then1, label %if.else1 
if.else:
  %137 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %138 = insertvalue {i64, i1} %137, i1 0, 1 
  ret {i64, i1} %138 
if.then1:
  %122 = trunc i64 16 to i32  
  %123 = tail call ccc  i8*  @wybe_malloc(i32  %122)  
  %124 = ptrtoint i8* %123 to i64 
  %125 = add   i64 %124, 1 
  %126 = sub   i64 %"$rec#0", 1 
  %127 = inttoptr i64 %124 to i8* 
  %128 = inttoptr i64 %126 to i8* 
  %129 = trunc i64 16 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %127, i8*  %128, i32  %129, i32  8, i1  0)  
  %130 = add   i64 %125, 7 
  %131 = inttoptr i64 %130 to i64* 
  %132 = getelementptr  i64, i64* %131, i64 0 
  store  i64 %"$field#0", i64* %132 
  %133 = insertvalue {i64, i1} undef, i64 %125, 0 
  %134 = insertvalue {i64, i1} %133, i1 1, 1 
  ret {i64, i1} %134 
if.else1:
  %135 = insertvalue {i64, i1} undef, i64 %"$rec#0", 0 
  %136 = insertvalue {i64, i1} %135, i1 0, 1 
  ret {i64, i1} %136 
}


define external fastcc  i64 @"multictr.simple.zero<0>"()    {
entry:
  ret i64 0 
}
--------------------------------------------------
 Module multictr.suit
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.suit./=<0>
                    multictr.suit.=<0>
                    multictr.suit.clubs<0>
                    multictr.suit.diamonds<0>
                    multictr.suit.hearts<0>
                    multictr.suit.spades<0>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline (0 calls)
0: /=($left#0:multictr.suit, $right#0:multictr.suit, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.suit, ~$right#0:multictr.suit, ?tmp$0#0:wybe.bool)
    foreign llvm xor(~tmp$0#0:wybe.bool, 1:wybe.bool, ?$$#0:wybe.bool)


= > public inline (1 calls)
0: =($left#0:multictr.suit, $right#0:multictr.suit, ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm icmp eq(~$left#0:multictr.suit, ~$right#0:multictr.suit, ?$$#0:wybe.bool)


clubs > public inline (0 calls)
0: clubs(?$#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.suit, ?$#0:multictr.suit)


diamonds > public inline (0 calls)
0: diamonds(?$#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(1:multictr.suit, ?$#0:multictr.suit)


hearts > public inline (0 calls)
0: hearts(?$#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(2:multictr.suit, ?$#0:multictr.suit)


spades > public inline (0 calls)
0: spades(?$#0:multictr.suit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(3:multictr.suit, ?$#0:multictr.suit)

  LLVM code       :

; ModuleID = 'multictr.suit'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.suit./=<0>"(i2  %"$left#0", i2  %"$right#0")    {
entry:
  %"1$tmp$0#0" = icmp eq i2 %"$left#0", %"$right#0" 
  %"1$$$#0" = xor i1 %"1$tmp$0#0", 1 
  ret i1 %"1$$$#0" 
}


define external fastcc  i1 @"multictr.suit.=<0>"(i2  %"$left#0", i2  %"$right#0")    {
entry:
  %"1$$$#0" = icmp eq i2 %"$left#0", %"$right#0" 
  ret i1 %"1$$$#0" 
}


define external fastcc  i2 @"multictr.suit.clubs<0>"()    {
entry:
  ret i2 0 
}


define external fastcc  i2 @"multictr.suit.diamonds<0>"()    {
entry:
  ret i2 1 
}


define external fastcc  i2 @"multictr.suit.hearts<0>"()    {
entry:
  ret i2 2 
}


define external fastcc  i2 @"multictr.suit.spades<0>"()    {
entry:
  ret i2 3 
}
--------------------------------------------------
 Module multictr.unit
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.unit./=<0>
                    multictr.unit.=<0>
                    multictr.unit.unit<0>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

/= > public inline (0 calls)
0: /=([$left#0:multictr.unit], [$right#0:multictr.unit], ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)


= > public inline (1 calls)
0: =([$left#0:multictr.unit], [$right#0:multictr.unit], ?$$#0:wybe.bool):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


unit > public inline (0 calls)
0: unit(?$#0:multictr.unit):
 AliasPairs: []
 InterestingCallProperties: []
    foreign llvm move(0:multictr.unit, ?$#0:multictr.unit)

  LLVM code       :

; ModuleID = 'multictr.unit'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i32, i1)    


define external fastcc  i1 @"multictr.unit./=<0>"()    {
entry:
  ret i1 0 
}


define external fastcc  i1 @"multictr.unit.=<0>"()    {
entry:
  ret i1 1 
}


define external fastcc  void @"multictr.unit.unit<0>"()    {
entry:
  ret void 
}
