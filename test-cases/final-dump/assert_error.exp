======================================================================
AFTER EVERYTHING:


--------------------------------------------------
 Module assert_error
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : assert_error.<0>
  imports         : use wybe
  resources       : 
  procs           : 

module top-level code > public {semipure} (0 calls)
0: assert_error.<0>
()<{}; {}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.control.assert<0>(0:wybe.bool, c"assert_error:3:2":wybe.c_string) #1 @assert_error:nn:nn
    foreign c {terminal,semipure} error_exit(c"assert_error:5:2":wybe.c_string, c"we should never get here":wybe.c_string) @assert_error:nn:nn

  LLVM code       :

;; FILE GENERATED BY wybemk 0.2 -- see https://github.com/pschachte/wybe
; ModuleID = 'assert_error'

source_filename = "!ROOT!/final-dump/assert_error.wybe"
target triple    ????

@"cstring#0" = private unnamed_addr constant [ ?? x i8 ] c"assert_error:3:2\00", align 8
@"cstring#1" = private unnamed_addr constant [ ?? x i8 ] c"assert_error:5:2\00", align 8
@"cstring#2" = private unnamed_addr constant [ ?? x i8 ] c"we should never get here\00", align 8

declare external fastcc void @"wybe.control.assert<0>"(i1, i64)
declare external ccc void @error_exit(i64, i64)
declare external ccc void @llvm.memcpy.p0.p0.i64(ptr, ptr, i64, i1)

define external fastcc void @"assert_error.<0>"() {
  tail call fastcc void @"wybe.control.assert<0>"(i1 0, i64 ptrtoint( ptr @"cstring#0" to i64 ))
  call ccc void @error_exit(i64 ptrtoint( ptr @"cstring#1" to i64 ), i64 ptrtoint( ptr @"cstring#2" to i64 ))
  ret void
}
