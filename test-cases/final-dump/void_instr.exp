======================================================================
AFTER EVERYTHING:
 Module void_instr
  representation  : (not a type)
  public submods  : 
  public resources: 
  public procs    : void_instr.<0>
  imports         : use wybe
  resources       : 
  procs           : 

module top-level code > public {inline,impure} (0 calls)
0: void_instr.<0>
()<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    void_instr.complex_computation<0>(?tmp#0##0:wybe.int) #0 @void_instr:nn:nn
    foreign lpvm {impure} void(~tmp#0##0:wybe.int) @void_instr:nn:nn


complex_computation > {noinline} (1 calls)
0: void_instr.complex_computation<0>
complex_computation(?x##1:wybe.int)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.range...<0>(0:wybe.int, 100:wybe.int, ?tmp#1##0:wybe.range) #0 @void_instr:nn:nn
    void_instr.gen#1<0>(~tmp#1##0:wybe.range, ~tmp#1##0:wybe.range, 0:wybe.int, ?x##1:wybe.int) #1 @void_instr:nn:nn


gen#1 > (2 calls)
0: void_instr.gen#1<0>[410bae77d3]
gen#1(tmp#0##0:wybe.range, tmp#1##0:wybe.range, x##0:wybe.int, ?x##2:wybe.int)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: [InterestingUnaliased 0]
  MultiSpeczDepInfo: [(0,(wybe.range.[|]<0>,fromList [NonAliasedParamCond 2 [0]])),(2,(void_instr.gen#1<0>,fromList [NonAliasedParamCond 0 []]))]
    wybe.range.[|]<0>(?i##0:wybe.int, ?tmp#0##1:wybe.range, ~tmp#0##0:wybe.range, ?tmp#2##0:wybe.bool) #0 @void_instr:nn:nn
    case ~tmp#2##0:wybe.bool of
    0:
        foreign llvm move(~x##0:wybe.int, ?x##2:wybe.int)

    1:
        foreign llvm add(~i##0:wybe.int, ~x##0:wybe.int, ?x##1:wybe.int) @int:nn:nn
        void_instr.gen#1<0>[410bae77d3](~tmp#0##1:wybe.range, ~tmp#1##0:wybe.range, ~x##1:wybe.int, ?x##2:wybe.int) #2 @void_instr:nn:nn

 [410bae77d3] [NonAliasedParam 0] :
    wybe.range.[|]<0>[785a827a1b](?i##0:wybe.int, ?tmp#0##1:wybe.range, ~tmp#0##0:wybe.range, ?tmp#2##0:wybe.bool) #0 @void_instr:nn:nn
    case ~tmp#2##0:wybe.bool of
    0:
        foreign llvm move(~x##0:wybe.int, ?x##2:wybe.int)

    1:
        foreign llvm add(~i##0:wybe.int, ~x##0:wybe.int, ?x##1:wybe.int) @int:nn:nn
        void_instr.gen#1<0>[410bae77d3](~tmp#0##1:wybe.range, ~tmp#1##0:wybe.range, ~x##1:wybe.int, ?x##2:wybe.int) #2 @void_instr:nn:nn


  LLVM code       :

; ModuleID = 'void_instr'


 


declare external fastcc  {i64, i64, i1} @"wybe.range.[|]<0>[785a827a1b]"(i64)    


declare external fastcc  {i64, i64, i1} @"wybe.range.[|]<0>"(i64)    


declare external fastcc  i64 @"wybe.range...<0>"(i64, i64)    


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i1)    


define external fastcc  void @"void_instr.<0>"() alwaysinline   {
entry:
  %0 = tail call fastcc  i64  @"void_instr.complex_computation<0>"()  
  ret void 
}


define external fastcc  i64 @"void_instr.complex_computation<0>"() noinline   {
entry:
  %0 = tail call fastcc  i64  @"wybe.range...<0>"(i64  0, i64  100)  
  %1 = tail call fastcc  i64  @"void_instr.gen#1<0>"(i64  %0, i64  %0, i64  0)  
  ret i64 %1 
}


define external fastcc  i64 @"void_instr.gen#1<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"x##0")    {
entry:
  %0 = tail call fastcc  {i64, i64, i1}  @"wybe.range.[|]<0>"(i64  %"tmp#0##0")  
  %1 = extractvalue {i64, i64, i1} %0, 0 
  %2 = extractvalue {i64, i64, i1} %0, 1 
  %3 = extractvalue {i64, i64, i1} %0, 2 
  br i1 %3, label %if.then, label %if.else 
if.then:
  %4 = add   i64 %1, %"x##0" 
  %5 = musttail call fastcc  i64  @"void_instr.gen#1<0>[410bae77d3]"(i64  %2, i64  %"tmp#1##0", i64  %4)  
  ret i64 %5 
if.else:
  ret i64 %"x##0" 
}


define external fastcc  i64 @"void_instr.gen#1<0>[410bae77d3]"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"x##0")    {
entry:
  %0 = tail call fastcc  {i64, i64, i1}  @"wybe.range.[|]<0>[785a827a1b]"(i64  %"tmp#0##0")  
  %1 = extractvalue {i64, i64, i1} %0, 0 
  %2 = extractvalue {i64, i64, i1} %0, 1 
  %3 = extractvalue {i64, i64, i1} %0, 2 
  br i1 %3, label %if.then, label %if.else 
if.then:
  %4 = add   i64 %1, %"x##0" 
  %5 = musttail call fastcc  i64  @"void_instr.gen#1<0>[410bae77d3]"(i64  %2, i64  %"tmp#1##0", i64  %4)  
  ret i64 %5 
if.else:
  ret i64 %"x##0" 
}
