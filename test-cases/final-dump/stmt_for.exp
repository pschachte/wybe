======================================================================
AFTER EVERYTHING:
 Module stmt_for
  representation  : (not a type)
  public submods  : int_sequence -> stmt_for.int_sequence
  public resources: 
  public procs    : stmt_for.<0>
                    stmt_for.irange<0>
                    stmt_for.multiple_generator<0>
                    stmt_for.semi_det_for_loop<0>
                    stmt_for.shortest_generator_termination<0>
                    stmt_for.single_generator<0>
                    stmt_for.using_break<0>
                    stmt_for.using_irange<0>
                    stmt_for.using_irange_reverse<0>
                    stmt_for.using_next<0>
                    stmt_for.using_unless<0>
                    stmt_for.using_until<0>
                    stmt_for.using_when<0>
                    stmt_for.using_while<0>
                    stmt_for.using_xrange<0>
                    stmt_for.using_xrange_reverse<0>
                    stmt_for.xrange<0>
                    stmt_for.int_sequence.=<0>
                    stmt_for.int_sequence.[|]<0>
                    stmt_for.int_sequence.end<0>
                    stmt_for.int_sequence.end<1>
                    stmt_for.int_sequence.int_sequence<0>
                    stmt_for.int_sequence.int_sequence<1>
                    stmt_for.int_sequence.start<0>
                    stmt_for.int_sequence.start<1>
                    stmt_for.int_sequence.stride<0>
                    stmt_for.int_sequence.stride<1>
                    stmt_for.int_sequence.~=<0>
  imports         : public use stmt_for.int_sequence
                    use wybe
  resources       : 
  submodules      : stmt_for.int_sequence
  procs           : 

module top-level code > public {impure} (0 calls)
0: stmt_for.<0>
()<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    wybe.string.print<0>("single_generator:":wybe.string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #26 @string:nn:nn
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#1##0:wybe.phantom) @io:nn:nn
    foreign c putchar('\n':wybe.char, ~tmp#1##0:wybe.phantom, ?tmp#2##0:wybe.phantom) @io:nn:nn
    foreign lpvm store(~%tmp#2##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
    stmt_for.single_generator<0><{<<wybe.io.io>>}; {<<wybe.io.io>>}> #1 @stmt_for:nn:nn
    wybe.string.print<0>("\nmultiple_generator":wybe.string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #27 @string:nn:nn
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#4##0:wybe.phantom) @io:nn:nn
    foreign c putchar('\n':wybe.char, ~tmp#4##0:wybe.phantom, ?tmp#5##0:wybe.phantom) @io:nn:nn
    foreign lpvm store(~%tmp#5##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
    stmt_for.multiple_generator<0><{<<wybe.io.io>>}; {<<wybe.io.io>>}> #3 @stmt_for:nn:nn
    wybe.string.print<0>("\nshortest_generator_termination":wybe.string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #28 @string:nn:nn
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#7##0:wybe.phantom) @io:nn:nn
    foreign c putchar('\n':wybe.char, ~tmp#7##0:wybe.phantom, ?tmp#8##0:wybe.phantom) @io:nn:nn
    foreign lpvm store(~%tmp#8##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
    stmt_for.shortest_generator_termination<0><{<<wybe.io.io>>}; {<<wybe.io.io>>}> #5 @stmt_for:nn:nn
    wybe.string.print<0>("\nusing_break":wybe.string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #29 @string:nn:nn
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#10##0:wybe.phantom) @io:nn:nn
    foreign c putchar('\n':wybe.char, ~tmp#10##0:wybe.phantom, ?tmp#11##0:wybe.phantom) @io:nn:nn
    foreign lpvm store(~%tmp#11##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
    stmt_for.using_break<0><{<<wybe.io.io>>}; {<<wybe.io.io>>}> #7 @stmt_for:nn:nn
    wybe.string.print<0>("\nusing_next":wybe.string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #30 @string:nn:nn
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#13##0:wybe.phantom) @io:nn:nn
    foreign c putchar('\n':wybe.char, ~tmp#13##0:wybe.phantom, ?tmp#14##0:wybe.phantom) @io:nn:nn
    foreign lpvm store(~%tmp#14##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
    stmt_for.using_next<0><{<<wybe.io.io>>}; {<<wybe.io.io>>}> #9 @stmt_for:nn:nn
    wybe.string.print<0>("\nusing_while":wybe.string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #31 @string:nn:nn
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#16##0:wybe.phantom) @io:nn:nn
    foreign c putchar('\n':wybe.char, ~tmp#16##0:wybe.phantom, ?tmp#17##0:wybe.phantom) @io:nn:nn
    foreign lpvm store(~%tmp#17##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
    stmt_for.using_while<0><{<<wybe.io.io>>}; {<<wybe.io.io>>}> #11 @stmt_for:nn:nn
    wybe.string.print<0>("\nusing_until":wybe.string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #32 @string:nn:nn
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#19##0:wybe.phantom) @io:nn:nn
    foreign c putchar('\n':wybe.char, ~tmp#19##0:wybe.phantom, ?tmp#20##0:wybe.phantom) @io:nn:nn
    foreign lpvm store(~%tmp#20##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
    stmt_for.using_until<0><{<<wybe.io.io>>}; {<<wybe.io.io>>}> #13 @stmt_for:nn:nn
    wybe.string.print<0>("\nusing_when":wybe.string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #33 @string:nn:nn
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#22##0:wybe.phantom) @io:nn:nn
    foreign c putchar('\n':wybe.char, ~tmp#22##0:wybe.phantom, ?tmp#23##0:wybe.phantom) @io:nn:nn
    foreign lpvm store(~%tmp#23##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
    stmt_for.using_when<0><{<<wybe.io.io>>}; {<<wybe.io.io>>}> #15 @stmt_for:nn:nn
    wybe.string.print<0>("\nusing_unless":wybe.string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #34 @string:nn:nn
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#25##0:wybe.phantom) @io:nn:nn
    foreign c putchar('\n':wybe.char, ~tmp#25##0:wybe.phantom, ?tmp#26##0:wybe.phantom) @io:nn:nn
    foreign lpvm store(~%tmp#26##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
    stmt_for.using_unless<0><{<<wybe.io.io>>}; {<<wybe.io.io>>}> #17 @stmt_for:nn:nn
    wybe.string.print<0>("\nusing_xrange":wybe.string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #35 @string:nn:nn
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#28##0:wybe.phantom) @io:nn:nn
    foreign c putchar('\n':wybe.char, ~tmp#28##0:wybe.phantom, ?tmp#29##0:wybe.phantom) @io:nn:nn
    foreign lpvm store(~%tmp#29##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
    stmt_for.using_xrange<0><{<<wybe.io.io>>}; {<<wybe.io.io>>}> #19 @stmt_for:nn:nn
    wybe.string.print<0>("\nusing_xrange_reverse":wybe.string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #36 @string:nn:nn
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#31##0:wybe.phantom) @io:nn:nn
    foreign c putchar('\n':wybe.char, ~tmp#31##0:wybe.phantom, ?tmp#32##0:wybe.phantom) @io:nn:nn
    foreign lpvm store(~%tmp#32##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
    stmt_for.using_xrange_reverse<0><{<<wybe.io.io>>}; {<<wybe.io.io>>}> #21 @stmt_for:nn:nn
    wybe.string.print<0>("\nusing_irange":wybe.string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #37 @string:nn:nn
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#34##0:wybe.phantom) @io:nn:nn
    foreign c putchar('\n':wybe.char, ~tmp#34##0:wybe.phantom, ?tmp#35##0:wybe.phantom) @io:nn:nn
    foreign lpvm store(~%tmp#35##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
    stmt_for.using_irange<0><{<<wybe.io.io>>}; {<<wybe.io.io>>}> #23 @stmt_for:nn:nn
    wybe.string.print<0>("\nusing_irange_reverse":wybe.string)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #38 @string:nn:nn
    foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#37##0:wybe.phantom) @io:nn:nn
    foreign c putchar('\n':wybe.char, ~tmp#37##0:wybe.phantom, ?tmp#38##0:wybe.phantom) @io:nn:nn
    foreign lpvm store(~%tmp#38##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
    stmt_for.using_irange_reverse<0><{<<wybe.io.io>>}; {<<wybe.io.io>>}> #25 @stmt_for:nn:nn


gen#1 > (2 calls)
0: stmt_for.gen#1<0>
gen#1(tmp#0##0:wybe.list(wybe.int), tmp#1##0:wybe.list(wybe.int), tmp#2##0:wybe.list(wybe.int), tmp#3##0:wybe.list(wybe.int), tmp#4##0:wybe.list(wybe.int), tmp#5##0:wybe.list(wybe.int), tmp#6##0:wybe.list(wybe.int), tmp#7##0:wybe.list(wybe.int), tmp#8##0:wybe.list(wybe.int), tmp#9##0:wybe.list(wybe.int), x##0:wybe.list(wybe.int), y##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(tmp#8##0:wybe.int, 0:wybe.int, ?tmp#13##0:wybe.bool)
    case ~tmp#13##0:wybe.bool of
    0:

    1:
        foreign lpvm access(tmp#8##0:wybe.list(T), 0:wybe.int, 16:wybe.int, 0:wybe.int, ?i##0:wybe.int) @list:nn:nn
        foreign lpvm access(~tmp#8##0:wybe.list(T), 8:wybe.int, 16:wybe.int, 0:wybe.int, ?tmp#8##1:wybe.list(wybe.int)) @list:nn:nn
        foreign llvm icmp_ne(tmp#9##0:wybe.int, 0:wybe.int, ?tmp#15##0:wybe.bool)
        case ~tmp#15##0:wybe.bool of
        0:

        1:
            foreign lpvm access(tmp#9##0:wybe.list(T), 0:wybe.int, 16:wybe.int, 0:wybe.int, ?j##0:wybe.int) @list:nn:nn
            foreign lpvm access(~tmp#9##0:wybe.list(T), 8:wybe.int, 16:wybe.int, 0:wybe.int, ?tmp#9##1:wybe.list(wybe.int)) @list:nn:nn
            foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#17##0:wybe.phantom) @int:nn:nn
            foreign c print_int(~i##0:wybe.int, ~tmp#17##0:wybe.phantom, ?tmp#18##0:wybe.phantom) @int:nn:nn
            foreign c putchar('\n':wybe.char, ~tmp#18##0:wybe.phantom, ?tmp#19##0:wybe.phantom) @io:nn:nn
            foreign c print_int(~j##0:wybe.int, ~tmp#19##0:wybe.phantom, ?tmp#22##0:wybe.phantom) @int:nn:nn
            foreign c putchar('\n':wybe.char, ~tmp#22##0:wybe.phantom, ?tmp#23##0:wybe.phantom) @io:nn:nn
            foreign lpvm store(~%tmp#23##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
            stmt_for.gen#1<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), ~tmp#4##0:wybe.list(wybe.int), ~tmp#5##0:wybe.list(wybe.int), ~tmp#6##0:wybe.list(wybe.int), ~tmp#7##0:wybe.list(wybe.int), ~tmp#8##1:wybe.list(wybe.int), ~tmp#9##1:wybe.list(wybe.int), ~x##0:wybe.list(wybe.int), ~y##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #4 @stmt_for:nn:nn




gen#10 > (2 calls)
0: stmt_for.gen#10<0>
gen#10(tmp#0##0:wybe.list(wybe.int), tmp#1##0:wybe.list(wybe.int), tmp#2##0:wybe.list(wybe.int), tmp#3##0:wybe.list(wybe.int), tmp#4##0:wybe.list(wybe.int), tmp#5##0:wybe.list(wybe.int), x##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(tmp#5##0:wybe.int, 0:wybe.int, ?tmp#9##0:wybe.bool)
    case ~tmp#9##0:wybe.bool of
    0:

    1:
        foreign lpvm access(tmp#5##0:wybe.list(T), 0:wybe.int, 16:wybe.int, 0:wybe.int, ?i##0:wybe.int) @list:nn:nn
        foreign lpvm access(~tmp#5##0:wybe.list(T), 8:wybe.int, 16:wybe.int, 0:wybe.int, ?tmp#5##1:wybe.list(wybe.int)) @list:nn:nn
        foreign llvm icmp_eq(i##0:wybe.int, 3:wybe.int, ?tmp#6##0:wybe.bool) @int:nn:nn
        case ~tmp#6##0:wybe.bool of
        0:
            foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#13##0:wybe.phantom) @int:nn:nn
            foreign c print_int(~i##0:wybe.int, ~tmp#13##0:wybe.phantom, ?tmp#14##0:wybe.phantom) @int:nn:nn
            foreign c putchar('\n':wybe.char, ~tmp#14##0:wybe.phantom, ?tmp#15##0:wybe.phantom) @io:nn:nn
            foreign lpvm store(~%tmp#15##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
            stmt_for.gen#10<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), ~tmp#4##0:wybe.list(wybe.int), ~tmp#5##1:wybe.list(wybe.int), ~x##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #3 @stmt_for:nn:nn

        1:




gen#11 > (3 calls)
0: stmt_for.gen#11<0>
gen#11(tmp#0##0:wybe.list(wybe.int), tmp#1##0:wybe.list(wybe.int), tmp#2##0:wybe.list(wybe.int), tmp#3##0:wybe.list(wybe.int), tmp#4##0:wybe.list(wybe.int), tmp#5##0:wybe.list(wybe.int), x##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(tmp#5##0:wybe.int, 0:wybe.int, ?tmp#9##0:wybe.bool)
    case ~tmp#9##0:wybe.bool of
    0:

    1:
        foreign lpvm access(tmp#5##0:wybe.list(T), 0:wybe.int, 16:wybe.int, 0:wybe.int, ?i##0:wybe.int) @list:nn:nn
        foreign lpvm access(~tmp#5##0:wybe.list(T), 8:wybe.int, 16:wybe.int, 0:wybe.int, ?tmp#5##1:wybe.list(wybe.int)) @list:nn:nn
        foreign llvm icmp_slt(i##0:wybe.int, 3:wybe.int, ?tmp#6##0:wybe.bool) @int:nn:nn
        case ~tmp#6##0:wybe.bool of
        0:
            stmt_for.gen#11<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), ~tmp#4##0:wybe.list(wybe.int), ~tmp#5##1:wybe.list(wybe.int), ~x##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #4 @stmt_for:nn:nn

        1:
            foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#13##0:wybe.phantom) @int:nn:nn
            foreign c print_int(~i##0:wybe.int, ~tmp#13##0:wybe.phantom, ?tmp#14##0:wybe.phantom) @int:nn:nn
            foreign c putchar('\n':wybe.char, ~tmp#14##0:wybe.phantom, ?tmp#15##0:wybe.phantom) @io:nn:nn
            foreign lpvm store(~%tmp#15##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
            stmt_for.gen#11<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), ~tmp#4##0:wybe.list(wybe.int), ~tmp#5##1:wybe.list(wybe.int), ~x##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #3 @stmt_for:nn:nn




gen#12 > (2 calls)
0: stmt_for.gen#12<0>
gen#12(tmp#0##0:wybe.list(wybe.int), tmp#1##0:wybe.list(wybe.int), tmp#2##0:wybe.list(wybe.int), tmp#3##0:wybe.list(wybe.int), tmp#4##0:wybe.list(wybe.int), tmp#5##0:wybe.list(wybe.int), x##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(tmp#5##0:wybe.int, 0:wybe.int, ?tmp#9##0:wybe.bool)
    case ~tmp#9##0:wybe.bool of
    0:

    1:
        foreign lpvm access(tmp#5##0:wybe.list(T), 0:wybe.int, 16:wybe.int, 0:wybe.int, ?i##0:wybe.int) @list:nn:nn
        foreign lpvm access(~tmp#5##0:wybe.list(T), 8:wybe.int, 16:wybe.int, 0:wybe.int, ?tmp#5##1:wybe.list(wybe.int)) @list:nn:nn
        foreign llvm icmp_slt(i##0:wybe.int, 3:wybe.int, ?tmp#6##0:wybe.bool) @int:nn:nn
        case ~tmp#6##0:wybe.bool of
        0:

        1:
            foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#13##0:wybe.phantom) @int:nn:nn
            foreign c print_int(~i##0:wybe.int, ~tmp#13##0:wybe.phantom, ?tmp#14##0:wybe.phantom) @int:nn:nn
            foreign c putchar('\n':wybe.char, ~tmp#14##0:wybe.phantom, ?tmp#15##0:wybe.phantom) @io:nn:nn
            foreign lpvm store(~%tmp#15##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
            stmt_for.gen#12<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), ~tmp#4##0:wybe.list(wybe.int), ~tmp#5##1:wybe.list(wybe.int), ~x##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #3 @stmt_for:nn:nn




gen#13 > (2 calls)
0: stmt_for.gen#13<0>
gen#13(tmp#0##0:stmt_for.int_sequence, tmp#1##0:stmt_for.int_sequence)<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    stmt_for.int_sequence.[|]<0>(?i##0:wybe.int, ?tmp#0##1:stmt_for.int_sequence, ~tmp#0##0:stmt_for.int_sequence, ?tmp#2##0:wybe.bool) #0 @stmt_for:nn:nn
    case ~tmp#2##0:wybe.bool of
    0:

    1:
        foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#4##0:wybe.phantom) @int:nn:nn
        foreign c print_int(~i##0:wybe.int, ~tmp#4##0:wybe.phantom, ?tmp#5##0:wybe.phantom) @int:nn:nn
        foreign c putchar('\n':wybe.char, ~tmp#5##0:wybe.phantom, ?tmp#6##0:wybe.phantom) @io:nn:nn
        foreign lpvm store(~%tmp#6##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
        stmt_for.gen#13<0>(~tmp#0##1:stmt_for.int_sequence, ~tmp#1##0:stmt_for.int_sequence)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #2 @stmt_for:nn:nn



gen#14 > (2 calls)
0: stmt_for.gen#14<0>
gen#14(tmp#0##0:stmt_for.int_sequence, tmp#1##0:stmt_for.int_sequence)<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    stmt_for.int_sequence.[|]<0>(?i##0:wybe.int, ?tmp#0##1:stmt_for.int_sequence, ~tmp#0##0:stmt_for.int_sequence, ?tmp#2##0:wybe.bool) #0 @stmt_for:nn:nn
    case ~tmp#2##0:wybe.bool of
    0:

    1:
        foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#4##0:wybe.phantom) @int:nn:nn
        foreign c print_int(~i##0:wybe.int, ~tmp#4##0:wybe.phantom, ?tmp#5##0:wybe.phantom) @int:nn:nn
        foreign c putchar('\n':wybe.char, ~tmp#5##0:wybe.phantom, ?tmp#6##0:wybe.phantom) @io:nn:nn
        foreign lpvm store(~%tmp#6##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
        stmt_for.gen#14<0>(~tmp#0##1:stmt_for.int_sequence, ~tmp#1##0:stmt_for.int_sequence)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #2 @stmt_for:nn:nn



gen#2 > (2 calls)
0: stmt_for.gen#2<0>
gen#2(tmp#0##0:stmt_for.int_sequence, tmp#1##0:stmt_for.int_sequence, ?#success##0:wybe.bool)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    stmt_for.int_sequence.[|]<0>(?i##0:wybe.int, ?tmp#0##1:stmt_for.int_sequence, ~tmp#0##0:stmt_for.int_sequence, ?tmp#3##0:wybe.bool) #0 @stmt_for:nn:nn
    case ~tmp#3##0:wybe.bool of
    0:
        foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)

    1:
        foreign llvm icmp_slt(~i##0:wybe.int, 5:wybe.int, ?tmp#2##0:wybe.bool) @int:nn:nn
        case ~tmp#2##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)

        1:
            stmt_for.gen#2<0>(~tmp#0##1:stmt_for.int_sequence, ~tmp#1##0:stmt_for.int_sequence, ?#success##0:wybe.bool) #2 @stmt_for:nn:nn




gen#3 > (2 calls)
0: stmt_for.gen#3<0>
gen#3(tmp#0##0:wybe.list(wybe.int), tmp#1##0:wybe.list(wybe.int), tmp#2##0:wybe.list(wybe.int), tmp#3##0:wybe.list(wybe.int), tmp#4##0:wybe.list(wybe.int), tmp#5##0:wybe.list(wybe.int), tmp#6##0:wybe.list(wybe.int), tmp#7##0:wybe.list(wybe.int), tmp#8##0:wybe.list(wybe.int), tmp#9##0:wybe.list(wybe.int), x##0:wybe.list(wybe.int), y##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(tmp#8##0:wybe.int, 0:wybe.int, ?tmp#13##0:wybe.bool)
    case ~tmp#13##0:wybe.bool of
    0:

    1:
        foreign lpvm access(tmp#8##0:wybe.list(T), 0:wybe.int, 16:wybe.int, 0:wybe.int, ?i##0:wybe.int) @list:nn:nn
        foreign lpvm access(~tmp#8##0:wybe.list(T), 8:wybe.int, 16:wybe.int, 0:wybe.int, ?tmp#8##1:wybe.list(wybe.int)) @list:nn:nn
        foreign llvm icmp_ne(tmp#9##0:wybe.int, 0:wybe.int, ?tmp#15##0:wybe.bool)
        case ~tmp#15##0:wybe.bool of
        0:

        1:
            foreign lpvm access(tmp#9##0:wybe.list(T), 0:wybe.int, 16:wybe.int, 0:wybe.int, ?j##0:wybe.int) @list:nn:nn
            foreign lpvm access(~tmp#9##0:wybe.list(T), 8:wybe.int, 16:wybe.int, 0:wybe.int, ?tmp#9##1:wybe.list(wybe.int)) @list:nn:nn
            foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#17##0:wybe.phantom) @int:nn:nn
            foreign c print_int(~i##0:wybe.int, ~tmp#17##0:wybe.phantom, ?tmp#18##0:wybe.phantom) @int:nn:nn
            foreign c putchar('\n':wybe.char, ~tmp#18##0:wybe.phantom, ?tmp#19##0:wybe.phantom) @io:nn:nn
            foreign c print_int(~j##0:wybe.int, ~tmp#19##0:wybe.phantom, ?tmp#22##0:wybe.phantom) @int:nn:nn
            foreign c putchar('\n':wybe.char, ~tmp#22##0:wybe.phantom, ?tmp#23##0:wybe.phantom) @io:nn:nn
            foreign lpvm store(~%tmp#23##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
            stmt_for.gen#3<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), ~tmp#4##0:wybe.list(wybe.int), ~tmp#5##0:wybe.list(wybe.int), ~tmp#6##0:wybe.list(wybe.int), ~tmp#7##0:wybe.list(wybe.int), ~tmp#8##1:wybe.list(wybe.int), ~tmp#9##1:wybe.list(wybe.int), ~x##0:wybe.list(wybe.int), ~y##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #4 @stmt_for:nn:nn




gen#4 > (2 calls)
0: stmt_for.gen#4<0>
gen#4(tmp#0##0:wybe.list(wybe.int), tmp#1##0:wybe.list(wybe.int), tmp#2##0:wybe.list(wybe.int), tmp#3##0:wybe.list(wybe.int), tmp#4##0:wybe.list(wybe.int), x##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(tmp#4##0:wybe.int, 0:wybe.int, ?tmp#7##0:wybe.bool)
    case ~tmp#7##0:wybe.bool of
    0:

    1:
        foreign lpvm access(tmp#4##0:wybe.list(T), 0:wybe.int, 16:wybe.int, 0:wybe.int, ?i##0:wybe.int) @list:nn:nn
        foreign lpvm access(~tmp#4##0:wybe.list(T), 8:wybe.int, 16:wybe.int, 0:wybe.int, ?tmp#4##1:wybe.list(wybe.int)) @list:nn:nn
        foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#9##0:wybe.phantom) @int:nn:nn
        foreign c print_int(~i##0:wybe.int, ~tmp#9##0:wybe.phantom, ?tmp#10##0:wybe.phantom) @int:nn:nn
        foreign c putchar('\n':wybe.char, ~tmp#10##0:wybe.phantom, ?tmp#11##0:wybe.phantom) @io:nn:nn
        foreign lpvm store(~%tmp#11##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
        stmt_for.gen#4<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), ~tmp#4##1:wybe.list(wybe.int), ~x##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #2 @stmt_for:nn:nn



gen#5 > (2 calls)
0: stmt_for.gen#5<0>
gen#5(tmp#0##0:wybe.list(wybe.int), tmp#1##0:wybe.list(wybe.int), tmp#2##0:wybe.list(wybe.int), tmp#3##0:wybe.list(wybe.int), tmp#4##0:wybe.list(wybe.int), tmp#5##0:wybe.list(wybe.int), x##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(tmp#5##0:wybe.int, 0:wybe.int, ?tmp#9##0:wybe.bool)
    case ~tmp#9##0:wybe.bool of
    0:

    1:
        foreign lpvm access(tmp#5##0:wybe.list(T), 0:wybe.int, 16:wybe.int, 0:wybe.int, ?i##0:wybe.int) @list:nn:nn
        foreign lpvm access(~tmp#5##0:wybe.list(T), 8:wybe.int, 16:wybe.int, 0:wybe.int, ?tmp#5##1:wybe.list(wybe.int)) @list:nn:nn
        foreign llvm icmp_eq(i##0:wybe.int, 3:wybe.int, ?tmp#6##0:wybe.bool) @int:nn:nn
        case ~tmp#6##0:wybe.bool of
        0:
            foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#13##0:wybe.phantom) @int:nn:nn
            foreign c print_int(~i##0:wybe.int, ~tmp#13##0:wybe.phantom, ?tmp#14##0:wybe.phantom) @int:nn:nn
            foreign c putchar('\n':wybe.char, ~tmp#14##0:wybe.phantom, ?tmp#15##0:wybe.phantom) @io:nn:nn
            foreign lpvm store(~%tmp#15##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
            stmt_for.gen#5<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), ~tmp#4##0:wybe.list(wybe.int), ~tmp#5##1:wybe.list(wybe.int), ~x##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #3 @stmt_for:nn:nn

        1:




gen#6 > (2 calls)
0: stmt_for.gen#6<0>
gen#6(tmp#0##0:stmt_for.int_sequence, tmp#1##0:stmt_for.int_sequence)<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    stmt_for.int_sequence.[|]<0>(?i##0:wybe.int, ?tmp#0##1:stmt_for.int_sequence, ~tmp#0##0:stmt_for.int_sequence, ?tmp#2##0:wybe.bool) #0 @stmt_for:nn:nn
    case ~tmp#2##0:wybe.bool of
    0:

    1:
        foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#4##0:wybe.phantom) @int:nn:nn
        foreign c print_int(~i##0:wybe.int, ~tmp#4##0:wybe.phantom, ?tmp#5##0:wybe.phantom) @int:nn:nn
        foreign c putchar('\n':wybe.char, ~tmp#5##0:wybe.phantom, ?tmp#6##0:wybe.phantom) @io:nn:nn
        foreign lpvm store(~%tmp#6##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
        stmt_for.gen#6<0>(~tmp#0##1:stmt_for.int_sequence, ~tmp#1##0:stmt_for.int_sequence)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #2 @stmt_for:nn:nn



gen#7 > (2 calls)
0: stmt_for.gen#7<0>
gen#7(tmp#0##0:stmt_for.int_sequence, tmp#1##0:stmt_for.int_sequence)<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    stmt_for.int_sequence.[|]<0>(?i##0:wybe.int, ?tmp#0##1:stmt_for.int_sequence, ~tmp#0##0:stmt_for.int_sequence, ?tmp#2##0:wybe.bool) #0 @stmt_for:nn:nn
    case ~tmp#2##0:wybe.bool of
    0:

    1:
        foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#4##0:wybe.phantom) @int:nn:nn
        foreign c print_int(~i##0:wybe.int, ~tmp#4##0:wybe.phantom, ?tmp#5##0:wybe.phantom) @int:nn:nn
        foreign c putchar('\n':wybe.char, ~tmp#5##0:wybe.phantom, ?tmp#6##0:wybe.phantom) @io:nn:nn
        foreign lpvm store(~%tmp#6##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
        stmt_for.gen#7<0>(~tmp#0##1:stmt_for.int_sequence, ~tmp#1##0:stmt_for.int_sequence)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #2 @stmt_for:nn:nn



gen#8 > (3 calls)
0: stmt_for.gen#8<0>
gen#8(tmp#0##0:wybe.list(wybe.int), tmp#1##0:wybe.list(wybe.int), tmp#2##0:wybe.list(wybe.int), tmp#3##0:wybe.list(wybe.int), tmp#4##0:wybe.list(wybe.int), tmp#5##0:wybe.list(wybe.int), x##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(tmp#5##0:wybe.int, 0:wybe.int, ?tmp#9##0:wybe.bool)
    case ~tmp#9##0:wybe.bool of
    0:

    1:
        foreign lpvm access(tmp#5##0:wybe.list(T), 0:wybe.int, 16:wybe.int, 0:wybe.int, ?i##0:wybe.int) @list:nn:nn
        foreign lpvm access(~tmp#5##0:wybe.list(T), 8:wybe.int, 16:wybe.int, 0:wybe.int, ?tmp#5##1:wybe.list(wybe.int)) @list:nn:nn
        foreign llvm icmp_eq(i##0:wybe.int, 3:wybe.int, ?tmp#6##0:wybe.bool) @int:nn:nn
        case ~tmp#6##0:wybe.bool of
        0:
            foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#13##0:wybe.phantom) @int:nn:nn
            foreign c print_int(~i##0:wybe.int, ~tmp#13##0:wybe.phantom, ?tmp#14##0:wybe.phantom) @int:nn:nn
            foreign c putchar('\n':wybe.char, ~tmp#14##0:wybe.phantom, ?tmp#15##0:wybe.phantom) @io:nn:nn
            foreign lpvm store(~%tmp#15##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
            stmt_for.gen#8<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), ~tmp#4##0:wybe.list(wybe.int), ~tmp#5##1:wybe.list(wybe.int), ~x##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #4 @stmt_for:nn:nn

        1:
            stmt_for.gen#8<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), ~tmp#4##0:wybe.list(wybe.int), ~tmp#5##1:wybe.list(wybe.int), ~x##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #2 @stmt_for:nn:nn




gen#9 > (3 calls)
0: stmt_for.gen#9<0>
gen#9(tmp#0##0:wybe.list(wybe.int), tmp#1##0:wybe.list(wybe.int), tmp#2##0:wybe.list(wybe.int), tmp#3##0:wybe.list(wybe.int), tmp#4##0:wybe.list(wybe.int), tmp#5##0:wybe.list(wybe.int), x##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_ne(tmp#5##0:wybe.int, 0:wybe.int, ?tmp#9##0:wybe.bool)
    case ~tmp#9##0:wybe.bool of
    0:

    1:
        foreign lpvm access(tmp#5##0:wybe.list(T), 0:wybe.int, 16:wybe.int, 0:wybe.int, ?i##0:wybe.int) @list:nn:nn
        foreign lpvm access(~tmp#5##0:wybe.list(T), 8:wybe.int, 16:wybe.int, 0:wybe.int, ?tmp#5##1:wybe.list(wybe.int)) @list:nn:nn
        foreign llvm icmp_slt(i##0:wybe.int, 3:wybe.int, ?tmp#6##0:wybe.bool) @int:nn:nn
        case ~tmp#6##0:wybe.bool of
        0:
            foreign lpvm load(<<wybe.io.io>>:wybe.phantom, ?%tmp#13##0:wybe.phantom) @int:nn:nn
            foreign c print_int(~i##0:wybe.int, ~tmp#13##0:wybe.phantom, ?tmp#14##0:wybe.phantom) @int:nn:nn
            foreign c putchar('\n':wybe.char, ~tmp#14##0:wybe.phantom, ?tmp#15##0:wybe.phantom) @io:nn:nn
            foreign lpvm store(~%tmp#15##0:wybe.phantom, <<wybe.io.io>>:wybe.phantom) @io:nn:nn
            stmt_for.gen#9<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), ~tmp#4##0:wybe.list(wybe.int), ~tmp#5##1:wybe.list(wybe.int), ~x##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #4 @stmt_for:nn:nn

        1:
            stmt_for.gen#9<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), ~tmp#4##0:wybe.list(wybe.int), ~tmp#5##1:wybe.list(wybe.int), ~x##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #2 @stmt_for:nn:nn




irange > public (2 calls)
0: stmt_for.irange<0>
irange(start##0:wybe.int, stride##0:wybe.int, end##0:wybe.int, ?#result##0:stmt_for.int_sequence)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm icmp_slt(stride##0:wybe.int, 0:wybe.int, ?tmp#4##0:wybe.bool) @int:nn:nn
    case ~tmp#4##0:wybe.bool of
    0:
        foreign llvm add(~end##0:wybe.int, 1:wybe.int, ?tmp#3##0:wybe.int) @int:nn:nn
        foreign lpvm alloc(24:wybe.int, ?tmp#12##0:stmt_for.int_sequence) @stmt_for:nn:nn
        foreign lpvm mutate(~tmp#12##0:stmt_for.int_sequence, ?tmp#13##0:stmt_for.int_sequence, 0:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~start##0:wybe.int) @stmt_for:nn:nn
        foreign lpvm mutate(~tmp#13##0:stmt_for.int_sequence, ?tmp#14##0:stmt_for.int_sequence, 8:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~stride##0:wybe.int) @stmt_for:nn:nn
        foreign lpvm mutate(~tmp#14##0:stmt_for.int_sequence, ?#result##0:stmt_for.int_sequence, 16:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~tmp#3##0:wybe.int) @stmt_for:nn:nn

    1:
        foreign llvm sub(~end##0:wybe.int, 1:wybe.int, ?tmp#2##0:wybe.int) @int:nn:nn
        foreign lpvm alloc(24:wybe.int, ?tmp#12##0:stmt_for.int_sequence) @stmt_for:nn:nn
        foreign lpvm mutate(~tmp#12##0:stmt_for.int_sequence, ?tmp#13##0:stmt_for.int_sequence, 0:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~start##0:wybe.int) @stmt_for:nn:nn
        foreign lpvm mutate(~tmp#13##0:stmt_for.int_sequence, ?tmp#14##0:stmt_for.int_sequence, 8:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~stride##0:wybe.int) @stmt_for:nn:nn
        foreign lpvm mutate(~tmp#14##0:stmt_for.int_sequence, ?#result##0:stmt_for.int_sequence, 16:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~tmp#2##0:wybe.int) @stmt_for:nn:nn



multiple_generator > public (1 calls)
0: stmt_for.multiple_generator<0>
multiple_generator()<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?tmp#14##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#14##0:wybe.list(T), ?tmp#15##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 3:T) @list:nn:nn
    foreign lpvm mutate(~tmp#15##0:wybe.list(T), ?tmp#2##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#18##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#18##0:wybe.list(T), ?tmp#19##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 2:T) @list:nn:nn
    foreign lpvm mutate(~tmp#19##0:wybe.list(T), ?tmp#1##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#2##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#22##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#22##0:wybe.list(T), ?tmp#23##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 1:T) @list:nn:nn
    foreign lpvm mutate(~tmp#23##0:wybe.list(T), ?tmp#0##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#1##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#26##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#26##0:wybe.list(T), ?tmp#27##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 6:T) @list:nn:nn
    foreign lpvm mutate(~tmp#27##0:wybe.list(T), ?tmp#6##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#30##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#30##0:wybe.list(T), ?tmp#31##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 5:T) @list:nn:nn
    foreign lpvm mutate(~tmp#31##0:wybe.list(T), ?tmp#5##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#6##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#34##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#34##0:wybe.list(T), ?tmp#35##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 4:T) @list:nn:nn
    foreign lpvm mutate(~tmp#35##0:wybe.list(T), ?tmp#4##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#5##0:wybe.list(T)) @list:nn:nn
    stmt_for.gen#1<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), 0:wybe.list(wybe.int), ~tmp#4##0:wybe.list(wybe.int), ~tmp#5##0:wybe.list(wybe.int), ~tmp#6##0:wybe.list(wybe.int), 0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int), ~tmp#4##0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int), ~tmp#4##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #8 @stmt_for:nn:nn


semi_det_for_loop > public (0 calls)
0: stmt_for.semi_det_for_loop<0>
semi_det_for_loop(?#success##0:wybe.bool)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    stmt_for.xrange<0>(0:wybe.int, 1:wybe.int, 10:wybe.int, ?tmp#1##0:stmt_for.int_sequence) #0 @stmt_for:nn:nn
    stmt_for.gen#2<0>(~tmp#1##0:stmt_for.int_sequence, ~tmp#1##0:stmt_for.int_sequence, ?#success##0:wybe.bool) #1 @stmt_for:nn:nn


shortest_generator_termination > public (1 calls)
0: stmt_for.shortest_generator_termination<0>
shortest_generator_termination()<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?tmp#14##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#14##0:wybe.list(T), ?tmp#15##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 4:T) @list:nn:nn
    foreign lpvm mutate(~tmp#15##0:wybe.list(T), ?tmp#3##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#18##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#18##0:wybe.list(T), ?tmp#19##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 3:T) @list:nn:nn
    foreign lpvm mutate(~tmp#19##0:wybe.list(T), ?tmp#2##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#3##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#22##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#22##0:wybe.list(T), ?tmp#23##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 2:T) @list:nn:nn
    foreign lpvm mutate(~tmp#23##0:wybe.list(T), ?tmp#1##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#2##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#26##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#26##0:wybe.list(T), ?tmp#27##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 1:T) @list:nn:nn
    foreign lpvm mutate(~tmp#27##0:wybe.list(T), ?tmp#0##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#1##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#30##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#30##0:wybe.list(T), ?tmp#31##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 5:T) @list:nn:nn
    foreign lpvm mutate(~tmp#31##0:wybe.list(T), ?tmp#6##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#34##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#34##0:wybe.list(T), ?tmp#35##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 4:T) @list:nn:nn
    foreign lpvm mutate(~tmp#35##0:wybe.list(T), ?tmp#5##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#6##0:wybe.list(T)) @list:nn:nn
    stmt_for.gen#3<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), 0:wybe.list(wybe.int), ~tmp#5##0:wybe.list(wybe.int), ~tmp#6##0:wybe.list(wybe.int), 0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int), ~tmp#5##0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int), ~tmp#5##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #8 @stmt_for:nn:nn


single_generator > public (1 calls)
0: stmt_for.single_generator<0>
single_generator()<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?tmp#8##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#8##0:wybe.list(T), ?tmp#9##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 3:T) @list:nn:nn
    foreign lpvm mutate(~tmp#9##0:wybe.list(T), ?tmp#2##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#12##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#12##0:wybe.list(T), ?tmp#13##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 2:T) @list:nn:nn
    foreign lpvm mutate(~tmp#13##0:wybe.list(T), ?tmp#1##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#2##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#16##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#16##0:wybe.list(T), ?tmp#17##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 1:T) @list:nn:nn
    foreign lpvm mutate(~tmp#17##0:wybe.list(T), ?tmp#0##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#1##0:wybe.list(T)) @list:nn:nn
    stmt_for.gen#4<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), 0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #4 @stmt_for:nn:nn


using_break > public (1 calls)
0: stmt_for.using_break<0>
using_break()<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?tmp#10##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#10##0:wybe.list(T), ?tmp#11##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 4:T) @list:nn:nn
    foreign lpvm mutate(~tmp#11##0:wybe.list(T), ?tmp#3##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#14##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#14##0:wybe.list(T), ?tmp#15##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 3:T) @list:nn:nn
    foreign lpvm mutate(~tmp#15##0:wybe.list(T), ?tmp#2##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#3##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#18##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#18##0:wybe.list(T), ?tmp#19##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 2:T) @list:nn:nn
    foreign lpvm mutate(~tmp#19##0:wybe.list(T), ?tmp#1##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#2##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#22##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#22##0:wybe.list(T), ?tmp#23##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 1:T) @list:nn:nn
    foreign lpvm mutate(~tmp#23##0:wybe.list(T), ?tmp#0##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#1##0:wybe.list(T)) @list:nn:nn
    stmt_for.gen#5<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), 0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #5 @stmt_for:nn:nn


using_irange > public (1 calls)
0: stmt_for.using_irange<0>
using_irange()<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    stmt_for.irange<0>(1:wybe.int, 1:wybe.int, 10:wybe.int, ?tmp#1##0:stmt_for.int_sequence) #0 @stmt_for:nn:nn
    stmt_for.gen#6<0>(~tmp#1##0:stmt_for.int_sequence, ~tmp#1##0:stmt_for.int_sequence)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #1 @stmt_for:nn:nn


using_irange_reverse > public (1 calls)
0: stmt_for.using_irange_reverse<0>
using_irange_reverse()<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    stmt_for.irange<0>(10:wybe.int, -1:wybe.int, 1:wybe.int, ?tmp#1##0:stmt_for.int_sequence) #0 @stmt_for:nn:nn
    stmt_for.gen#7<0>(~tmp#1##0:stmt_for.int_sequence, ~tmp#1##0:stmt_for.int_sequence)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #1 @stmt_for:nn:nn


using_next > public (1 calls)
0: stmt_for.using_next<0>
using_next()<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?tmp#10##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#10##0:wybe.list(T), ?tmp#11##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 4:T) @list:nn:nn
    foreign lpvm mutate(~tmp#11##0:wybe.list(T), ?tmp#3##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#14##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#14##0:wybe.list(T), ?tmp#15##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 3:T) @list:nn:nn
    foreign lpvm mutate(~tmp#15##0:wybe.list(T), ?tmp#2##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#3##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#18##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#18##0:wybe.list(T), ?tmp#19##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 2:T) @list:nn:nn
    foreign lpvm mutate(~tmp#19##0:wybe.list(T), ?tmp#1##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#2##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#22##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#22##0:wybe.list(T), ?tmp#23##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 1:T) @list:nn:nn
    foreign lpvm mutate(~tmp#23##0:wybe.list(T), ?tmp#0##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#1##0:wybe.list(T)) @list:nn:nn
    stmt_for.gen#8<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), 0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #5 @stmt_for:nn:nn


using_unless > public (1 calls)
0: stmt_for.using_unless<0>
using_unless()<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?tmp#10##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#10##0:wybe.list(T), ?tmp#11##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 4:T) @list:nn:nn
    foreign lpvm mutate(~tmp#11##0:wybe.list(T), ?tmp#3##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#14##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#14##0:wybe.list(T), ?tmp#15##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 3:T) @list:nn:nn
    foreign lpvm mutate(~tmp#15##0:wybe.list(T), ?tmp#2##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#3##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#18##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#18##0:wybe.list(T), ?tmp#19##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 2:T) @list:nn:nn
    foreign lpvm mutate(~tmp#19##0:wybe.list(T), ?tmp#1##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#2##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#22##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#22##0:wybe.list(T), ?tmp#23##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 1:T) @list:nn:nn
    foreign lpvm mutate(~tmp#23##0:wybe.list(T), ?tmp#0##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#1##0:wybe.list(T)) @list:nn:nn
    stmt_for.gen#9<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), 0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #5 @stmt_for:nn:nn


using_until > public (1 calls)
0: stmt_for.using_until<0>
using_until()<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?tmp#10##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#10##0:wybe.list(T), ?tmp#11##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 4:T) @list:nn:nn
    foreign lpvm mutate(~tmp#11##0:wybe.list(T), ?tmp#3##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#14##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#14##0:wybe.list(T), ?tmp#15##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 3:T) @list:nn:nn
    foreign lpvm mutate(~tmp#15##0:wybe.list(T), ?tmp#2##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#3##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#18##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#18##0:wybe.list(T), ?tmp#19##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 2:T) @list:nn:nn
    foreign lpvm mutate(~tmp#19##0:wybe.list(T), ?tmp#1##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#2##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#22##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#22##0:wybe.list(T), ?tmp#23##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 1:T) @list:nn:nn
    foreign lpvm mutate(~tmp#23##0:wybe.list(T), ?tmp#0##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#1##0:wybe.list(T)) @list:nn:nn
    stmt_for.gen#10<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), 0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #5 @stmt_for:nn:nn


using_when > public (1 calls)
0: stmt_for.using_when<0>
using_when()<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?tmp#10##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#10##0:wybe.list(T), ?tmp#11##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 4:T) @list:nn:nn
    foreign lpvm mutate(~tmp#11##0:wybe.list(T), ?tmp#3##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#14##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#14##0:wybe.list(T), ?tmp#15##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 3:T) @list:nn:nn
    foreign lpvm mutate(~tmp#15##0:wybe.list(T), ?tmp#2##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#3##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#18##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#18##0:wybe.list(T), ?tmp#19##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 2:T) @list:nn:nn
    foreign lpvm mutate(~tmp#19##0:wybe.list(T), ?tmp#1##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#2##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#22##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#22##0:wybe.list(T), ?tmp#23##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 1:T) @list:nn:nn
    foreign lpvm mutate(~tmp#23##0:wybe.list(T), ?tmp#0##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#1##0:wybe.list(T)) @list:nn:nn
    stmt_for.gen#11<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), 0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #5 @stmt_for:nn:nn


using_while > public (1 calls)
0: stmt_for.using_while<0>
using_while()<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm alloc(16:wybe.int, ?tmp#10##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#10##0:wybe.list(T), ?tmp#11##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 4:T) @list:nn:nn
    foreign lpvm mutate(~tmp#11##0:wybe.list(T), ?tmp#3##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#14##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#14##0:wybe.list(T), ?tmp#15##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 3:T) @list:nn:nn
    foreign lpvm mutate(~tmp#15##0:wybe.list(T), ?tmp#2##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#3##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#18##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#18##0:wybe.list(T), ?tmp#19##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 2:T) @list:nn:nn
    foreign lpvm mutate(~tmp#19##0:wybe.list(T), ?tmp#1##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#2##0:wybe.list(T)) @list:nn:nn
    foreign lpvm alloc(16:wybe.int, ?tmp#22##0:wybe.list(T)) @list:nn:nn
    foreign lpvm mutate(~tmp#22##0:wybe.list(T), ?tmp#23##0:wybe.list(T), 0:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, 1:T) @list:nn:nn
    foreign lpvm mutate(~tmp#23##0:wybe.list(T), ?tmp#0##0:wybe.list(wybe.int), 8:wybe.int, 1:wybe.int, 16:wybe.int, 0:wybe.int, tmp#1##0:wybe.list(T)) @list:nn:nn
    stmt_for.gen#12<0>(~tmp#0##0:wybe.list(wybe.int), ~tmp#1##0:wybe.list(wybe.int), ~tmp#2##0:wybe.list(wybe.int), ~tmp#3##0:wybe.list(wybe.int), 0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int), ~tmp#0##0:wybe.list(wybe.int))<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #5 @stmt_for:nn:nn


using_xrange > public (1 calls)
0: stmt_for.using_xrange<0>
using_xrange()<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    stmt_for.xrange<0>(1:wybe.int, 1:wybe.int, 10:wybe.int, ?tmp#1##0:stmt_for.int_sequence) #0 @stmt_for:nn:nn
    stmt_for.gen#13<0>(~tmp#1##0:stmt_for.int_sequence, ~tmp#1##0:stmt_for.int_sequence)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #1 @stmt_for:nn:nn


using_xrange_reverse > public (1 calls)
0: stmt_for.using_xrange_reverse<0>
using_xrange_reverse()<{<<wybe.io.io>>}; {<<wybe.io.io>>}>:
  AliasPairs: []
  InterestingCallProperties: []
    stmt_for.xrange<0>(10:wybe.int, -1:wybe.int, 1:wybe.int, ?tmp#1##0:stmt_for.int_sequence) #0 @stmt_for:nn:nn
    stmt_for.gen#14<0>(~tmp#1##0:stmt_for.int_sequence, ~tmp#1##0:stmt_for.int_sequence)<{<<wybe.io.io>>}; {<<wybe.io.io>>}> #1 @stmt_for:nn:nn


xrange > public (3 calls)
0: stmt_for.xrange<0>
xrange(start##0:wybe.int, stride##0:wybe.int, end##0:wybe.int, ?#result##0:stmt_for.int_sequence)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm alloc(24:wybe.int, ?tmp#4##0:stmt_for.int_sequence) @stmt_for:nn:nn
    foreign lpvm mutate(~tmp#4##0:stmt_for.int_sequence, ?tmp#5##0:stmt_for.int_sequence, 0:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~start##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm mutate(~tmp#5##0:stmt_for.int_sequence, ?tmp#6##0:stmt_for.int_sequence, 8:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~stride##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm mutate(~tmp#6##0:stmt_for.int_sequence, ?#result##0:stmt_for.int_sequence, 16:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~end##0:wybe.int) @stmt_for:nn:nn

  LLVM code       :

; ModuleID = 'stmt_for'


 


@stmt_for.16 =    constant {i64, i64} { i64 11, i64 ptrtoint ([?? x i8]* @stmt_for.15 to i64) }


@stmt_for.10 =    constant {i64, i64} { i64 11, i64 ptrtoint ([?? x i8]* @stmt_for.9 to i64) }


@stmt_for.12 =    constant {i64, i64} { i64 12, i64 ptrtoint ([?? x i8]* @stmt_for.11 to i64) }


@stmt_for.14 =    constant {i64, i64} { i64 12, i64 ptrtoint ([?? x i8]* @stmt_for.13 to i64) }


@stmt_for.8 =    constant {i64, i64} { i64 12, i64 ptrtoint ([?? x i8]* @stmt_for.7 to i64) }


@stmt_for.18 =    constant {i64, i64} { i64 13, i64 ptrtoint ([?? x i8]* @stmt_for.17 to i64) }


@stmt_for.20 =    constant {i64, i64} { i64 13, i64 ptrtoint ([?? x i8]* @stmt_for.19 to i64) }


@stmt_for.24 =    constant {i64, i64} { i64 13, i64 ptrtoint ([?? x i8]* @stmt_for.23 to i64) }


@stmt_for.2 =    constant {i64, i64} { i64 17, i64 ptrtoint ([?? x i8]* @stmt_for.1 to i64) }


@stmt_for.4 =    constant {i64, i64} { i64 19, i64 ptrtoint ([?? x i8]* @stmt_for.3 to i64) }


@stmt_for.22 =    constant {i64, i64} { i64 21, i64 ptrtoint ([?? x i8]* @stmt_for.21 to i64) }


@stmt_for.26 =    constant {i64, i64} { i64 21, i64 ptrtoint ([?? x i8]* @stmt_for.25 to i64) }


@stmt_for.6 =    constant {i64, i64} { i64 31, i64 ptrtoint ([?? x i8]* @stmt_for.5 to i64) }


@stmt_for.3 =    constant [?? x i8] c"\0amultiple_generator\00"


@stmt_for.5 =    constant [?? x i8] c"\0ashortest_generator_termination\00"


@stmt_for.7 =    constant [?? x i8] c"\0ausing_break\00"


@stmt_for.23 =    constant [?? x i8] c"\0ausing_irange\00"


@stmt_for.25 =    constant [?? x i8] c"\0ausing_irange_reverse\00"


@stmt_for.9 =    constant [?? x i8] c"\0ausing_next\00"


@stmt_for.17 =    constant [?? x i8] c"\0ausing_unless\00"


@stmt_for.13 =    constant [?? x i8] c"\0ausing_until\00"


@stmt_for.15 =    constant [?? x i8] c"\0ausing_when\00"


@stmt_for.11 =    constant [?? x i8] c"\0ausing_while\00"


@stmt_for.19 =    constant [?? x i8] c"\0ausing_xrange\00"


@stmt_for.21 =    constant [?? x i8] c"\0ausing_xrange_reverse\00"


@stmt_for.1 =    constant [?? x i8] c"single_generator:\00"


declare external ccc  void @putchar(i8)    


declare external ccc  void @print_int(i64)    


declare external fastcc  void @"wybe.string.print<0>"(i64)    


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i1)    


define external fastcc  void @"stmt_for.<0>"()    {
entry:
  tail call fastcc  void  @"wybe.string.print<0>"(i64  ptrtoint (i64* getelementptr inbounds ({i64, i64}, {i64, i64}* @stmt_for.2, i32 0, i32 0) to i64))  
  tail call ccc  void  @putchar(i8  10)  
  tail call fastcc  void  @"stmt_for.single_generator<0>"()  
  tail call fastcc  void  @"wybe.string.print<0>"(i64  ptrtoint (i64* getelementptr inbounds ({i64, i64}, {i64, i64}* @stmt_for.4, i32 0, i32 0) to i64))  
  tail call ccc  void  @putchar(i8  10)  
  tail call fastcc  void  @"stmt_for.multiple_generator<0>"()  
  tail call fastcc  void  @"wybe.string.print<0>"(i64  ptrtoint (i64* getelementptr inbounds ({i64, i64}, {i64, i64}* @stmt_for.6, i32 0, i32 0) to i64))  
  tail call ccc  void  @putchar(i8  10)  
  tail call fastcc  void  @"stmt_for.shortest_generator_termination<0>"()  
  tail call fastcc  void  @"wybe.string.print<0>"(i64  ptrtoint (i64* getelementptr inbounds ({i64, i64}, {i64, i64}* @stmt_for.8, i32 0, i32 0) to i64))  
  tail call ccc  void  @putchar(i8  10)  
  tail call fastcc  void  @"stmt_for.using_break<0>"()  
  tail call fastcc  void  @"wybe.string.print<0>"(i64  ptrtoint (i64* getelementptr inbounds ({i64, i64}, {i64, i64}* @stmt_for.10, i32 0, i32 0) to i64))  
  tail call ccc  void  @putchar(i8  10)  
  tail call fastcc  void  @"stmt_for.using_next<0>"()  
  tail call fastcc  void  @"wybe.string.print<0>"(i64  ptrtoint (i64* getelementptr inbounds ({i64, i64}, {i64, i64}* @stmt_for.12, i32 0, i32 0) to i64))  
  tail call ccc  void  @putchar(i8  10)  
  tail call fastcc  void  @"stmt_for.using_while<0>"()  
  tail call fastcc  void  @"wybe.string.print<0>"(i64  ptrtoint (i64* getelementptr inbounds ({i64, i64}, {i64, i64}* @stmt_for.14, i32 0, i32 0) to i64))  
  tail call ccc  void  @putchar(i8  10)  
  tail call fastcc  void  @"stmt_for.using_until<0>"()  
  tail call fastcc  void  @"wybe.string.print<0>"(i64  ptrtoint (i64* getelementptr inbounds ({i64, i64}, {i64, i64}* @stmt_for.16, i32 0, i32 0) to i64))  
  tail call ccc  void  @putchar(i8  10)  
  tail call fastcc  void  @"stmt_for.using_when<0>"()  
  tail call fastcc  void  @"wybe.string.print<0>"(i64  ptrtoint (i64* getelementptr inbounds ({i64, i64}, {i64, i64}* @stmt_for.18, i32 0, i32 0) to i64))  
  tail call ccc  void  @putchar(i8  10)  
  tail call fastcc  void  @"stmt_for.using_unless<0>"()  
  tail call fastcc  void  @"wybe.string.print<0>"(i64  ptrtoint (i64* getelementptr inbounds ({i64, i64}, {i64, i64}* @stmt_for.20, i32 0, i32 0) to i64))  
  tail call ccc  void  @putchar(i8  10)  
  tail call fastcc  void  @"stmt_for.using_xrange<0>"()  
  tail call fastcc  void  @"wybe.string.print<0>"(i64  ptrtoint (i64* getelementptr inbounds ({i64, i64}, {i64, i64}* @stmt_for.22, i32 0, i32 0) to i64))  
  tail call ccc  void  @putchar(i8  10)  
  tail call fastcc  void  @"stmt_for.using_xrange_reverse<0>"()  
  tail call fastcc  void  @"wybe.string.print<0>"(i64  ptrtoint (i64* getelementptr inbounds ({i64, i64}, {i64, i64}* @stmt_for.24, i32 0, i32 0) to i64))  
  tail call ccc  void  @putchar(i8  10)  
  tail call fastcc  void  @"stmt_for.using_irange<0>"()  
  tail call fastcc  void  @"wybe.string.print<0>"(i64  ptrtoint (i64* getelementptr inbounds ({i64, i64}, {i64, i64}* @stmt_for.26, i32 0, i32 0) to i64))  
  tail call ccc  void  @putchar(i8  10)  
  musttail call fastcc  void  @"stmt_for.using_irange_reverse<0>"()  
  ret void 
}


define external fastcc  void @"stmt_for.gen#1<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %"tmp#5##0", i64  %"tmp#6##0", i64  %"tmp#7##0", i64  %"tmp#8##0", i64  %"tmp#9##0", i64  %"x##0", i64  %"y##0")    {
entry:
  %"1#tmp#13##0" = icmp ne i64 %"tmp#8##0", 0 
  br i1 %"1#tmp#13##0", label %if.then, label %if.else 
if.then:
  %27 = inttoptr i64 %"tmp#8##0" to i64* 
  %28 = getelementptr  i64, i64* %27, i64 0 
  %29 = load  i64, i64* %28 
  %30 = add   i64 %"tmp#8##0", 8 
  %31 = inttoptr i64 %30 to i64* 
  %32 = getelementptr  i64, i64* %31, i64 0 
  %33 = load  i64, i64* %32 
  %"2#tmp#15##0" = icmp ne i64 %"tmp#9##0", 0 
  br i1 %"2#tmp#15##0", label %if.then1, label %if.else1 
if.else:
  ret void 
if.then1:
  %34 = inttoptr i64 %"tmp#9##0" to i64* 
  %35 = getelementptr  i64, i64* %34, i64 0 
  %36 = load  i64, i64* %35 
  %37 = add   i64 %"tmp#9##0", 8 
  %38 = inttoptr i64 %37 to i64* 
  %39 = getelementptr  i64, i64* %38, i64 0 
  %40 = load  i64, i64* %39 
  tail call ccc  void  @print_int(i64  %29)  
  tail call ccc  void  @putchar(i8  10)  
  tail call ccc  void  @print_int(i64  %36)  
  tail call ccc  void  @putchar(i8  10)  
  musttail call fastcc  void  @"stmt_for.gen#1<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %"tmp#5##0", i64  %"tmp#6##0", i64  %"tmp#7##0", i64  %33, i64  %40, i64  %"x##0", i64  %"y##0")  
  ret void 
if.else1:
  ret void 
}


define external fastcc  void @"stmt_for.gen#10<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %"tmp#5##0", i64  %"x##0")    {
entry:
  %"1#tmp#9##0" = icmp ne i64 %"tmp#5##0", 0 
  br i1 %"1#tmp#9##0", label %if.then, label %if.else 
if.then:
  %41 = inttoptr i64 %"tmp#5##0" to i64* 
  %42 = getelementptr  i64, i64* %41, i64 0 
  %43 = load  i64, i64* %42 
  %44 = add   i64 %"tmp#5##0", 8 
  %45 = inttoptr i64 %44 to i64* 
  %46 = getelementptr  i64, i64* %45, i64 0 
  %47 = load  i64, i64* %46 
  %"2#tmp#6##0" = icmp eq i64 %43, 3 
  br i1 %"2#tmp#6##0", label %if.then1, label %if.else1 
if.else:
  ret void 
if.then1:
  ret void 
if.else1:
  tail call ccc  void  @print_int(i64  %43)  
  tail call ccc  void  @putchar(i8  10)  
  musttail call fastcc  void  @"stmt_for.gen#10<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %47, i64  %"x##0")  
  ret void 
}


define external fastcc  void @"stmt_for.gen#11<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %"tmp#5##0", i64  %"x##0")    {
entry:
  %"1#tmp#9##0" = icmp ne i64 %"tmp#5##0", 0 
  br i1 %"1#tmp#9##0", label %if.then, label %if.else 
if.then:
  %48 = inttoptr i64 %"tmp#5##0" to i64* 
  %49 = getelementptr  i64, i64* %48, i64 0 
  %50 = load  i64, i64* %49 
  %51 = add   i64 %"tmp#5##0", 8 
  %52 = inttoptr i64 %51 to i64* 
  %53 = getelementptr  i64, i64* %52, i64 0 
  %54 = load  i64, i64* %53 
  %"2#tmp#6##0" = icmp slt i64 %50, 3 
  br i1 %"2#tmp#6##0", label %if.then1, label %if.else1 
if.else:
  ret void 
if.then1:
  tail call ccc  void  @print_int(i64  %50)  
  tail call ccc  void  @putchar(i8  10)  
  musttail call fastcc  void  @"stmt_for.gen#11<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %54, i64  %"x##0")  
  ret void 
if.else1:
  musttail call fastcc  void  @"stmt_for.gen#11<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %54, i64  %"x##0")  
  ret void 
}


define external fastcc  void @"stmt_for.gen#12<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %"tmp#5##0", i64  %"x##0")    {
entry:
  %"1#tmp#9##0" = icmp ne i64 %"tmp#5##0", 0 
  br i1 %"1#tmp#9##0", label %if.then, label %if.else 
if.then:
  %55 = inttoptr i64 %"tmp#5##0" to i64* 
  %56 = getelementptr  i64, i64* %55, i64 0 
  %57 = load  i64, i64* %56 
  %58 = add   i64 %"tmp#5##0", 8 
  %59 = inttoptr i64 %58 to i64* 
  %60 = getelementptr  i64, i64* %59, i64 0 
  %61 = load  i64, i64* %60 
  %"2#tmp#6##0" = icmp slt i64 %57, 3 
  br i1 %"2#tmp#6##0", label %if.then1, label %if.else1 
if.else:
  ret void 
if.then1:
  tail call ccc  void  @print_int(i64  %57)  
  tail call ccc  void  @putchar(i8  10)  
  musttail call fastcc  void  @"stmt_for.gen#12<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %61, i64  %"x##0")  
  ret void 
if.else1:
  ret void 
}


define external fastcc  void @"stmt_for.gen#13<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0")    {
entry:
  %62 = tail call fastcc  {i64, i64, i1}  @"stmt_for.int_sequence.[|]<0>"(i64  %"tmp#0##0")  
  %63 = extractvalue {i64, i64, i1} %62, 0 
  %64 = extractvalue {i64, i64, i1} %62, 1 
  %65 = extractvalue {i64, i64, i1} %62, 2 
  br i1 %65, label %if.then, label %if.else 
if.then:
  tail call ccc  void  @print_int(i64  %63)  
  tail call ccc  void  @putchar(i8  10)  
  musttail call fastcc  void  @"stmt_for.gen#13<0>"(i64  %64, i64  %"tmp#1##0")  
  ret void 
if.else:
  ret void 
}


define external fastcc  void @"stmt_for.gen#14<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0")    {
entry:
  %66 = tail call fastcc  {i64, i64, i1}  @"stmt_for.int_sequence.[|]<0>"(i64  %"tmp#0##0")  
  %67 = extractvalue {i64, i64, i1} %66, 0 
  %68 = extractvalue {i64, i64, i1} %66, 1 
  %69 = extractvalue {i64, i64, i1} %66, 2 
  br i1 %69, label %if.then, label %if.else 
if.then:
  tail call ccc  void  @print_int(i64  %67)  
  tail call ccc  void  @putchar(i8  10)  
  musttail call fastcc  void  @"stmt_for.gen#14<0>"(i64  %68, i64  %"tmp#1##0")  
  ret void 
if.else:
  ret void 
}


define external fastcc  i1 @"stmt_for.gen#2<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0")    {
entry:
  %70 = tail call fastcc  {i64, i64, i1}  @"stmt_for.int_sequence.[|]<0>"(i64  %"tmp#0##0")  
  %71 = extractvalue {i64, i64, i1} %70, 0 
  %72 = extractvalue {i64, i64, i1} %70, 1 
  %73 = extractvalue {i64, i64, i1} %70, 2 
  br i1 %73, label %if.then, label %if.else 
if.then:
  %"2#tmp#2##0" = icmp slt i64 %71, 5 
  br i1 %"2#tmp#2##0", label %if.then1, label %if.else1 
if.else:
  ret i1 1 
if.then1:
  %"4##success##0" = musttail call fastcc  i1  @"stmt_for.gen#2<0>"(i64  %72, i64  %"tmp#1##0")  
  ret i1 %"4##success##0" 
if.else1:
  ret i1 0 
}


define external fastcc  void @"stmt_for.gen#3<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %"tmp#5##0", i64  %"tmp#6##0", i64  %"tmp#7##0", i64  %"tmp#8##0", i64  %"tmp#9##0", i64  %"x##0", i64  %"y##0")    {
entry:
  %"1#tmp#13##0" = icmp ne i64 %"tmp#8##0", 0 
  br i1 %"1#tmp#13##0", label %if.then, label %if.else 
if.then:
  %74 = inttoptr i64 %"tmp#8##0" to i64* 
  %75 = getelementptr  i64, i64* %74, i64 0 
  %76 = load  i64, i64* %75 
  %77 = add   i64 %"tmp#8##0", 8 
  %78 = inttoptr i64 %77 to i64* 
  %79 = getelementptr  i64, i64* %78, i64 0 
  %80 = load  i64, i64* %79 
  %"2#tmp#15##0" = icmp ne i64 %"tmp#9##0", 0 
  br i1 %"2#tmp#15##0", label %if.then1, label %if.else1 
if.else:
  ret void 
if.then1:
  %81 = inttoptr i64 %"tmp#9##0" to i64* 
  %82 = getelementptr  i64, i64* %81, i64 0 
  %83 = load  i64, i64* %82 
  %84 = add   i64 %"tmp#9##0", 8 
  %85 = inttoptr i64 %84 to i64* 
  %86 = getelementptr  i64, i64* %85, i64 0 
  %87 = load  i64, i64* %86 
  tail call ccc  void  @print_int(i64  %76)  
  tail call ccc  void  @putchar(i8  10)  
  tail call ccc  void  @print_int(i64  %83)  
  tail call ccc  void  @putchar(i8  10)  
  musttail call fastcc  void  @"stmt_for.gen#3<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %"tmp#5##0", i64  %"tmp#6##0", i64  %"tmp#7##0", i64  %80, i64  %87, i64  %"x##0", i64  %"y##0")  
  ret void 
if.else1:
  ret void 
}


define external fastcc  void @"stmt_for.gen#4<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %"x##0")    {
entry:
  %"1#tmp#7##0" = icmp ne i64 %"tmp#4##0", 0 
  br i1 %"1#tmp#7##0", label %if.then, label %if.else 
if.then:
  %88 = inttoptr i64 %"tmp#4##0" to i64* 
  %89 = getelementptr  i64, i64* %88, i64 0 
  %90 = load  i64, i64* %89 
  %91 = add   i64 %"tmp#4##0", 8 
  %92 = inttoptr i64 %91 to i64* 
  %93 = getelementptr  i64, i64* %92, i64 0 
  %94 = load  i64, i64* %93 
  tail call ccc  void  @print_int(i64  %90)  
  tail call ccc  void  @putchar(i8  10)  
  musttail call fastcc  void  @"stmt_for.gen#4<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %94, i64  %"x##0")  
  ret void 
if.else:
  ret void 
}


define external fastcc  void @"stmt_for.gen#5<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %"tmp#5##0", i64  %"x##0")    {
entry:
  %"1#tmp#9##0" = icmp ne i64 %"tmp#5##0", 0 
  br i1 %"1#tmp#9##0", label %if.then, label %if.else 
if.then:
  %95 = inttoptr i64 %"tmp#5##0" to i64* 
  %96 = getelementptr  i64, i64* %95, i64 0 
  %97 = load  i64, i64* %96 
  %98 = add   i64 %"tmp#5##0", 8 
  %99 = inttoptr i64 %98 to i64* 
  %100 = getelementptr  i64, i64* %99, i64 0 
  %101 = load  i64, i64* %100 
  %"2#tmp#6##0" = icmp eq i64 %97, 3 
  br i1 %"2#tmp#6##0", label %if.then1, label %if.else1 
if.else:
  ret void 
if.then1:
  ret void 
if.else1:
  tail call ccc  void  @print_int(i64  %97)  
  tail call ccc  void  @putchar(i8  10)  
  musttail call fastcc  void  @"stmt_for.gen#5<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %101, i64  %"x##0")  
  ret void 
}


define external fastcc  void @"stmt_for.gen#6<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0")    {
entry:
  %102 = tail call fastcc  {i64, i64, i1}  @"stmt_for.int_sequence.[|]<0>"(i64  %"tmp#0##0")  
  %103 = extractvalue {i64, i64, i1} %102, 0 
  %104 = extractvalue {i64, i64, i1} %102, 1 
  %105 = extractvalue {i64, i64, i1} %102, 2 
  br i1 %105, label %if.then, label %if.else 
if.then:
  tail call ccc  void  @print_int(i64  %103)  
  tail call ccc  void  @putchar(i8  10)  
  musttail call fastcc  void  @"stmt_for.gen#6<0>"(i64  %104, i64  %"tmp#1##0")  
  ret void 
if.else:
  ret void 
}


define external fastcc  void @"stmt_for.gen#7<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0")    {
entry:
  %106 = tail call fastcc  {i64, i64, i1}  @"stmt_for.int_sequence.[|]<0>"(i64  %"tmp#0##0")  
  %107 = extractvalue {i64, i64, i1} %106, 0 
  %108 = extractvalue {i64, i64, i1} %106, 1 
  %109 = extractvalue {i64, i64, i1} %106, 2 
  br i1 %109, label %if.then, label %if.else 
if.then:
  tail call ccc  void  @print_int(i64  %107)  
  tail call ccc  void  @putchar(i8  10)  
  musttail call fastcc  void  @"stmt_for.gen#7<0>"(i64  %108, i64  %"tmp#1##0")  
  ret void 
if.else:
  ret void 
}


define external fastcc  void @"stmt_for.gen#8<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %"tmp#5##0", i64  %"x##0")    {
entry:
  %"1#tmp#9##0" = icmp ne i64 %"tmp#5##0", 0 
  br i1 %"1#tmp#9##0", label %if.then, label %if.else 
if.then:
  %110 = inttoptr i64 %"tmp#5##0" to i64* 
  %111 = getelementptr  i64, i64* %110, i64 0 
  %112 = load  i64, i64* %111 
  %113 = add   i64 %"tmp#5##0", 8 
  %114 = inttoptr i64 %113 to i64* 
  %115 = getelementptr  i64, i64* %114, i64 0 
  %116 = load  i64, i64* %115 
  %"2#tmp#6##0" = icmp eq i64 %112, 3 
  br i1 %"2#tmp#6##0", label %if.then1, label %if.else1 
if.else:
  ret void 
if.then1:
  musttail call fastcc  void  @"stmt_for.gen#8<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %116, i64  %"x##0")  
  ret void 
if.else1:
  tail call ccc  void  @print_int(i64  %112)  
  tail call ccc  void  @putchar(i8  10)  
  musttail call fastcc  void  @"stmt_for.gen#8<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %116, i64  %"x##0")  
  ret void 
}


define external fastcc  void @"stmt_for.gen#9<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %"tmp#5##0", i64  %"x##0")    {
entry:
  %"1#tmp#9##0" = icmp ne i64 %"tmp#5##0", 0 
  br i1 %"1#tmp#9##0", label %if.then, label %if.else 
if.then:
  %117 = inttoptr i64 %"tmp#5##0" to i64* 
  %118 = getelementptr  i64, i64* %117, i64 0 
  %119 = load  i64, i64* %118 
  %120 = add   i64 %"tmp#5##0", 8 
  %121 = inttoptr i64 %120 to i64* 
  %122 = getelementptr  i64, i64* %121, i64 0 
  %123 = load  i64, i64* %122 
  %"2#tmp#6##0" = icmp slt i64 %119, 3 
  br i1 %"2#tmp#6##0", label %if.then1, label %if.else1 
if.else:
  ret void 
if.then1:
  musttail call fastcc  void  @"stmt_for.gen#9<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %123, i64  %"x##0")  
  ret void 
if.else1:
  tail call ccc  void  @print_int(i64  %119)  
  tail call ccc  void  @putchar(i8  10)  
  musttail call fastcc  void  @"stmt_for.gen#9<0>"(i64  %"tmp#0##0", i64  %"tmp#1##0", i64  %"tmp#2##0", i64  %"tmp#3##0", i64  %"tmp#4##0", i64  %123, i64  %"x##0")  
  ret void 
}


define external fastcc  i64 @"stmt_for.irange<0>"(i64  %"start##0", i64  %"stride##0", i64  %"end##0")    {
entry:
  %"1#tmp#4##0" = icmp slt i64 %"stride##0", 0 
  br i1 %"1#tmp#4##0", label %if.then, label %if.else 
if.then:
  %"2#tmp#2##0" = sub   i64 %"end##0", 1 
  %124 = trunc i64 24 to i32  
  %125 = tail call ccc  i8*  @wybe_malloc(i32  %124)  
  %126 = ptrtoint i8* %125 to i64 
  %127 = inttoptr i64 %126 to i64* 
  %128 = getelementptr  i64, i64* %127, i64 0 
  store  i64 %"start##0", i64* %128 
  %129 = add   i64 %126, 8 
  %130 = inttoptr i64 %129 to i64* 
  %131 = getelementptr  i64, i64* %130, i64 0 
  store  i64 %"stride##0", i64* %131 
  %132 = add   i64 %126, 16 
  %133 = inttoptr i64 %132 to i64* 
  %134 = getelementptr  i64, i64* %133, i64 0 
  store  i64 %"2#tmp#2##0", i64* %134 
  ret i64 %126 
if.else:
  %"3#tmp#3##0" = add   i64 %"end##0", 1 
  %135 = trunc i64 24 to i32  
  %136 = tail call ccc  i8*  @wybe_malloc(i32  %135)  
  %137 = ptrtoint i8* %136 to i64 
  %138 = inttoptr i64 %137 to i64* 
  %139 = getelementptr  i64, i64* %138, i64 0 
  store  i64 %"start##0", i64* %139 
  %140 = add   i64 %137, 8 
  %141 = inttoptr i64 %140 to i64* 
  %142 = getelementptr  i64, i64* %141, i64 0 
  store  i64 %"stride##0", i64* %142 
  %143 = add   i64 %137, 16 
  %144 = inttoptr i64 %143 to i64* 
  %145 = getelementptr  i64, i64* %144, i64 0 
  store  i64 %"3#tmp#3##0", i64* %145 
  ret i64 %137 
}


define external fastcc  void @"stmt_for.multiple_generator<0>"()    {
entry:
  %146 = trunc i64 16 to i32  
  %147 = tail call ccc  i8*  @wybe_malloc(i32  %146)  
  %148 = ptrtoint i8* %147 to i64 
  %149 = inttoptr i64 %148 to i64* 
  %150 = getelementptr  i64, i64* %149, i64 0 
  store  i64 3, i64* %150 
  %151 = add   i64 %148, 8 
  %152 = inttoptr i64 %151 to i64* 
  %153 = getelementptr  i64, i64* %152, i64 0 
  store  i64 0, i64* %153 
  %154 = trunc i64 16 to i32  
  %155 = tail call ccc  i8*  @wybe_malloc(i32  %154)  
  %156 = ptrtoint i8* %155 to i64 
  %157 = inttoptr i64 %156 to i64* 
  %158 = getelementptr  i64, i64* %157, i64 0 
  store  i64 2, i64* %158 
  %159 = add   i64 %156, 8 
  %160 = inttoptr i64 %159 to i64* 
  %161 = getelementptr  i64, i64* %160, i64 0 
  store  i64 %148, i64* %161 
  %162 = trunc i64 16 to i32  
  %163 = tail call ccc  i8*  @wybe_malloc(i32  %162)  
  %164 = ptrtoint i8* %163 to i64 
  %165 = inttoptr i64 %164 to i64* 
  %166 = getelementptr  i64, i64* %165, i64 0 
  store  i64 1, i64* %166 
  %167 = add   i64 %164, 8 
  %168 = inttoptr i64 %167 to i64* 
  %169 = getelementptr  i64, i64* %168, i64 0 
  store  i64 %156, i64* %169 
  %170 = trunc i64 16 to i32  
  %171 = tail call ccc  i8*  @wybe_malloc(i32  %170)  
  %172 = ptrtoint i8* %171 to i64 
  %173 = inttoptr i64 %172 to i64* 
  %174 = getelementptr  i64, i64* %173, i64 0 
  store  i64 6, i64* %174 
  %175 = add   i64 %172, 8 
  %176 = inttoptr i64 %175 to i64* 
  %177 = getelementptr  i64, i64* %176, i64 0 
  store  i64 0, i64* %177 
  %178 = trunc i64 16 to i32  
  %179 = tail call ccc  i8*  @wybe_malloc(i32  %178)  
  %180 = ptrtoint i8* %179 to i64 
  %181 = inttoptr i64 %180 to i64* 
  %182 = getelementptr  i64, i64* %181, i64 0 
  store  i64 5, i64* %182 
  %183 = add   i64 %180, 8 
  %184 = inttoptr i64 %183 to i64* 
  %185 = getelementptr  i64, i64* %184, i64 0 
  store  i64 %172, i64* %185 
  %186 = trunc i64 16 to i32  
  %187 = tail call ccc  i8*  @wybe_malloc(i32  %186)  
  %188 = ptrtoint i8* %187 to i64 
  %189 = inttoptr i64 %188 to i64* 
  %190 = getelementptr  i64, i64* %189, i64 0 
  store  i64 4, i64* %190 
  %191 = add   i64 %188, 8 
  %192 = inttoptr i64 %191 to i64* 
  %193 = getelementptr  i64, i64* %192, i64 0 
  store  i64 %180, i64* %193 
  tail call fastcc  void  @"stmt_for.gen#1<0>"(i64  %164, i64  %156, i64  %148, i64  0, i64  %188, i64  %180, i64  %172, i64  0, i64  %164, i64  %188, i64  %164, i64  %188)  
  ret void 
}


define external fastcc  i1 @"stmt_for.semi_det_for_loop<0>"()    {
entry:
  %"1#tmp#1##0" = tail call fastcc  i64  @"stmt_for.xrange<0>"(i64  0, i64  1, i64  10)  
  %"1##success##0" = tail call fastcc  i1  @"stmt_for.gen#2<0>"(i64  %"1#tmp#1##0", i64  %"1#tmp#1##0")  
  ret i1 %"1##success##0" 
}


define external fastcc  void @"stmt_for.shortest_generator_termination<0>"()    {
entry:
  %194 = trunc i64 16 to i32  
  %195 = tail call ccc  i8*  @wybe_malloc(i32  %194)  
  %196 = ptrtoint i8* %195 to i64 
  %197 = inttoptr i64 %196 to i64* 
  %198 = getelementptr  i64, i64* %197, i64 0 
  store  i64 4, i64* %198 
  %199 = add   i64 %196, 8 
  %200 = inttoptr i64 %199 to i64* 
  %201 = getelementptr  i64, i64* %200, i64 0 
  store  i64 0, i64* %201 
  %202 = trunc i64 16 to i32  
  %203 = tail call ccc  i8*  @wybe_malloc(i32  %202)  
  %204 = ptrtoint i8* %203 to i64 
  %205 = inttoptr i64 %204 to i64* 
  %206 = getelementptr  i64, i64* %205, i64 0 
  store  i64 3, i64* %206 
  %207 = add   i64 %204, 8 
  %208 = inttoptr i64 %207 to i64* 
  %209 = getelementptr  i64, i64* %208, i64 0 
  store  i64 %196, i64* %209 
  %210 = trunc i64 16 to i32  
  %211 = tail call ccc  i8*  @wybe_malloc(i32  %210)  
  %212 = ptrtoint i8* %211 to i64 
  %213 = inttoptr i64 %212 to i64* 
  %214 = getelementptr  i64, i64* %213, i64 0 
  store  i64 2, i64* %214 
  %215 = add   i64 %212, 8 
  %216 = inttoptr i64 %215 to i64* 
  %217 = getelementptr  i64, i64* %216, i64 0 
  store  i64 %204, i64* %217 
  %218 = trunc i64 16 to i32  
  %219 = tail call ccc  i8*  @wybe_malloc(i32  %218)  
  %220 = ptrtoint i8* %219 to i64 
  %221 = inttoptr i64 %220 to i64* 
  %222 = getelementptr  i64, i64* %221, i64 0 
  store  i64 1, i64* %222 
  %223 = add   i64 %220, 8 
  %224 = inttoptr i64 %223 to i64* 
  %225 = getelementptr  i64, i64* %224, i64 0 
  store  i64 %212, i64* %225 
  %226 = trunc i64 16 to i32  
  %227 = tail call ccc  i8*  @wybe_malloc(i32  %226)  
  %228 = ptrtoint i8* %227 to i64 
  %229 = inttoptr i64 %228 to i64* 
  %230 = getelementptr  i64, i64* %229, i64 0 
  store  i64 5, i64* %230 
  %231 = add   i64 %228, 8 
  %232 = inttoptr i64 %231 to i64* 
  %233 = getelementptr  i64, i64* %232, i64 0 
  store  i64 0, i64* %233 
  %234 = trunc i64 16 to i32  
  %235 = tail call ccc  i8*  @wybe_malloc(i32  %234)  
  %236 = ptrtoint i8* %235 to i64 
  %237 = inttoptr i64 %236 to i64* 
  %238 = getelementptr  i64, i64* %237, i64 0 
  store  i64 4, i64* %238 
  %239 = add   i64 %236, 8 
  %240 = inttoptr i64 %239 to i64* 
  %241 = getelementptr  i64, i64* %240, i64 0 
  store  i64 %228, i64* %241 
  tail call fastcc  void  @"stmt_for.gen#3<0>"(i64  %220, i64  %212, i64  %204, i64  %196, i64  0, i64  %236, i64  %228, i64  0, i64  %220, i64  %236, i64  %220, i64  %236)  
  ret void 
}


define external fastcc  void @"stmt_for.single_generator<0>"()    {
entry:
  %242 = trunc i64 16 to i32  
  %243 = tail call ccc  i8*  @wybe_malloc(i32  %242)  
  %244 = ptrtoint i8* %243 to i64 
  %245 = inttoptr i64 %244 to i64* 
  %246 = getelementptr  i64, i64* %245, i64 0 
  store  i64 3, i64* %246 
  %247 = add   i64 %244, 8 
  %248 = inttoptr i64 %247 to i64* 
  %249 = getelementptr  i64, i64* %248, i64 0 
  store  i64 0, i64* %249 
  %250 = trunc i64 16 to i32  
  %251 = tail call ccc  i8*  @wybe_malloc(i32  %250)  
  %252 = ptrtoint i8* %251 to i64 
  %253 = inttoptr i64 %252 to i64* 
  %254 = getelementptr  i64, i64* %253, i64 0 
  store  i64 2, i64* %254 
  %255 = add   i64 %252, 8 
  %256 = inttoptr i64 %255 to i64* 
  %257 = getelementptr  i64, i64* %256, i64 0 
  store  i64 %244, i64* %257 
  %258 = trunc i64 16 to i32  
  %259 = tail call ccc  i8*  @wybe_malloc(i32  %258)  
  %260 = ptrtoint i8* %259 to i64 
  %261 = inttoptr i64 %260 to i64* 
  %262 = getelementptr  i64, i64* %261, i64 0 
  store  i64 1, i64* %262 
  %263 = add   i64 %260, 8 
  %264 = inttoptr i64 %263 to i64* 
  %265 = getelementptr  i64, i64* %264, i64 0 
  store  i64 %252, i64* %265 
  tail call fastcc  void  @"stmt_for.gen#4<0>"(i64  %260, i64  %252, i64  %244, i64  0, i64  %260, i64  %260)  
  ret void 
}


define external fastcc  void @"stmt_for.using_break<0>"()    {
entry:
  %266 = trunc i64 16 to i32  
  %267 = tail call ccc  i8*  @wybe_malloc(i32  %266)  
  %268 = ptrtoint i8* %267 to i64 
  %269 = inttoptr i64 %268 to i64* 
  %270 = getelementptr  i64, i64* %269, i64 0 
  store  i64 4, i64* %270 
  %271 = add   i64 %268, 8 
  %272 = inttoptr i64 %271 to i64* 
  %273 = getelementptr  i64, i64* %272, i64 0 
  store  i64 0, i64* %273 
  %274 = trunc i64 16 to i32  
  %275 = tail call ccc  i8*  @wybe_malloc(i32  %274)  
  %276 = ptrtoint i8* %275 to i64 
  %277 = inttoptr i64 %276 to i64* 
  %278 = getelementptr  i64, i64* %277, i64 0 
  store  i64 3, i64* %278 
  %279 = add   i64 %276, 8 
  %280 = inttoptr i64 %279 to i64* 
  %281 = getelementptr  i64, i64* %280, i64 0 
  store  i64 %268, i64* %281 
  %282 = trunc i64 16 to i32  
  %283 = tail call ccc  i8*  @wybe_malloc(i32  %282)  
  %284 = ptrtoint i8* %283 to i64 
  %285 = inttoptr i64 %284 to i64* 
  %286 = getelementptr  i64, i64* %285, i64 0 
  store  i64 2, i64* %286 
  %287 = add   i64 %284, 8 
  %288 = inttoptr i64 %287 to i64* 
  %289 = getelementptr  i64, i64* %288, i64 0 
  store  i64 %276, i64* %289 
  %290 = trunc i64 16 to i32  
  %291 = tail call ccc  i8*  @wybe_malloc(i32  %290)  
  %292 = ptrtoint i8* %291 to i64 
  %293 = inttoptr i64 %292 to i64* 
  %294 = getelementptr  i64, i64* %293, i64 0 
  store  i64 1, i64* %294 
  %295 = add   i64 %292, 8 
  %296 = inttoptr i64 %295 to i64* 
  %297 = getelementptr  i64, i64* %296, i64 0 
  store  i64 %284, i64* %297 
  tail call fastcc  void  @"stmt_for.gen#5<0>"(i64  %292, i64  %284, i64  %276, i64  %268, i64  0, i64  %292, i64  %292)  
  ret void 
}


define external fastcc  void @"stmt_for.using_irange<0>"()    {
entry:
  %"1#tmp#1##0" = tail call fastcc  i64  @"stmt_for.irange<0>"(i64  1, i64  1, i64  10)  
  tail call fastcc  void  @"stmt_for.gen#6<0>"(i64  %"1#tmp#1##0", i64  %"1#tmp#1##0")  
  ret void 
}


define external fastcc  void @"stmt_for.using_irange_reverse<0>"()    {
entry:
  %"1#tmp#1##0" = tail call fastcc  i64  @"stmt_for.irange<0>"(i64  10, i64  -1, i64  1)  
  tail call fastcc  void  @"stmt_for.gen#7<0>"(i64  %"1#tmp#1##0", i64  %"1#tmp#1##0")  
  ret void 
}


define external fastcc  void @"stmt_for.using_next<0>"()    {
entry:
  %298 = trunc i64 16 to i32  
  %299 = tail call ccc  i8*  @wybe_malloc(i32  %298)  
  %300 = ptrtoint i8* %299 to i64 
  %301 = inttoptr i64 %300 to i64* 
  %302 = getelementptr  i64, i64* %301, i64 0 
  store  i64 4, i64* %302 
  %303 = add   i64 %300, 8 
  %304 = inttoptr i64 %303 to i64* 
  %305 = getelementptr  i64, i64* %304, i64 0 
  store  i64 0, i64* %305 
  %306 = trunc i64 16 to i32  
  %307 = tail call ccc  i8*  @wybe_malloc(i32  %306)  
  %308 = ptrtoint i8* %307 to i64 
  %309 = inttoptr i64 %308 to i64* 
  %310 = getelementptr  i64, i64* %309, i64 0 
  store  i64 3, i64* %310 
  %311 = add   i64 %308, 8 
  %312 = inttoptr i64 %311 to i64* 
  %313 = getelementptr  i64, i64* %312, i64 0 
  store  i64 %300, i64* %313 
  %314 = trunc i64 16 to i32  
  %315 = tail call ccc  i8*  @wybe_malloc(i32  %314)  
  %316 = ptrtoint i8* %315 to i64 
  %317 = inttoptr i64 %316 to i64* 
  %318 = getelementptr  i64, i64* %317, i64 0 
  store  i64 2, i64* %318 
  %319 = add   i64 %316, 8 
  %320 = inttoptr i64 %319 to i64* 
  %321 = getelementptr  i64, i64* %320, i64 0 
  store  i64 %308, i64* %321 
  %322 = trunc i64 16 to i32  
  %323 = tail call ccc  i8*  @wybe_malloc(i32  %322)  
  %324 = ptrtoint i8* %323 to i64 
  %325 = inttoptr i64 %324 to i64* 
  %326 = getelementptr  i64, i64* %325, i64 0 
  store  i64 1, i64* %326 
  %327 = add   i64 %324, 8 
  %328 = inttoptr i64 %327 to i64* 
  %329 = getelementptr  i64, i64* %328, i64 0 
  store  i64 %316, i64* %329 
  tail call fastcc  void  @"stmt_for.gen#8<0>"(i64  %324, i64  %316, i64  %308, i64  %300, i64  0, i64  %324, i64  %324)  
  ret void 
}


define external fastcc  void @"stmt_for.using_unless<0>"()    {
entry:
  %330 = trunc i64 16 to i32  
  %331 = tail call ccc  i8*  @wybe_malloc(i32  %330)  
  %332 = ptrtoint i8* %331 to i64 
  %333 = inttoptr i64 %332 to i64* 
  %334 = getelementptr  i64, i64* %333, i64 0 
  store  i64 4, i64* %334 
  %335 = add   i64 %332, 8 
  %336 = inttoptr i64 %335 to i64* 
  %337 = getelementptr  i64, i64* %336, i64 0 
  store  i64 0, i64* %337 
  %338 = trunc i64 16 to i32  
  %339 = tail call ccc  i8*  @wybe_malloc(i32  %338)  
  %340 = ptrtoint i8* %339 to i64 
  %341 = inttoptr i64 %340 to i64* 
  %342 = getelementptr  i64, i64* %341, i64 0 
  store  i64 3, i64* %342 
  %343 = add   i64 %340, 8 
  %344 = inttoptr i64 %343 to i64* 
  %345 = getelementptr  i64, i64* %344, i64 0 
  store  i64 %332, i64* %345 
  %346 = trunc i64 16 to i32  
  %347 = tail call ccc  i8*  @wybe_malloc(i32  %346)  
  %348 = ptrtoint i8* %347 to i64 
  %349 = inttoptr i64 %348 to i64* 
  %350 = getelementptr  i64, i64* %349, i64 0 
  store  i64 2, i64* %350 
  %351 = add   i64 %348, 8 
  %352 = inttoptr i64 %351 to i64* 
  %353 = getelementptr  i64, i64* %352, i64 0 
  store  i64 %340, i64* %353 
  %354 = trunc i64 16 to i32  
  %355 = tail call ccc  i8*  @wybe_malloc(i32  %354)  
  %356 = ptrtoint i8* %355 to i64 
  %357 = inttoptr i64 %356 to i64* 
  %358 = getelementptr  i64, i64* %357, i64 0 
  store  i64 1, i64* %358 
  %359 = add   i64 %356, 8 
  %360 = inttoptr i64 %359 to i64* 
  %361 = getelementptr  i64, i64* %360, i64 0 
  store  i64 %348, i64* %361 
  tail call fastcc  void  @"stmt_for.gen#9<0>"(i64  %356, i64  %348, i64  %340, i64  %332, i64  0, i64  %356, i64  %356)  
  ret void 
}


define external fastcc  void @"stmt_for.using_until<0>"()    {
entry:
  %362 = trunc i64 16 to i32  
  %363 = tail call ccc  i8*  @wybe_malloc(i32  %362)  
  %364 = ptrtoint i8* %363 to i64 
  %365 = inttoptr i64 %364 to i64* 
  %366 = getelementptr  i64, i64* %365, i64 0 
  store  i64 4, i64* %366 
  %367 = add   i64 %364, 8 
  %368 = inttoptr i64 %367 to i64* 
  %369 = getelementptr  i64, i64* %368, i64 0 
  store  i64 0, i64* %369 
  %370 = trunc i64 16 to i32  
  %371 = tail call ccc  i8*  @wybe_malloc(i32  %370)  
  %372 = ptrtoint i8* %371 to i64 
  %373 = inttoptr i64 %372 to i64* 
  %374 = getelementptr  i64, i64* %373, i64 0 
  store  i64 3, i64* %374 
  %375 = add   i64 %372, 8 
  %376 = inttoptr i64 %375 to i64* 
  %377 = getelementptr  i64, i64* %376, i64 0 
  store  i64 %364, i64* %377 
  %378 = trunc i64 16 to i32  
  %379 = tail call ccc  i8*  @wybe_malloc(i32  %378)  
  %380 = ptrtoint i8* %379 to i64 
  %381 = inttoptr i64 %380 to i64* 
  %382 = getelementptr  i64, i64* %381, i64 0 
  store  i64 2, i64* %382 
  %383 = add   i64 %380, 8 
  %384 = inttoptr i64 %383 to i64* 
  %385 = getelementptr  i64, i64* %384, i64 0 
  store  i64 %372, i64* %385 
  %386 = trunc i64 16 to i32  
  %387 = tail call ccc  i8*  @wybe_malloc(i32  %386)  
  %388 = ptrtoint i8* %387 to i64 
  %389 = inttoptr i64 %388 to i64* 
  %390 = getelementptr  i64, i64* %389, i64 0 
  store  i64 1, i64* %390 
  %391 = add   i64 %388, 8 
  %392 = inttoptr i64 %391 to i64* 
  %393 = getelementptr  i64, i64* %392, i64 0 
  store  i64 %380, i64* %393 
  tail call fastcc  void  @"stmt_for.gen#10<0>"(i64  %388, i64  %380, i64  %372, i64  %364, i64  0, i64  %388, i64  %388)  
  ret void 
}


define external fastcc  void @"stmt_for.using_when<0>"()    {
entry:
  %394 = trunc i64 16 to i32  
  %395 = tail call ccc  i8*  @wybe_malloc(i32  %394)  
  %396 = ptrtoint i8* %395 to i64 
  %397 = inttoptr i64 %396 to i64* 
  %398 = getelementptr  i64, i64* %397, i64 0 
  store  i64 4, i64* %398 
  %399 = add   i64 %396, 8 
  %400 = inttoptr i64 %399 to i64* 
  %401 = getelementptr  i64, i64* %400, i64 0 
  store  i64 0, i64* %401 
  %402 = trunc i64 16 to i32  
  %403 = tail call ccc  i8*  @wybe_malloc(i32  %402)  
  %404 = ptrtoint i8* %403 to i64 
  %405 = inttoptr i64 %404 to i64* 
  %406 = getelementptr  i64, i64* %405, i64 0 
  store  i64 3, i64* %406 
  %407 = add   i64 %404, 8 
  %408 = inttoptr i64 %407 to i64* 
  %409 = getelementptr  i64, i64* %408, i64 0 
  store  i64 %396, i64* %409 
  %410 = trunc i64 16 to i32  
  %411 = tail call ccc  i8*  @wybe_malloc(i32  %410)  
  %412 = ptrtoint i8* %411 to i64 
  %413 = inttoptr i64 %412 to i64* 
  %414 = getelementptr  i64, i64* %413, i64 0 
  store  i64 2, i64* %414 
  %415 = add   i64 %412, 8 
  %416 = inttoptr i64 %415 to i64* 
  %417 = getelementptr  i64, i64* %416, i64 0 
  store  i64 %404, i64* %417 
  %418 = trunc i64 16 to i32  
  %419 = tail call ccc  i8*  @wybe_malloc(i32  %418)  
  %420 = ptrtoint i8* %419 to i64 
  %421 = inttoptr i64 %420 to i64* 
  %422 = getelementptr  i64, i64* %421, i64 0 
  store  i64 1, i64* %422 
  %423 = add   i64 %420, 8 
  %424 = inttoptr i64 %423 to i64* 
  %425 = getelementptr  i64, i64* %424, i64 0 
  store  i64 %412, i64* %425 
  tail call fastcc  void  @"stmt_for.gen#11<0>"(i64  %420, i64  %412, i64  %404, i64  %396, i64  0, i64  %420, i64  %420)  
  ret void 
}


define external fastcc  void @"stmt_for.using_while<0>"()    {
entry:
  %426 = trunc i64 16 to i32  
  %427 = tail call ccc  i8*  @wybe_malloc(i32  %426)  
  %428 = ptrtoint i8* %427 to i64 
  %429 = inttoptr i64 %428 to i64* 
  %430 = getelementptr  i64, i64* %429, i64 0 
  store  i64 4, i64* %430 
  %431 = add   i64 %428, 8 
  %432 = inttoptr i64 %431 to i64* 
  %433 = getelementptr  i64, i64* %432, i64 0 
  store  i64 0, i64* %433 
  %434 = trunc i64 16 to i32  
  %435 = tail call ccc  i8*  @wybe_malloc(i32  %434)  
  %436 = ptrtoint i8* %435 to i64 
  %437 = inttoptr i64 %436 to i64* 
  %438 = getelementptr  i64, i64* %437, i64 0 
  store  i64 3, i64* %438 
  %439 = add   i64 %436, 8 
  %440 = inttoptr i64 %439 to i64* 
  %441 = getelementptr  i64, i64* %440, i64 0 
  store  i64 %428, i64* %441 
  %442 = trunc i64 16 to i32  
  %443 = tail call ccc  i8*  @wybe_malloc(i32  %442)  
  %444 = ptrtoint i8* %443 to i64 
  %445 = inttoptr i64 %444 to i64* 
  %446 = getelementptr  i64, i64* %445, i64 0 
  store  i64 2, i64* %446 
  %447 = add   i64 %444, 8 
  %448 = inttoptr i64 %447 to i64* 
  %449 = getelementptr  i64, i64* %448, i64 0 
  store  i64 %436, i64* %449 
  %450 = trunc i64 16 to i32  
  %451 = tail call ccc  i8*  @wybe_malloc(i32  %450)  
  %452 = ptrtoint i8* %451 to i64 
  %453 = inttoptr i64 %452 to i64* 
  %454 = getelementptr  i64, i64* %453, i64 0 
  store  i64 1, i64* %454 
  %455 = add   i64 %452, 8 
  %456 = inttoptr i64 %455 to i64* 
  %457 = getelementptr  i64, i64* %456, i64 0 
  store  i64 %444, i64* %457 
  tail call fastcc  void  @"stmt_for.gen#12<0>"(i64  %452, i64  %444, i64  %436, i64  %428, i64  0, i64  %452, i64  %452)  
  ret void 
}


define external fastcc  void @"stmt_for.using_xrange<0>"()    {
entry:
  %"1#tmp#1##0" = tail call fastcc  i64  @"stmt_for.xrange<0>"(i64  1, i64  1, i64  10)  
  tail call fastcc  void  @"stmt_for.gen#13<0>"(i64  %"1#tmp#1##0", i64  %"1#tmp#1##0")  
  ret void 
}


define external fastcc  void @"stmt_for.using_xrange_reverse<0>"()    {
entry:
  %"1#tmp#1##0" = tail call fastcc  i64  @"stmt_for.xrange<0>"(i64  10, i64  -1, i64  1)  
  tail call fastcc  void  @"stmt_for.gen#14<0>"(i64  %"1#tmp#1##0", i64  %"1#tmp#1##0")  
  ret void 
}


define external fastcc  i64 @"stmt_for.xrange<0>"(i64  %"start##0", i64  %"stride##0", i64  %"end##0")    {
entry:
  %458 = trunc i64 24 to i32  
  %459 = tail call ccc  i8*  @wybe_malloc(i32  %458)  
  %460 = ptrtoint i8* %459 to i64 
  %461 = inttoptr i64 %460 to i64* 
  %462 = getelementptr  i64, i64* %461, i64 0 
  store  i64 %"start##0", i64* %462 
  %463 = add   i64 %460, 8 
  %464 = inttoptr i64 %463 to i64* 
  %465 = getelementptr  i64, i64* %464, i64 0 
  store  i64 %"stride##0", i64* %465 
  %466 = add   i64 %460, 16 
  %467 = inttoptr i64 %466 to i64* 
  %468 = getelementptr  i64, i64* %467, i64 0 
  store  i64 %"end##0", i64* %468 
  ret i64 %460 
}
--------------------------------------------------
 Module stmt_for.int_sequence
  representation  : address
  public submods  : 
  public resources: 
  public procs    : stmt_for.int_sequence.=<0>
                    stmt_for.int_sequence.[|]<0>
                    stmt_for.int_sequence.end<0>
                    stmt_for.int_sequence.end<1>
                    stmt_for.int_sequence.int_sequence<0>
                    stmt_for.int_sequence.int_sequence<1>
                    stmt_for.int_sequence.start<0>
                    stmt_for.int_sequence.start<1>
                    stmt_for.int_sequence.stride<0>
                    stmt_for.int_sequence.stride<1>
                    stmt_for.int_sequence.~=<0>
  imports         : use stmt_for
                    use wybe
  resources       : 
  procs           : 

= > public {inline} (1 calls)
0: stmt_for.int_sequence.=<0>
=(#left##0:stmt_for.int_sequence, #right##0:stmt_for.int_sequence, ?#success##0:wybe.bool)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(#left##0:stmt_for.int_sequence, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?#left#start##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm access(#left##0:stmt_for.int_sequence, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?#left#stride##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm access(~#left##0:stmt_for.int_sequence, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?#left#end##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm access(#right##0:stmt_for.int_sequence, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?#right#start##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm access(#right##0:stmt_for.int_sequence, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?#right#stride##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm access(~#right##0:stmt_for.int_sequence, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?#right#end##0:wybe.int) @stmt_for:nn:nn
    foreign llvm icmp_eq(~#left#start##0:wybe.int, ~#right#start##0:wybe.int, ?tmp#1##0:wybe.bool) @int:nn:nn
    case ~tmp#1##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)

    1:
        foreign llvm icmp_eq(~#left#stride##0:wybe.int, ~#right#stride##0:wybe.int, ?tmp#2##0:wybe.bool) @int:nn:nn
        case ~tmp#2##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)

        1:
            foreign llvm icmp_eq(~#left#end##0:wybe.int, ~#right#end##0:wybe.int, ?#success##0:wybe.bool) @int:nn:nn




[|] > public (0 calls)
0: stmt_for.int_sequence.[|]<0>
[|](?value##0:wybe.int, ?rest##0:stmt_for.int_sequence, current##0:stmt_for.int_sequence, ?#success##0:wybe.bool)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(current##0:stmt_for.int_sequence, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?s##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm access(current##0:stmt_for.int_sequence, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?st##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm access(~current##0:stmt_for.int_sequence, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?en##0:wybe.int) @stmt_for:nn:nn
    foreign llvm icmp_slt(st##0:wybe.int, 0:wybe.int, ?tmp#4##0:wybe.bool) @int:nn:nn
    case ~tmp#4##0:wybe.bool of
    0:
        foreign llvm icmp_sgt(en##0:wybe.int, s##0:wybe.int, ?tmp#3##0:wybe.bool) @int:nn:nn
        case ~tmp#3##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?value##0:wybe.int)
            foreign llvm move(undef:stmt_for.int_sequence, ?rest##0:stmt_for.int_sequence)

        1:
            stmt_for.int_sequence.gen#1<0>(_:stmt_for.int_sequence, ~en##0:wybe.int, ~s##0:wybe.int, ~st##0:wybe.int, ?value##0:wybe.int, ?rest##0:stmt_for.int_sequence, ?#success##0:wybe.bool) #5


    1:
        foreign llvm icmp_slt(en##0:wybe.int, s##0:wybe.int, ?tmp#2##0:wybe.bool) @int:nn:nn
        case ~tmp#2##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?#success##0:wybe.bool)
            foreign llvm move(undef:wybe.int, ?value##0:wybe.int)
            foreign llvm move(undef:stmt_for.int_sequence, ?rest##0:stmt_for.int_sequence)

        1:
            stmt_for.int_sequence.gen#1<0>(_:stmt_for.int_sequence, ~en##0:wybe.int, ~s##0:wybe.int, ~st##0:wybe.int, ?value##0:wybe.int, ?rest##0:stmt_for.int_sequence, ?#success##0:wybe.bool) #3




end > public {inline} (0 calls)
0: stmt_for.int_sequence.end<0>
end(#rec##0:stmt_for.int_sequence, ?#result##0:wybe.int)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(~#rec##0:stmt_for.int_sequence, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?#result##0:wybe.int) @stmt_for:nn:nn
end > public {inline} (0 calls)
1: stmt_for.int_sequence.end<1>
end(#rec##0:stmt_for.int_sequence, ?#rec##1:stmt_for.int_sequence, #field##0:wybe.int)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm {noalias} mutate(~#rec##0:stmt_for.int_sequence, ?#rec##1:stmt_for.int_sequence, 16:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, ~#field##0:wybe.int) @stmt_for:nn:nn


gen#1 > (2 calls)
0: stmt_for.int_sequence.gen#1<0>
gen#1([current##0:stmt_for.int_sequence], en##0:wybe.int, s##0:wybe.int, st##0:wybe.int, ?value##0:wybe.int, ?rest##0:stmt_for.int_sequence, ?#success##0:wybe.bool)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign llvm move(s##0:wybe.int, ?value##0:wybe.int) @stmt_for:nn:nn
    foreign llvm add(~s##0:wybe.int, st##0:wybe.int, ?tmp#1##0:wybe.int) @int:nn:nn
    foreign lpvm alloc(24:wybe.int, ?tmp#7##0:stmt_for.int_sequence) @stmt_for:nn:nn
    foreign lpvm mutate(~tmp#7##0:stmt_for.int_sequence, ?tmp#8##0:stmt_for.int_sequence, 0:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~tmp#1##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm mutate(~tmp#8##0:stmt_for.int_sequence, ?tmp#9##0:stmt_for.int_sequence, 8:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~st##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm mutate(~tmp#9##0:stmt_for.int_sequence, ?rest##0:stmt_for.int_sequence, 16:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~en##0:wybe.int) @stmt_for:nn:nn
    foreign llvm move(1:wybe.bool, ?#success##0:wybe.bool)


int_sequence > public {inline} (1 calls)
0: stmt_for.int_sequence.int_sequence<0>
int_sequence(start##0:wybe.int, stride##0:wybe.int, end##0:wybe.int, ?#result##0:stmt_for.int_sequence)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm alloc(24:wybe.int, ?#rec##0:stmt_for.int_sequence) @stmt_for:nn:nn
    foreign lpvm mutate(~#rec##0:stmt_for.int_sequence, ?#rec##1:stmt_for.int_sequence, 0:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~start##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm mutate(~#rec##1:stmt_for.int_sequence, ?#rec##2:stmt_for.int_sequence, 8:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~stride##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm mutate(~#rec##2:stmt_for.int_sequence, ?#result##0:stmt_for.int_sequence, 16:wybe.int, 1:wybe.int, 24:wybe.int, 0:wybe.int, ~end##0:wybe.int) @stmt_for:nn:nn
int_sequence > public {inline} (16 calls)
1: stmt_for.int_sequence.int_sequence<1>
int_sequence(?start##0:wybe.int, ?stride##0:wybe.int, ?end##0:wybe.int, #result##0:stmt_for.int_sequence)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(#result##0:stmt_for.int_sequence, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?start##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm access(#result##0:stmt_for.int_sequence, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?stride##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm access(~#result##0:stmt_for.int_sequence, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?end##0:wybe.int) @stmt_for:nn:nn


start > public {inline} (0 calls)
0: stmt_for.int_sequence.start<0>
start(#rec##0:stmt_for.int_sequence, ?#result##0:wybe.int)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(~#rec##0:stmt_for.int_sequence, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?#result##0:wybe.int) @stmt_for:nn:nn
start > public {inline} (0 calls)
1: stmt_for.int_sequence.start<1>
start(#rec##0:stmt_for.int_sequence, ?#rec##1:stmt_for.int_sequence, #field##0:wybe.int)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm {noalias} mutate(~#rec##0:stmt_for.int_sequence, ?#rec##1:stmt_for.int_sequence, 0:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, ~#field##0:wybe.int) @stmt_for:nn:nn


stride > public {inline} (0 calls)
0: stmt_for.int_sequence.stride<0>
stride(#rec##0:stmt_for.int_sequence, ?#result##0:wybe.int)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(~#rec##0:stmt_for.int_sequence, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?#result##0:wybe.int) @stmt_for:nn:nn
stride > public {inline} (0 calls)
1: stmt_for.int_sequence.stride<1>
stride(#rec##0:stmt_for.int_sequence, ?#rec##1:stmt_for.int_sequence, #field##0:wybe.int)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm {noalias} mutate(~#rec##0:stmt_for.int_sequence, ?#rec##1:stmt_for.int_sequence, 8:wybe.int, 0:wybe.int, 24:wybe.int, 0:wybe.int, ~#field##0:wybe.int) @stmt_for:nn:nn


~= > public {inline} (0 calls)
0: stmt_for.int_sequence.~=<0>
~=(#left##0:stmt_for.int_sequence, #right##0:stmt_for.int_sequence, ?#success##0:wybe.bool)<{}; {}>:
  AliasPairs: []
  InterestingCallProperties: []
    foreign lpvm access(#left##0:stmt_for.int_sequence, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?tmp#3##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm access(#left##0:stmt_for.int_sequence, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?tmp#4##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm access(~#left##0:stmt_for.int_sequence, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?tmp#5##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm access(#right##0:stmt_for.int_sequence, 0:wybe.int, 24:wybe.int, 0:wybe.int, ?tmp#6##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm access(#right##0:stmt_for.int_sequence, 8:wybe.int, 24:wybe.int, 0:wybe.int, ?tmp#7##0:wybe.int) @stmt_for:nn:nn
    foreign lpvm access(~#right##0:stmt_for.int_sequence, 16:wybe.int, 24:wybe.int, 0:wybe.int, ?tmp#8##0:wybe.int) @stmt_for:nn:nn
    foreign llvm icmp_eq(~tmp#3##0:wybe.int, ~tmp#6##0:wybe.int, ?tmp#9##0:wybe.bool) @int:nn:nn
    case ~tmp#9##0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?tmp#0##0:wybe.bool)
        foreign llvm xor(~tmp#0##0:wybe.bool, 1:wybe.bool, ?#success##0:wybe.bool)

    1:
        foreign llvm icmp_eq(~tmp#4##0:wybe.int, ~tmp#7##0:wybe.int, ?tmp#10##0:wybe.bool) @int:nn:nn
        case ~tmp#10##0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?tmp#0##0:wybe.bool)
            foreign llvm xor(~tmp#0##0:wybe.bool, 1:wybe.bool, ?#success##0:wybe.bool)

        1:
            foreign llvm icmp_eq(~tmp#5##0:wybe.int, ~tmp#8##0:wybe.int, ?tmp#0##0:wybe.bool) @int:nn:nn
            foreign llvm xor(~tmp#0##0:wybe.bool, 1:wybe.bool, ?#success##0:wybe.bool)



  LLVM code       :

; ModuleID = 'stmt_for.int_sequence'


 


declare external ccc  i8* @wybe_malloc(i32)    


declare external ccc  void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i1)    


define external fastcc  i1 @"stmt_for.int_sequence.=<0>"(i64  %"#left##0", i64  %"#right##0")    {
entry:
  %1 = inttoptr i64 %"#left##0" to i64* 
  %2 = getelementptr  i64, i64* %1, i64 0 
  %3 = load  i64, i64* %2 
  %4 = add   i64 %"#left##0", 8 
  %5 = inttoptr i64 %4 to i64* 
  %6 = getelementptr  i64, i64* %5, i64 0 
  %7 = load  i64, i64* %6 
  %8 = add   i64 %"#left##0", 16 
  %9 = inttoptr i64 %8 to i64* 
  %10 = getelementptr  i64, i64* %9, i64 0 
  %11 = load  i64, i64* %10 
  %12 = inttoptr i64 %"#right##0" to i64* 
  %13 = getelementptr  i64, i64* %12, i64 0 
  %14 = load  i64, i64* %13 
  %15 = add   i64 %"#right##0", 8 
  %16 = inttoptr i64 %15 to i64* 
  %17 = getelementptr  i64, i64* %16, i64 0 
  %18 = load  i64, i64* %17 
  %19 = add   i64 %"#right##0", 16 
  %20 = inttoptr i64 %19 to i64* 
  %21 = getelementptr  i64, i64* %20, i64 0 
  %22 = load  i64, i64* %21 
  %"1#tmp#1##0" = icmp eq i64 %3, %14 
  br i1 %"1#tmp#1##0", label %if.then, label %if.else 
if.then:
  %"2#tmp#2##0" = icmp eq i64 %7, %18 
  br i1 %"2#tmp#2##0", label %if.then1, label %if.else1 
if.else:
  ret i1 0 
if.then1:
  %"4##success##0" = icmp eq i64 %11, %22 
  ret i1 %"4##success##0" 
if.else1:
  ret i1 0 
}


define external fastcc  {i64, i64, i1} @"stmt_for.int_sequence.[|]<0>"(i64  %"current##0")    {
entry:
  %23 = inttoptr i64 %"current##0" to i64* 
  %24 = getelementptr  i64, i64* %23, i64 0 
  %25 = load  i64, i64* %24 
  %26 = add   i64 %"current##0", 8 
  %27 = inttoptr i64 %26 to i64* 
  %28 = getelementptr  i64, i64* %27, i64 0 
  %29 = load  i64, i64* %28 
  %30 = add   i64 %"current##0", 16 
  %31 = inttoptr i64 %30 to i64* 
  %32 = getelementptr  i64, i64* %31, i64 0 
  %33 = load  i64, i64* %32 
  %"1#tmp#4##0" = icmp slt i64 %29, 0 
  br i1 %"1#tmp#4##0", label %if.then, label %if.else 
if.then:
  %"2#tmp#2##0" = icmp slt i64 %33, %25 
  br i1 %"2#tmp#2##0", label %if.then1, label %if.else1 
if.else:
  %"3#tmp#3##0" = icmp sgt i64 %33, %25 
  br i1 %"3#tmp#3##0", label %if.then2, label %if.else2 
if.then1:
  %34 = tail call fastcc  {i64, i64, i1}  @"stmt_for.int_sequence.gen#1<0>"(i64  %33, i64  %25, i64  %29)  
  %35 = extractvalue {i64, i64, i1} %34, 0 
  %36 = extractvalue {i64, i64, i1} %34, 1 
  %37 = extractvalue {i64, i64, i1} %34, 2 
  %38 = insertvalue {i64, i64, i1} undef, i64 %35, 0 
  %39 = insertvalue {i64, i64, i1} %38, i64 %36, 1 
  %40 = insertvalue {i64, i64, i1} %39, i1 %37, 2 
  ret {i64, i64, i1} %40 
if.else1:
  %41 = insertvalue {i64, i64, i1} undef, i64 undef, 0 
  %42 = insertvalue {i64, i64, i1} %41, i64 undef, 1 
  %43 = insertvalue {i64, i64, i1} %42, i1 0, 2 
  ret {i64, i64, i1} %43 
if.then2:
  %44 = tail call fastcc  {i64, i64, i1}  @"stmt_for.int_sequence.gen#1<0>"(i64  %33, i64  %25, i64  %29)  
  %45 = extractvalue {i64, i64, i1} %44, 0 
  %46 = extractvalue {i64, i64, i1} %44, 1 
  %47 = extractvalue {i64, i64, i1} %44, 2 
  %48 = insertvalue {i64, i64, i1} undef, i64 %45, 0 
  %49 = insertvalue {i64, i64, i1} %48, i64 %46, 1 
  %50 = insertvalue {i64, i64, i1} %49, i1 %47, 2 
  ret {i64, i64, i1} %50 
if.else2:
  %51 = insertvalue {i64, i64, i1} undef, i64 undef, 0 
  %52 = insertvalue {i64, i64, i1} %51, i64 undef, 1 
  %53 = insertvalue {i64, i64, i1} %52, i1 0, 2 
  ret {i64, i64, i1} %53 
}


define external fastcc  i64 @"stmt_for.int_sequence.end<0>"(i64  %"#rec##0")    {
entry:
  %54 = add   i64 %"#rec##0", 16 
  %55 = inttoptr i64 %54 to i64* 
  %56 = getelementptr  i64, i64* %55, i64 0 
  %57 = load  i64, i64* %56 
  ret i64 %57 
}


define external fastcc  i64 @"stmt_for.int_sequence.end<1>"(i64  %"#rec##0", i64  %"#field##0")    {
entry:
  %58 = trunc i64 24 to i32  
  %59 = tail call ccc  i8*  @wybe_malloc(i32  %58)  
  %60 = ptrtoint i8* %59 to i64 
  %61 = inttoptr i64 %60 to i8* 
  %62 = inttoptr i64 %"#rec##0" to i8* 
  %63 = trunc i64 24 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %61, i8*  %62, i32  %63, i1  0)  
  %64 = add   i64 %60, 16 
  %65 = inttoptr i64 %64 to i64* 
  %66 = getelementptr  i64, i64* %65, i64 0 
  store  i64 %"#field##0", i64* %66 
  ret i64 %60 
}


define external fastcc  {i64, i64, i1} @"stmt_for.int_sequence.gen#1<0>"(i64  %"en##0", i64  %"s##0", i64  %"st##0")    {
entry:
  %"1#tmp#1##0" = add   i64 %"s##0", %"st##0" 
  %67 = trunc i64 24 to i32  
  %68 = tail call ccc  i8*  @wybe_malloc(i32  %67)  
  %69 = ptrtoint i8* %68 to i64 
  %70 = inttoptr i64 %69 to i64* 
  %71 = getelementptr  i64, i64* %70, i64 0 
  store  i64 %"1#tmp#1##0", i64* %71 
  %72 = add   i64 %69, 8 
  %73 = inttoptr i64 %72 to i64* 
  %74 = getelementptr  i64, i64* %73, i64 0 
  store  i64 %"st##0", i64* %74 
  %75 = add   i64 %69, 16 
  %76 = inttoptr i64 %75 to i64* 
  %77 = getelementptr  i64, i64* %76, i64 0 
  store  i64 %"en##0", i64* %77 
  %78 = insertvalue {i64, i64, i1} undef, i64 %"s##0", 0 
  %79 = insertvalue {i64, i64, i1} %78, i64 %69, 1 
  %80 = insertvalue {i64, i64, i1} %79, i1 1, 2 
  ret {i64, i64, i1} %80 
}


define external fastcc  i64 @"stmt_for.int_sequence.int_sequence<0>"(i64  %"start##0", i64  %"stride##0", i64  %"end##0")    {
entry:
  %81 = trunc i64 24 to i32  
  %82 = tail call ccc  i8*  @wybe_malloc(i32  %81)  
  %83 = ptrtoint i8* %82 to i64 
  %84 = inttoptr i64 %83 to i64* 
  %85 = getelementptr  i64, i64* %84, i64 0 
  store  i64 %"start##0", i64* %85 
  %86 = add   i64 %83, 8 
  %87 = inttoptr i64 %86 to i64* 
  %88 = getelementptr  i64, i64* %87, i64 0 
  store  i64 %"stride##0", i64* %88 
  %89 = add   i64 %83, 16 
  %90 = inttoptr i64 %89 to i64* 
  %91 = getelementptr  i64, i64* %90, i64 0 
  store  i64 %"end##0", i64* %91 
  ret i64 %83 
}


define external fastcc  {i64, i64, i64} @"stmt_for.int_sequence.int_sequence<1>"(i64  %"#result##0")    {
entry:
  %92 = inttoptr i64 %"#result##0" to i64* 
  %93 = getelementptr  i64, i64* %92, i64 0 
  %94 = load  i64, i64* %93 
  %95 = add   i64 %"#result##0", 8 
  %96 = inttoptr i64 %95 to i64* 
  %97 = getelementptr  i64, i64* %96, i64 0 
  %98 = load  i64, i64* %97 
  %99 = add   i64 %"#result##0", 16 
  %100 = inttoptr i64 %99 to i64* 
  %101 = getelementptr  i64, i64* %100, i64 0 
  %102 = load  i64, i64* %101 
  %103 = insertvalue {i64, i64, i64} undef, i64 %94, 0 
  %104 = insertvalue {i64, i64, i64} %103, i64 %98, 1 
  %105 = insertvalue {i64, i64, i64} %104, i64 %102, 2 
  ret {i64, i64, i64} %105 
}


define external fastcc  i64 @"stmt_for.int_sequence.start<0>"(i64  %"#rec##0")    {
entry:
  %106 = inttoptr i64 %"#rec##0" to i64* 
  %107 = getelementptr  i64, i64* %106, i64 0 
  %108 = load  i64, i64* %107 
  ret i64 %108 
}


define external fastcc  i64 @"stmt_for.int_sequence.start<1>"(i64  %"#rec##0", i64  %"#field##0")    {
entry:
  %109 = trunc i64 24 to i32  
  %110 = tail call ccc  i8*  @wybe_malloc(i32  %109)  
  %111 = ptrtoint i8* %110 to i64 
  %112 = inttoptr i64 %111 to i8* 
  %113 = inttoptr i64 %"#rec##0" to i8* 
  %114 = trunc i64 24 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %112, i8*  %113, i32  %114, i1  0)  
  %115 = inttoptr i64 %111 to i64* 
  %116 = getelementptr  i64, i64* %115, i64 0 
  store  i64 %"#field##0", i64* %116 
  ret i64 %111 
}


define external fastcc  i64 @"stmt_for.int_sequence.stride<0>"(i64  %"#rec##0")    {
entry:
  %117 = add   i64 %"#rec##0", 8 
  %118 = inttoptr i64 %117 to i64* 
  %119 = getelementptr  i64, i64* %118, i64 0 
  %120 = load  i64, i64* %119 
  ret i64 %120 
}


define external fastcc  i64 @"stmt_for.int_sequence.stride<1>"(i64  %"#rec##0", i64  %"#field##0")    {
entry:
  %121 = trunc i64 24 to i32  
  %122 = tail call ccc  i8*  @wybe_malloc(i32  %121)  
  %123 = ptrtoint i8* %122 to i64 
  %124 = inttoptr i64 %123 to i8* 
  %125 = inttoptr i64 %"#rec##0" to i8* 
  %126 = trunc i64 24 to i32  
  tail call ccc  void  @llvm.memcpy.p0i8.p0i8.i32(i8*  %124, i8*  %125, i32  %126, i1  0)  
  %127 = add   i64 %123, 8 
  %128 = inttoptr i64 %127 to i64* 
  %129 = getelementptr  i64, i64* %128, i64 0 
  store  i64 %"#field##0", i64* %129 
  ret i64 %123 
}


define external fastcc  i1 @"stmt_for.int_sequence.~=<0>"(i64  %"#left##0", i64  %"#right##0")    {
entry:
  %130 = inttoptr i64 %"#left##0" to i64* 
  %131 = getelementptr  i64, i64* %130, i64 0 
  %132 = load  i64, i64* %131 
  %133 = add   i64 %"#left##0", 8 
  %134 = inttoptr i64 %133 to i64* 
  %135 = getelementptr  i64, i64* %134, i64 0 
  %136 = load  i64, i64* %135 
  %137 = add   i64 %"#left##0", 16 
  %138 = inttoptr i64 %137 to i64* 
  %139 = getelementptr  i64, i64* %138, i64 0 
  %140 = load  i64, i64* %139 
  %141 = inttoptr i64 %"#right##0" to i64* 
  %142 = getelementptr  i64, i64* %141, i64 0 
  %143 = load  i64, i64* %142 
  %144 = add   i64 %"#right##0", 8 
  %145 = inttoptr i64 %144 to i64* 
  %146 = getelementptr  i64, i64* %145, i64 0 
  %147 = load  i64, i64* %146 
  %148 = add   i64 %"#right##0", 16 
  %149 = inttoptr i64 %148 to i64* 
  %150 = getelementptr  i64, i64* %149, i64 0 
  %151 = load  i64, i64* %150 
  %"1#tmp#9##0" = icmp eq i64 %132, %143 
  br i1 %"1#tmp#9##0", label %if.then, label %if.else 
if.then:
  %"2#tmp#10##0" = icmp eq i64 %136, %147 
  br i1 %"2#tmp#10##0", label %if.then1, label %if.else1 
if.else:
  %"3##success##0" = xor i1 0, 1 
  ret i1 %"3##success##0" 
if.then1:
  %"4#tmp#0##0" = icmp eq i64 %140, %151 
  %"4##success##0" = xor i1 %"4#tmp#0##0", 1 
  ret i1 %"4##success##0" 
if.else1:
  %"5##success##0" = xor i1 0, 1 
  ret i1 %"5##success##0" 
}
